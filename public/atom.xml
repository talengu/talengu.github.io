<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一塘</title>
  
  
  <link href="/public/atom.xml" rel="self"/>
  
  <link href="https://talengu.github.io/public/"/>
  <updated>2022-12-04T12:00:00.000Z</updated>
  <id>https://talengu.github.io/public/</id>
  
  <author>
    <name>一塘</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「转」连接跟踪（conntrack）：原理、应用及 Linux 内核实现</title>
    <link href="https://talengu.github.io/public/2022/12/04/linux_network/conntrack_linux/"/>
    <id>https://talengu.github.io/public/2022/12/04/linux_network/conntrack_linux/</id>
    <published>2022-12-04T12:00:00.000Z</published>
    <updated>2022-12-04T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a class="header-anchor" href="#摘要">¶</a>摘要</h2><p>本文介绍连接跟踪（connection tracking，conntrack，CT）的原理，应用，及其在 Linux 内核中的实现。</p><p>代码分析基于内核 <code>4.19</code>。为使行文简洁，所贴代码只保留了核心逻辑，但都给出了代码 所在的源文件，如有需要请查阅。</p><p>水平有限，文中不免有错误之处，欢迎指正交流。</p><p>连接跟踪是许多网络应用的基础。例如，Kubernetes Service、ServiceMesh sidecar、 软件四层负载均衡器 LVS/IPVS、Docker network、OVS、iptables 主机防火墙等等，都依赖 连接跟踪功能。</p><a id="more"></a><h2 id="1-1-概念"><a class="header-anchor" href="#1-1-概念">¶</a>1.1 概念</h2><p>连接跟踪，顾名思义，就是<strong>跟踪（并记录）连接的状态</strong>。</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/node-conntrack.png" alt></p><p>Fig 1.1. 连接跟踪及其内核位置示意图</p><p>例如，上图是一台 IP 地址为 <code>10.1.1.2</code> 的 Linux 机器，我们能看到这台机器上有三条 连接：</p><ol><li>机器访问外部 HTTP 服务的连接（目的端口 80）</li><li>外部访问机器内 FTP 服务的连接（目的端口 21）</li><li>机器访问外部 DNS 服务的连接（目的端口 53）</li></ol><p>连接跟踪所做的事情就是发现并跟踪这些连接的状态，具体包括：</p><ul><li>从数据包中提取<strong>元组</strong>（tuple）信息，辨别<strong>数据流</strong>（flow）和对应的<strong>连接</strong>（connection）</li><li>为所有连接维护一个<strong>状态数据库</strong>（conntrack table），例如连接的创建时间、发送 包数、发送字节数等等</li><li>回收过期的连接（GC）</li><li>为更上层的功能（例如 NAT）提供服务</li></ul><p>需要注意的是，<strong>连接跟踪中所说的“连接”，概念和 TCP/IP 协议中“面向连接”（ connection oriented）的 “连接” 并不完全相同</strong>，简单来说：</p><ul><li>TCP/IP 协议中，连接是一个四层（Layer 4）的概念。<ul><li>TCP 是有连接的，或称面向连接的（connection oriented），发送出去的包都要求对端应答（ACK），并且有重传机制</li><li>UDP 是无连接的，发送的包无需对端应答，也没有重传机制</li></ul></li><li>CT 中，一个元组（tuple）定义的一条数据流（flow ）就表示一条连接（connection）。<ul><li>后面会看到 UDP 甚至是 <strong>ICMP 这种三层协议在 CT 中也都是有连接记录的</strong></li><li>但<strong>不是所有协议都会被连接跟踪</strong></li></ul></li></ul><p>本文中用到 “连接” 一词时，大部分情况下指的都是后者，即 “连接跟踪” 中的“连接”。</p><h2 id="1-2-原理"><a class="header-anchor" href="#1-2-原理">¶</a>1.2 原理</h2><p>了解以上概念之后，我们来思考下连接跟踪的技术原理。</p><p>要跟踪一台机器的所有连接状态，就需要</p><ol><li><strong>拦截（或称过滤）流经这台机器的每一个数据包，并进行分析</strong>。</li><li>根据这些信息<strong>建立</strong>起这台机器上的<strong>连接信息数据库</strong>（conntrack table）。</li><li>根据拦截到的包信息，不断更新数据库</li></ol><p>例如，</p><ol><li>拦截到一个 TCP <code>SYNC</code> 包时，说明正在尝试建立 TCP 连接，需要创建一条新 conntrack entry 来记录这条连接</li><li>拦截到一个属于已有 conntrack entry 的包时，需要更新这条 conntrack entry 的收发包数等统计信息</li></ol><p>除了以上两点功能需求，还要考虑<strong>性能问题</strong>，因为连接跟踪要对每个包进行过滤和分析 。性能问题非常重要，但不是本文重点，后面介绍实现时会进一步提及。</p><p>之外，这些功能最好还有配套的管理工具来更方便地使用。</p><h2 id="1-3-设计：Netfilter"><a class="header-anchor" href="#1-3-设计：Netfilter">¶</a>1.3 设计：Netfilter</h2><p><strong>Linux 的连接跟踪是在 <a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Netfilter</a> 中实现的。</strong></p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/netfilter-design.png" alt></p><p>Fig 1.2. Netfilter architecture inside Linux kernel</p><p><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Netfilter</a> 是 Linux 内核中一个对数据 包进行<strong>控制、修改和过滤</strong>（manipulation and filtering）的框架。它在内核协议 栈中设置了若干 hook 点，以此对数据包进行拦截、过滤或其他处理。</p><blockquote><p>说地更直白一些，hook 机制就是在数据包的必经之路上设置若干检测点，所有到达这 些检测点的包都必须接受检测，根据检测的结果决定：</p><ol><li>放行：不对包进行任何修改，退出检测逻辑，继续后面正常的包处理</li><li>修改：例如修改 IP 地址进行 NAT，然后将包放回正常的包处理逻辑</li><li>丢弃：安全策略或防火墙功能</li></ol><p>连接跟踪模块只是完成连接信息的采集和录入功能，并不会修改或丢弃数据包，后者是其 他模块（例如 NAT）基于 Netfilter hook 完成的。</p></blockquote><p>Netfilter 是最古老的内核框架之一，1998 年开始开发，2000 年合并到 <code>2.4.x</code> 内 核主线版本 [5]。</p><h2 id="1-4-设计：进一步思考"><a class="header-anchor" href="#1-4-设计：进一步思考">¶</a>1.4 设计：进一步思考</h2><p>现在提到连接跟踪（conntrack），可能首先都会想到 Netfilter。但由上节讨论可知， 连接跟踪概念是独立于 Netfilter 的，<strong>Netfilter 只是 Linux 内核中的一种连接跟踪实现</strong>。</p><p>换句话说，<strong>只要具备了 hook 能力，能拦截到进出主机的每个包，完全可以在此基础上自 己实现一套连接跟踪</strong>。</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/cilium-conntrack.png" alt></p><p>Fig 1.3. Cilium's conntrack and NAT architectrue</p><p>云原生网络方案 Cilium 在 <code>1.7.4+</code> 版本就实现了这样一套独立的连接跟踪和 NAT 机制 （完备功能需要 Kernel <code>4.19+</code>）。其基本原理是：</p><ol><li>基于 BPF hook 实现数据包的拦截功能（等价于 netfilter 里面的 hook 机制）</li><li>在 BPF hook 的基础上，实现一套全新的 conntrack 和 NAT</li></ol><p>因此，即便<a href="https://github.com/cilium/cilium/issues/12879" target="_blank" rel="noopener">卸载 Netfilter</a> ，也不会影响 Cilium 对 Kubernetes ClusterIP、NodePort、ExternalIPs 和 LoadBalancer 等功能的支持 [2]。</p><p>由于这套连接跟踪机制是独立于 Netfilter 的，因此它的 conntrack 和 NAT 信息也没有 存储在内核的（也就是 Netfilter 的）conntrack table 和 NAT table。所以常规的 <code>conntrack/netstats/ss/lsof</code> 等工具是看不到的，要使用 Cilium 的命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cilium bpf nat list</span><br><span class="line">$ cilium bpf ct list global</span><br></pre></td></tr></table></figure><p>配置也是独立的，需要在 Cilium 里面配置，例如命令行选项 <code>--bpf-ct-tcp-max</code>。</p><p>另外，本文会多次提到连接跟踪模块和 NAT 模块独立，但<strong>出于性能考虑，具体实现中 二者代码可能是有耦合的</strong>。例如 Cilium 做 conntrack 的垃圾回收（GC）时就会顺便把 NAT 里相应的 entry 回收掉，而非为 NAT 做单独的 GC。</p><h2 id="1-5-应用"><a class="header-anchor" href="#1-5-应用">¶</a>1.5 应用</h2><p>来看几个 conntrack 的具体应用。</p><h3 id="1-5-1-网络地址转换（NAT）"><a class="header-anchor" href="#1-5-1-网络地址转换（NAT）">¶</a>1.5.1 网络地址转换（NAT）</h3><p>网络地址转换（NAT），名字表达的意思也比较清楚：对（数据包的）网络地址（<code>IP + Port</code>）进行转换。</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/node-nat.png" alt></p><p>Fig 1.4. NAT 及其内核位置示意图</p><p>例如上图中，机器自己的 IP <code>10.1.1.2</code> 是能与外部正常通信的，但 <code>192.168</code> 网段是私有 IP 段，外界无法访问，也就是说源 IP 地址是 <code>192.168</code> 的包，其<strong>应答包是无 法回来的</strong>。因此，</p><ul><li>当源地址为 <code>192.168</code> 网段的包要出去时，机器会先将源 IP 换成机器自己的 <code>10.1.1.2</code> 再发送出去；</li><li>收到应答包时，再进行相反的转换。</li></ul><p>这就是 NAT 的基本过程。</p><p>Docker 默认的 <code>bridge</code> 网络模式就是这个原理 [4]。每个容器会分一个私有网段的 IP 地址，这个 IP 地址可以在宿主机内的不同容器之间通信，但容器流量出宿主机时要进行 NAT。</p><p>NAT 又可以细分为几类：</p><ul><li>SNAT：对源地址（source）进行转换</li><li>DNAT：对目的地址（destination）进行转换</li><li>Full NAT：同时对源地址和目的地址进行转换</li></ul><p>以上场景属于 SNAT，将不同私有 IP 都映射成同一个 “公有 IP”，以使其能访问外部网络服 务。这种场景也属于正向代理。</p><p>NAT 依赖连接跟踪的结果。连接跟踪<strong>最重要的使用场景</strong>就是 NAT。</p><h4 id="四层负载均衡（L4LB）"><a class="header-anchor" href="#四层负载均衡（L4LB）">¶</a>四层负载均衡（L4LB）</h4><p>再将范围稍微延伸一点，讨论一下 NAT 模式的四层负载均衡。</p><p>四层负载均衡是根据包的四层信息（例如 <code>src/dst ip, src/dst port, proto</code>）做流量分发。</p><p>VIP（Virtual IP）是四层负载均衡的一种实现方式：</p><ul><li>多个后端真实 IP（Real IP）挂到同一个虚拟 IP（VIP）上</li><li>客户端过来的流量先到达 VIP，再经负载均衡算法转发给某个特定的后端 IP</li></ul><p>如果在 VIP 和 Real IP 节点之间使用的 NAT 技术（也可以使用其他技术），那客户端访 问服务端时，L4LB 节点将做双向 NAT（Full NAT），数据流如下图所示：</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/nat.png" alt></p><p>Fig 1.5. L4LB: Traffic path in NAT mode [3]</p><h3 id="1-5-2-有状态防火墙"><a class="header-anchor" href="#1-5-2-有状态防火墙">¶</a>1.5.2 有状态防火墙</h3><p>有状态防火墙（stateful firewall）是相对于早期的<strong>无状态防火墙</strong>（stateless firewall）而言的：早期防火墙只能写 <code>drop syn to port 443</code> 或者 <code>allow syn to port 80</code> 这种非常简单直接 的规则，<strong>没有 flow 的概念</strong>，因此无法实现诸如 <strong>“如果这个 ack 之前已经有 syn， 就 allow，否则 drop”</strong> 这样的规则，使用非常受限 [6]。</p><p>显然，要实现有状态防火墙，就必须记录 flow 和状态，这正是 conntrack 做的事情。</p><p>来看个更具体的防火墙应用：OpenStack 主机防火墙解决方案 —— 安全组（security group）。</p><h4 id="OpenStack-安全组"><a class="header-anchor" href="#OpenStack-安全组">¶</a>OpenStack 安全组</h4><p>简单来说，安全组实现了<strong>虚拟机级别</strong>的安全隔离，具体实现是：在 node 上连接 VM 的 网络设备上做有状态防火墙。在当时，最能实现这一功能的可能就是 Netfilter/iptables。</p><p>回到宿主机内网络拓扑问题： OpenStack 使用 OVS bridge 来连接一台宿主机内的所有 VM。 如果只从网络连通性考虑，那每个 VM 应该直接连到 OVS bridge <code>br-int</code>。但这里问题 就来了 [7]：</p><ul><li>（较早版本的）OVS 没有 conntrack 模块，</li><li>Linux 中有 conntrack 模块，但基于 conntrack 的防火墙<strong>工作在 IP 层</strong>（L3），通过 iptables 控制，</li><li>而 <strong>OVS 是 L2 模块</strong>，无法使用 L3 模块的功能，</li></ul><p>最终结果是：无法在 OVS （连接虚拟机）的设备上做防火墙。</p><p>所以，2016 之前 OpenStack 的解决方案是，在每个 OVS 和 VM 之间再加一个 Linux bridge ，如下图所示，</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/ovs-compute.png" alt></p><p>Fig 1.6. Network topology within an OpenStack compute node, picture from <a href="https://thesaitech.wordpress.com/2017/09/24/how-to-trace-the-tap-interfaces-and-linux-bridges-on-the-hypervisor-your-openstack-vm-is-on/" target="_blank" rel="noopener">Sai's Blog</a></p><p>Linux bridge 也是 L2 模块，按道理也无法使用 iptables。但是，<strong>它有一个 L2 工具 ebtables，能够跳转到 iptables</strong>，因此间接支持了 iptables，也就能用到 Netfilter/iptables 防火墙的功能。</p><p>这种暴力堆砌的方式不仅丑陋、增加网络复杂性，而且会导致性能问题。因此， RedHat 在 2016 年提出了一个 OVS conntrack 方案 [7]，从那以后，才有可能干掉 Linux bridge 而仍然具备安全组的功能。</p><h2 id="1-6-小结"><a class="header-anchor" href="#1-6-小结">¶</a>1.6 小结</h2><p>以上是理论篇，接下来看一下内核实现。</p><p>Netfilter 由几个模块构成，其中最主要的是<strong>连接跟踪</strong>（CT）模块和<strong>网络地址转换</strong>（NAT）模块。</p><p>CT 模块的主要职责是识别出可进行连接跟踪的包。 CT 模块独立于 NAT 模块，但主要目的是服务于后者。</p><h2 id="2-1-Netfilter-框架"><a class="header-anchor" href="#2-1-Netfilter-框架">¶</a>2.1 Netfilter 框架</h2><h3 id="5-个-hook-点"><a class="header-anchor" href="#5-个-hook-点">¶</a>5 个 hook 点</h3><p><img src="/public/2022/12/04/linux_network/conntrack_linux/hooks.png" alt></p><p>图 2.1. The 5 hook points in netfilter framework</p><p>如上图所示，Netfilter 在内核协议栈的包处理路径上提供了 5 个 hook 点，分别是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/netfilter_ipv4.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_PRE_ROUTING    0 <span class="comment">/* After promisc drops, checksum checks. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_LOCAL_IN       1 <span class="comment">/* If the packet is destined for this box. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_FORWARD        2 <span class="comment">/* If the packet is destined for another interface. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_LOCAL_OUT      3 <span class="comment">/* Packets coming from a local process. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_POST_ROUTING   4 <span class="comment">/* Packets about to hit the wire. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_NUMHOOKS       5</span></span><br></pre></td></tr></table></figure><p>用户可以在这些 hook 点注册自己的处理函数（handlers）。当有数据包经过 hook 点时， 就会调用相应的 handlers。</p><blockquote><p>另外还有一套 <code>NF_INET_</code> 开头的定义，<code>include/uapi/linux/netfilter.h</code>。 这两套是等价的，从注释看，<code>NF_IP_</code> 开头的定义可能是为了保持兼容性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">enum</span> nf_inet_hooks &#123;</span><br><span class="line">&gt;  NF_INET_PRE_ROUTING,</span><br><span class="line">&gt;  NF_INET_LOCAL_IN,</span><br><span class="line">&gt;  NF_INET_FORWARD,</span><br><span class="line">&gt;  NF_INET_LOCAL_OUT,</span><br><span class="line">&gt;  NF_INET_POST_ROUTING,</span><br><span class="line">&gt;  NF_INET_NUMHOOKS</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="hook-返回值类型"><a class="header-anchor" href="#hook-返回值类型">¶</a>hook 返回值类型</h3><p>hook 函数对包进行判断或处理之后，需要返回一个判断结果，指导接下来要对这个包做什 么。可能的结果有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/netfilter.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_DROP   0  <span class="comment">// 已丢弃这个包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_ACCEPT 1  <span class="comment">// 接受这个包，结束判断，继续下一步处理</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_STOLEN 2  <span class="comment">// 临时 hold 这个包，不用再继续穿越协议栈了。常见的情形是缓存分片之后的包（等待重组）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_QUEUE  3  <span class="comment">// 应当将包放到队列</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_REPEAT 4  <span class="comment">// 当前处理函数应当被再次调用</span></span></span><br></pre></td></tr></table></figure><h3 id="hook-优先级"><a class="header-anchor" href="#hook-优先级">¶</a>hook 优先级</h3><p>每个 hook 点可以注册多个处理函数（handler）。在注册时必须指定这些 handlers 的<strong>优先级</strong>，这样触发 hook 时能够根据优先级依次调用处理函数。</p><h2 id="2-2-过滤规则的组织"><a class="header-anchor" href="#2-2-过滤规则的组织">¶</a>2.2 过滤规则的组织</h2><p><code>iptables</code> 是配置 Netfilter 过滤功能的用户空间工具。为便于管理， 过滤规则按功能分为若干 table：</p><ul><li>raw</li><li>filter</li><li>nat</li><li>mangle</li></ul><p>这不是本文重点。更多信息可参考 <a href="chrome-extension://ijllcpnolfcooahcekpamkbidhejabll/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener">(译) 深入理解 iptables 和 netfilter 架构</a></p><p>连接跟踪模块用于维护<strong>可跟踪协议</strong>（trackable protocols）的连接状态。 也就是说，连接跟踪<strong>针对的是特定协议的包，而不是所有协议的包</strong>。 稍后会看到它支持哪些协议。</p><h2 id="3-1-重要结构体和函数"><a class="header-anchor" href="#3-1-重要结构体和函数">¶</a>3.1 重要结构体和函数</h2><p>重要结构体：</p><ul><li><code>struct nf_conntrack_tuple {}</code>: 定义一个 tuple。<ul><li><code>struct nf_conntrack_man {}</code>：tuple 的 manipulable part。<ul><li><code>struct nf_conntrack_man_proto {}</code>：manipulable part 中协议相关的部分。</li></ul></li></ul></li><li><code>struct nf_conntrack_l4proto {}</code>: 支持连接跟踪的<strong>协议需要实现的方法集</strong>（以及其他协议相关字段）。</li><li><code>struct nf_conntrack_tuple_hash {}</code>：哈希表（conntrack table）中的表项（entry）。</li><li><code>struct nf_conn {}</code>：<strong>定义一个 flow</strong>。</li></ul><p>重要函数：</p><ul><li><p><code>hash_conntrack_raw()</code>：根据 tuple 计算出一个 32 位的哈希值（hash key）。</p></li><li><p><code>nf_conntrack_in()</code>：<strong>连接跟踪模块的核心，包进入连接跟踪的地方</strong>。</p></li><li><p><code>resolve_normal_ct() -&gt; init_conntrack() -&gt; ct = __nf_conntrack_alloc(); l4proto-&gt;new(ct)</code></p><p>创建一个新的连接记录（conntrack entry），然后初始化。</p></li><li><p><code>nf_conntrack_confirm()</code>：确认前面通过 <code>nf_conntrack_in()</code> 创建的新连接（是否被丢弃）。</p></li></ul><h2 id="3-2-struct-nf-conntrack-tuple-：元组（Tuple）"><a class="header-anchor" href="#3-2-struct-nf-conntrack-tuple-：元组（Tuple）">¶</a>3.2 <code>struct nf_conntrack_tuple {}</code>：元组（Tuple）</h2><p>Tuple 是连接跟踪中最重要的概念之一。</p><p><strong>一个 tuple 定义一个单向（unidirectional）flow</strong>。内核代码中有如下注释：</p><blockquote><p>//include/net/netfilter/nf_conntrack_tuple.h</p><p>A <code>tuple</code> is a structure containing the information to uniquely identify a connection. ie. if two packets have the same tuple, they are in the same connection; if not, they are not.</p></blockquote><h3 id="结构体定义"><a class="header-anchor" href="#结构体定义">¶</a>结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/net/netfilter/nf_conntrack_tuple.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为方便 NAT 的实现，内核将 tuple 结构体拆分为 "manipulatable" 和 "non-manipulatable" 两部分</span></span><br><span class="line"><span class="comment">// 下面结构体中的 _man 是 manipulatable 的缩写</span></span><br><span class="line">                                               <span class="comment">// ude/uapi/linux/netfilter.h</span></span><br><span class="line">                                               <span class="keyword">union</span> nf_inet_addr &#123;</span><br><span class="line">                                                   __u32            all[<span class="number">4</span>];</span><br><span class="line">                                                   __be32           ip;</span><br><span class="line">                                                   __be32           ip6[<span class="number">4</span>];</span><br><span class="line">                                                   <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>   <span class="title">in</span>;</span></span><br><span class="line">                                                   <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span>  <span class="title">in6</span>;</span></span><br><span class="line"><span class="comment">/* manipulable part of the tuple */</span>         /  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_man</span> &#123;</span>                  /</span><br><span class="line">    <span class="keyword">union</span> nf_inet_addr           u3; --&gt;--/</span><br><span class="line">    <span class="keyword">union</span> nf_conntrack_man_proto u;  --&gt;--\</span><br><span class="line">                                           \   <span class="comment">// include/uapi/linux/netfilter/nf_conntrack_tuple_common.h</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> l3num; <span class="comment">// L3 proto            \  // 协议相关的部分</span></span><br><span class="line">&#125;;                                            <span class="keyword">union</span> nf_conntrack_man_proto &#123;</span><br><span class="line">                                                  __be16 all;<span class="comment">/* Add other protocols here. */</span></span><br><span class="line"></span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; tcp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; udp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 id;   &#125; icmp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; dccp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; sctp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 key;  &#125; gre;</span><br><span class="line">                                              &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> &#123;</span> <span class="comment">/* This contains the information to distinguish a connection. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_man</span> <span class="title">src</span>;</span>  <span class="comment">// 源地址信息，manipulable part</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">union</span> nf_inet_addr u3;</span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">            __be16 all; <span class="comment">/* Add other protocols here. */</span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; tcp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; udp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">u_int8_t</span> type, code; &#125; icmp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; dccp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; sctp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 key;          &#125; gre;</span><br><span class="line">        &#125; u;</span><br><span class="line">        <span class="keyword">u_int8_t</span> protonum; <span class="comment">/* The protocol. */</span></span><br><span class="line">        <span class="keyword">u_int8_t</span> dir;      <span class="comment">/* The direction (for tuplehash) */</span></span><br><span class="line">    &#125; dst;                       <span class="comment">// 目的地址信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Tuple 结构体中只有两个字段 src 和 dst</strong>，分别保存源和目的信息。<code>src</code> 和 <code>dst</code> 自身也是结构体，能保存不同类型协议的数据。以 IPv4 UDP 为例，五元组分别保存在如下字段：</p><ul><li><code>dst.protonum</code>：协议类型</li><li><code>src.u3.ip</code>：源 IP 地址</li><li><code>dst.u3.ip</code>：目的 IP 地址</li><li><code>src.u.udp.port</code>：源端口号</li><li><code>dst.u.udp.port</code>：目的端口号</li></ul><h3 id="CT-支持的协议"><a class="header-anchor" href="#CT-支持的协议">¶</a>CT 支持的协议</h3><p>从以上定义可以看到，连接跟踪模块<strong>目前只支持以下六种协议</strong>：TCP、UDP、ICMP、DCCP、SCTP、GRE。</p><p><strong>注意其中的 ICMP 协议</strong>。大家可能会认为，连接跟踪模块依据包的三层和四层信息做 哈希，而 ICMP 是三层协议，没有四层信息，因此 ICMP 肯定不会被 CT 记录。但<strong>实际上 是会的</strong>，上面代码可以看到，ICMP 使用了其头信息中的 ICMP <code>type</code>和 <code>code</code> 字段来 定义 tuple。</p><h2 id="3-3-struct-nf-conntrack-l4proto-：协议需要实现的方法集合"><a class="header-anchor" href="#3-3-struct-nf-conntrack-l4proto-：协议需要实现的方法集合">¶</a>3.3 <code>struct nf_conntrack_l4proto {}</code>：协议需要实现的方法集合</h2><p>支持连接跟踪的协议都需要实现 <code>struct nf_conntrack_l4proto {}</code> 结构体 中定义的方法，例如 <code>pkt_to_tuple()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_l4proto.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_l4proto</span> &#123;</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> l3proto; <span class="comment">/* L3 Protocol number. */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span>  l4proto; <span class="comment">/* L4 Protocol number. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从包（skb）中提取 tuple</span></span><br><span class="line">    <span class="keyword">bool</span> (*pkt_to_tuple)(struct sk_buff *skb, ... struct nf_conntrack_tuple *tuple);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对包进行判决，返回判决结果（returns verdict for packet）</span></span><br><span class="line">    <span class="keyword">int</span> (*packet)(struct nf_conn *ct, <span class="keyword">const</span> struct sk_buff *skb ...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新连接。如果成功返回 TRUE；如果返回的是 TRUE，接下来会调用 packet() 方法</span></span><br><span class="line">    <span class="keyword">bool</span> (*<span class="keyword">new</span>)(struct nf_conn *ct, <span class="keyword">const</span> struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> dataoff);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前数据包能否被连接跟踪。如果返回成功，接下来会调用 packet() 方法</span></span><br><span class="line">    <span class="keyword">int</span> (*error)(struct net *net, struct nf_conn *tmpl, struct sk_buff *skb, ...);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-4-struct-nf-conntrack-tuple-hash-：哈希表项"><a class="header-anchor" href="#3-4-struct-nf-conntrack-tuple-hash-：哈希表项">¶</a>3.4 <code>struct nf_conntrack_tuple_hash {}</code>：哈希表项</h2><p>conntrack 将活动连接的状态存储在一张哈希表中（<code>key: value</code>）。</p><p><code>hash_conntrack_raw()</code> 根据 tuple 计算出一个 32 位的哈希值（key）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">hash_conntrack_raw</span><span class="params">(struct nf_conntrack_tuple *tuple, struct net *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    get_random_once(&amp;nf_conntrack_hash_rnd, <span class="keyword">sizeof</span>(nf_conntrack_hash_rnd));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The direction must be ignored, so we hash everything up to the</span></span><br><span class="line"><span class="comment">     * destination ports (which is a multiple of 4) and treat the last three bytes manually.  */</span></span><br><span class="line">    u32 seed = nf_conntrack_hash_rnd ^ net_hash_mix(net);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = (<span class="keyword">sizeof</span>(tuple-&gt;src) + <span class="keyword">sizeof</span>(tuple-&gt;dst.u3)) / <span class="keyword">sizeof</span>(u32);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jhash2((u32 *)tuple, n, seed ^ ((tuple-&gt;dst.u.all &lt;&lt; <span class="number">16</span>) | tuple-&gt;dst.protonum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意其中是如何利用 tuple 的不同字段来计算哈希的。</p><p><code>nf_conntrack_tuple_hash</code> 是哈希表中的表项（value）:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_tuple.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每条连接在哈希表中都对应两项，分别对应两个方向（egress/ingress）</span></span><br><span class="line"><span class="comment">// Connections have two entries in the hash table: one for each way</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_node</span>   <span class="title">hnnode</span>;</span>   <span class="comment">// 指向该哈希对应的连接 struct nf_conn，采用 list 形式是为了解决哈希冲突</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> <span class="title">tuple</span>;</span>    <span class="comment">// N 元组，前面详细介绍过了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-5-struct-nf-conn-：连接（connection）"><a class="header-anchor" href="#3-5-struct-nf-conn-：连接（connection）">¶</a>3.5 <code>struct nf_conn {}</code>：连接（connection）</h2><p><strong>Netfilter 中每个 flow 都称为一个 connection</strong>，即使是对那些非面向连接的协议（例 如 UDP）。每个 connection 用 <code>struct nf_conn {}</code> 表示，主要字段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack.h</span></span><br><span class="line"></span><br><span class="line">                                                  <span class="comment">// include/linux/skbuff.h</span></span><br><span class="line">                                        ------&gt;   <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack</span> &#123;</span></span><br><span class="line">                                        |             <span class="keyword">atomic_t</span> use;  <span class="comment">// 连接引用计数？</span></span><br><span class="line">                                        |         &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> &#123;</span>                        |</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack</span>            <span class="title">ct_general</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> <span class="title">tuplehash</span>[<span class="title">IP_CT_DIR_MAX</span>];</span> <span class="comment">// 哈希表项，数组是因为要记录两个方向的 flow</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> status; <span class="comment">// 连接状态，见下文</span></span><br><span class="line">    u32 timeout;          <span class="comment">// 连接状态的定时器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">possible_net_t</span> ct_net;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>    <span class="title">nat_bysource</span>;</span></span><br><span class="line">                                                        <span class="comment">// per conntrack: protocol private data</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">master</span>;</span>                             <span class="keyword">union</span> nf_conntrack_proto &#123;</span><br><span class="line">                                                       /    <span class="comment">/* insert conntrack proto private data here */</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> mark;    <span class="comment">/* 对 skb 进行特殊标记 */</span>      /     <span class="class"><span class="keyword">struct</span> <span class="title">nf_ct_dccp</span> <span class="title">dccp</span>;</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> secmark;                               /      <span class="class"><span class="keyword">struct</span> <span class="title">ip_ct_sctp</span> <span class="title">sctp</span>;</span></span><br><span class="line">                                                    /       <span class="class"><span class="keyword">struct</span> <span class="title">ip_ct_tcp</span> <span class="title">tcp</span>;</span></span><br><span class="line">    <span class="keyword">union</span> nf_conntrack_proto proto; ----------&gt;----/        <span class="class"><span class="keyword">struct</span> <span class="title">nf_ct_gre</span> <span class="title">gre</span>;</span></span><br><span class="line">&#125;;                                                          <span class="keyword">unsigned</span> <span class="keyword">int</span> tmpl_padto;</span><br><span class="line">                                                        &#125;;</span><br></pre></td></tr></table></figure><p><strong>连接的状态集合 enum ip_conntrack_status</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// include/uapi/linux/netfilter/nf_conntrack_common.h</span><br><span class="line"></span><br><span class="line">enum ip_conntrack_status &#123;</span><br><span class="line">    IPS_EXPECTED      = (1 &lt;&lt; IPS_EXPECTED_BIT),</span><br><span class="line">    IPS_SEEN_REPLY    = (1 &lt;&lt; IPS_SEEN_REPLY_BIT),</span><br><span class="line">    IPS_ASSURED       = (1 &lt;&lt; IPS_ASSURED_BIT),</span><br><span class="line">    IPS_CONFIRMED     = (1 &lt;&lt; IPS_CONFIRMED_BIT),</span><br><span class="line">    IPS_SRC_NAT       = (1 &lt;&lt; IPS_SRC_NAT_BIT),</span><br><span class="line">    IPS_DST_NAT       = (1 &lt;&lt; IPS_DST_NAT_BIT),</span><br><span class="line">    IPS_NAT_MASK      = (IPS_DST_NAT | IPS_SRC_NAT),</span><br><span class="line">    IPS_SEQ_ADJUST    = (1 &lt;&lt; IPS_SEQ_ADJUST_BIT),</span><br><span class="line">    IPS_SRC_NAT_DONE  = (1 &lt;&lt; IPS_SRC_NAT_DONE_BIT),</span><br><span class="line">    IPS_DST_NAT_DONE  = (1 &lt;&lt; IPS_DST_NAT_DONE_BIT),</span><br><span class="line">    IPS_NAT_DONE_MASK = (IPS_DST_NAT_DONE | IPS_SRC_NAT_DONE),</span><br><span class="line">    IPS_DYING         = (1 &lt;&lt; IPS_DYING_BIT),</span><br><span class="line">    IPS_FIXED_TIMEOUT = (1 &lt;&lt; IPS_FIXED_TIMEOUT_BIT),</span><br><span class="line">    IPS_TEMPLATE      = (1 &lt;&lt; IPS_TEMPLATE_BIT),</span><br><span class="line">    IPS_UNTRACKED     = (1 &lt;&lt; IPS_UNTRACKED_BIT),</span><br><span class="line">    IPS_HELPER        = (1 &lt;&lt; IPS_HELPER_BIT),</span><br><span class="line">    IPS_OFFLOAD       = (1 &lt;&lt; IPS_OFFLOAD_BIT),</span><br><span class="line"></span><br><span class="line">    IPS_UNCHANGEABLE_MASK = (IPS_NAT_DONE_MASK | IPS_NAT_MASK |</span><br><span class="line">                 IPS_EXPECTED | IPS_CONFIRMED | IPS_DYING |</span><br><span class="line">                 IPS_SEQ_ADJUST | IPS_TEMPLATE | IPS_OFFLOAD),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-6-nf-conntrack-in-：进入连接跟踪"><a class="header-anchor" href="#3-6-nf-conntrack-in-：进入连接跟踪">¶</a>3.6 <code>nf_conntrack_in()</code>：进入连接跟踪</h2><p><img src="/public/2022/12/04/linux_network/conntrack_linux/netfilter-conntrack.png" alt></p><p>Fig. Netfilter 中的连接跟踪点</p><p>如上图所示，Netfilter 在四个 Hook 点对包进行跟踪：</p><ol><li><p><code>PRE_ROUTING</code> 和 <code>LOCAL_OUT</code>：<strong>调用 nf_conntrack_in() 开始连接跟踪</strong>， 正常情况下会创建一条新连接记录，然后将 conntrack entry 放到 <strong>unconfirmed list</strong>。</p><p>为什么是这两个 hook 点呢？因为它们都是<strong>新连接的第一个包最先达到的地方</strong>，</p><ul><li><code>PRE_ROUTING</code> 是<strong>外部主动和本机建连</strong>时包最先到达的地方</li><li><code>LOCAL_OUT</code> 是<strong>本机主动和外部建连</strong>时包最先到达的地方</li></ul></li><li><p><code>POST_ROUTING</code> 和 <code>LOCAL_IN</code>：<strong>调用 nf_conntrack_confirm() 将 nf_conntrack_in() 创建的连接移到 confirmed list</strong>。</p><p>同样要问，为什么在这两个 hook 点呢？因为如果新连接的第一个包没有被丢弃，那这 是它们<strong>离开 netfilter 之前的最后 hook 点</strong>：</p><ul><li><strong>外部主动和本机建连</strong>的包，如果在中间处理中没有被丢弃，<code>LOCAL_IN</code> 是其被送到应用（例如 nginx 服务）之前的最后 hook 点</li><li><strong>本机主动和外部建连</strong>的包，如果在中间处理中没有被丢弃，<code>POST_ROUTING</code> 是其离开主机时的最后 hook 点</li></ul></li></ol><p>下面的代码可以看到<strong>这些 handler 是如何注册到 Netfilter hook 点的</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_proto.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Connection tracking may drop packets, but never alters them, so make it the first hook.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> <span class="title">ipv4_conntrack_ops</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_conntrack_in,       <span class="comment">// 调用 nf_conntrack_in() 进入连接跟踪</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_PRE_ROUTING,     <span class="comment">// PRE_ROUTING hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_conntrack_local,    <span class="comment">// 调用 nf_conntrack_in() 进入连接跟踪</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_LOCAL_OUT,       <span class="comment">// LOCAL_OUT hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_confirm,            <span class="comment">// 调用 nf_conntrack_confirm()</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_POST_ROUTING,    <span class="comment">// POST_ROUTING hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK_CONFIRM,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_confirm,            <span class="comment">// 调用 nf_conntrack_confirm()</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_LOCAL_IN,        <span class="comment">// LOCAL_IN hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK_CONFIRM,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>nf_conntrack_in()</code> 是<strong>连接跟踪模块的核心</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">nf_conntrack_in(struct net *net, <span class="keyword">u_int8_t</span> pf, <span class="keyword">unsigned</span> <span class="keyword">int</span> hooknum, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">tmpl</span> = <span class="title">nf_ct_get</span>(<span class="title">skb</span>, &amp;<span class="title">ctinfo</span>);</span> <span class="comment">// 获取 skb 对应的 conntrack_info 和连接记录</span></span><br><span class="line">  <span class="keyword">if</span> (tmpl || ctinfo == IP_CT_UNTRACKED) &#123;        <span class="comment">// 如果记录存在，或者是不需要跟踪的类型</span></span><br><span class="line">      <span class="keyword">if</span> ((tmpl &amp;&amp; !nf_ct_is_template(tmpl)) || ctinfo == IP_CT_UNTRACKED) &#123;</span><br><span class="line">          NF_CT_STAT_INC_ATOMIC(net, ignore);     <span class="comment">// 无需跟踪的类型，增加 ignore 计数</span></span><br><span class="line">          <span class="keyword">return</span> NF_ACCEPT;                       <span class="comment">// 返回 NF_ACCEPT，继续后面的处理</span></span><br><span class="line">      &#125;</span><br><span class="line">      skb-&gt;_nfct = <span class="number">0</span>;                             <span class="comment">// 不属于 ignore 类型，计数器置零，准备后续处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_l4proto</span> *<span class="title">l4proto</span> = __<span class="title">nf_ct_l4proto_find</span>(...);</span>    <span class="comment">// 提取协议相关的 L4 头信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l4proto-&gt;error != <span class="literal">NULL</span>) &#123;                   <span class="comment">// skb 的完整性和合法性验证</span></span><br><span class="line">      <span class="keyword">if</span> (l4proto-&gt;error(net, tmpl, skb, dataoff, pf, hooknum) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          NF_CT_STAT_INC_ATOMIC(net, error);</span><br><span class="line">          NF_CT_STAT_INC_ATOMIC(net, invalid);</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">  <span class="comment">// 开始连接跟踪：提取 tuple；创建新连接记录，或者更新已有连接的状态</span></span><br><span class="line">  resolve_normal_ct(net, tmpl, skb, ... l4proto);</span><br><span class="line"></span><br><span class="line">  l4proto-&gt;packet(ct, skb, dataoff, ctinfo); <span class="comment">// 进行一些协议相关的处理，例如 UDP 会更新 timeout</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctinfo == IP_CT_ESTABLISHED_REPLY &amp;&amp; !test_and_set_bit(IPS_SEEN_REPLY_BIT, &amp;ct-&gt;status))</span><br><span class="line">      nf_conntrack_event_cache(IPCT_REPLY, ct);</span><br><span class="line">out:</span><br><span class="line">  <span class="keyword">if</span> (tmpl)</span><br><span class="line">      nf_ct_put(tmpl); <span class="comment">// 解除对连接记录 tmpl 的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致流程：</p><ol><li>尝试获取这个 skb 对应的连接跟踪记录</li><li>判断是否需要对这个包做连接跟踪，如果不需要，更新 ignore 计数（<code>conntrack -S</code> 能看到这个计数）， 返回 <code>NF_ACCEPT</code>；如果需要，就<strong>初始化这个 skb 的引用计数</strong>。</li><li>从包的 L4 header 中提取信息，初始化协议相关的 <code>struct nf_conntrack_l4proto {}</code> 变量，其中包含了该协议的<strong>连接跟踪相关的回调方法</strong>。</li><li>调用该协议的 <code>error()</code> 方法检查包的完整性、校验和等信息。</li><li>调用 <code>resolve_normal_ct()</code> <strong>开始连接跟踪</strong>，它会创建新 tuple，新 conntrack entry，或者更新已有连接的状态。</li><li>调用该协议的 <code>packet()</code> 方法进行一些协议相关的处理，例如对于 UDP，如果 status bit 里面设置了 <code>IPS_SEEN_REPLY</code> 位，就会更新 timeout。timeout 大小和协 议相关，越小越越可以防止 DoS 攻击（DoS 的基本原理就是将机器的可用连接耗尽）</li></ol><h2 id="3-7-init-conntrack-：创建新连接记录"><a class="header-anchor" href="#3-7-init-conntrack-：创建新连接记录">¶</a>3.7 <code>init_conntrack()</code>：创建新连接记录</h2><p>如果连接不存在（flow 的第一个包），<code>resolve_normal_ct()</code> 会调用 <code>init_conntrack</code> ，后者进而会调用 <code>new()</code> 方法创建一个新的 conntrack entry。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a new conntrack</span></span><br><span class="line"><span class="keyword">static</span> noinline <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> *</span></span><br><span class="line"><span class="class"><span class="title">init_conntrack</span>(<span class="title">struct</span> <span class="title">net</span> *<span class="title">net</span>, <span class="title">struct</span> <span class="title">nf_conn</span> *<span class="title">tmpl</span>,</span></span><br><span class="line"><span class="class">           <span class="title">const</span> <span class="title">struct</span> <span class="title">nf_conntrack_tuple</span> *<span class="title">tuple</span>,</span></span><br><span class="line"><span class="class">           <span class="title">const</span> <span class="title">struct</span> <span class="title">nf_conntrack_l4proto</span> *<span class="title">l4proto</span>,</span></span><br><span class="line"><span class="class">           <span class="title">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">dataoff</span>, <span class="title">u32</span> <span class="title">hash</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">ct</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 conntrack table 中分配一个 entry，如果哈希表满了，会在内核日志中打印</span></span><br><span class="line">    <span class="comment">// "nf_conntrack: table full, dropping packet" 信息，通过 `dmesg -T` 能看到</span></span><br><span class="line">    ct = __nf_conntrack_alloc(net, zone, tuple, &amp;repl_tuple, GFP_ATOMIC, hash);</span><br><span class="line"></span><br><span class="line">    l4proto-&gt;<span class="keyword">new</span>(ct, skb, dataoff); <span class="comment">// 协议相关的方法</span></span><br><span class="line"></span><br><span class="line">    local_bh_disable();             <span class="comment">// 关闭软中断</span></span><br><span class="line">    <span class="keyword">if</span> (net-&gt;ct.expect_count) &#123;</span><br><span class="line">        <span class="built_in">exp</span> = nf_ct_find_expectation(net, zone, tuple);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>) &#123;</span><br><span class="line">            <span class="comment">/* Welcome, Mr. Bond.  We've been expecting you... */</span></span><br><span class="line">            __set_bit(IPS_EXPECTED_BIT, &amp;ct-&gt;status);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* exp-&gt;master safe, refcnt bumped in nf_ct_find_expectation */</span></span><br><span class="line">            ct-&gt;master = <span class="built_in">exp</span>-&gt;master;</span><br><span class="line">            ct-&gt;mark = <span class="built_in">exp</span>-&gt;master-&gt;mark;</span><br><span class="line">            ct-&gt;secmark = <span class="built_in">exp</span>-&gt;master-&gt;secmark;</span><br><span class="line">            NF_CT_STAT_INC(net, expect_new);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now it is inserted into the unconfirmed list, bump refcount */</span></span><br><span class="line">    <span class="comment">// 至此这个新的 conntrack entry 已经被插入 unconfirmed list</span></span><br><span class="line">    nf_conntrack_get(&amp;ct-&gt;ct_general);</span><br><span class="line">    nf_ct_add_to_unconfirmed_list(ct);</span><br><span class="line"></span><br><span class="line">    local_bh_enable();              <span class="comment">// 重新打开软中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>-&gt;expectfn)</span><br><span class="line">            <span class="built_in">exp</span>-&gt;expectfn(ct, <span class="built_in">exp</span>);</span><br><span class="line">        nf_ct_expect_put(<span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每种协议需要实现自己的 <code>l4proto-&gt;new()</code> 方法，代码见：<code>net/netfilter/nf_conntrack_proto_*.c</code>。 例如 TCP 协议对应的 <code>new()</code> 方法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_proto_tcp.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called when a new connection for this protocol found. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">tcp_new</span><span class="params">(struct nf_conn *ct, <span class="keyword">const</span> struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> dataoff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (new_state == TCP_CONNTRACK_SYN_SENT) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;ct-&gt;proto.tcp, <span class="number">0</span>, <span class="keyword">sizeof</span>(ct-&gt;proto.tcp));</span><br><span class="line">        <span class="comment">/* SYN packet */</span></span><br><span class="line">        ct-&gt;proto.tcp.seen[<span class="number">0</span>].td_end = segment_seq_plus_len(ntohl(th-&gt;seq), skb-&gt;len, dataoff, th);</span><br><span class="line">        ct-&gt;proto.tcp.seen[<span class="number">0</span>].td_maxwin = ntohs(th-&gt;window);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前包会影响后面包的状态判断，<code>init_conntrack()</code> 会设置 <code>struct nf_conn</code> 的 <code>master</code> 字段。面向连接的协议会用到这个特性，例如 TCP。</p><h2 id="3-8-nf-conntrack-confirm-：确认包没有被丢弃"><a class="header-anchor" href="#3-8-nf-conntrack-confirm-：确认包没有被丢弃">¶</a>3.8 <code>nf_conntrack_confirm()</code>：确认包没有被丢弃</h2><p><code>nf_conntrack_in()</code> 创建的新 conntrack entry 会插入到一个 <strong>未确认连接</strong>（ unconfirmed connection）列表。</p><p>如果这个包之后没有被丢弃，那它在经过 <code>POST_ROUTING</code> 时会被 <code>nf_conntrack_confirm()</code> 方法处理，原理我们在分析过了 3.6 节的开头分析过了。 <code>nf_conntrack_confirm()</code> 完成之后，状态就变为了 <code>IPS_CONFIRMED</code>，并且连接记录从 <strong>未确认列表</strong>移到<strong>正常</strong>的列表。</p><p>之所以把创建一个新 entry 的过程分为创建（new）和确认（confirm）两个阶段 ，是因为<strong>包在经过 nf_conntrack_in() 之后，到达 nf_conntrack_confirm() 之前 ，可能会被内核丢弃</strong>。这样会导致系统残留大量的半连接状态记录，在性能和安全性上都 是很大问题。分为两步之后，可以加快半连接状态 conntrack entry 的 GC。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_core.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Confirm a connection: returns NF_DROP if packet must be dropped. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nf_conntrack_confirm</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">ct</span> = (<span class="title">struct</span> <span class="title">nf_conn</span> *)<span class="title">skb_nfct</span>(<span class="title">skb</span>);</span></span><br><span class="line">    <span class="keyword">int</span> ret = NF_ACCEPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ct) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nf_ct_is_confirmed(ct))</span><br><span class="line">            ret = __nf_conntrack_confirm(skb);</span><br><span class="line">        <span class="keyword">if</span> (likely(ret == NF_ACCEPT))</span><br><span class="line">            nf_ct_deliver_cached_events(ct);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>confirm 逻辑，省略了各种错误处理逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Confirm a connection given skb; places it in hash table */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__nf_conntrack_confirm(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">ct</span>;</span></span><br><span class="line">    ct = nf_ct_get(skb, &amp;ctinfo);</span><br><span class="line"></span><br><span class="line">    local_bh_disable();               <span class="comment">// 关闭软中断</span></span><br><span class="line"></span><br><span class="line">    hash = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;ct-&gt;tuplehash[IP_CT_DIR_REPLY].hnnode.pprev;</span><br><span class="line">    reply_hash = hash_conntrack(net, &amp;ct-&gt;tuplehash[IP_CT_DIR_REPLY].tuple);</span><br><span class="line"></span><br><span class="line">    ct-&gt;timeout += nfct_time_stamp;   <span class="comment">// 更新连接超时时间，超时后会被 GC</span></span><br><span class="line">    atomic_inc(&amp;ct-&gt;ct_general.use);  <span class="comment">// 设置连接引用计数？</span></span><br><span class="line">    ct-&gt;status |= IPS_CONFIRMED;      <span class="comment">// 设置连接状态为 confirmed</span></span><br><span class="line"></span><br><span class="line">    __nf_conntrack_hash_insert(ct, hash, reply_hash);  <span class="comment">// 插入到连接跟踪哈希表</span></span><br><span class="line"></span><br><span class="line">    local_bh_enable();                <span class="comment">// 重新打开软中断</span></span><br><span class="line"></span><br><span class="line">    nf_conntrack_event_cache(master_ct(ct) ? IPCT_RELATED : IPCT_NEW, ct);</span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>连接跟踪的处理逻辑中需要频繁关闭和打开软中断</strong>，此外还有各种锁， 这是短连高并发场景下连接跟踪性能损耗的主要原因？。</p><p>NAT 是与连接跟踪独立的模块。</p><h2 id="4-1-重要数据结构和函数"><a class="header-anchor" href="#4-1-重要数据结构和函数">¶</a>4.1 重要数据结构和函数</h2><p><strong>重要数据结构：</strong></p><p>支持 NAT 的协议需要实现其中的方法：</p><ul><li><code>struct nf_nat_l3proto {}</code></li><li><code>struct nf_nat_l4proto {}</code></li></ul><p><strong>重要函数：</strong></p><ul><li><code>nf_nat_inet_fn()</code>：NAT 的核心函数，在<strong>除 NF_INET_FORWARD 之外的其他 hook 点都会被调用</strong>。</li></ul><h2 id="4-2-NAT-模块初始化"><a class="header-anchor" href="#4-2-NAT-模块初始化">¶</a>4.2 NAT 模块初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_nat_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_hook</span> <span class="title">nat_hook</span> = &#123;</span></span><br><span class="line">    .parse_nat_setup    = nfnetlink_parse_nat_setup,</span><br><span class="line">    .decode_session        = __nf_nat_decode_session,</span><br><span class="line">    .manip_pkt        = nf_nat_manip_pkt,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">nf_nat_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nf_nat_bysource = nf_ct_alloc_hashtable(&amp;nf_nat_htable_size, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    nf_ct_helper_expectfn_register(&amp;follow_master_nat);</span><br><span class="line"></span><br><span class="line">    RCU_INIT_POINTER(nf_nat_hook, &amp;nat_hook);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">module_init(nf_nat_init);</span><br></pre></td></tr></table></figure><h2 id="4-3-struct-nf-nat-l3proto-：协议相关的-NAT-方法集"><a class="header-anchor" href="#4-3-struct-nf-nat-l3proto-：协议相关的-NAT-方法集">¶</a>4.3 <code>struct nf_nat_l3proto {}</code>：协议相关的 NAT 方法集</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_nat_l3proto.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_l3proto</span> &#123;</span></span><br><span class="line">    u8    l3proto; <span class="comment">// 例如，AF_INET</span></span><br><span class="line"></span><br><span class="line">    u32     (*secure_port    )(<span class="keyword">const</span> struct nf_conntrack_tuple *t, __be16);</span><br><span class="line">    <span class="keyword">bool</span>    (*manip_pkt      )(struct sk_buff *skb, ...);</span><br><span class="line">    <span class="keyword">void</span>    (*csum_update    )(struct sk_buff *skb, ...);</span><br><span class="line">    <span class="keyword">void</span>    (*csum_recalc    )(struct sk_buff *skb, u8 proto, ...);</span><br><span class="line">    <span class="keyword">void</span>    (*decode_session )(struct sk_buff *skb, ...);</span><br><span class="line">    <span class="keyword">int</span>     (*nlattr_to_range)(struct nlattr *tb[], struct nf_nat_range2 *range);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-4-struct-nf-nat-l4proto-：协议相关的-NAT-方法集"><a class="header-anchor" href="#4-4-struct-nf-nat-l4proto-：协议相关的-NAT-方法集">¶</a>4.4 <code>struct nf_nat_l4proto {}</code>：协议相关的 NAT 方法集</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_nat_l4proto.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_l4proto</span> &#123;</span></span><br><span class="line">    u8 l4proto; <span class="comment">// Protocol number，例如 IPPROTO_UDP, IPPROTO_TCP</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传入的 tuple 和 NAT 类型（SNAT/DNAT）修改包的 L3/L4 头</span></span><br><span class="line">    <span class="keyword">bool</span> (*manip_pkt)(struct sk_buff *skb, *l3proto, *tuple, maniptype);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个唯一的 tuple</span></span><br><span class="line">    <span class="comment">// 例如对于 UDP，会根据 src_ip, dst_ip, src_port 加一个随机数生成一个 16bit 的 dst_port</span></span><br><span class="line">    <span class="keyword">void</span> (*unique_tuple)(*l3proto, tuple, struct nf_nat_range2 *range, maniptype, struct nf_conn *ct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the address range is exhausted the NAT modules will begin to drop packets.</span></span><br><span class="line">    <span class="keyword">int</span> (*nlattr_to_range)(struct nlattr *tb[], struct nf_nat_range2 *range);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>各协议实现的方法，见：<code>net/netfilter/nf_nat_proto_*.c</code>。例如 TCP 的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_nat_proto_tcp.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_l4proto</span> <span class="title">nf_nat_l4proto_tcp</span> = &#123;</span></span><br><span class="line">    .l4proto        = IPPROTO_TCP,</span><br><span class="line">    .manip_pkt        = tcp_manip_pkt,</span><br><span class="line">    .in_range        = nf_nat_l4proto_in_range,</span><br><span class="line">    .unique_tuple        = tcp_unique_tuple,</span><br><span class="line">    .nlattr_to_range    = nf_nat_l4proto_nlattr_to_range,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-5-nf-nat-inet-fn-：进入-NAT"><a class="header-anchor" href="#4-5-nf-nat-inet-fn-：进入-NAT">¶</a>4.5 <code>nf_nat_inet_fn()</code>：进入 NAT</h2><p>NAT 的核心函数是 <code>nf_nat_inet_fn()</code>，它会在以下 hook 点被调用：</p><ul><li><code>NF_INET_PRE_ROUTING</code></li><li><code>NF_INET_POST_ROUTING</code></li><li><code>NF_INET_LOCAL_OUT</code></li><li><code>NF_INET_LOCAL_IN</code></li></ul><p>也就是除了 <code>NF_INET_FORWARD</code> 之外其他 hook 点都会被调用。</p><p><strong>在这些 hook 点的优先级</strong>：<strong>Conntrack &gt; NAT &gt; Packet Filtering</strong>。 <strong>连接跟踪的优先级高于 NAT</strong> 是因为 NAT 依赖连接跟踪的结果。</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/hook-to-nat.png" alt></p><p>Fig. NAT</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">nf_nat_inet_fn(<span class="keyword">void</span> *priv, struct sk_buff *skb, <span class="keyword">const</span> struct nf_hook_state *state)</span><br><span class="line">&#123;</span><br><span class="line">    ct = nf_ct_get(skb, &amp;ctinfo);</span><br><span class="line">    <span class="keyword">if</span> (!ct)    <span class="comment">// conntrack 不存在就做不了 NAT，直接返回，这也是我们为什么说 NAT 依赖 conntrack 的结果</span></span><br><span class="line">        <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line"></span><br><span class="line">    nat = nfct_nat(ct);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ctinfo) &#123;</span><br><span class="line">    <span class="keyword">case</span> IP_CT_RELATED:</span><br><span class="line">    <span class="keyword">case</span> IP_CT_RELATED_REPLY: <span class="comment">/* Only ICMPs can be IP_CT_IS_REPLY.  Fallthrough */</span></span><br><span class="line">    <span class="keyword">case</span> IP_CT_NEW: <span class="comment">/* Seen it before? This can happen for loopback, retrans, or local packets. */</span></span><br><span class="line">        <span class="keyword">if</span> (!nf_nat_initialized(ct, maniptype)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_entries</span> *<span class="title">e</span> = <span class="title">rcu_dereference</span>(<span class="title">lpriv</span>-&gt;<span class="title">entries</span>);</span> <span class="comment">// 获取所有 NAT 规则</span></span><br><span class="line">            <span class="keyword">if</span> (!e)</span><br><span class="line">                <span class="keyword">goto</span> null_bind;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e-&gt;num_hook_entries; i++) &#123; <span class="comment">// 依次执行 NAT 规则</span></span><br><span class="line">                <span class="keyword">if</span> (e-&gt;hooks[i].hook(e-&gt;hooks[i].priv, skb, state) != NF_ACCEPT )</span><br><span class="line">                    <span class="keyword">return</span> ret;                         <span class="comment">// 任何规则返回非 NF_ACCEPT，就停止当前处理</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nf_nat_initialized(ct, maniptype))</span><br><span class="line">                    <span class="keyword">goto</span> do_nat;</span><br><span class="line">            &#125;</span><br><span class="line">null_bind:</span><br><span class="line">            nf_nat_alloc_null_binding(ct, state-&gt;hook);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Already setup manip</span></span><br><span class="line">            <span class="keyword">if</span> (nf_nat_oif_changed(state-&gt;hook, ctinfo, nat, state-&gt;out))</span><br><span class="line">                <span class="keyword">goto</span> oif_changed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* ESTABLISHED */</span></span><br><span class="line">        <span class="keyword">if</span> (nf_nat_oif_changed(state-&gt;hook, ctinfo, nat, state-&gt;out))</span><br><span class="line">            <span class="keyword">goto</span> oif_changed;</span><br><span class="line">    &#125;</span><br><span class="line">do_nat:</span><br><span class="line">    <span class="keyword">return</span> nf_nat_packet(ct, ctinfo, state-&gt;hook, skb);</span><br><span class="line">oif_changed:</span><br><span class="line">    nf_ct_kill_acct(ct, ctinfo, skb);</span><br><span class="line">    <span class="keyword">return</span> NF_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查询 conntrack 记录，如果不存在，就意味着无法跟踪这个连接，那就更不可能做 NAT 了，因此直接返回。</p><p>如果找到了 conntrack 记录，并且是 <code>IP_CT_RELATED</code>、<code>IP_CT_RELATED_REPLY</code> 或 <code>IP_CT_NEW</code> 状态，就去获取 NAT 规则。如果没有规则，直接返回 <code>NF_ACCEPT</code>，对包不 做任何改动；如果有规则，最后执行 <code>nf_nat_packet</code>，这个函数会进一步调用 <code>manip_pkt</code> 完成对包的修改，如果失败，包将被丢弃。</p><h3 id="Masquerade"><a class="header-anchor" href="#Masquerade">¶</a>Masquerade</h3><p>NAT 模块</p><ul><li>一般配置方式：<code>Change IP1 to IP2 if matching XXX</code>。</li><li>高级配置方式：<code>Change IP1 to dev1's IP if matching XXX</code>，这种方式称为 Masquerade。</li></ul><p>Masquerade 优缺点：</p><ul><li>优点：<strong>当设备（网卡）的 IP 地址发生变化时，NAT 规则无需做任何修改</strong>。</li><li>缺点：<strong>性能比第一种方式要差</strong>。</li></ul><h2 id="4-6-nf-nat-packet-：执行-NAT"><a class="header-anchor" href="#4-6-nf-nat-packet-：执行-NAT">¶</a>4.6 <code>nf_nat_packet()</code>：执行 NAT</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_nat_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do packet manipulations according to nf_nat_setup_info. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">nf_nat_packet</span><span class="params">(struct nf_conn *ct, <span class="keyword">enum</span> ip_conntrack_info ctinfo,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">unsigned</span> <span class="keyword">int</span> hooknum, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> nf_nat_manip_type mtype = HOOK2MANIP(hooknum);</span><br><span class="line">    <span class="keyword">enum</span> ip_conntrack_dir dir = CTINFO2DIR(ctinfo);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> verdict = NF_ACCEPT;</span><br><span class="line"></span><br><span class="line">    statusbit = (mtype == NF_NAT_MANIP_SRC? IPS_SRC_NAT : IPS_DST_NAT)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dir == IP_CT_DIR_REPLY)     <span class="comment">// Invert if this is reply dir</span></span><br><span class="line">        statusbit ^= IPS_NAT_MASK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ct-&gt;status &amp; statusbit)     <span class="comment">// Non-atomic: these bits don't change. */</span></span><br><span class="line">        verdict = nf_nat_manip_pkt(skb, ct, mtype, dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> verdict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">nf_nat_manip_pkt</span><span class="params">(struct sk_buff *skb, struct nf_conn *ct,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">enum</span> nf_nat_manip_type mtype, <span class="keyword">enum</span> ip_conntrack_dir dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> <span class="title">target</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We are aiming to look like inverse of other direction. */</span></span><br><span class="line">    nf_ct_invert_tuplepr(&amp;target, &amp;ct-&gt;tuplehash[!dir].tuple);</span><br><span class="line"></span><br><span class="line">    l3proto = __nf_nat_l3proto_find(target.src.l3num);</span><br><span class="line">    l4proto = __nf_nat_l4proto_find(target.src.l3num, target.dst.protonum);</span><br><span class="line">    <span class="keyword">if</span> (!l3proto-&gt;manip_pkt(skb, <span class="number">0</span>, l4proto, &amp;target, mtype)) <span class="comment">// 协议相关处理</span></span><br><span class="line">        <span class="keyword">return</span> NF_DROP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-1-查看-加载-卸载-nf-conntrack-模块"><a class="header-anchor" href="#5-1-查看-加载-卸载-nf-conntrack-模块">¶</a>5.1 查看 / 加载 / 卸载 nf_conntrack 模块</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ modinfo nf_conntrack</span><br><span class="line">filename:       /lib/modules/5.15.0-46-generic/kernel/net/netfilter/nf_conntrack.ko</span><br><span class="line">license:        GPL</span><br><span class="line"><span class="built_in">alias</span>:          nf_conntrack-10</span><br><span class="line"><span class="built_in">alias</span>:          nf_conntrack-2</span><br><span class="line"><span class="built_in">alias</span>:          ip_conntrack</span><br><span class="line">srcversion:     30B45E5822722ACEDE23A4B</span><br><span class="line">depends:        nf_defrag_ipv6,libcrc32c,nf_defrag_ipv4</span><br><span class="line">retpoline:      Y</span><br><span class="line">intree:         Y</span><br><span class="line">name:           nf_conntrack</span><br><span class="line">vermagic:       5.15.0-46-generic SMP mod_unload modversions</span><br><span class="line">sig_id:         PKCS<span class="comment">#7</span></span><br><span class="line">signer:         Build time autogenerated kernel key</span><br><span class="line">sig_key:        17:6F:92:2F:58:6B:B2:28:13:DC:71:DC:5A:97:EE:BA:D8:4B:C7:DE</span><br><span class="line">sig_hashalgo:   sha512</span><br><span class="line">signature:      0B:32:AA:93:F4:31:52:9C:FE:0D:80:B4:F6:7C:30:63:4C:F6:03:AA:</span><br><span class="line">                ...</span><br><span class="line">                E9:1F:45:C6:77:C2:29:99:B4:3D:1A:D2</span><br><span class="line">parm:           tstamp:Enable connection tracking flow timestamping. (bool)</span><br><span class="line">parm:           acct:Enable connection tracking flow accounting. (bool)</span><br><span class="line">parm:           nf_conntrack_helper:Enable automatic conntrack helper assignment (default 0) (bool)</span><br><span class="line">parm:           expect_hashsize:uint</span><br><span class="line">parm:           enable_hooks:Always <span class="built_in">enable</span> conntrack hooks (bool)</span><br></pre></td></tr></table></figure><p>卸载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rmmod nf_conntrack_netlink nf_conntrack</span><br></pre></td></tr></table></figure><p>重新加载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ modprobe nf_conntrack</span><br><span class="line"></span><br><span class="line"># 加载时还可以指定额外的配置参数，例如：</span><br><span class="line">$ modprobe nf_conntrack nf_conntrack_helper=1 expect_hashsize=131072</span><br></pre></td></tr></table></figure><h2 id="5-2-sysctl-配置项"><a class="header-anchor" href="#5-2-sysctl-配置项">¶</a>5.2 sysctl 配置项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -a | grep nf_conntrack</span><br><span class="line">net.netfilter.nf_conntrack_acct = 0</span><br><span class="line">net.netfilter.nf_conntrack_buckets = 262144                 # hashsize = nf_conntrack_max/nf_conntrack_buckets</span><br><span class="line">net.netfilter.nf_conntrack_checksum = 1</span><br><span class="line">net.netfilter.nf_conntrack_count = 2148</span><br><span class="line">... # DCCP options</span><br><span class="line">net.netfilter.nf_conntrack_events = 1</span><br><span class="line">net.netfilter.nf_conntrack_expect_max = 1024</span><br><span class="line">... # IPv6 options</span><br><span class="line">net.netfilter.nf_conntrack_generic_timeout = 600</span><br><span class="line">net.netfilter.nf_conntrack_helper = 0</span><br><span class="line">net.netfilter.nf_conntrack_icmp_timeout = 30</span><br><span class="line">net.netfilter.nf_conntrack_log_invalid = 0</span><br><span class="line">net.netfilter.nf_conntrack_max = 1048576                    # conntrack table size</span><br><span class="line">... # SCTP options</span><br><span class="line">net.netfilter.nf_conntrack_tcp_be_liberal = 0</span><br><span class="line">net.netfilter.nf_conntrack_tcp_loose = 1</span><br><span class="line">net.netfilter.nf_conntrack_tcp_max_retrans = 3</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_close = 10</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_established = 21600</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_last_ack = 30</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_max_retrans = 300</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_syn_recv = 60</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_syn_sent = 120</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_unacknowledged = 300</span><br><span class="line">net.netfilter.nf_conntrack_timestamp = 0</span><br><span class="line">net.netfilter.nf_conntrack_udp_timeout = 30</span><br><span class="line">net.netfilter.nf_conntrack_udp_timeout_stream = 180</span><br></pre></td></tr></table></figure><h2 id="5-3-监控"><a class="header-anchor" href="#5-3-监控">¶</a>5.3 监控</h2><h3 id="丢包监控"><a class="header-anchor" href="#丢包监控">¶</a>丢包监控</h3><p><code>/proc/net/stat</code> 下面有一些关于 conntrack 的详细统计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/net/stat/nf_conntrack</span><br><span class="line">entries   searched found    new      invalid  ignore   delete   delete_list insert   insert_failed drop     early_drop icmp_error  expect_new expect_create expect_delete search_restart</span><br><span class="line">000008e3  00000000 00000000 00000000 0000309d 001e72d4 00000000 00000000    00000000 00000000      00000000 00000000   000000ee    00000000   00000000      00000000       000368d7</span><br><span class="line">000008e3  00000000 00000000 00000000 00007301 002b8e8c 00000000 00000000    00000000 00000000      00000000 00000000   00000170    00000000   00000000      00000000       00035794</span><br><span class="line">000008e3  00000000 00000000 00000000 00001eea 001e6382 00000000 00000000    00000000 00000000      00000000 00000000   00000059    00000000   00000000      00000000       0003f166</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此外，还可以用 <code>conntrack</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ conntrack -S</span><br><span class="line">cpu=0   found=0 invalid=743150 ignore=238069 insert=0 insert_failed=0 drop=195603 early_drop=118583 error=16 search_restart=22391652</span><br><span class="line">cpu=1   found=0 invalid=2004   ignore=402790 insert=0 insert_failed=0 drop=44371  early_drop=34890  error=0  search_restart=1225447</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>ignore：不需要做连接跟踪的包（回忆前面，只有特定协议的包才会做连接跟踪）</li></ul><h3 id="conntrack-table-使用量监控"><a class="header-anchor" href="#conntrack-table-使用量监控">¶</a>conntrack table 使用量监控</h3><p>可以定期采集系统的 conntrack 使用量，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_count</span><br><span class="line">257273</span><br></pre></td></tr></table></figure><p>并与最大值比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_max</span><br><span class="line">262144</span><br></pre></td></tr></table></figure><h2 id="6-1-连接太多导致-conntrack-table-被打爆"><a class="header-anchor" href="#6-1-连接太多导致-conntrack-table-被打爆">¶</a>6.1 连接太多导致 conntrack table 被打爆</h2><h3 id="现象"><a class="header-anchor" href="#现象">¶</a>现象</h3><h4 id="业务层（应用层）现象"><a class="header-anchor" href="#业务层（应用层）现象">¶</a>业务层（应用层）现象</h4><ol><li><p>存在随机、偶发的<strong>新建连接</strong>超时（connect timeout）。</p><p>例如，如果业务用的是 Java，那对应的是 <code>jdbc4.CommunicationsException</code> communications link failure 之类的错误。</p></li><li><p><strong>已有连接</strong>正常。</p><p>也就是没有 read timeout 或 write timeout 之类的报错，报错都集中为 connect timeout。</p></li></ol><h4 id="网络层现象"><a class="header-anchor" href="#网络层现象">¶</a>网络层现象</h4><ol><li><p>抓包会看到三次握手的<strong>第一个 SYN 包被宿主机静默丢弃了</strong>。</p><p>需要注意的是，常规的网卡统计（<code>ifconfig</code>）和内核统计（<code>/proc/net/softnet_stat</code>） <strong>无法反映出这些丢包</strong>。</p></li><li><p><code>1s+</code> 之后出发 SYN 重传，或者还没重传连接就关闭了。</p><p><strong>第一个 SYN 的重传是 1s，这个是内核代码里写死的，不可配置</strong>（具体实现见 <a href="#ch_8.1">附录</a>）。</p><p>再考虑到其他一些耗时，第一次重传的实际间隔要大于 1s。 如果客户端设置的超时时间很小，例如 <code>1.05s</code>，那可能来不及重传连接就被关闭了，然后向上层报 connect timeout 错误。</p></li></ol><h4 id="操作系统层现象"><a class="header-anchor" href="#操作系统层现象">¶</a>操作系统层现象</h4><p>内核日志中有如下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ demsg -T</span><br><span class="line">[Tue Apr  6 18:12:30 2021] nf_conntrack: nf_conntrack: table full, dropping packet</span><br><span class="line">[Tue Apr  6 18:12:30 2021] nf_conntrack: nf_conntrack: table full, dropping packet</span><br><span class="line">[Tue Apr  6 18:12:30 2021] nf_conntrack: nf_conntrack: table full, dropping packet</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>另外，<code>cat /proc/net/stat/nf_conntrack</code> 或 <code>conntrack -S</code> 能看到有 drop 统计。</p><h3 id="确认-conntrack-table-被打爆"><a class="header-anchor" href="#确认-conntrack-table-被打爆">¶</a>确认 conntrack table 被打爆</h3><p>遇到以上现象，基本就是 conntrack 表被打爆了。确认：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_count</span><br><span class="line">257273</span><br><span class="line"></span><br><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_max</span><br><span class="line">net.netfilter.nf_conntrack_max = 262144</span><br></pre></td></tr></table></figure><p>如果有 conntrack count 监控会看的更清楚，因为我们命令行查看时，高峰可能过了。</p><h3 id="解决方式"><a class="header-anchor" href="#解决方式">¶</a>解决方式</h3><p>优先级从高到低：</p><ol><li><p>调大 conntrack 表</p><p>运行时配置（经实际测试，<strong>不会对现有连接造成影响</strong>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.netfilter.nf_conntrack_max=524288</span><br><span class="line">$ sysctl -w net.netfilter.nf_conntrack_buckets=131072 # 推荐配置 hashsize=nf_conntrack_count/4</span><br></pre></td></tr></table></figure><p>持久化配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;net.netfilter.nf_conntrack_max = 524288&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">$ echo &apos;net.netfilter.nf_conntrack_buckets = 131072&apos; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>影响：连接跟踪模块<strong>会多用一些内存</strong>。具体多用多少内存，可参考 <a href="#ch_8.2">附录</a>。</p></li><li><p>减小 GC 时间</p><p>还可以调小 conntrack 的 GC（也叫 timeout）时间，加快过期 entry 的回收。</p><p><code>nf_conntrack</code> 针对不同 TCP 状态（established、fin_wait、time_wait 等）的 entry 有不同的 GC 时间。</p><p>例如，<strong>默认的 established 状态的 GC 时间是 423000s（5 天）</strong>。设置成这么长的 <strong>可能原因</strong>是：TCP/IP 协议中允许 established 状态的连接无限期不发送任何东西（但仍然活着） [8]，协议的具体实现（Linux、BSD、Windows 等）会设置各自允许的最大 idle timeout。为防止 GC 掉这样长时间没流量但实际还活着的连接，就设置一个足够保守的 timeout 时间。[8] 中建议这个值不小于 2 小时 4 分钟（作为对比和参考， <strong>Cilium 自己实现的 CT 中，默认 established GC 是 6 小时</strong>）。 但也能看到一些厂商推荐比这个小得多的配置，例如 20 分钟。</p><p>如果对自己的网络环境和需求非常清楚，那可以将这个时间调到一个合理的、足够小的值； 如果不是非常确定的话，还是<strong>建议保守一些，例如设置 6 个小时</strong> —— 这已经比默认值 5 天小多了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.netfilter.nf_conntrack_tcp_timeout_established = 21600</span><br></pre></td></tr></table></figure><p>持久化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;net.netfilter.nf_conntrack_tcp_timeout_established = 21600&apos; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>其他几个 timeout 值（尤其是 <code>nf_conntrack_tcp_timeout_time_wait</code>，默认 <code>120s</code>）也可以适当调小， 但还是那句话：<strong>如果不确定潜在后果，千万不要激进地调小</strong>。</p></li></ol><p>连接跟踪是一个非常基础且重要的网络模块，但只有在少数场景下才会引起普通开发者的注意。</p><p>例如，L4LB 短时高并发场景下，LB 节点每秒接受大量并发短连接，可能导致 conntrack table 被打爆。此时的现象是：</p><ul><li>客户端和 L4LB 建连失败，失败可能是随机的，也可能是集中在某些时间点。</li><li>客户端重试可能会成功，也可能会失败。</li><li>在 L4LB 节点抓包看，客户端过来的 TCP SYNC 包 L4LB 收到了，但没有回 ACK。即，包 被静默丢弃了（silently dropped）。</li></ul><p>此时的原因可能是 conntrack table 太小，也可能是 GC 不够及 时，甚至是 <a href="https://github.com/cilium/cilium/pull/12729" target="_blank" rel="noopener">GC 有 bug</a>。</p><h2 id="8-1-第一个-SYN-包的重传间隔计算（Linux-4-19-118-实现）"><a class="header-anchor" href="#8-1-第一个-SYN-包的重传间隔计算（Linux-4-19-118-实现）">¶</a>8.1 第一个 SYN 包的重传间隔计算（Linux 4.19.118 实现）</h2><p>调用路径：<code>tcp_connect() -&gt; tcp_connect_init() -&gt; tcp_timeout_init()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp_output.c</span></span><br><span class="line"><span class="comment">/* Do all connect socket setups that can be done AF independent. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcp_connect_init</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inet_csk(sk)-&gt;icsk_rto = tcp_timeout_init(sk);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/net/tcp.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u32 <span class="title">tcp_timeout_init</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取 SYN-RTO：如果这个 socket 上没有 BPF 程序，或者有 BPF 程序但执行失败，都返回 -1</span></span><br><span class="line">    <span class="comment">// 除非用户自己编写 BPF 程序并 attach 到 cgroup/socket，否则这里都是没有 BPF 的，因此这里返回 -1</span></span><br><span class="line">    timeout = tcp_call_bpf(sk, BPF_SOCK_OPS_TIMEOUT_INIT, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>)                <span class="comment">// timeout == -1，接下来使用默认值</span></span><br><span class="line">        timeout = TCP_TIMEOUT_INIT;  <span class="comment">// 宏定义，等于系统的 HZ 数，也就是 1 秒，见下面</span></span><br><span class="line">    <span class="keyword">return</span> timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/net/tcp.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_RTO_MAX    ((unsigned)(120*HZ))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_RTO_MIN    ((unsigned)(HZ/5))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_TIMEOUT_MIN    (2U) <span class="comment">/* Min timeout for TCP timers in jiffies */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_TIMEOUT_INIT ((unsigned)(1*HZ))    <span class="comment">/* RFC6298 2.1 initial RTO value    */</span></span></span><br></pre></td></tr></table></figure><h2 id="8-2-根据-nf-conntrack-max-计算-conntrack-模块所需的内存"><a class="header-anchor" href="#8-2-根据-nf-conntrack-max-计算-conntrack-模块所需的内存">¶</a>8.2 根据 nf_conntrack_max 计算 conntrack 模块所需的内存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/slabinfo | head -n2; cat /proc/slabinfo | grep conntrack</span><br><span class="line">slabinfo - version: 2.1</span><br><span class="line"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span><br><span class="line">nf_conntrack      512824 599505    320   51    4 : tunables    0    0    0 : slabdata  11755  11755      0</span><br></pre></td></tr></table></figure><p>其中的 <strong>objsize 表示这个内核对象</strong>（这里对应的是 <code>struct nf_conn</code>）的大小， 单位是<strong>字节</strong>，所以以上输出表明<strong>每个 conntrack entry 占用 320 字节的内存空间</strong>。</p><p>如果忽略内存碎片（内存分配单位为 slab），那<strong>不同 size 的 conntrack table 占用的内存</strong>如下：</p><ul><li><code>nf_conntrack_max=512K</code>: <code>512K * 320Byte = 160MB</code></li><li><code>nf_conntrack_max=1M</code>: <code>1M * 320Byte = 320MB</code></li></ul><p>更精确的计算，可以参考 [9]。</p><ol><li><a href="https://wiki.aalto.fi/download/attachments/69901948/netfilter-paper.pdf" target="_blank" rel="noopener">Netfilter connection tracking and NAT implementation</a>. Proc. Seminar on Network Protocols in Operating Systems, Dept. Commun. and Networking, Aalto Univ. 2013.</li><li><a href="https://docs.cilium.io/en/v1.7/gettingstarted/kubeproxy-free/" target="_blank" rel="noopener">Cilium: Kubernetes without kube-proxy</a></li><li><a href="chrome-extension://ijllcpnolfcooahcekpamkbidhejabll/blog/k8s-l4lb/" target="_blank" rel="noopener">L4LB for Kubernetes: Theory and Practice with Cilium+BGP+ECMP</a></li><li><a href="https://docs.docker.com/network/bridge/" target="_blank" rel="noopener">Docker bridge network mode</a></li><li><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Wikipedia: Netfilter</a></li><li><a href="https://blog.cloudflare.com/conntrack-tales-one-thousand-and-one-flows/" target="_blank" rel="noopener">Conntrack tales - one thousand and one flows</a></li><li><a href="https://www.redhat.com/en/blog/how-connection-tracking-open-vswitch-helps-openstack-performance" target="_blank" rel="noopener">How connection tracking in Open vSwitch helps OpenStack performance</a></li><li><a href="https://tools.ietf.org/html/rfc5382#section-5" target="_blank" rel="noopener">NAT Behavioral Requirements for TCP</a>, RFC5382</li><li><a href="https://johnleach.co.uk/posts/2009/06/17/netfilter-conntrack-memory-usage/" target="_blank" rel="noopener">Netfilter Conntrack Memory Usage</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#摘要&quot;&gt;¶&lt;/a&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文介绍连接跟踪（connection tracking，conntrack，CT）的原理，应用，及其在 Linux 内核中的实现。&lt;/p&gt;
&lt;p&gt;代码分析基于内核 &lt;code&gt;4.19&lt;/code&gt;。为使行文简洁，所贴代码只保留了核心逻辑，但都给出了代码 所在的源文件，如有需要请查阅。&lt;/p&gt;
&lt;p&gt;水平有限，文中不免有错误之处，欢迎指正交流。&lt;/p&gt;
&lt;p&gt;连接跟踪是许多网络应用的基础。例如，Kubernetes Service、ServiceMesh sidecar、 软件四层负载均衡器 LVS/IPVS、Docker network、OVS、iptables 主机防火墙等等，都依赖 连接跟踪功能。&lt;/p&gt;
    
    </summary>
    
      <category term="连接跟踪" scheme="https://talengu.github.io/public/categories/%E8%BF%9E%E6%8E%A5%E8%B7%9F%E8%B8%AA/"/>
    
    
      <category term="conntrack" scheme="https://talengu.github.io/public/tags/conntrack/"/>
    
  </entry>
  
  <entry>
    <title>「202211月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/11/26/test/202211_obsidian/"/>
    <id>https://talengu.github.io/public/2022/11/26/test/202211_obsidian/</id>
    <published>2022-11-26T16:00:04.000Z</published>
    <updated>2022-11-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 0 📅 : 0 🔖 : 0</p><a id="more"></a><h2 id="✅-0"><a class="header-anchor" href="#✅-0">¶</a>✅ : 0</h2><h2 id="📅-0"><a class="header-anchor" href="#📅-0">¶</a>📅 : 0</h2><h2 id="🔖-0"><a class="header-anchor" href="#🔖-0">¶</a>🔖 : 0</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 0 📅 : 0 🔖 : 0&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>「202211月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/11/15/test/202211/"/>
    <id>https://talengu.github.io/public/2022/11/15/test/202211/</id>
    <published>2022-11-15T16:00:04.000Z</published>
    <updated>2022-11-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 1</p><a id="more"></a><h2 id="🔖微软官方小工具更新，这些新特性你或许也能用得上"><a class="header-anchor" href="#🔖微软官方小工具更新，这些新特性你或许也能用得上">¶</a>🔖<a href="https://sspai.com/post/76649" target="_blank" rel="noopener">微软官方小工具更新，这些新特性你或许也能用得上</a></h2><p>pubdata:2022-11-06 03:40:00markdate:2022-11-17 17:18:09.571032</p><p><img src="/public/2022/11/15/test/202211/2022-11-17-171809571032.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 1&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>「202210月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/10/26/test/202210_obsidian/"/>
    <id>https://talengu.github.io/public/2022/10/26/test/202210_obsidian/</id>
    <published>2022-10-26T16:00:04.000Z</published>
    <updated>2022-10-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 0 📅 : 2 🔖 : 8</p><a id="more"></a><h2 id="✅-0"><a class="header-anchor" href="#✅-0">¶</a>✅ : 0</h2><h2 id="📅-2"><a class="header-anchor" href="#📅-2">¶</a>📅 : 2</h2><p>📅 转载一下-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>📅 tracker更新-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a></p><h2 id="🔖-8"><a class="header-anchor" href="#🔖-8">¶</a>🔖 : 8</h2><p>🔖肝下50万字的《Linux内核精通》笔记，你的底层原理水平将从入门到入魔【建议收藏】-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖计算机组成原理(万字爆肝整理)-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖 <a href="https://xiaolincoding.com/network/" target="_blank" rel="noopener">图解网络介绍</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>🔖 <a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener">常用设计模式有哪些？</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>🔖 智能家庭网关-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>🔖 <a href="https://sadh.life/post/builtins/" target="_blank" rel="noopener">Understanding all of Python, through its builtins</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>🔖 操作系统自学-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>🔖 机器人计划-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 0 📅 : 2 🔖 : 8&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>「202210月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/10/15/test/202210/"/>
    <id>https://talengu.github.io/public/2022/10/15/test/202210/</id>
    <published>2022-10-15T16:00:04.000Z</published>
    <updated>2022-10-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 2</p><a id="more"></a><h2 id="🔖一日一技｜Obsidian-Command-进阶用法三则"><a class="header-anchor" href="#🔖一日一技｜Obsidian-Command-进阶用法三则">¶</a>🔖<a href="https://sspai.com/post/75847" target="_blank" rel="noopener">一日一技｜Obsidian Command 进阶用法三则</a></h2><p>pubdata:2022-10-01 07:00:00markdate:2022-10-08 11:41:38.979766</p><p><img src="/public/2022/10/15/test/202210/2022-10-08-114138979766.jpg" alt="img"></p><h2 id="🔖用代码编辑器进行知识管理：我用-VSCode-构建自己的笔记系统"><a class="header-anchor" href="#🔖用代码编辑器进行知识管理：我用-VSCode-构建自己的笔记系统">¶</a>🔖<a href="https://sspai.com/post/75940" target="_blank" rel="noopener">用代码编辑器进行知识管理：我用 VSCode 构建自己的笔记系统</a></h2><p>pubdata:2022-09-28 03:29:57markdate:2022-10-09 04:14:05.692239</p><p><img src="/public/2022/10/15/test/202210/2022-10-09-041405692239.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 2&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>「202209月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/09/26/test/202209_obsidian/"/>
    <id>https://talengu.github.io/public/2022/09/26/test/202209_obsidian/</id>
    <published>2022-09-26T16:00:04.000Z</published>
    <updated>2022-09-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 0 📅 : 2 🔖 : 10</p><a id="more"></a><h2 id="✅-0"><a class="header-anchor" href="#✅-0">¶</a>✅ : 0</h2><h2 id="📅-2"><a class="header-anchor" href="#📅-2">¶</a>📅 : 2</h2><p>📅升级电脑-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W35.md">C日常/2022-W35.md</a><br>📅 添加rss-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a></p><h2 id="🔖-10"><a class="header-anchor" href="#🔖-10">¶</a>🔖 : 10</h2><p>🔖 <a href="https://www.appinn.com/umi-ocr/" target="_blank" rel="noopener">Umi-OCR - 免费的离线 OCR 文字识别软件[Windows] - 小众软件</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖 设计模式-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖 苏炳添向母校捐赠100万元！-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖 <a href="https://github.com/dlvhdr/gh-dash" target="_blank" rel="noopener">gh-dash</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖 <a href="https://nginxproxymanager.com/" target="_blank" rel="noopener">Nginx Proxy Manager</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖1、<a href="https://knots3d.com/knots/en_us/ALL" target="_blank" rel="noopener">Knots 3D</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>🔖 <a href="https://m.runoob.com/typescript/" target="_blank" rel="noopener">TypeScript 教程 | 菜鸟教程</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>🔖 <a href="https://m.runoob.com/js/" target="_blank" rel="noopener">Javascript 教程 | 菜鸟教程</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>🔖 Makefile-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>🔖 <a href="https://www.zhihu.com/question/450738311/answer/2635126508?utm_medium=social&amp;utm_oi=619610399826382848&amp;utm_psn=1545021439438381056&amp;utm_source=ZHShareTargetIDMore" target="_blank" rel="noopener">windows 有什么好用的截图软件？ - 知乎</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 0 📅 : 2 🔖 : 10&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「202209月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/09/15/test/202209/"/>
    <id>https://talengu.github.io/public/2022/09/15/test/202209/</id>
    <published>2022-09-15T16:00:04.000Z</published>
    <updated>2022-09-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 3</p><a id="more"></a><h2 id="🔖WireGuard-基础教程：wg-quick-路由策略解读"><a class="header-anchor" href="#🔖WireGuard-基础教程：wg-quick-路由策略解读">¶</a>🔖<a href="https://icloudnative.io/posts/linux-routing-of-wireguard/" target="_blank" rel="noopener">WireGuard 基础教程：wg-quick 路由策略解读</a></h2><p>pubdata:2022-08-31 01:06:37markdate:2022-09-03 06:23:25.656749</p><p><img src="/public/2022/09/15/test/202209/2022-09-03-062325656749.jpg" alt="img"></p><h2 id="🔖微软官方超实用-15-小工具集-PowerToys-v0-62-0-发布，新增文本提取器-OCR-功能"><a class="header-anchor" href="#🔖微软官方超实用-15-小工具集-PowerToys-v0-62-0-发布，新增文本提取器-OCR-功能">¶</a>🔖<a href="https://www.appinn.com/powertoys-v0-62-0/" target="_blank" rel="noopener">微软官方超实用 15+ 小工具集 PowerToys v0.62.0 发布，新增文本提取器 OCR 功能</a></h2><p>pubdata:2022-09-07 04:11:14markdate:2022-09-08 04:19:59.942860</p><p><img src="/public/2022/09/15/test/202209/2022-09-08-041959942860.jpg" alt="img"></p><h2 id="🔖Stream-Deck-太贵了？触屏音箱也能成为你的直播助手"><a class="header-anchor" href="#🔖Stream-Deck-太贵了？触屏音箱也能成为你的直播助手">¶</a>🔖<a href="https://sspai.com/post/75789" target="_blank" rel="noopener">Stream Deck 太贵了？触屏音箱也能成为你的直播助手</a></h2><p>pubdata:2022-09-19 06:31:44markdate:2022-09-21 03:28:05.514939</p><p><img src="/public/2022/09/15/test/202209/2022-09-21-032805514939.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 3&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「202208月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/08/26/test/202208_obsidian/"/>
    <id>https://talengu.github.io/public/2022/08/26/test/202208_obsidian/</id>
    <published>2022-08-26T16:00:04.000Z</published>
    <updated>2022-08-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 1 📅 : 1 🔖 : 26</p><a id="more"></a><h2 id="✅-1"><a class="header-anchor" href="#✅-1">¶</a>✅ : 1</h2><p>✅自动生成rss月报-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a></p><h2 id="📅-1"><a class="header-anchor" href="#📅-1">¶</a>📅 : 1</h2><p>📅 加上地区统计-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a></p><h2 id="🔖-26"><a class="header-anchor" href="#🔖-26">¶</a>🔖 : 26</h2><p>🔖 <a href="https://github.com/serhack/pdf-diff" target="_blank" rel="noopener">GitHub - serhack/pdf-diff: A tool for visualizing differences between two pdf files.</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="http://arthurchiao.art/blog/conntrack-design-and-implementation-zh/" target="_blank" rel="noopener">连接跟踪（conntrack）：原理、应用及 Linux 内核实现</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="https://codemirror.net/docs/guide/" target="_blank" rel="noopener">CodeMirror System Guide</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/357334969?utm_id=0" target="_blank" rel="noopener">mac使用VNC远程访问Ubuntu图形界面</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="https://mp.weixin.qq.com/s/FBJ_GIvdwNbvGKVKeroZjA" target="_blank" rel="noopener">冠军私教课</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="https://cloud.tencent.com/developer/article/1585686" target="_blank" rel="noopener">如何统计 Hexo 网站的访问地区和IP - 腾讯云开发者社区-腾讯云</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="https://www.appinn.com/navidrome/" target="_blank" rel="noopener">Navidrome - 开源音乐服务器，自建云端音乐播放器 - 小众软件</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W30.md">C日常/2022-W30.md</a><br>🔖 <a href="https://sspai.com/post/73443" target="_blank" rel="noopener">力量训练：办卡之前需要了解的训练基础与细节制定 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W30.md">C日常/2022-W30.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/495262462" target="_blank" rel="noopener">网站低代码开发</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖长大后，如果是时间修剪了我们的好奇心，我们应该责怪时间吗？-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖半导体行业的组成-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖Weylus – 共享屏幕，将平板作为电脑触摸屏使用[Win/macOS/Linux]-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖跨平台开发 <a href="https://beeware.org/" target="_blank" rel="noopener">BeeWare</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖资本论复旦大学-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 Linux三剑客-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖pdf补丁丁-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://www.wdbyte.com/java/char-image.html_1-%E5%AD%97%E7%AC%A6%E5%9B%BE%E6%A1%88%E6%80%9D%E8%B7%AF" target="_blank" rel="noopener">字符作画，我用字符画个冰墩墩 | 未读代码</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/474337723?utm_source=ZHShareTargetIDMore&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">一文让你读懂Linux五大模块内核源码，内核整体架构设计（超详细）</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/483731291?utm_source=ZHShareTargetIDMore&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">学习数学思维推荐阅读的五本数学书籍</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖Snapdrop for Android – 在电脑与 Android 手机间互传文件-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖Photoview – 支持人脸识别的开源、自托管本地相册-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖GitHub - LibrePhotos/librephotos: A self-hosted open source photo management service. This is the repository of the backend.-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://www.cnblogs.com/imxiaobei/p/13619630.html" target="_blank" rel="noopener">一文搞懂后台高性能服务器设计的常见套路, BAT 高频面试系列 - 编程指北 - 博客园</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://www.appinn.com/dual-subtitles/" target="_blank" rel="noopener">YouTube™ 双字幕 - 显示双语字幕（包括自动翻译）、字幕下载，以及自定义字幕样式[Chrome/Edge] - 小众软件</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://mp.weixin.qq.com/s/cd-uS5NDIreT02GaHpdxlw" target="_blank" rel="noopener">一文搞懂WiFi的所有知识点</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/122523174" target="_blank" rel="noopener">Doxygen 中文文档</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 1 📅 : 1 🔖 : 26&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「202208月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/08/15/test/202208/"/>
    <id>https://talengu.github.io/public/2022/08/15/test/202208/</id>
    <published>2022-08-15T16:00:04.000Z</published>
    <updated>2022-08-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 5</p><a id="more"></a><h2 id="🔖AVNC-–-Android-上的开源-VNC-客户端"><a class="header-anchor" href="#🔖AVNC-–-Android-上的开源-VNC-客户端">¶</a>🔖<a href="https://www.appinn.com/avnc-for-android/" target="_blank" rel="noopener">AVNC – Android 上的开源 VNC 客户端</a></h2><p>pubdata:2022-08-07 04:59:52markdate:2022-08-07 17:42:37.878979</p><p><img src="/public/2022/08/15/test/202208/2022-08-07-174237878979.jpg" alt="img"></p><h2 id="🔖TigerVNC-–-高性能、跨平台开源-VNC-服务器与客户端"><a class="header-anchor" href="#🔖TigerVNC-–-高性能、跨平台开源-VNC-服务器与客户端">¶</a>🔖<a href="https://www.appinn.com/tigervnc/" target="_blank" rel="noopener">TigerVNC – 高性能、跨平台开源 VNC 服务器与客户端</a></h2><p>pubdata:2022-08-08 04:30:32markdate:2022-08-09 00:48:54.680756</p><p><img src="/public/2022/08/15/test/202208/2022-08-09-004854680756.jpg" alt="img"></p><h2 id="🔖Notion-又一开源替代品，诞生了！"><a class="header-anchor" href="#🔖Notion-又一开源替代品，诞生了！">¶</a>🔖<a href="https://zhuanlan.zhihu.com/p/552965032" target="_blank" rel="noopener">Notion 又一开源替代品，诞生了！</a></h2><p>pubdata:2022-08-12 04:42:26markdate:2022-08-13 16:16:00.234349</p><p><img src="/public/2022/08/15/test/202208/2022-08-13-161600234349.jpg" alt="img"></p><h2 id="🔖如何写一份高可读性的软件工程设计文档"><a class="header-anchor" href="#🔖如何写一份高可读性的软件工程设计文档">¶</a>🔖<a href="https://zhuanlan.zhihu.com/p/552095835" target="_blank" rel="noopener">如何写一份高可读性的软件工程设计文档</a></h2><p>pubdata:2022-08-10 09:00:14markdate:2022-08-20 02:27:47.773301</p><p><img src="/public/2022/08/15/test/202208/2022-08-20-022747773301.jpg" alt="img"></p><h2 id="🔖StrokesPlus-net-–-一款很厉害的鼠标手势软件，还有大佬汉化、以及持续更新脚本"><a class="header-anchor" href="#🔖StrokesPlus-net-–-一款很厉害的鼠标手势软件，还有大佬汉化、以及持续更新脚本">¶</a>🔖<a href="https://www.appinn.com/strokesplus-net/" target="_blank" rel="noopener">StrokesPlus.net – 一款很厉害的鼠标手势软件，还有大佬汉化、以及持续更新脚本</a></h2><p>pubdata:2022-08-24 04:29:23markdate:2022-08-25 03:51:08.820884</p><p><img src="/public/2022/08/15/test/202208/2022-08-25-035108820884.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 5&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「202207月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/07/26/test/202207_obsidian/"/>
    <id>https://talengu.github.io/public/2022/07/26/test/202207_obsidian/</id>
    <published>2022-07-26T16:00:04.000Z</published>
    <updated>2022-07-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 6 📅 : 3 🔖 : 47</p><a id="more"></a><h2 id="✅-6"><a class="header-anchor" href="#✅-6">¶</a>✅ : 6</h2><p>✅目标图标系统-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>✅ <a href="https://blog.csdn.net/hhhhhyyyyy8/article/details/102133863" target="_blank" rel="noopener">Linux内核数据包bridge上转发流程_hhhhhyyyyy8的博客-CSDN博客_br_multicast_flood</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>✅ 邮箱转rss-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a><br>✅  hacker news rss添加-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a><br>✅ 经济学人转载leader文章-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a><br>✅ github博客评论系统是否换成【不换】-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a></p><h2 id="📅-3"><a class="header-anchor" href="#📅-3">¶</a>📅 : 3</h2><p>📅 端口触发 端口转发-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>📅 全屋智能-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>📅 改进-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a></p><h2 id="🔖-47"><a class="header-anchor" href="#🔖-47">¶</a>🔖 : 47</h2><p>🔖 ish保持后台运行-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>🔖 <a href="https://www.jianshu.com/p/f29ca723db4f" target="_blank" rel="noopener">Git 运行配置（git config、gitk、git gui） - michael_jia - 简书</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>🔖<a href="https://www.cnblogs.com/xuanbjut/p/12624702.html" target="_blank" rel="noopener">wmctrl像xmonad那样方便地用快捷键来控制任务窗口的显示 - pycod - 博客园</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>🔖 <a href="https://blog.csdn.net/anlian523/article/details/113627568" target="_blank" rel="noopener">VSCode复制代码时去掉样式/语法高亮/代码高亮/黑色背景_anlian523的博客-CSDN博客_idea复制代码不带黑色背景</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>🔖 <a href="https://blog.csdn.net/dog250/article/details/121400218" target="_blank" rel="noopener">为什么除法，开方，求对数比乘法，乘方，求指数更难_dog250的博客-CSDN博客</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖学习小林博客的写法-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖一万字统计学梳理-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖腾讯 彻底搞清楚tcp-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖0x5f3759df这个快速开方中的常数的数学依据是什么？-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖https流程-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖使用 Clion + QEMU/GDB 远程调试Linux内核（分享自知乎网）<a href="https://zhuanlan.zhihu.com/p/412604505?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/412604505?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖TCP/IP协议到底在讲什么？ <a href="http://www.zhihu.com/question/51074319?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">http://www.zhihu.com/question/51074319?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【什么是动态规划（Dynamic Programming）？动态规划的意义是什么？】阮行止：… <a href="https://www.zhihu.com/question/23995189/answer/613096905?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/23995189/answer/613096905?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【为什么有人说弄懂了《算法导论》的 90%，就超越了 90%的程序员？】启舰：… <a href="https://www.zhihu.com/question/315201616/answer/1960517601?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/315201616/answer/1960517601?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【vs code】【keil】优雅地使用vs code代替keil。by 童话与云 👉 <a href="https://www.zhihu.com/zvideo/1422934459457253376?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/zvideo/1422934459457253376?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖图解网络 - 75张图带你了解网络设备、网络地址规划、静态路由、实战演练（分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖vscode-journal：vscode中写日记/便签/提醒，配合nutstore与安卓、ios同步_TeQuL的博客-CSDN博客-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖结构体（结构体嵌套、结构体指针、结构体参数传递） - 蓝海人 - 博客园-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖Feedme - 8大 RSS 阅读器第三方客户端[Android] - 小众软件-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖聪明人必学的停车小技巧！。by Felicidades 👉 <a href="https://www.zhihu.com/zvideo/1414008107094093824?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/zvideo/1414008107094093824?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖在线 DOS 游戏 - 近 2000 款怀旧游戏，仙剑、红警、三国志、大富翁、明星志愿、大航海、主题医院等 - 小众软件-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖Feeddd · 重新掌控你的订阅源-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【如何长时间高效学习？】硬核学长2077：… <a href="https://www.zhihu.com/question/28358499/answer/1762418904?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/28358499/answer/1762418904?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【你身边的学霸都有怎样的学习方法或习惯？】硬核学长2077：… <a href="https://www.zhihu.com/question/54265751/answer/1995587976?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/54265751/answer/1995587976?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【如何不痛苦地早起？】铁木君：… <a href="https://www.zhihu.com/question/22120300/answer/1887544838?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/22120300/answer/1887544838?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖[[obsidian_tips]]-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖<a href="https://sspai.com/post/72757" target="_blank" rel="noopener">随时可用的 PC 体验是这样「炼」成的，Windows 新版睡眠机制详解 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖<a href="https://blog.csdn.net/who538592/article/details/79483323" target="_blank" rel="noopener">TC流量控制_who538592的博客-CSDN博客_tc流量控制</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖 <a href="https://sspai.com/post/74090" target="_blank" rel="noopener">大家都说好的蛋白粉，我们应该如何取舍 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/508345279" target="_blank" rel="noopener">我的obsidian插件开发的学习过程</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>🔖 <a href="https://blog.csdn.net/Haywardwang/article/details/108626491" target="_blank" rel="noopener">python 词云构建_Haywardwang的博客-CSDN博客</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>🔖 <a href="https://blog.csdn.net/weixin_56842628/article/details/117921526?utm_medium=distribute.wap_relevant.none-task-blog-2~default~baidujs_title~default-9-117921526-blog-108626491.wap_blog_relevant_default&amp;spm=1001.2101.3001.4242.6&amp;utm_relevant_index=10" target="_blank" rel="noopener">如何用Python制作简单又好看的词云？来瞅瞅吧~_小熊爱Python的博客-CSDN博客_python词云代码简单</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>🔖 <a href="https://sspai.com/post/73779" target="_blank" rel="noopener">跨时空圆桌：伟大创作者们如何安排日常生活 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://www.appinn.com/typing-learner/" target="_blank" rel="noopener">Typing Learner - 硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」[Windows/macOS] - 小众软件</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://www.zhihu.com/question/391756708/answer/2556173863" target="_blank" rel="noopener">SpaceX的可回收火箭有什么神奇之处，为何其他航天大国还不能仿造？ - YY硕 的回答 - 知乎</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://mp.weixin.qq.com/s/KBKO4C1d4CkyHAPEkh8D4Q" target="_blank" rel="noopener">这几个通信协议的动图不错</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://oorkan.medium.com/emojifying-your-linux-terminal-9a5c1e8f6b3c" target="_blank" rel="noopener">Emojifying your Linux terminal  🚀</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://sspai.com/post/74167" target="_blank" rel="noopener">为 WSL 配置这些新功能，不用虚拟机也能体验完整 Linux - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖<a href="https://sspai.com/post/72274" target="_blank" rel="noopener">意识先行，工具辅助：谈谈我们该怎样分辨虚假信息</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖<a href="https://zhuanlan.zhihu.com/p/495262462" target="_blank" rel="noopener">网站低代码开发</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 学习体系化，效率提升-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://sspai.com/post/73958" target="_blank" rel="noopener">玩转 Obsidian 08：利用 Dataview 打造自动化 HomePage - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>🔖 <a href="https://post.m.smzdm.com/p/adwgg2rd/" target="_blank" rel="noopener">小爱同学，打开我的三菱空调——米家空调伴侣2使用分享_智能家居_什么值得买</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>🔖 <a href="https://sspai.com/post/73829" target="_blank" rel="noopener">用 59 分钟，找到工具的效率之源 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>🔖 <a href="https://cloud.tencent.com/developer/article/1879646" target="_blank" rel="noopener">tcpdump是在哪儿抓到的包？ - 腾讯云开发者社区-腾讯云</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>🔖 <a href="https://www.jianshu.com/p/79bcf09aed25" target="_blank" rel="noopener">IPTables五----ebtables - marshalzxy - 简书</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>🔖 <a href="https://david-waiting.medium.com/a-beginners-guide-to-generic-routing-encapsulation-fb2b4fb63abb" target="_blank" rel="noopener">A Beginner’s Guide to Generic Routing Encapsulation</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 6 📅 : 3 🔖 : 47&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「202207月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/07/15/test/202207/"/>
    <id>https://talengu.github.io/public/2022/07/15/test/202207/</id>
    <published>2022-07-15T16:00:04.000Z</published>
    <updated>2022-07-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 13</p><a id="more"></a><h2 id="🔖BGmi-–-自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人"><a class="header-anchor" href="#🔖BGmi-–-自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人">¶</a>🔖<a href="https://www.appinn.com/bgmi/" target="_blank" rel="noopener">BGmi – 自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人</a></h2><p>pubdata:2022-06-30 02:48:00markdate:2022-07-01 06:32:58.020141</p><p><img src="/public/2022/07/15/test/202207/2022-07-01-063258020141.jpg" alt="img"></p><h2 id="🔖老牌截图工具-PicPick-更新，新增录屏功能，支持-MP4-GIF-格式"><a class="header-anchor" href="#🔖老牌截图工具-PicPick-更新，新增录屏功能，支持-MP4-GIF-格式">¶</a>🔖<a href="https://www.appinn.com/picpick-6-2/" target="_blank" rel="noopener">老牌截图工具 PicPick 更新，新增录屏功能，支持 MP4/GIF 格式</a></h2><p>pubdata:2022-06-29 07:19:19markdate:2022-07-02 04:11:20.453414</p><p><img src="/public/2022/07/15/test/202207/2022-07-02-041120453414.jpg" alt="img"></p><h2 id="🔖白板与笔记融合：我的四个氢图使用场景"><a class="header-anchor" href="#🔖白板与笔记融合：我的四个氢图使用场景">¶</a>🔖<a href="https://sspai.com/post/73246" target="_blank" rel="noopener">白板与笔记融合：我的四个氢图使用场景</a></h2><p>pubdata:2022-06-30 03:30:02markdate:2022-07-03 01:08:35.583781</p><p><img src="/public/2022/07/15/test/202207/2022-07-03-010835583781.jpg" alt="img"></p><h2 id="🔖跨时空圆桌：伟大创作者们如何安排日常生活"><a class="header-anchor" href="#🔖跨时空圆桌：伟大创作者们如何安排日常生活">¶</a>🔖<a href="https://sspai.com/post/73779" target="_blank" rel="noopener">跨时空圆桌：伟大创作者们如何安排日常生活</a></h2><p>pubdata:2022-06-15 09:30:00markdate:2022-07-03 01:50:35.971655</p><p><img src="/public/2022/07/15/test/202207/2022-07-03-015035971655.jpg" alt="img"></p><h2 id="🔖Typing-Learner-–-硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」-Windows-macOS"><a class="header-anchor" href="#🔖Typing-Learner-–-硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」-Windows-macOS">¶</a>🔖<a href="https://www.appinn.com/typing-learner/" target="_blank" rel="noopener">Typing Learner – 硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」[Windows/macOS]</a></h2><p>pubdata:2022-07-03 04:07:39markdate:2022-07-04 05:06:58.902152</p><p><img src="/public/2022/07/15/test/202207/2022-07-04-050658902152.jpg" alt="img"></p><h2 id="🔖创建自己的第一个-Power-Automate-工作流，从此繁琐操作是路人"><a class="header-anchor" href="#🔖创建自己的第一个-Power-Automate-工作流，从此繁琐操作是路人">¶</a>🔖<a href="https://sspai.com/post/73710" target="_blank" rel="noopener">创建自己的第一个 Power Automate 工作流，从此繁琐操作是路人</a></h2><p>pubdata:2022-07-05 10:44:47markdate:2022-07-06 11:29:55.648077</p><p><img src="/public/2022/07/15/test/202207/2022-07-06-112955648077.jpg" alt="img"></p><h2 id="🔖为-WSL-配置这些新功能，不用虚拟机也能体验完整-Linux"><a class="header-anchor" href="#🔖为-WSL-配置这些新功能，不用虚拟机也能体验完整-Linux">¶</a>🔖<a href="https://sspai.com/post/74167" target="_blank" rel="noopener">为 WSL 配置这些新功能，不用虚拟机也能体验完整 Linux</a></h2><p>pubdata:2022-07-08 03:30:00markdate:2022-07-09 03:08:43.747852</p><p><img src="/public/2022/07/15/test/202207/2022-07-09-030843747852.jpg" alt="img"></p><h2 id="🔖当飞盘成为人类的玩具，我们该如何参与这场游戏"><a class="header-anchor" href="#🔖当飞盘成为人类的玩具，我们该如何参与这场游戏">¶</a>🔖<a href="https://sspai.com/post/73505" target="_blank" rel="noopener">当飞盘成为人类的玩具，我们该如何参与这场游戏</a></h2><p>pubdata:2022-06-06 08:00:00markdate:2022-07-10 01:36:40.114938</p><p><img src="/public/2022/07/15/test/202207/2022-07-10-013640114938.jpg" alt="img"></p><h2 id="🔖走进小众但不冷门的房车世界"><a class="header-anchor" href="#🔖走进小众但不冷门的房车世界">¶</a>🔖<a href="https://sspai.com/post/74043" target="_blank" rel="noopener">走进小众但不冷门的房车世界</a></h2><p>pubdata:2022-07-01 08:04:43markdate:2022-07-10 02:09:34.733003</p><p><img src="/public/2022/07/15/test/202207/2022-07-10-020934733003.jpg" alt="img"></p><h2 id="🔖从盲目崇拜到理性使用，谈谈我眼中的「双向链接」"><a class="header-anchor" href="#🔖从盲目崇拜到理性使用，谈谈我眼中的「双向链接」">¶</a>🔖<a href="https://sspai.com/post/73407" target="_blank" rel="noopener">从盲目崇拜到理性使用，谈谈我眼中的「双向链接」</a></h2><p>pubdata:2022-05-27 06:31:27markdate:2022-07-11 14:31:37.724795</p><p><img src="/public/2022/07/15/test/202207/2022-07-11-143137724795.jpg" alt="img"></p><h2 id="🔖打开终端总有好心情：我的美化方案及配置分享"><a class="header-anchor" href="#🔖打开终端总有好心情：我的美化方案及配置分享">¶</a>🔖<a href="https://sspai.com/post/74216" target="_blank" rel="noopener">打开终端总有好心情：我的美化方案及配置分享</a></h2><p>pubdata:2022-07-11 08:00:51markdate:2022-07-12 04:52:00.122103</p><p><img src="/public/2022/07/15/test/202207/2022-07-12-045200122103.jpg" alt="img"></p><h2 id="🔖咖啡美酒冷泡茶，这些消暑饮品在家就能动手做"><a class="header-anchor" href="#🔖咖啡美酒冷泡茶，这些消暑饮品在家就能动手做">¶</a>🔖<a href="https://sspai.com/post/74196" target="_blank" rel="noopener">咖啡美酒冷泡茶，这些消暑饮品在家就能动手做</a></h2><p>pubdata:2022-07-10 07:17:11markdate:2022-07-12 05:03:55.504330</p><p><img src="/public/2022/07/15/test/202207/2022-07-12-050355504330.jpg" alt="img"></p><h2 id="🔖语雀，即将开源！"><a class="header-anchor" href="#🔖语雀，即将开源！">¶</a>🔖<a href="https://zhuanlan.zhihu.com/p/540713275" target="_blank" rel="noopener">语雀，即将开源！</a></h2><p>pubdata:2022-07-12 08:19:47markdate:2022-07-14 10:28:28.713392</p><p><img src="/public/2022/07/15/test/202207/2022-07-14-102828713392.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 13&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「转」Linux内核数据包bridge上转发流程</title>
    <link href="https://talengu.github.io/public/2022/07/06/linux/linux_bridge_forward/"/>
    <id>https://talengu.github.io/public/2022/07/06/linux/linux_bridge_forward/</id>
    <published>2022-07-06T16:00:04.000Z</published>
    <updated>2022-07-06T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://blog.csdn.net/hhhhhyyyyy8/article/details/102133863" target="_blank" rel="noopener">blog.csdn.net</a>@hhhhhyyyyy8 @4.15.1</p></blockquote><h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>linux 内核源代码变动怎么这么大，handle_bridge 函数居然没有了，本来接着准备以 3.9.1 分析的，但发现和后面的又变了，还是以 4.15.1 现在电脑上用的版本分析吧。</p><p><strong>linux kernel：4.15.1</strong></p><p>best of best [<a href="url">link</a>](<a href="https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg" target="_blank" rel="noopener">https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg</a>)</p><p><img src="/public/2022/07/06/linux/linux_bridge_forward/Netfilter-packet-flow5.svg" alt></p><p>先看三张图片</p><p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76153027" target="_blank" rel="noopener">IMG skb桥转发蓝图</a><img src="/public/2022/07/06/linux/linux_bridge_forward/20191005153149853.jpg" alt></p><p><a href="https://blog.csdn.net/u012247418/article/details/90137663" target="_blank" rel="noopener">IMG linux TCP/IP L2层数据包接收流程</a><img src="/public/2022/07/06/linux/linux_bridge_forward/t_70.png" alt></p><p><a href="https://www.cnblogs.com/xuanxuanBOSS/p/11424290.html" target="_blank" rel="noopener">IMG 浅析ebtables的概念和一些基本应用</a><img src="/public/2022/07/06/linux/linux_bridge_forward/netfilter.png" alt></p><blockquote><p>tips: linux 内核版本不一样，流程函数会发生细微改变。</p></blockquote><a id="more"></a><h2 id="1-br-handle-frame"><a class="header-anchor" href="#1-br-handle-frame">¶</a>1. br_handle_frame()</h2><p>作用：</p><ol><li><p>对于需要转发的报文，调用 <code>NF_BR_PRE_ROUTING</code> 处钩子函数，结束后，进入 <code>br_handle_frame_finish()</code> 函数；</p></li><li><p>对于 STP 报文，调用 <code>NF_BR_LOCAL_IN</code> 处钩子函数，结束后，进入 <code>br_handle_local_finish()</code> 函数，在 <code>br_handle_local_finish()</code> 函数中会调用 <code>br_pass_frame_up()</code> 函数。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return NULL if skb is handled</span></span><br><span class="line"><span class="comment"> * note: already called with rcu_read_lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">rx_handler_result_t</span> <span class="title">br_handle_frame</span><span class="params">(struct sk_buff **pskb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> = *<span class="title">pskb</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line"><span class="keyword">br_should_route_hook_t</span> *rhook;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*如果是环回地址，直接返回RX_HANDLER_PASS*/</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(skb-&gt;pkt_type == PACKET_LOOPBACK))</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断源MAC地址是否是有效的地址，不是直接丢弃，源MAC地址不能是多播地址和全0地址*/</span></span><br><span class="line"><span class="keyword">if</span> (!is_valid_ether_addr(eth_hdr(skb)-&gt;h_source))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"><span class="comment">/*判断是否是共享数据包，若是则clone该数据包；若clone时分配内存出错，返回NULL*/</span></span><br><span class="line">skb = skb_share_check(skb, GFP_ATOMIC);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*获取dev对应的网桥端口*/</span></span><br><span class="line">p = br_port_get_rcu(skb-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; BR_VLAN_TUNNEL) &#123;</span><br><span class="line"><span class="keyword">if</span> (br_handle_ingress_vlan_tunnel(skb, p,</span><br><span class="line">  nbp_vlan_group_rcu(p)))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*特殊MAC地址处理*/</span></span><br><span class="line"><span class="comment">//如果目的mac地址是本地链路地址link local reserved addr (01:80:c2:00:00:0X) STP报文</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(is_link_local_ether_addr(dest))) &#123;</span><br><span class="line">u16 fwd_mask = p-&gt;br-&gt;group_fwd_mask_required;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * See IEEE 802.1D Table 7-10 Reserved addresses</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Assignment Value</span></span><br><span class="line"><span class="comment"> * Bridge Group Address01-80-C2-00-00-00</span></span><br><span class="line"><span class="comment"> * (MAC Control) 802.301-80-C2-00-00-01</span></span><br><span class="line"><span class="comment"> * (Link Aggregation) 802.301-80-C2-00-00-02</span></span><br><span class="line"><span class="comment"> * 802.1X PAE address01-80-C2-00-00-03</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 802.1AB LLDP 01-80-C2-00-00-0E</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Others reserved for future standardization</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fwd_mask |= p-&gt;group_fwd_mask;</span><br><span class="line"><span class="keyword">switch</span> (dest[<span class="number">5</span>]) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x00</span>:<span class="comment">/* Bridge Group Address */</span></span><br><span class="line"><span class="comment">/* If STP is turned off,</span></span><br><span class="line"><span class="comment">   then must forward to keep loop detection */</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;br-&gt;stp_enabled == BR_NO_STP ||</span><br><span class="line">    fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line"><span class="keyword">goto</span> forward;</span><br><span class="line">*pskb = skb;</span><br><span class="line">__br_handle_local_finish(skb);</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> <span class="number">0x01</span>:<span class="comment">/* IEEE MAC (Pause) */</span></span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0E</span>:<span class="comment">/* 802.1AB LLDP */</span></span><br><span class="line">fwd_mask |= p-&gt;br-&gt;group_fwd_mask;</span><br><span class="line"><span class="keyword">if</span> (fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line"><span class="keyword">goto</span> forward;</span><br><span class="line">*pskb = skb;</span><br><span class="line">__br_handle_local_finish(skb);</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* Allow selective forwarding for most other protocols */</span></span><br><span class="line">fwd_mask |= p-&gt;br-&gt;group_fwd_mask;</span><br><span class="line"><span class="keyword">if</span> (fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line"><span class="keyword">goto</span> forward;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Deliver packet to local host only */</span></span><br><span class="line"><span class="comment">/*调用NF_BR_LOCAL_IN处钩子函数，结束后，进入br_handle_local_finish函数*/</span></span><br><span class="line">NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, dev_net(skb-&gt;dev),</span><br><span class="line"><span class="literal">NULL</span>, skb, skb-&gt;dev, <span class="literal">NULL</span>, br_handle_local_finish);</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">forward:</span><br><span class="line"><span class="keyword">switch</span> (p-&gt;state) &#123;</span><br><span class="line"><span class="comment">//网桥端口处于转发状态</span></span><br><span class="line"><span class="keyword">case</span> BR_STATE_FORWARDING:</span><br><span class="line">rhook = rcu_dereference(br_should_route_hook);</span><br><span class="line"><span class="keyword">if</span> (rhook) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*rhook)(skb)) &#123;</span><br><span class="line">*pskb = skb;</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line">&#125;</span><br><span class="line">dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* fall through */</span></span><br><span class="line"><span class="comment">/*网桥端口处于学习状态，处于转发状态也会执行下面的代码，因为上面的case没有break。*/</span></span><br><span class="line"><span class="keyword">case</span> BR_STATE_LEARNING:</span><br><span class="line"><span class="comment">/*数据包目的MAC为网桥的Mac，发往本地的数据包*/</span></span><br><span class="line"><span class="keyword">if</span> (ether_addr_equal(p-&gt;br-&gt;dev-&gt;dev_addr, dest))</span><br><span class="line">skb-&gt;pkt_type = PACKET_HOST;</span><br><span class="line"><span class="comment">/*调用NF_BR_PRE_ROUTING处钩子函数，结束后进入br_handle_frame_finish函数*/</span></span><br><span class="line">NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,</span><br><span class="line">dev_net(skb-&gt;dev), <span class="literal">NULL</span>, skb, skb-&gt;dev, <span class="literal">NULL</span>,</span><br><span class="line">br_handle_frame_finish);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">drop:</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关函数</p><h3 id="rx-handler-result-t-枚举类型"><a class="header-anchor" href="#rx-handler-result-t-枚举类型">¶</a><code>rx_handler_result_t</code> 枚举类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> rx_handler_result &#123;</span><br><span class="line">RX_HANDLER_CONSUMED,</span><br><span class="line">RX_HANDLER_ANOTHER,</span><br><span class="line">RX_HANDLER_EXACT,</span><br><span class="line">RX_HANDLER_PASS,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> rx_handler_result <span class="keyword">rx_handler_result_t</span>;</span><br></pre></td></tr></table></figure><h3 id="is-valid-ether-addr"><a class="header-anchor" href="#is-valid-ether-addr">¶</a><code>is_valid_ether_addr()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * is_valid_ether_addr - Determine if the given Ethernet address is valid</span></span><br><span class="line"><span class="comment"> * @addr: Pointer to a six-byte array containing the Ethernet address</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not</span></span><br><span class="line"><span class="comment"> * a multicast address, and is not FF:FF:FF:FF:FF:FF.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return true if the address is valid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Please note: addr must be aligned to u16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_valid_ether_addr</span><span class="params">(<span class="keyword">const</span> u8 *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to</span></span><br><span class="line"><span class="comment"> * explicitly check for it here. */</span></span><br><span class="line"><span class="keyword">return</span> !is_multicast_ether_addr(addr) &amp;&amp; !is_zero_ether_addr(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="br-handle-local-finish"><a class="header-anchor" href="#br-handle-local-finish">¶</a><code>br_handle_local_finish()</code></h3><p><code>br_handle_local_finish()</code> 函数中调用 <code>br_pass_fame_up()</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/* note: already called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">br_handle_local_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span> = <span class="title">br_port_get_rcu</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line"> </span><br><span class="line">__br_handle_local_finish(skb);</span><br><span class="line"> </span><br><span class="line">BR_INPUT_SKB_CB(skb)-&gt;brdev = p-&gt;br-&gt;dev;</span><br><span class="line">br_pass_frame_up(skb);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-br-handle-frame-finish"><a class="header-anchor" href="#2-br-handle-frame-finish">¶</a>2. br_handle_frame_finish()</h2><p>作用：</p><p>网桥设备是否处于混杂模式，如果是，则会发一份到本地进行处理</p><p>如果是广播包，则会进行广播洪泛，并会发一份到本地处理</p><p>如果是组播包，则根据组播表进行组播转发，并发一份数数包到本地处理</p><p>如果是单播包，发往本地的单播包则送到本地处理，在 fdb 表中可以找到转发表项的单播包则进行转发，未知单播包在广播域内进行洪泛</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="comment">/* note: already called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_handle_frame_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span> = <span class="title">br_port_get_rcu</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line"><span class="keyword">enum</span> br_pkt_type pkt_type = BR_PKT_UNICAST;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_fdb_entry</span> *<span class="title">dst</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_mdb_entry</span> *<span class="title">mdst</span>;</span></span><br><span class="line"><span class="keyword">bool</span> local_rcv, mcast_hit = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *dest;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span>;</span></span><br><span class="line">u16 vid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果网桥端口不存在或者网桥端口状态为BR_STATE_DISABLED，则丢弃*/</span></span><br><span class="line"><span class="keyword">if</span> (!p || p-&gt;state == BR_STATE_DISABLED)</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"><span class="comment">/*判断是否允许进入桥内，如果没有开启VLAN则所有数据包都可以进入，</span></span><br><span class="line"><span class="comment">如果开启了VLAN,则根据VLAN相应的规则，从桥上进行数据包转发。*/</span></span><br><span class="line"><span class="keyword">if</span> (!br_allowed_ingress(p-&gt;br, nbp_vlan_group_rcu(p), skb, &amp;vid))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line">nbp_switchdev_frame_mark(p, skb);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* insert into forwarding database after filtering to avoid spoofing */</span></span><br><span class="line">br = p-&gt;br;</span><br><span class="line"><span class="comment">/*如果网桥端口标志有BR_LEARNING,则更新fdb表。</span></span><br><span class="line"><span class="comment">    一般新建网桥端口p-&gt;flags=BR_LEARNING| BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD*/</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; BR_LEARNING)</span><br><span class="line">br_fdb_update(br, p, eth_hdr(skb)-&gt;h_source, vid, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发往本地数据包标记，!!的作用是转换为bool值</span></span><br><span class="line">local_rcv = !!(br-&gt;dev-&gt;flags &amp; IFF_PROMISC);</span><br><span class="line">dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line"><span class="comment">/*目的地址为多播地址*/</span></span><br><span class="line"><span class="keyword">if</span> (is_multicast_ether_addr(dest)) &#123;</span><br><span class="line"><span class="comment">/* by definition the broadcast is also a multicast address */</span></span><br><span class="line"><span class="comment">/*如果目的地址是广播地址，将数据包也发往本地一份*/</span></span><br><span class="line"><span class="keyword">if</span> (is_broadcast_ether_addr(dest)) &#123;</span><br><span class="line">pkt_type = BR_PKT_BROADCAST;</span><br><span class="line">local_rcv = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pkt_type = BR_PKT_MULTICAST;</span><br><span class="line"><span class="comment">//igmp snooping留给网桥子系统的外部接口函数，</span></span><br><span class="line"><span class="comment">//当网桥接收了igmp数据包后就会调用该函数进行后续处理</span></span><br><span class="line"><span class="keyword">if</span> (br_multicast_rcv(br, p, skb, vid))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果网桥端口状态此时还是BR_STATE_LEARNING,则丢弃。</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;state == BR_STATE_LEARNING)</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"><span class="comment">//将网桥所属的net_device放入skb的私有数据中（struct br_input_skb_cb）</span></span><br><span class="line">BR_INPUT_SKB_CB(skb)-&gt;brdev = br-&gt;dev;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_INET) &amp;&amp;</span><br><span class="line">    (skb-&gt;protocol == htons(ETH_P_ARP) ||</span><br><span class="line">     skb-&gt;protocol == htons(ETH_P_RARP))) &#123;</span><br><span class="line">br_do_proxy_suppress_arp(skb, br, vid, p);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ENABLED(CONFIG_IPV6) &amp;&amp;</span><br><span class="line">   skb-&gt;protocol == htons(ETH_P_IPV6) &amp;&amp;</span><br><span class="line">   br-&gt;neigh_suppress_enabled &amp;&amp;</span><br><span class="line">   pskb_may_pull(skb, <span class="keyword">sizeof</span>(struct ipv6hdr) +</span><br><span class="line"> <span class="keyword">sizeof</span>(struct nd_msg)) &amp;&amp;</span><br><span class="line">   ipv6_hdr(skb)-&gt;nexthdr == IPPROTO_ICMPV6) &#123;</span><br><span class="line">struct nd_msg *msg, _msg;</span><br><span class="line"> </span><br><span class="line">msg = br_is_nd_neigh_msg(skb, &amp;_msg);</span><br><span class="line"><span class="keyword">if</span> (msg)</span><br><span class="line">br_do_suppress_nd(skb, br, vid, p, msg);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">switch</span> (pkt_type) &#123;</span><br><span class="line"><span class="comment">//组播包</span></span><br><span class="line"><span class="keyword">case</span> BR_PKT_MULTICAST:</span><br><span class="line"><span class="comment">//获取组播转发项，设置local_rcv为true，组播包也要发往本地一份。</span></span><br><span class="line">mdst = br_mdb_get(br, skb, vid);</span><br><span class="line"><span class="keyword">if</span> ((mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) &amp;&amp;</span><br><span class="line">    br_multicast_querier_exists(br, eth_hdr(skb))) &#123;</span><br><span class="line"><span class="keyword">if</span> ((mdst &amp;&amp; mdst-&gt;host_joined) ||</span><br><span class="line">    br_multicast_is_router(br)) &#123;</span><br><span class="line">local_rcv = <span class="literal">true</span>;</span><br><span class="line">br-&gt;dev-&gt;stats.multicast++;</span><br><span class="line">&#125;</span><br><span class="line">mcast_hit = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">local_rcv = <span class="literal">true</span>;</span><br><span class="line">br-&gt;dev-&gt;stats.multicast++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//单播包</span></span><br><span class="line"><span class="keyword">case</span> BR_PKT_UNICAST:</span><br><span class="line"><span class="comment">//根据目的MAC地址查找fdb表，看是否有对应的表项</span></span><br><span class="line">dst = br_fdb_find_rcu(br, dest, vid);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果找到目的MAC对应的表项</span></span><br><span class="line"><span class="keyword">if</span> (dst) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> now = jiffies;</span><br><span class="line"><span class="comment">//送入上层处理</span></span><br><span class="line"><span class="keyword">if</span> (dst-&gt;is_local)</span><br><span class="line"><span class="keyword">return</span> br_pass_frame_up(skb);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (now != dst-&gt;used)</span><br><span class="line">dst-&gt;used = now;</span><br><span class="line"><span class="comment">//根据fdb转发表项进行转发，若这里local_rcv 为1,（即端口处于混杂模式IFF_PROMISC），则会克隆一份再转发</span></span><br><span class="line"><span class="comment">//传入的第一个参数dst-&gt;dst 即为要转发的目的端口</span></span><br><span class="line">br_forward(dst-&gt;dst, skb, local_rcv, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//进行广播或者组播洪泛</span></span><br><span class="line"><span class="keyword">if</span> (!mcast_hit)</span><br><span class="line">br_flood(br, skb, pkt_type, local_rcv, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">br_multicast_flood(mdst, skb, local_rcv, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//local_rcv标记为1，送入上层处理。</span></span><br><span class="line"><span class="keyword">if</span> (local_rcv)</span><br><span class="line"><span class="keyword">return</span> br_pass_frame_up(skb);</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">drop:</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-br-pass-frame-up"><a class="header-anchor" href="#3-br-pass-frame-up">¶</a>3.br_pass_frame_up</h2><p>数据包的目的 MAC 是本地的单播报文，广播，组播和网桥处于混杂模式时，报文都会通过 br_pass_frame_up 函数交由上层处理。</p><p>作用：</p><p>调用 NF_BR_LOCAL_IN 处钩子函数，最后调用 br_netif_receive_skb 函数，绕一圈后，交友上层处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">br_pass_frame_up</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">indev</span>, *<span class="title">brdev</span> = <span class="title">BR_INPUT_SKB_CB</span>(<span class="title">skb</span>)-&gt;<span class="title">brdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span> = <span class="title">netdev_priv</span>(<span class="title">brdev</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_vlan_group</span> *<span class="title">vg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcpu_sw_netstats</span> *<span class="title">brstats</span> = <span class="title">this_cpu_ptr</span>(<span class="title">br</span>-&gt;<span class="title">stats</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//统计网桥设备上的收包流量数据</span></span><br><span class="line">u64_stats_update_begin(&amp;brstats-&gt;syncp);</span><br><span class="line">brstats-&gt;rx_packets++;</span><br><span class="line">brstats-&gt;rx_bytes += skb-&gt;len;</span><br><span class="line">u64_stats_update_end(&amp;brstats-&gt;syncp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取网桥设备上的VLAN组</span></span><br><span class="line">vg = br_vlan_group_rcu(br);</span><br><span class="line"><span class="comment">/* Bridge is just like any other port.  Make sure the</span></span><br><span class="line"><span class="comment"> * packet is allowed except in promisc modue when someone</span></span><br><span class="line"><span class="comment"> * may be running packet capture.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!(brdev-&gt;flags &amp; IFF_PROMISC) &amp;&amp;</span><br><span class="line">    !br_allowed_egress(vg, skb)) &#123;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录数据包的收包网络设备</span></span><br><span class="line">indev = skb-&gt;dev;</span><br><span class="line"><span class="comment">//将数据包的收包设备改为网桥设备</span></span><br><span class="line"><span class="comment">//当再次进入__netif_receive_skb_core时就不会再次进入桥处理了，因为网桥上没有注册rx_handler 函数</span></span><br><span class="line">skb-&gt;dev = brdev;</span><br><span class="line"><span class="comment">//配置数据包vlan相关信息</span></span><br><span class="line">skb = br_handle_vlan(br, <span class="literal">NULL</span>, vg, skb);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line"><span class="comment">/* update the multicast stats if the packet is IGMP/MLD */</span></span><br><span class="line"><span class="comment">//如果数据包是组播，更新组播数据包的统计信息</span></span><br><span class="line">br_multicast_count(br, <span class="literal">NULL</span>, skb, br_multicast_igmp_type(skb),</span><br><span class="line">   BR_MCAST_DIR_TX);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用NF_BR_LOCAL_IN处钩子函数，最后调用br_netif_receive_skb函数。</span></span><br><span class="line"><span class="keyword">return</span> NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,</span><br><span class="line">       dev_net(indev), <span class="literal">NULL</span>, skb, indev, <span class="literal">NULL</span>,</span><br><span class="line">       br_netif_receive_skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次进入 netif_receive_skb，由于 skb-dev 被设置成了 bridge，而 bridge 设备的 rx_handler 函数是没有被设置的，所以就不会再次进入 bridge 逻辑，而直接进入了主机上层协议栈。</p><p>相关函数</p><h3 id="br-netif-receive-skb"><a class="header-anchor" href="#br-netif-receive-skb">¶</a><code>br_netif_receive_skb()</code></h3><p>可以看到在 br_netif_receive_skb() 函数中调用了 netif_receive_skb() 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">static int</span><br><span class="line">br_netif_receive_skb(struct net *net, struct sock *sk, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">br_drop_fake_rtable(skb);</span><br><span class="line">return netif_receive_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-br-forward"><a class="header-anchor" href="#4-br-forward">¶</a>4. br_forward()</h2><p>不是发往本地的数据包，但在 fdb 表中能找到对应的表项，则进行转发 br_forward()，若在 fdb 表中找不到对应表项就进行洪泛 br_blood().</p><p>作用：</p><p>主要是调用__br_forward() 转发报文</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * br_forward - forward a packet to a specific port</span></span><br><span class="line"><span class="comment"> * @to: destination port</span></span><br><span class="line"><span class="comment"> * @skb: packet being forwarded</span></span><br><span class="line"><span class="comment"> * @local_rcv: packet will be received locally after forwarding</span></span><br><span class="line"><span class="comment"> * @local_orig: packet is locally originated</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Should be called with rcu_read_lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_forward</span><span class="params">(<span class="keyword">const</span> struct net_bridge_port *to,</span></span></span><br><span class="line"><span class="function"><span class="params">struct sk_buff *skb, <span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//should_deliver测试是否应该将该包转发出去</span></span><br><span class="line"><span class="keyword">if</span> (to &amp;&amp; should_deliver(to, skb)) &#123;</span><br><span class="line"><span class="comment">//如果local_rcv为1，表明端口为混杂模式，先clone一份数据包再进行转发</span></span><br><span class="line"><span class="keyword">if</span> (local_rcv)</span><br><span class="line">deliver_clone(to, skb, local_orig);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__br_forward(to, skb, local_orig);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!local_rcv)</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-br-forward"><a class="header-anchor" href="#5-br-forward">¶</a>5. __br_forward()</h2><p>作用:</p><p>__br_forward() 函数根据数据包的来源（local_orig）分别进入不同的钩子点，如果数据包是从本地发出的，则进入 NF_BR_LOCAL_OUT，如果不是本地发出的，则进入 NF_BR_FORWARD 钩子，最后都进入 br_forward_finish() 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __br_forward(<span class="keyword">const</span> struct net_bridge_port *to,</span><br><span class="line"> struct sk_buff *skb, <span class="keyword">bool</span> local_orig)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_vlan_group</span> *<span class="title">vg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">indev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line"><span class="keyword">int</span> br_hook;</span><br><span class="line"><span class="comment">//获取vlan组，这个组中有许多的vlanid，br_handle_vlan函数就是要在这个组中查找自己的vid</span></span><br><span class="line">vg = nbp_vlan_group_rcu(to);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加vlan的相关配置</span></span><br><span class="line">skb = br_handle_vlan(to-&gt;br, to, vg, skb);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//记录数据包的原始收包网络设备</span></span><br><span class="line">indev = skb-&gt;dev;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将skb的dev修改为出口网络设备</span></span><br><span class="line">skb-&gt;dev = to-&gt;dev;</span><br><span class="line"><span class="comment">/*如果local_orig标志位(判断是否从本地发出的数据包)为false，就进入NF_BR_FORWARD钩子</span></span><br><span class="line"><span class="comment">若为true，就进入NF_BR_LOCAL_OUT钩子点*/</span></span><br><span class="line"><span class="keyword">if</span> (!local_orig) &#123;</span><br><span class="line"><span class="keyword">if</span> (skb_warn_if_lro(skb)) &#123;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不是本地发出的数据包，进入NF_BR_FORWARD</span></span><br><span class="line">br_hook = NF_BR_FORWARD;</span><br><span class="line">skb_forward_csum(skb);</span><br><span class="line">net = dev_net(indev);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(netpoll_tx_running(to-&gt;br-&gt;dev))) &#123;</span><br><span class="line"><span class="keyword">if</span> (!is_skb_forwardable(skb-&gt;dev, skb)) &#123;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">skb_push(skb, ETH_HLEN);</span><br><span class="line">br_netpoll_send_skb(to, skb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若是本地发出的数据包，进入NF_BR_LOCAL_OUT处理</span></span><br><span class="line">br_hook = NF_BR_LOCAL_OUT;</span><br><span class="line">net = dev_net(skb-&gt;dev);</span><br><span class="line">indev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入钩子点，最后执行br_forward_finish函数。</span></span><br><span class="line">NF_HOOK(NFPROTO_BRIDGE, br_hook,</span><br><span class="line">net, <span class="literal">NULL</span>, skb, indev, skb-&gt;dev,</span><br><span class="line">br_forward_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-br-forward-finish"><a class="header-anchor" href="#6-br-forward-finish">¶</a>6. br_forward_finish()</h2><p><code>br_forward_finish()</code> 函数比较简单，调用 <code>NF_BR_POST_ROUTING</code> 处的钩子函数，最后进入 <code>br_dev_queue_push_xmit</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_forward_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING,</span><br><span class="line">       net, sk, skb, <span class="literal">NULL</span>, skb-&gt;dev,</span><br><span class="line">       br_dev_queue_push_xmit);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-br-dev-queue-push-xmit"><a class="header-anchor" href="#7-br-dev-queue-push-xmit">¶</a>7. br_dev_queue_push_xmit</h2><p>在 <code>br_dev_queue_push_xmit()</code> 中，会先 <code>skb_push(skb,ETH,HLEN);</code> 将 data 指向二层头部，然后调用 <code>dev_queue_xmit()</code> 发送报文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_dev_queue_push_xmit</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!is_skb_forwardable(skb-&gt;dev, skb))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//注意这句操作</span></span><br><span class="line">skb_push(skb, ETH_HLEN);</span><br><span class="line">br_drop_fake_rtable(skb);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_PARTIAL &amp;&amp;</span><br><span class="line">    (skb-&gt;protocol == htons(ETH_P_8021Q) ||</span><br><span class="line">     skb-&gt;protocol == htons(ETH_P_8021AD))) &#123;</span><br><span class="line"><span class="keyword">int</span> depth;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!__vlan_get_protocol(skb, skb-&gt;protocol, &amp;depth))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">skb_set_network_header(skb, depth);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">dev_queue_xmit(skb);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">drop:</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-br-flood"><a class="header-anchor" href="#8-br-flood">¶</a>8. br_flood</h2><p><code>br_flood()</code> 也是调用 <code>__br_forward()</code> 函数转发报文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/* called under rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_flood</span><span class="params">(struct net_bridge *br, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">enum</span> br_pkt_type pkt_type, <span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 igmp_type = br_multicast_igmp_type(skb);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*遍历网桥设备的port_list，取出所有的网桥端口*/</span></span><br><span class="line">list_for_each_entry_rcu(p, &amp;br-&gt;port_list, <span class="built_in">list</span>) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">/* Do not flood unicast traffic to ports that turn it off, nor</span></span><br><span class="line"><span class="comment"> * other traffic if flood off, except for traffic we originate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (pkt_type) </span><br><span class="line">                &#123;</span><br><span class="line"><span class="keyword">case</span> BR_PKT_UNICAST:</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; BR_FLOOD))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BR_PKT_MULTICAST:</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; BR_MCAST_FLOOD) &amp;&amp; skb-&gt;dev != br-&gt;dev)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BR_PKT_BROADCAST:</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; BR_BCAST_FLOOD) &amp;&amp; skb-&gt;dev != br-&gt;dev)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Do not flood to ports that enable proxy ARP */</span></span><br><span class="line">                <span class="comment">/*代理arp*/</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; BR_PROXYARP)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((p-&gt;flags &amp; (BR_PROXYARP_WIFI | BR_NEIGH_SUPPRESS)) &amp;&amp;</span><br><span class="line">    BR_INPUT_SKB_CB(skb)-&gt;proxyarp_replied)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">prev = maybe_deliver(prev, p, skb, local_orig);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(prev))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (prev == p)</span><br><span class="line">br_multicast_count(p-&gt;br, p, skb, igmp_type,</span><br><span class="line">   BR_MCAST_DIR_TX);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!prev)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (local_rcv)</span><br><span class="line">deliver_clone(prev, skb, local_orig);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__br_forward(prev, skb, local_orig);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (!local_rcv)</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-br-mulicast-flood"><a class="header-anchor" href="#9-br-mulicast-flood">¶</a>9. br_mulicast_flood()</h2><hr><p>以后再分析，肚子饿了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/* called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_multicast_flood</span><span class="params">(struct net_bridge_mdb_entry *mdst,</span></span></span><br><span class="line"><span class="function"><span class="params">struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">BR_INPUT_SKB_CB</span>(<span class="title">skb</span>)-&gt;<span class="title">brdev</span>;</span></span><br><span class="line">u8 igmp_type = br_multicast_igmp_type(skb);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port_group</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">rp</span>;</span></span><br><span class="line"> </span><br><span class="line">rp = rcu_dereference(hlist_first_rcu(&amp;br-&gt;router_list));</span><br><span class="line">p = mdst ? rcu_dereference(mdst-&gt;ports) : <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p || rp) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">port</span>, *<span class="title">lport</span>, *<span class="title">rport</span>;</span></span><br><span class="line"> </span><br><span class="line">lport = p ? p-&gt;port : <span class="literal">NULL</span>;</span><br><span class="line">rport = rp ? hlist_entry(rp, struct net_bridge_port, rlist) :</span><br><span class="line">     <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)lport &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)rport) &#123;</span><br><span class="line">port = lport;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (port-&gt;flags &amp; BR_MULTICAST_TO_UNICAST) &#123;</span><br><span class="line">maybe_deliver_addr(lport, skb, p-&gt;eth_addr,</span><br><span class="line">   local_orig);</span><br><span class="line"><span class="keyword">goto</span> delivered;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">port = rport;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">prev = maybe_deliver(prev, port, skb, local_orig);</span><br><span class="line">delivered:</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(prev))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (prev == port)</span><br><span class="line">br_multicast_count(port-&gt;br, port, skb, igmp_type,</span><br><span class="line">   BR_MCAST_DIR_TX);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)lport &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)port)</span><br><span class="line">p = rcu_dereference(p-&gt;next);</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)rport &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)port)</span><br><span class="line">rp = rcu_dereference(hlist_next_rcu(rp));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!prev)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (local_rcv)</span><br><span class="line">deliver_clone(prev, skb, local_orig);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__br_forward(prev, skb, local_orig);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (!local_rcv)</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2><p><a href="http://ebtables.netfilter.org/br_fw_ia/br_fw_ia.html" target="_blank" rel="noopener">ebtables/iptables interaction on a Linux-based bridge</a>@ebtables @2.4.x kernel</p><p><a href="https://blog.csdn.net/sxd2001/article/details/125031113" target="_blank" rel="noopener">Iptables DNAT实现broadcast与unicast之间相互映射</a>@sxd2001 分析ebtables 的redirect 和 iptables 的redirect</p><p><a href="https://blog.csdn.net/Sophisticated_/article/details/87923362" target="_blank" rel="noopener">Linux-4.20.8内核桥收包源码解析（七）--本地（br_pass_frame_up）or 转发（br_forward）</a>@lw_yang @Linux-4.20.8</p><p><a href="http://blog.chinaunix.net/uid-28541347-id-5750406.html" target="_blank" rel="noopener">Linux 3.10 kernel bridge转发逻辑</a>@lvyilong316 @Linux 3.10 kernel</p><p><a href="https://blog.csdn.net/linyt/article/details/5191512" target="_blank" rel="noopener">kernel 网桥代码分析</a>@海枫 @ 2.6.24.4</p><p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76674232" target="_blank" rel="noopener">桥数据包处理函数——br_handle_frame_finish（七）</a>@不留你的名字</p><p><a href="https://www.cnblogs.com/super-king/p/bridge_implement.html" target="_blank" rel="noopener">Bridge实现</a>@SuperKing @linux 2.6.18</p><p><a href="https://www.cnblogs.com/ck1020/p/5894235.html" target="_blank" rel="noopener">LInux下桥接模式详解三</a>@jack.chen @linux 3.10.1</p><p><a href="https://blog.csdn.net/one_clouder/article/details/52877737" target="_blank" rel="noopener">协议栈报文接收之netif_receive_skb函数分析</a>@one_clouder @Linux4.1.12</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址 &lt;a href=&quot;https://blog.csdn.net/hhhhhyyyyy8/article/details/102133863&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;blog.csdn.net&lt;/a&gt;
@hhhhhyyyyy8 @4.15.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;linux 内核源代码变动怎么这么大，handle_bridge 函数居然没有了，本来接着准备以 3.9.1 分析的，但发现和后面的又变了，还是以 4.15.1 现在电脑上用的版本分析吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;linux kernel：4.15.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;best of best [&lt;a href=&quot;url&quot;&gt;link&lt;/a&gt;](&lt;a href=&quot;https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/public/2022/07/06/linux/linux_bridge_forward/Netfilter-packet-flow5.svg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;先看三张图片&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/NW_NW_NW/article/details/76153027&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IMG skb桥转发蓝图&lt;/a&gt;
&lt;img src=&quot;/public/2022/07/06/linux/linux_bridge_forward/20191005153149853.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u012247418/article/details/90137663&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IMG linux TCP/IP L2层数据包接收流程&lt;/a&gt;
&lt;img src=&quot;/public/2022/07/06/linux/linux_bridge_forward/t_70.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xuanxuanBOSS/p/11424290.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IMG 浅析ebtables的概念和一些基本应用&lt;/a&gt;
&lt;img src=&quot;/public/2022/07/06/linux/linux_bridge_forward/netfilter.png&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;tips: linux 内核版本不一样，流程函数会发生细微改变。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://talengu.github.io/public/categories/Linux/"/>
    
    
      <category term="bridge" scheme="https://talengu.github.io/public/tags/bridge/"/>
    
      <category term="netfilter" scheme="https://talengu.github.io/public/tags/netfilter/"/>
    
  </entry>
  
  <entry>
    <title>「转」tcpdump是在哪儿抓到的包？</title>
    <link href="https://talengu.github.io/public/2022/07/01/linux/how_tcpdump/"/>
    <id>https://talengu.github.io/public/2022/07/01/linux/how_tcpdump/</id>
    <published>2022-07-01T16:00:04.000Z</published>
    <updated>2022-07-01T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://cloud.tencent.com/developer/article/1879646" target="_blank" rel="noopener">cloud.tencent.com</a></p></blockquote><blockquote><p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对...</p></blockquote><p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对这个问题，我进行了一番学习探究。</p><p>先说结论：通过 PF_PACKET 这个特殊的套接字协议，直接接收来自链路层的帧。数据包<strong>并非没有</strong>进入内核，而是在进入内核后直接跳过了内核中三层 / 四层的协议栈，直达套接字接口，被应用层的 tcpdump 所使用。实际上，在网卡驱动程序通知内核接受到数据帧的时候，数据包就已经进入了内核处理流程。具体的区别，可以见下图。</p><p><img src="/public/2022/07/01/linux/how_tcpdump/1620.png" alt></p><p>内核网络协议栈示意图</p><a id="more"></a><p>先来看看，普通的套接字的收包路径在内核中是怎么样。</p><p>以最常见的以太网网卡，当网卡接口接收到了一个帧，那么接受者知道它一定包含了一个 Ethernet 报头。封包在协议栈向上传递过程中，一定会在报头中包含一个字段，指出下一阶段的处理应该使用哪一个协议。 以太网卡拥有特定的 MAC 地址，在监听数据帧的时候，当看到帧的目的 MAC 地址与自己的地址或者链路层广播地址（FF:FF:FF:FF:FF:FF）相匹配，就会通过 DMA 把该帧读取到内存中的 ring buffer。</p><p>当一个数据帧被写入到内存后，将产生一个硬件中断请求，以通知 CPU 收到了数据包。操作系统为了减少硬中断产生的次数，会采用一个软中断 (softirq) 唤醒 NAPI 子系统。这样会产生一个单独的线程，调用网卡驱动注册的 poll 方法收包，同时禁止网卡产生新的硬中断，这样的效果便是一次中断可以接收多个包。一旦软终端代码判断有 softirq 处于 pending 状态，便会调用软终端处理函数 net_rx_action。</p><p>中断处理函数会在处理循环中调用 NAPI poll 来接收数据包。poll 方法会分配一个 sk_buff 数据结构（include/linux/skbuff.h），表示该数据包的内核视图。然后将数据从缓冲区提取到新建的 sk_buff 中，并对其中的 protocol 字段做初始化，该字段用以识别特定的协议。之后这个字段会被 netif_receive_skb 内核函数查询，用来确定该执行哪个函数来处理三层的封包。字段涉及协议的值都列在了 include/uapi/linux/if_ether.h 中，名字形如 ETH_P_XXX，比如 ip 协议为 ETH_P_IP。而有一种特殊情况，单一封包可以传递给多个处理函数，这就是 tcpdump 等网络嗅探应用会用到的 ETH_P_ALL。</p><p>软终端处理循环的最后是通过 netif_receive_skb 函数将将数据交给 TCP/IP 协议栈的。它会从数据包包头中取出协议信息，然后遍历注册在这个协议上的回调函数列表。这里的列表值得一提，分别是 ptype_all 和 ptype_base。他们是 hash table 数据结构，分别对应通用数据包（ETH_P_ALL 类型）和特定协议的数据包（ETH_P_XXX 类型），其中存放着指向对应协议处理函数的指针，当收到该类型的数据包时便调用对应的处理函数。</p><p>因此，以 IP 数据包为例，当 ETH_P_IP 类型数据包出队后，软中断处理程序 net_rx_action 最终会在 ptype_base 列表中找到 IP 协议的处理函数 ip_rcv() 并调用它，完成数据包向上提交到协议栈。这里略过 IP 协议栈的处理过程，简而言之，在经过 IP 数据包完整性校验、Netfilter 子系统（iptables 的底层实现）、路由子系统等等一些列流程之后，开始准备送往高层协议。这里的处理和 net_rx_action 很相似，从 IP 数据包头部提取出协议类型后，通过名为 inet_protos 的哈希来寻找高层协议的处理函数，每个高层协议都对应一个处理函数，型如 tcp_v4_rcv(), udp_rcv() 等。</p><p>四层协议以较为简单的 UDP 为例，udp_rcv 会对 udp 包进行合法性校验，然后查找是否有愿意接收此数据包的套接字，如果找到，__udp_queue_rcv_skb 会将包放到 socket 的接收队列。最后，所有在这个 socket 上等待数据的进程都会收到通过 sk_data_ready 函数处理的通知。</p><p>以上是一个数据包穿越协议栈到达 socket 的简要过程，实际的内核处理过程会复杂的多，这里只是做简要的描述。以引入本文的主角：PF_PACKET 协议数据包在内核中的处理路径。</p><p>当创建 PF_PACKET 套接字时，与协议相关的数据包类型将被同时注册进 ptype_all 和 ptype_base，接受函数为 packet_rcb()。此时，net_rx_action 函数会拦截所有进入机器的包，并同样通过 netif_receive_skb 函数遍历 ptype_all 后，传递给 PF_PACKET 接受函数。值得一提的是，tcpdump 依赖的 libpcap 库并非使用原始套接字 + recvfrom 的方式收包，而是在内核空间分配一块内核缓冲区，然后用户空间调用 mmap 系统调用映射到用户空间。</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2><p><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/" target="_blank" rel="noopener">Monitoring and Tuning the Linux Networking Stack: Receiving Data</a></p><p><a href="https://www.linuxjournal.com/article/4852" target="_blank" rel="noopener">Inside the Linux Packet Filter</a></p><p><a href="https://km.woa.com/group/17746/articles/show/%E5%9B%BE%E8%A7%A3linux%20tcpdump" target="_blank" rel="noopener">图解 linux tcpdump</a></p><p>《深入理解 Linux 网络技术内幕》</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址 &lt;a href=&quot;https://cloud.tencent.com/developer/article/1879646&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cloud.tencent.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对这个问题，我进行了一番学习探究。&lt;/p&gt;
&lt;p&gt;先说结论：通过 PF_PACKET 这个特殊的套接字协议，直接接收来自链路层的帧。数据包&lt;strong&gt;并非没有&lt;/strong&gt;进入内核，而是在进入内核后直接跳过了内核中三层 / 四层的协议栈，直达套接字接口，被应用层的 tcpdump 所使用。实际上，在网卡驱动程序通知内核接受到数据帧的时候，数据包就已经进入了内核处理流程。具体的区别，可以见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/public/2022/07/01/linux/how_tcpdump/1620.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;内核网络协议栈示意图&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://talengu.github.io/public/categories/Linux/"/>
    
    
      <category term="tcpdump" scheme="https://talengu.github.io/public/tags/tcpdump/"/>
    
  </entry>
  
  <entry>
    <title>使用脚本将英文rss转成中文rss</title>
    <link href="https://talengu.github.io/public/2022/05/08/rss_google_translate/"/>
    <id>https://talengu.github.io/public/2022/05/08/rss_google_translate/</id>
    <published>2022-05-08T22:00:04.000Z</published>
    <updated>2022-05-08T22:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>本文中我们将英文rss 自动转成中文 rss供ttrss使用。（利用谷歌翻译）</p><p>方便在手机上进行阅读或者收听。</p><center><img src="/public/2022/05/08/rss_google_translate/20220508-22-28-27.png" width="30%"></center><a id="more"></a><h2 id="举例"><a class="header-anchor" href="#举例">¶</a>举例</h2><p>国外有很多不错的rss源，比如:</p><ul><li><a href="http://www.mckinsey.com/insights/rss" target="_blank" rel="noopener">McKinsey Insights &amp; Publications</a>  <center><img src="/public/2022/05/08/rss_google_translate/20220508-22-18-23.png" width="50%"></center></li></ul>    转成中文rss    <center><img src="/public/2022/05/08/rss_google_translate/20220508-22-20-48.png" width="50%"></center><ul><li><p><a href="http://rss.acast.com/nature" target="_blank" rel="noopener">Nature Podcast</a></p>  <center><img src="/public/2022/05/08/rss_google_translate/20220508-22-25-04.png" width="50%"></center></li></ul>   转成中文rss       <center><img src="/public/2022/05/08/rss_google_translate/20220508-22-26-36.png" width="50%"></center><h2 id="脚本"><a class="header-anchor" href="#脚本">¶</a>脚本</h2><p>使用 Translate 和 BeautifulSoup 项目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8 </span></span><br><span class="line"><span class="keyword">from</span> pygtrans <span class="keyword">import</span> Translate</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment"># pip 安装</span></span><br><span class="line"><span class="comment"># pip install pygtrans BeautifulSoup -i https://pypi.org/simple</span></span><br><span class="line"><span class="comment"># ref:https://zhuanlan.zhihu.com/p/390801784</span></span><br><span class="line"><span class="comment"># ref:https://beautifulsoup.readthedocs.io/zh_CN/latest/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># client = Translate()</span></span><br><span class="line"><span class="comment"># text = client.translate('Google Translate')</span></span><br><span class="line"><span class="comment"># print(text.translatedText)  # 谷歌翻译</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"></span><br><span class="line">args = sys.argv</span><br><span class="line">URL=<span class="string">"http://www.mckinsey.com/insights/rss"</span></span><br><span class="line"></span><br><span class="line">BASE=<span class="string">"/home/xxx/www/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tran</span><span class="params">(url=URL,out_dir=BASE+<span class="string">"mckinsey_rss.xml"</span>)</span>:</span></span><br><span class="line">    GT = Translate()</span><br><span class="line">    content= request.urlopen(url).read().decode(<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="comment"># 变tag，以使用谷歌翻译</span></span><br><span class="line">    content=content.replace(<span class="string">'title&gt;'</span>, <span class="string">'stitle&gt;'</span>) <span class="comment">#谷歌翻译会将很多titile去掉，所以需要换一个tag</span></span><br><span class="line">    content=content.replace( <span class="string">'&lt;pubDate&gt;'</span>,<span class="string">'&lt;pubDate&gt;&lt;span translate="no"&gt;'</span>) </span><br><span class="line">    <span class="comment"># 谷歌翻译对&lt;span translate="no"&gt; &lt;/span&gt; 不翻译。</span></span><br><span class="line">    content=content.replace( <span class="string">'&lt;/pubDate&gt;'</span>,<span class="string">'&lt;/span&gt;&lt;/pubDate&gt;'</span>)</span><br><span class="line">    <span class="comment">#print(content)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    _text = GT.translate(content)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(out_dir,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        c=_text.translatedText</span><br><span class="line">        <span class="comment"># 还原tag</span></span><br><span class="line">        c=c.replace(<span class="string">'stitle&gt;'</span>, <span class="string">'title&gt;'</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;span translate="no"&gt;'</span>, <span class="string">''</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;/span&gt;&lt;/pubDate&gt;'</span>, <span class="string">'&lt;/pubDate&gt;'</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        f.write(c)</span><br><span class="line">        <span class="comment">#f.write(content)</span></span><br><span class="line">    print(<span class="string">"GT: "</span>+ url +<span class="string">" &gt; "</span>+ out_dir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(args)==<span class="number">1</span>:</span><br><span class="line">    tran()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    tran(args[<span class="number">1</span>],args[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tran_nature</span><span class="params">(url=<span class="string">"http://rss.acast.com/nature"</span>,out_dir=BASE+<span class="string">"nature_rss.xml"</span>)</span>:</span></span><br><span class="line">    GT = Translate()</span><br><span class="line">    </span><br><span class="line">    html_doc=request.urlopen(url).read().decode(<span class="string">'utf8'</span>)</span><br><span class="line">    soup = BeautifulSoup(html_doc)</span><br><span class="line"></span><br><span class="line">    items=soup.find_all(<span class="string">'item'</span>)</span><br><span class="line">    <span class="comment"># nature post内容太多，谷歌api翻译不了，去掉一些</span></span><br><span class="line">    <span class="keyword">for</span> idx,e <span class="keyword">in</span> enumerate(items):</span><br><span class="line">        <span class="keyword">if</span> idx &gt;<span class="number">8</span>:</span><br><span class="line">                e.decompose()</span><br><span class="line">    </span><br><span class="line">    content= str(soup)</span><br><span class="line">    content=content.replace(<span class="string">'title&gt;'</span>, <span class="string">'stitle&gt;'</span>)</span><br><span class="line">    content=content.replace( <span class="string">'&lt;pubdate&gt;'</span>,<span class="string">'&lt;pubDate&gt;&lt;span translate="no"&gt;'</span>)</span><br><span class="line">    content=content.replace( <span class="string">'&lt;/pubdate&gt;'</span>,<span class="string">'&lt;/span&gt;&lt;/pubdate&gt;'</span>)</span><br><span class="line">    <span class="comment">#print(content)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    _text = GT.translate(content)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(out_dir,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        c=_text.translatedText</span><br><span class="line">        c=c.replace(<span class="string">'stitle&gt;'</span>, <span class="string">'title&gt;'</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;span translate="no"&gt;'</span>, <span class="string">''</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;/span&gt;&lt;/pubdate&gt;'</span>, <span class="string">'&lt;/pubDate&gt;'</span>) <span class="comment"># 对于ttrss需要为pubDate才会识别正确</span></span><br><span class="line">        c=c.replace(<span class="string">'&amp;gt'</span>,<span class="string">'&gt;'</span>) <span class="comment"># &amp;gt 会影响识别</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        f.write(c)</span><br><span class="line">        <span class="comment">#f.write(content)</span></span><br><span class="line">    print(<span class="string">"GT: "</span>+ url +<span class="string">" &gt; "</span>+ out_dir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tran_nature()</span><br></pre></td></tr></table></figure><h3 id="定时任务"><a class="header-anchor" href="#定时任务">¶</a>定时任务</h3><blockquote><p>注意激活一下miniconda3 这个命令<code>source /home/xxx/miniconda3/bin/activate</code></p></blockquote><p>放到 <code>/etc/cron.daily/</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">source</span> /home/xxx/miniconda3/bin/activate</span><br><span class="line">python /home/xxx/txxx.py</span><br></pre></td></tr></table></figure><h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2><ul><li><a href="https://blog.csdn.net/wokuailewozihao/article/details/82021709" target="_blank" rel="noopener">利用Google翻译实现网站国际化——js插件</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;本文中我们将英文rss 自动转成中文 rss供ttrss使用。（利用谷歌翻译）&lt;/p&gt;
&lt;p&gt;方便在手机上进行阅读或者收听。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/public/2022/05/08/rss_google_translate/20220508-22-28-27.png&quot; width=&quot;30%&quot;&gt;
&lt;/center&gt;
    
    </summary>
    
      <category term="工具" scheme="https://talengu.github.io/public/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="python" scheme="https://talengu.github.io/public/tags/python/"/>
    
      <category term="rss" scheme="https://talengu.github.io/public/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>rss统计 基于ttrss的PostgresQL数据库</title>
    <link href="https://talengu.github.io/public/2022/05/08/rss_ttrss_statics/"/>
    <id>https://talengu.github.io/public/2022/05/08/rss_ttrss_statics/</id>
    <published>2022-05-08T22:00:04.000Z</published>
    <updated>2022-05-08T22:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>统计ttrss的使用数据。</p><ul><li>月度mark文件分析 OK</li></ul><p>TODO：</p><ul><li>全年阅读报告 doing</li></ul><a id="more"></a><h2 id="按月保存mark的内容"><a class="header-anchor" href="#按月保存mark的内容">¶</a>按月保存mark的内容</h2><p>账号 密码 和你docker文件里面的一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按月来保存</span></span><br><span class="line"><span class="keyword">import</span> html2text</span><br><span class="line"><span class="comment"># psycopg2 head</span></span><br><span class="line"><span class="keyword">import</span> psycopg2</span><br><span class="line"><span class="comment"># pip3 install psycopg2-binary</span></span><br><span class="line"><span class="comment"># ref:https://blog.csdn.net/Haiqiang1995/article/details/89069791</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_from_dataset</span><span class="params">(cmd_sql)</span>:</span></span><br><span class="line">    conn = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># read database configuration</span></span><br><span class="line">        params = &#123;</span><br><span class="line">        <span class="string">'host'</span>: <span class="string">"?????"</span>,</span><br><span class="line">        <span class="string">'user'</span>: <span class="string">"????"</span>,</span><br><span class="line">        <span class="string">'password'</span>: <span class="string">"????"</span>,</span><br><span class="line">        <span class="string">'dbname'</span>: <span class="string">"ttrss"</span>,</span><br><span class="line">        'port': ??00</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># connect to the PostgresQL database</span></span><br><span class="line">        conn = psycopg2.connect(**params)</span><br><span class="line">        <span class="comment"># create a new cursor object</span></span><br><span class="line">        cur = conn.cursor()</span><br><span class="line">        <span class="comment"># execute the SELECT statement</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        print(cmd_sql)</span><br><span class="line">        cur.execute(cmd_sql)</span><br><span class="line"></span><br><span class="line">        blob = cur.fetchall()</span><br><span class="line">        <span class="comment"># blob = cur.fetchone()</span></span><br><span class="line">        <span class="comment">#open(path_to_dir + str(blob[0]) + '.jpg', 'wb').write(blob[1])</span></span><br><span class="line">        <span class="comment"># close the communication with the PostgresQL database</span></span><br><span class="line">        cur.close()</span><br><span class="line">    <span class="keyword">except</span> (Exception, psycopg2.DatabaseError) <span class="keyword">as</span> error:</span><br><span class="line">        print(error)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> conn <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            conn.close()</span><br><span class="line">    print(<span class="string">"get_from_dataset success"</span>)</span><br><span class="line">    <span class="keyword">return</span> blob</span><br><span class="line"></span><br><span class="line">_s=<span class="string">"ref_id,feed_id,last_read,last_marked"</span></span><br><span class="line">cmd_sql=<span class="string">"SELECT %s  FROM public.ttrss_user_entries Where marked=TRUE AND last_marked BETWEEN '2022-04-01' And '2022-5-01'"</span> % _s</span><br><span class="line"><span class="comment"># 可以自己改日期</span></span><br><span class="line"></span><br><span class="line">g_content=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> _e <span class="keyword">in</span> sorted(get_from_dataset(cmd_sql),key=<span class="keyword">lambda</span> x:x[<span class="number">3</span>]):</span><br><span class="line">    [ref_id,feed_id,last_read,last_marked] = _e</span><br><span class="line">    _s=<span class="string">"id,title,link,updated,content"</span></span><br><span class="line">    cmd_sql=<span class="string">"SELECT %s FROM public.ttrss_entries WHERE id = %s"</span> % (_s,ref_id)</span><br><span class="line">    [id,title,link,updated,content] =get_from_dataset(cmd_sql)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    g_content += <span class="string">"# [%s](%s)\n"</span>%(title,link)</span><br><span class="line">    g_content +=<span class="string">"pubdata:%s\n"</span>%str(updated)</span><br><span class="line">    g_content +=<span class="string">"markdate:%s\n"</span>%str(last_marked)</span><br><span class="line">    g_content+=html2text.html2text(content)</span><br><span class="line">    </span><br><span class="line">    g_content+=<span class="string">"\n\n"</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">D=<span class="string">"C:\\Users\\talen\\Desktop\\"</span></span><br><span class="line"><span class="keyword">with</span> open(D+<span class="string">"cc.md"</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(g_content)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;
统计ttrss的使用数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;月度mark文件分析 OK&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TODO：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全年阅读报告 doing&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="工具" scheme="https://talengu.github.io/public/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="python" scheme="https://talengu.github.io/public/tags/python/"/>
    
      <category term="rss" scheme="https://talengu.github.io/public/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>「转」GRE隧道测试</title>
    <link href="https://talengu.github.io/public/2022/05/05/linux/gre_test/"/>
    <id>https://talengu.github.io/public/2022/05/05/linux/gre_test/</id>
    <published>2022-05-05T22:52:28.000Z</published>
    <updated>2022-10-05T22:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6988645230987706398" target="_blank" rel="noopener">juejin.cn</a></p></blockquote><p><img src="/public/2022/05/05/linux/gre_test/e31bac5bcb1347a59142486adaf94e30.jpg" alt></p><h2 id="0-前言"><a class="header-anchor" href="#0-前言">¶</a>0. 前言</h2><p>在学习 ipsec 过程中，一般都会涉及到 ipsec 的局限性：ipsec 协议是一种点对点协议，不支持组播，也不能保护组播、广播报文。因此 ipsec 协议无法用于音视频会议等场合，此时通常的解决办法是采用 <strong>GRE Over IPSec</strong> .</p><p>给出的解释是：GRE 协议可以封装组播、广播报文，但是无法对业务内容进行加密；而 ipsec 可以对报文进行加密，但是无法封装组播和广播报文。因此将两种协议结合，因而 GRE over IPSec 协议应运而生。 但是我找了很多资料 (其实没有多少)，都没有找到为什么 GRE 协议支持封装组播和广播报文，而 ipsec 不行；他们作为点对点协议，为什么  GRE 可以而 IPsec  不行呢？因为没有找到答案，所以不能证实自己的想法正确与否，于是通过搭建 GRE 隧道环境，学习 Linux 内核中 GRE 隧道的操作配置原则，希望能从中得到些许启发。</p><p>搭建 GRE 隧道环境实际上是很简单的，因为 Linux 内核已经支持了 GRE 隧道，因此直接在虚拟机 (ubuntu 和 CentOS) 里进行简单的配置即可完成操作。</p><a id="more"></a><p><img src="/public/2022/05/05/linux/gre_test/db260d2dc98445f9988f1c768ca3e744.jpg" alt></p><h2 id="1-Linux-内核支持的隧道类型"><a class="header-anchor" href="#1-Linux-内核支持的隧道类型">¶</a>1. Linux 内核支持的隧道类型</h2><p>目前 Linux 内核已经支持多种隧道类型，包括：IPIP 隧道，GRE 隧道，... 。其余这几个我也没见过。当然除了这几种，还有 ipsec 协议，l2tp 协议，可以的是我目前都还没有用过，实在是暴殄天物，罪过罪过</p><p><img src="/public/2022/05/05/linux/gre_test/412f1154b6c64d74acd7b8cb31f713a5.jpg" alt></p><p><img src="/public/2022/05/05/linux/gre_test/e080bb892ca045a3b92f83ace7642a68.jpg" alt></p><p>下面通过搭建两组拓扑环境，来学习 GRE 隧道的基本规则，然后在此基础上分析下 GRE 和 IPSEC 在组播和广播报文封装的表现出不同行为的可能原因 (另写一遍文章喽)。</p><h2 id="2-GRE-隧道跨-公-网连接相同子网地址主机"><a class="header-anchor" href="#2-GRE-隧道跨-公-网连接相同子网地址主机">¶</a>2. GRE 隧道跨 (公) 网连接相同子网地址主机</h2><h3 id="2-1-拓扑环境"><a class="header-anchor" href="#2-1-拓扑环境">¶</a>2.1 拓扑环境</h3><p><img src="/public/2022/05/05/linux/gre_test/4759759198334a2ebc2c296e548026b0.jpg" alt></p><p>家里设备有限，只有一台电脑，还是通过无线网卡来上网的，因此拓扑环境比较寒酸，其实这些并不重要，只需明白我的两台虚拟机 Ubantu 和 CentOS 通过桥接的方式连在一起，网络上可以通讯即可。</p><p>现在，我准备将两个地址分别为 10.1.2.1/24、10.1.2.2/24 的两台主机 (假的，只是个 IP 地址而已) 通过 GRE 隧道连接起来进行通讯。原则上这两个地址属于不同的子网中(Ubantu 中的子网和 CentOS 中的子网，只是这两个子网的网段相同仅此而已)，无法直接通讯。</p><h3 id="2-1-ubuntu-配置"><a class="header-anchor" href="#2-1-ubuntu-配置">¶</a>2.1 ubuntu 配置</h3><p>首先，我确定了下该虚拟机中是否存在 gre 相关的接口，结果当然是没有了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/toney<span class="comment"># ifconfig -a</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 2409:8a00:18e9:810:141:383c:ac6f:8b11  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 2409:8a00:18e9:810:f8dd:500e:b1a:463b  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 fe80::8e84:574c:7a8b:440a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:fb:db:ad  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 3581  bytes 1030105 (1.0 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1177  bytes 114532 (114.5 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 160  bytes 12920 (12.9 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 160  bytes 12920 (12.9 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2-1-1-添加-GRE-隧道"><a class="header-anchor" href="#2-1-1-添加-GRE-隧道">¶</a>2.1.1 添加 GRE 隧道</h4><blockquote><p>ip tunnel add Tunnel-1 mode gre remote 192.168.1.13 local 192.168.1.10</p></blockquote><p>添加 GRE 隧道时, 需要指定隧道的名称，我这里叫做 Tunnel-1; 因为要搭建 GRE 类型隧道，因此 mode 为 gre。 而 GRE 隧道的地址为 192.168.1.13&lt;========&gt;192.168.1.10。</p><p>由于是第一次执行此命令，底层实际上安装上了 gre 隧道相关的驱动。用户只有在此基础上才能配置 GRE 隧道，不过，无需担心，内核自动完成。</p><p>如果在添加隧道时不指定 remote 和 local 地址，也是可以的，它实际上是只是安装 gre 隧道相关驱动。下面是添加隧道时没有指定 remote 和 local 地址时的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">root@ubantu:/home/toney<span class="comment"># ip tunnel add Tunnel-1</span></span><br><span class="line">cannot determine tunnel mode (ipip, gre, vti or sit)</span><br><span class="line">root@ubantu:/home/toney<span class="comment"># ifconfig -a</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 2409:8a00:18e9:810:141:383c:ac6f:8b11  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 2409:8a00:18e9:810:200d:99e2:4f3d:cb6f  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 fe80::8e84:574c:7a8b:440a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:fb:db:ad  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 5038  bytes 5896155 (5.8 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2744  bytes 309264 (309.2 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 164  bytes 15044 (15.0 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 164  bytes 15044 (15.0 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">root@ubantu:/home/toney<span class="comment"># ip tunnel add Tunnel-1 mode gre</span></span><br><span class="line">add tunnel <span class="string">"gre0"</span> failed: File exists</span><br><span class="line">root@ubantu:/home/toney<span class="comment"># ifconfig -a</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 2409:8a00:18e9:810:141:383c:ac6f:8b11  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 2409:8a00:18e9:810:200d:99e2:4f3d:cb6f  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 fe80::8e84:574c:7a8b:440a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:fb:db:ad  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 5097  bytes 5900501 (5.9 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2766  bytes 311496 (311.4 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">erspan0: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1450</span><br><span class="line">        ether 00:00:00:00:00:00  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">gre0: flags=128&lt;NOARP&gt;  mtu 1452</span><br><span class="line">        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 1000  (UNSPEC)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">gretap0: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1462</span><br><span class="line">        ether 00:00:00:00:00:00  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 164  bytes 15044 (15.0 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 164  bytes 15044 (15.0 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">root@ubantu:/home/toney<span class="comment">#</span></span><br><span class="line">root@ubantu:/home/toney<span class="comment"># lsmod | grep gre</span></span><br><span class="line">ip_gre                 28672  0</span><br><span class="line">ip_tunnel              24576  1 ip_gre</span><br><span class="line">gre                    16384  1 ip_gre</span><br><span class="line">root@ubantu:/home/toney<span class="comment">#</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果输入完整的命令，则会成功添加上 Tunnel-1 隧道：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">root@ubantu:/home/toney<span class="comment"># ifconfig -a</span></span><br><span class="line">Tunnel-1: flags=144&lt;POINTOPOINT,NOARP&gt;  mtu 1476</span><br><span class="line">        unspec C0-A8-01-0A-00-00-00-87-00-00-00-00-00-00-00-00  txqueuelen 1000  (UNSPEC)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 2409:8a00:18e9:810:141:383c:ac6f:8b11  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 2409:8a00:18e9:810:200d:99e2:4f3d:cb6f  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 fe80::8e84:574c:7a8b:440a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:fb:db:ad  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 5745  bytes 5947674 (5.9 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2965  bytes 329731 (329.7 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">erspan0: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1450</span><br><span class="line">        ether 00:00:00:00:00:00  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">gre0: flags=128&lt;NOARP&gt;  mtu 1452</span><br><span class="line">        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 1000  (UNSPEC)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">gretap0: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1462</span><br><span class="line">        ether 00:00:00:00:00:00  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 169  bytes 15509 (15.5 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 169  bytes 15509 (15.5 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2-1-2-配置-GRE-隧道接口-IP"><a class="header-anchor" href="#2-1-2-配置-GRE-隧道接口-IP">¶</a>2.1.2 配置 GRE 隧道接口 IP</h4><blockquote><p>ip addr add 10.1.2.1/24 dev Tunnel-1</p></blockquote><p>或者</p><blockquote><p>ifconfig Tunnel-1 10.1.2.1/24</p></blockquote><p>从添加隧道结果来看，Tunnel-1 接口虽然已经成功添加，但是处于 down 状态，此外也没有 IP 地址。 不，等等，那我们在添加隧道时指定的 remote 和 local 是什么呢？</p><p><strong>它是经过 <strong><strong>GRE</strong></strong> 隧道封装后的报文 <strong><strong>IP</strong></strong> 地址，但是针对什么报文进行封装，目前我们尚未配置</strong>。</p><p>配置此接口 IP 的目的是：为了确定哪些报文需要进入 GRE 接口，然后进行隧道封装。为什么需要添加 IP 呢？ 因为我们是通过路由将报文引入到 Tunnel-1 接口的, 如果不填 IP，那么我路由的下一条该写成什么呢， 是吧。</p><p><img src="/public/2022/05/05/linux/gre_test/772109c097cd48cab17c50d4dad64b10.jpg" alt></p><h4 id="2-1-3-激活-GRE-隧道接口-IP"><a class="header-anchor" href="#2-1-3-激活-GRE-隧道接口-IP">¶</a>2.1.3 激活 GRE 隧道接口 IP</h4><blockquote><p>ifconfig Tunnel-1 up</p></blockquote><p>或者</p><blockquote><p>ip link set Tunnel-1 up</p></blockquote><p>至于配置接口 IP 和是否 up 接口，没有什么先后顺序，把他们当做不同的 eth 接口处理即可。</p><p><img src="/public/2022/05/05/linux/gre_test/2410e66154a84a70b95d16a5df32e360.jpg" alt></p><h3 id="2-2-CentOS-配置"><a class="header-anchor" href="#2-2-CentOS-配置">¶</a>2.2 CentOS 配置</h3><p>CentOS 虚拟机的配置和 Ubantu 的配置完全相同，安照此步骤操作即可。</p><blockquote><p>ip tunnel add Tunnel-1 mode gre local 192.168.1.13 remote 192.168.1.10<br>ip link set Tunnel-1 up<br>ip addr add 10.1.2.2/24 dev Tunnel-1</p></blockquote><p>查看配置结果 r 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@toney toney]#</span><br><span class="line">[root@toney toney]#</span><br><span class="line">[root@toney toney]# ifconfig</span><br><span class="line">Tunnel-1  Link encap:UNSPEC  HWaddr C0-A8-01-0D-FF-FF-90-6D-00-00-00-00-00-00-00-00</span><br><span class="line">          inet addr:10.1.2.2  P-t-P:10.1.2.2  Mask:255.255.255.0</span><br><span class="line">          UP POINTOPOINT RUNNING NOARP  MTU:1476  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)</span><br><span class="line"></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:0C:29:DA:34:3C</span><br><span class="line">          inet addr:192.168.1.13  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: 2409:8a00:18e9:810:20c:29ff:feda:343c/64 Scope:Global</span><br><span class="line">          inet6 addr: fe80::20c:29ff:feda:343c/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:3571 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:781 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:236685 (231.1 KiB)  TX bytes:71021 (69.3 KiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:4 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:4 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:240 (240.0 b)  TX bytes:240 (240.0 b)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>路由表信息如下：</p><p><img src="/public/2022/05/05/linux/gre_test/f70bfbe84af74c21bab5b21a5bea3821.jpg" alt></p><h3 id="2-3-ping-包测试通讯链路"><a class="header-anchor" href="#2-3-ping-包测试通讯链路">¶</a>2.3 ping 包测试通讯链路</h3><p>这里有一点需要注意：Linux 系统可能开了 iptables 过滤功能，因此在 ping 时出现了类似 &quot;ICMP host 192.168.1.13 unreachable - admin prohibited, length 116&quot; 信息，详情如下：</p><p><img src="/public/2022/05/05/linux/gre_test/26f4422a5f9d4772ac9a354db2dd9847.jpg" alt></p><p>百度一下, 在两台虚拟机上都执行如下操作即可：</p><blockquote><p>iptables -F</p></blockquote><p>然后在 ping 包测试，数据可通：</p><p><img src="/public/2022/05/05/linux/gre_test/2df9a98e03d54319ad3b00704fc31a32.jpg" alt></p><p><img src="/public/2022/05/05/linux/gre_test/b01f9527ea6842b68acbf612ec34c084.jpg" alt></p><p>至此，基本 GRE 隧道环境搭建成功。</p><h2 id="3-GRE-隧道跨-公-网连接不同子网地址主机"><a class="header-anchor" href="#3-GRE-隧道跨-公-网连接不同子网地址主机">¶</a>3. GRE 隧道跨 (公) 网连接不同子网地址主机</h2><h3 id="3-1-拓扑环境"><a class="header-anchor" href="#3-1-拓扑环境">¶</a>3.1 拓扑环境</h3><p><img src="/public/2022/05/05/linux/gre_test/8752f3648dbc4dc4bd9036f00348ec9c.jpg" alt></p><p><strong>目的：</strong> 通过 GRE 隧道将 20.1.2.1/24、20.1.3.2/24 两个子网连接起来进行通讯。</p><h3 id="3-2-Ubantu-配置"><a class="header-anchor" href="#3-2-Ubantu-配置">¶</a>3.2 Ubantu 配置</h3><h4 id="3-2-1-配置-ens33-子接口-IP"><a class="header-anchor" href="#3-2-1-配置-ens33-子接口-IP">¶</a>3.2.1 配置 ens33 子接口 IP</h4><blockquote><p>ifconfig eth0:1 192.168.100.1/24</p></blockquote><p>查看接口配置如下：</p><p><img src="/public/2022/05/05/linux/gre_test/773d0b1700254e8ba9f847fdc2e79fd4.jpg" alt></p><h4 id="3-2-2-添加另一个-GRE-隧道接口并-up"><a class="header-anchor" href="#3-2-2-添加另一个-GRE-隧道接口并-up">¶</a>3.2.2 添加另一个 GRE 隧道接口并 up</h4><blockquote><p>ip tunnel add Tunnel-2 mode gre local 192.168.100.1 remote 192.168.100.2</p><p>ifconfig Tunnel-2 up</p></blockquote><h4 id="3-2-3-配置隧道接口-IP"><a class="header-anchor" href="#3-2-3-配置隧道接口-IP">¶</a>3.2.3 配置隧道接口 IP</h4><blockquote><p>ifconfig Tunnel-2 20.1.2.1/24</p></blockquote><p><img src="/public/2022/05/05/linux/gre_test/fbefdbdcba514312960176a103139de9.jpg" alt></p><h4 id="3-2-4-添加对端子网路由表"><a class="header-anchor" href="#3-2-4-添加对端子网路由表">¶</a>3.2.4 添加对端子网路由表</h4><p>由于本端没有对端子网 20.1.3.0/24 的路由，因此需要添加路由，将该网段报文引入到 Tunnel-2 接口，这样便可以通过 GRE 隧道进行封装。</p><blockquote><p>route add -net 20.1.3.0/24 gw 20.1.2.1</p></blockquote><p><img src="/public/2022/05/05/linux/gre_test/199432ae8e9e40e8b993ec0a0bca9016.jpg" alt></p><h3 id="3-3-CentOS-配置"><a class="header-anchor" href="#3-3-CentOS-配置">¶</a>3.3 CentOS 配置</h3><h4 id="3-3-1-配置-ens33-子接口-IP"><a class="header-anchor" href="#3-3-1-配置-ens33-子接口-IP">¶</a>3.3.1 配置 ens33 子接口 IP</h4><blockquote><p>ifconfig ens33:1 192.168.100.2/24</p></blockquote><p><img src="/public/2022/05/05/linux/gre_test/e9e2f1e4871f4c42ade68774b4bb4e75.jpg" alt></p><h4 id="3-3-2-添加另一个-GRE-隧道接口并-up"><a class="header-anchor" href="#3-3-2-添加另一个-GRE-隧道接口并-up">¶</a>3.3.2 添加另一个 GRE 隧道接口并 up</h4><blockquote><p>ip tunnel add Tunnel-2 mode gre remote 192.168.100.1 local 192.168.100.2</p><p>ifconfig Tunnel-2 up</p></blockquote><p>结果如下：</p><p><img src="/public/2022/05/05/linux/gre_test/8618b40c1afb497dbc85234fd0c58ad8.jpg" alt></p><h4 id="3-3-3-配置隧道接口-IP"><a class="header-anchor" href="#3-3-3-配置隧道接口-IP">¶</a>3.3.3 配置隧道接口 IP</h4><blockquote><p>ifconfig Tunnel-2 20.1.3.1/24</p></blockquote><h4 id="3-3-4-添加对端子网路由表"><a class="header-anchor" href="#3-3-4-添加对端子网路由表">¶</a>3.3.4 添加对端子网路由表</h4><p>由于本端没有对端子网 20.1.2.0/24 的路由，因此需要添加路由，将该网段报文引入到 Tunnel-2 接口，这样便可以通过 GRE 隧道进行封装。</p><blockquote><p>route add -net 20.1.2.0/24 gw 20.1.3.1</p></blockquote><p><img src="/public/2022/05/05/linux/gre_test/da52fb97c1044858bd28e645df512622.jpg" alt></p><h3 id="3-4-ping-测试链路连通性"><a class="header-anchor" href="#3-4-ping-测试链路连通性">¶</a>3.4 ping 测试链路连通性</h3><p><img src="/public/2022/05/05/linux/gre_test/1a28e720a97746f3a801a824a9ff95fd.jpg" alt></p><p><img src="/public/2022/05/05/linux/gre_test/5d3739151b0843c98c1c7352e91008c3.jpg" alt></p><p>​</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&quot;http://ksria.com/simpread/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&quot;https://juejin.cn/post/6988645230987706398&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;juejin.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/public/2022/05/05/linux/gre_test/e31bac5bcb1347a59142486adaf94e30.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#0-前言&quot;&gt;¶&lt;/a&gt;0. 前言&lt;/h2&gt;
&lt;p&gt;在学习 ipsec 过程中，一般都会涉及到 ipsec 的局限性：ipsec 协议是一种点对点协议，不支持组播，也不能保护组播、广播报文。因此 ipsec 协议无法用于音视频会议等场合，此时通常的解决办法是采用 &lt;strong&gt;GRE Over IPSec&lt;/strong&gt; .&lt;/p&gt;
&lt;p&gt;给出的解释是：GRE 协议可以封装组播、广播报文，但是无法对业务内容进行加密；而 ipsec 可以对报文进行加密，但是无法封装组播和广播报文。因此将两种协议结合，因而 GRE over IPSec 协议应运而生。 但是我找了很多资料 (其实没有多少)，都没有找到为什么 GRE 协议支持封装组播和广播报文，而 ipsec 不行；他们作为点对点协议，为什么  GRE 可以而 IPsec  不行呢？因为没有找到答案，所以不能证实自己的想法正确与否，于是通过搭建 GRE 隧道环境，学习 Linux 内核中 GRE 隧道的操作配置原则，希望能从中得到些许启发。&lt;/p&gt;
&lt;p&gt;搭建 GRE 隧道环境实际上是很简单的，因为 Linux 内核已经支持了 GRE 隧道，因此直接在虚拟机 (ubuntu 和 CentOS) 里进行简单的配置即可完成操作。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://talengu.github.io/public/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="隧道技术" scheme="https://talengu.github.io/public/tags/%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>本地安装rss</title>
    <link href="https://talengu.github.io/public/2022/04/16/rss_local_install/"/>
    <id>https://talengu.github.io/public/2022/04/16/rss_local_install/</id>
    <published>2022-04-16T12:39:04.000Z</published>
    <updated>2022-04-27T12:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>在 “<a href="https://zhuanlan.zhihu.com/p/149452085" target="_blank" rel="noopener">二零年RSS杂谈</a>”中说到，我想建立一种信息的获取系统，免受广告和推荐算法的困扰。</p><p>我希望其的功能包括：</p><ul><li>多终端 Web、PC、 mobile的同步</li><li>全文获取能力</li><li>可自定义过滤规则</li><li>RSS源自定义</li></ul><p>方案：</p><ul><li>RSS源 rsshub</li><li>RSS服务  ttrss</li><li>RSS电脑手机软件：Android的Readably、Feedme，mac的reeder等等。windows上我暂时没有发现，我用的是ttrss的web界面。</li></ul><a id="more"></a><p>rsshub 是由 DIYgod 开发的开源RSS源生成工具，RSShub原始的网站可能不稳定，所以我选择了自己搭建。</p><p>ttrss 是一个rss源管理配置的工具，可获取全文，可自定义过滤规则。</p><p>本教程我们将完成在window电脑通过docker安装，ttrss与全文插件、rsshub的过程。</p><p>服务器的成本还是有点小贵的，我们可以在本地搭建整个服务，即利用docker安装这些服务，开机的时候记得启动这些服务。不爽点：</p><ul><li>需要后台开启docker服务，使得其自动更新信息</li><li>没有公网ip的情况下，无法全网连接服务</li></ul><h2 id="最终ttrss界面"><a class="header-anchor" href="#最终ttrss界面">¶</a>最终ttrss界面</h2><p>在这里我已经添加一些rss源了。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626135803804.png" alt="image-20200626135803804"></p><h2 id="docker-windows安装"><a class="header-anchor" href="#docker-windows安装">¶</a>docker windows安装</h2><p>从<a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">docker 官网</a> 下载windows版本安装。完成后，在图标区会有一个鲸鱼船。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626141604658.png" alt="image-20200626141604658"></p><p>我们使用docker-compose 来进行下一步 网站服务的安装。将下面的资料保存到s<code>docker-compose.yml</code> 然后利用docker-compose方法安装。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">service.rsshub:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">diygod/rsshub</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rsshub</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"1200:1200"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rsshub_data:/app/lib</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">service.rss:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangqiru/ttrss:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ttrss</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8118</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SELF_URL_PATH=http://127.0.0.1:8118/</span> <span class="comment"># please change to your own domain</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_HOST=database.postgres</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PORT=5432</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_NAME=ttrss</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_USER=postgres</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PASS=ttrss</span> <span class="comment"># please change the password</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ENABLE_PLUGINS=auth_internal,fever</span> <span class="comment"># auth_internal is required. Plugins enabled here will be enabled for all users as system plugins</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FEED_LOG_QUIET=true</span></span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">'sh /wait-for.sh $$DB_HOST:$$DB_PORT -- php /configure-db.php &amp;&amp; exec s6-svscan /etc/s6/'</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">database.postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_PASSWORD=ttrss</span> <span class="comment"># please change the password</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgres_data:/var/lib/postgresql/data</span> <span class="comment"># persist postgres data to ~/postgres/data/ on the host</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">service.mercury:</span> <span class="comment"># set Mercury Parser API endpoint to `service.mercury:3000` on TTRSS plugin setting page</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangqiru/mercury-parser-api:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mercury</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">postgres_data:</span></span><br><span class="line">  <span class="attr">rsshub_data:</span></span><br></pre></td></tr></table></figure><p><img src="/public/2022/04/16/rss_local_install/image-20200626140114783.png" alt="image-20200626140114783"></p><p>在地址栏输入<code>cmd</code>，我们就可以打开cmd界面了，然后运行<code>docker-compose up -d</code> ，就可以自动安装全部内容了。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626134626593.png" alt="image-20200626134626593"></p><p>在地址栏输入<code>cmd</code> 然后回车，我们就能进入cmd界面，然后使用docker-compose，进行安装，网速好的话，安装很快。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626140147402.png" alt="image-20200626140147402"></p><p>安装完毕我们就可以使用了，下面是其资源占用情况。</p><table><thead><tr><th></th><th>内容</th><th>占用内存空间（M）</th></tr></thead><tbody><tr><td>mercury</td><td>全文获取ttrss插件</td><td>66.8</td></tr><tr><td>postgres</td><td>ttrss数据库</td><td>6.8</td></tr><tr><td>ttrss</td><td>ttrss工具</td><td>30.2</td></tr><tr><td>rsshub</td><td>rsshub各种b站源等等</td><td>142.4</td></tr><tr><td></td><td></td><td>246.2</td></tr></tbody></table><p><img src="/public/2022/04/16/rss_local_install/image-20200626140407183.png" alt="image-20200626140407183"></p><p>打开 <a href="http://127.0.0.1:8118/" target="_blank" rel="noopener">http://127.0.0.1:8118/</a></p><p>默认账户：admin 密码：password，请第一时间更改。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626143320968.png" alt="image-20200626143320968"></p><h2 id="在chrome安装-rsshub-radar"><a class="header-anchor" href="#在chrome安装-rsshub-radar">¶</a>在chrome安装 rsshub radar</h2><p><img src="/public/2022/04/16/rss_local_install/image-20200626144233385.png" alt="image-20200626144233385"></p><p>并设置到本机的rsshub地址，ttrss地址，如上。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626144330350.png" alt="image-20200626144330350"></p><p>打开bilibili up主的主页就能订阅了，订阅到ttrss。</p><p>这里有问题。需要解决。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626145153354.png" alt="image-20200626145153354"></p><p>本次安装教程到此结束，下期我们介绍全文获取功能，手机app的联动，即ttrss的设置问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;在 “&lt;a href=&quot;https://zhuanlan.zhihu.com/p/149452085&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二零年RSS杂谈&lt;/a&gt;”中说到，我想建立一种信息的获取系统，免受广告和推荐算法的困扰。&lt;/p&gt;
&lt;p&gt;我希望其的功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多终端 Web、PC、 mobile的同步&lt;/li&gt;
&lt;li&gt;全文获取能力&lt;/li&gt;
&lt;li&gt;可自定义过滤规则&lt;/li&gt;
&lt;li&gt;RSS源自定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RSS源 rsshub&lt;/li&gt;
&lt;li&gt;RSS服务  ttrss&lt;/li&gt;
&lt;li&gt;RSS电脑手机软件：Android的Readably、Feedme，mac的reeder等等。windows上我暂时没有发现，我用的是ttrss的web界面。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="信息收集" scheme="https://talengu.github.io/public/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="工具" scheme="https://talengu.github.io/public/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="rss" scheme="https://talengu.github.io/public/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>「转」window软件运行时间</title>
    <link href="https://talengu.github.io/public/2022/04/15/soft_run_time/"/>
    <id>https://talengu.github.io/public/2022/04/15/soft_run_time/</id>
    <published>2022-04-15T12:39:04.000Z</published>
    <updated>2022-04-27T12:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2><p>对关注性能的程序开发人员而言，一个好的计时部件既是益友，也是良师。计时器既可以作为程序组件帮助程序员精确的控制程序进程，又是一件有力的调试武器，在有经验的程序员手里可以尽快的确定程序的性能瓶颈，或者对不同的算法作出有说服力的性能比较。</p><a id="more"></a><p>在Windows平台下，常用的计时器有两种，一种是<code>timeGetTime</code>多媒体计时器，它可以提供毫秒级的计时。但这个精度对很多应用场合而言还是太粗糙了。另一种是<code>QueryPerformanceCount</code>计数器，随系统的不同可以提供微秒级的计数。对于实时图形处理、多媒体数据流处理、或者实时系统构造的程序员，善用<code>QueryPerformanceCount/QueryPerformanceFrequency</code>是一项基本功。</p><p>本文要介绍的，是另一种直接利用<code>Pentium CPU</code>内部时间戳进行计时的高精度计时手段。以下讨论主要得益于<code>《Windows图形编程》</code>一书，第15页－17页，有兴趣的读者可以直接参考该书。关于RDTSC指令的详细讨论，可以参考Intel产品手册。本文仅仅作抛砖之用。</p><p>在 <code>Intel Pentium</code>以上级别的CPU中，有一个称为“时间戳（Time   Stamp）”的部件，它以64位无符号整型数的格式，记录了自CPU上电以来所经过的时钟周期数。由于目前的CPU主频都非常高，因此这个部件可以达到纳秒级的计时精度。这个精确性是上述两种方法所无法比拟的。</p><p>在Pentium以上的CPU中，提供了一条机器指令RDTSC（Read Time   Stamp Counter）来读取这个时间戳的数字，并将其保存在EDX:EAX寄存器对中。由于<code>EDX:EAX</code>寄存器对恰好是Win32平台下C++语言保存函数返回值的寄存器，所以我们可以把这条指令看成是一个普通的函数调用。像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline   unsigned   __int64   GetCycleCount()   </span><br><span class="line">&#123;   </span><br><span class="line">  __asm   RDTSC   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是不行，因为RDTSC不被C++的内嵌汇编器直接支持，所以我们要用_emit伪指令直接嵌入该指令的机器码形式<code>0X0F</code>、<code>0X31</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  inline   unsigned   __int64   GetCycleCount()   </span><br><span class="line">  &#123;   </span><br><span class="line">    __asm   _emit   0x0F   </span><br><span class="line">    __asm   _emit   0x31   </span><br><span class="line">  &#125;   </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">以后在需要计数器的场合，可以像使用普通的Win32   API一样，调用两次GetCycleCount函数，比较两个返回值的差，像这样：</span><br></pre></td></tr></table></figure><p>unsigned   long   t;<br>t   =   (unsigned   long)GetCycleCount();<br>//Do   Something   time-intensive   ...<br>t   -=   (unsigned   long)GetCycleCount();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`《Windows图形编程》`第15页编写了一个类，把这个计数器封装起来。有兴趣的读者可以去参考那个类的代码。作者为了更精确的定时，做了一点小小的改进，把执行`RDTSC`指令的时间，通过连续两次调用`GetCycleCount`函数计算出来并保存了起来，以后每次计时结束后，都从实际得到的计数中减掉这一小段时间，以得到更准确的计时数字。但我个人觉得这一点点改进意义不大。在我的机器上实测，这条指令大概花掉了几十到100多个周期，在`Celeron 800MHz`的机器上，这不过是十分之一微秒的时间。对大多数应用来说，这点时间完全可以忽略不计；而对那些确实要精确到纳秒数量级的应用来说，这个补偿也过于粗糙了。   </span><br><span class="line">    </span><br><span class="line">  这个方法的优点是：   </span><br><span class="line">    </span><br><span class="line">  1. 高精度。可以直接达到纳秒级的计时精度（在1GHz的CPU上每个时钟周期就是一纳秒），这是其他计时方法所难以企及的。   </span><br><span class="line">    </span><br><span class="line">  2. 成本低。`timeGetTime`函数需要链接多媒体库 `winmm.lib`，`QueryPerformance*`函数根据MSDN的说明，需要硬件的支持（虽然我还没有见过不支持的机器）和KERNEL库的支持，所以二者都只能在Windows平台下使用（关于DOS平台下的高精度计时问题，可以参考`《图形程序开发人员指南》`，里面有关于控制定时器8253的详细说明）。但`RDTSC`指令是一条CPU指令，凡是i386平台下Pentium以上的机器均支持，甚至没有平台的限制（我相信i386版本UNIX和Linux下这个方法同样适用，但没有条件试验），而且函数调用的开销是最小的。   </span><br><span class="line">    </span><br><span class="line">  3. 具有和CPU主频直接对应的速率关系。一个计数相当于1/(CPU主频Hz数)秒，这样只要知道了CPU的主频，可以直接计算出时间。这和   `QueryPerformanceCount`不同，后者需要通过`QueryPerformanceFrequency`获取当前计数器每秒的计数次数才能换算成时间。   </span><br><span class="line">    </span><br><span class="line">  这个方法的缺点是：   </span><br><span class="line">    </span><br><span class="line">  1. 现有的C/C++编译器多数不直接支持使用RDTSC指令，需要用直接嵌入机器码的方式编程，比较麻烦。   </span><br><span class="line">    </span><br><span class="line">  2. 数据抖动比较厉害。其实对任何计量手段而言，精度和稳定性永远是一对矛盾。如果用低精度的`timeGetTime`来计时，基本上每次计时的结果都是相同的；而`RDTSC`指令每次结果都不一样，经常有几百甚至上千的差距。这是这种方法高精度本身固有的矛盾。   </span><br><span class="line">    </span><br><span class="line">  关于这个方法计时的最大长度，我们可以简单的用下列公式计算：</span><br></pre></td></tr></table></figure><p>自CPU上电以来的秒数   =   RDTSC读出的周期数   /   CPU主频速率（Hz）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">64位无符号整数所能表达的最大数字是`1.8×10^19`，在我的`Celeron   800`上可以计时大约700年（书中说可以在200MHz的Pentium上计时117年，这个数字不知道是怎么得出来的，与我的计算有出入）。无论如何，我们大可不必关心溢出的问题。   </span><br><span class="line">    </span><br><span class="line">下面是几个小例子，简要比较了三种计时方法的用法与精度   </span><br><span class="line"> ```c</span><br><span class="line">//Timer1.cpp   使用了RDTSC指令的Timer类//KTimer类的定义可以参见《Windows图形编程》P15   </span><br><span class="line">//编译行：CL Timer1.cpp   /link   USER32.lib   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">#include   &quot;KTimer.h&quot;   </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  unsigned   t;   </span><br><span class="line">  KTimer   timer;   </span><br><span class="line">  timer.Start();   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  t   =   timer.Stop();   </span><br><span class="line">  printf(&quot;Lasting   Time:   %d\n&quot;,t);   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">//Timer2.cpp   使用了timeGetTime函数   </span><br><span class="line">//需包含&lt;mmsys.h&gt;，但由于Windows头文件错综复杂的关系   </span><br><span class="line">//简单包含&lt;windows.h&gt;比较偷懒：）   </span><br><span class="line">//编译行：CL   timer2.cpp   /link   winmm.lib     </span><br><span class="line">#include   &lt;windows.h&gt;   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">  </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  DWORD   t1,   t2;   </span><br><span class="line">  t1   =   timeGetTime();   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  t2   =   timeGetTime();   </span><br><span class="line">  printf(&quot;Begin   Time:   %u\n&quot;,   t1);   </span><br><span class="line">  printf(&quot;End   Time:   %u\n&quot;,   t2);   </span><br><span class="line">  printf(&quot;Lasting   Time:   %u\n&quot;,(t2-t1));   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">//Timer3.cpp   使用了QueryPerformanceCounter函数   </span><br><span class="line">//编译行：CL   timer3.cpp   /link   KERNEl32.lib   </span><br><span class="line">#include   &lt;windows.h&gt;   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">  </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  LARGE_INTEGER   t1,   t2,   tc;   </span><br><span class="line">  QueryPerformanceFrequency(&amp;tc);   </span><br><span class="line">  printf(&quot;Frequency:   %u\n&quot;,   tc.QuadPart);   </span><br><span class="line">  QueryPerformanceCounter(&amp;t1);   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  QueryPerformanceCounter(&amp;t2);   </span><br><span class="line">  printf(&quot;Begin   Time:   %u\n&quot;,   t1.QuadPart);   </span><br><span class="line">  printf(&quot;End   Time:   %u\n&quot;,   t2.QuadPart);   </span><br><span class="line">  printf(&quot;Lasting   Time:   %u\n&quot;,(   t2.QuadPart-   t1.QuadPart));   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">////////////////////////////////////////////////   </span><br><span class="line">//以上三个示例程序都是测试1秒钟休眠所耗费的时间   </span><br><span class="line">//测试环境：Celeron   800MHz   /   256M   SDRAM       </span><br><span class="line">//         Windows   2000   Professional   SP2   </span><br><span class="line">//         Microsoft   Visual   C++   6.0   SP5   </span><br><span class="line">////////////////////////////////////////////////</span><br></pre></td></tr></table></figure><p>以下是Timer1的运行结果，使用的是高精度的<code>RDTSC</code>指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lasting   Time:   804586872</span><br></pre></td></tr></table></figure><p>以下是Timer2的运行结果，使用的是最粗糙的<code>timeGetTime API</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Begin   Time:   20254254   </span><br><span class="line">End   Time:   20255255   </span><br><span class="line">Lasting   Time:   1001</span><br></pre></td></tr></table></figure><p>以下是Timer3的运行结果，使用的是<code>QueryPerformanceCount API</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Frequency:   3579545   </span><br><span class="line">Begin   Time:   3804729124   </span><br><span class="line">End   Time:   3808298836   </span><br><span class="line">Lasting   Time:   3569712</span><br></pre></td></tr></table></figure><p>古人说，触类旁通。从一本介绍图形编程的书上得到一个如此有用的实时处理知识，我感到非常高兴。有美不敢自专，希望大家和我一样喜欢这个轻便有效的计时器。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#背景&quot;&gt;¶&lt;/a&gt;背景&lt;/h2&gt;
&lt;p&gt;对关注性能的程序开发人员而言，一个好的计时部件既是益友，也是良师。计时器既可以作为程序组件帮助程序员精确的控制程序进程，又是一件有力的调试武器，在有经验的程序员手里可以尽快的确定程序的性能瓶颈，或者对不同的算法作出有说服力的性能比较。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://talengu.github.io/public/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="软件运行" scheme="https://talengu.github.io/public/tags/%E8%BD%AF%E4%BB%B6%E8%BF%90%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>知识记忆软件anki的使用</title>
    <link href="https://talengu.github.io/public/2022/04/14/anki_tips/"/>
    <id>https://talengu.github.io/public/2022/04/14/anki_tips/</id>
    <published>2022-04-14T12:39:04.000Z</published>
    <updated>2022-04-27T12:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="anki使用-自建-anki-server"><a class="header-anchor" href="#anki使用-自建-anki-server">¶</a>anki使用 - 自建 anki  server</h2><p>当初想设计好用的英语背诵软件，现在发现了anki人家功能全部实现，还要啥自行车。</p><p>我当时设计的单词勇士开源Android软件：<a href="https://github.com/talengu/WordWarrior" target="_blank" rel="noopener">https://github.com/talengu/WordWarrior</a>现在已弃坑。</p><p>我们当然选用docker compose 来安装，相当丝滑。</p><p>在使用Anki过程中，主要工作是制作卡组，我们可以只关心内容而不关心技术。</p><a id="more"></a><h2 id="docker-compose"><a class="header-anchor" href="#docker-compose">¶</a>docker compose</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">service.anki:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kuklinistvan/anki-sync-server</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">anki-container</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8121</span><span class="string">:27701</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/anki-sync-server:/app/data</span> <span class="comment"># anki data</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="登陆container"><a class="header-anchor" href="#登陆container">¶</a>登陆container</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it anki-container /bin/sh</span><br><span class="line"></span><br><span class="line">./ankisyncctl.py lsuser             - list users</span><br><span class="line">./ankisyncctl.py adduser &lt;username&gt; - add a new user</span><br><span class="line">./ankisyncctl.py deluser &lt;username&gt; - delete a user</span><br><span class="line">./ankisyncctl.py passwd &lt;username&gt;  - change password of a user</span><br></pre></td></tr></table></figure><h2 id="客户端"><a class="header-anchor" href="#客户端">¶</a>客户端</h2><img src="/public/2022/04/14/anki_tips/image-20200424005627732.png" alt="image-20200424005627732" style="zoom:33%;"><h3 id="mac-win-客户端"><a class="header-anchor" href="#mac-win-客户端">¶</a>mac/win 客户端</h3><p>从官网下载 anki mac版本 2.1.21 (f1734a47) / Windows PC 客户端</p><p>中文网：<a href="http://www.ankichina.net/" target="_blank" rel="noopener">http://www.ankichina.net/</a></p><p>工具-&gt;附加组件-&gt;<code>获取插件</code>，输入 代码：2124817646</p><img src="/public/2022/04/14/anki_tips/add_server.png" alt="add_server" style="zoom:30%;"><img src="/public/2022/04/14/anki_tips/add_on1.png" alt="add_on1" style="zoom:30%;"><p>插件下载完成后设置ip地址，点击<code>设置</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"msyncUrl"</span>: <span class="string">"http://127.0.0.1:27701/msync/"</span>,</span><br><span class="line">    <span class="attr">"syncUrl"</span>: <span class="string">"http://127.0.0.1:27701/sync/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/public/2022/04/14/anki_tips/addon_2.png" alt="addon_2" style="zoom:30%;"><p>重启anki，同步并输入输入自定义服务器中配置的账户</p><h3 id="Android客户端-AnkiDroid"><a class="header-anchor" href="#Android客户端-AnkiDroid">¶</a>Android客户端 - AnkiDroid</h3><p>首先配置服务器地址信息，打开<code>设置-&gt;高级设置-&gt;自定义同步服务器</code>，输入同步地址 和 媒体文件同步地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 同步地址</span><br><span class="line">http://127.0.0.1:27701/</span><br><span class="line"># 媒体文件同步地址</span><br><span class="line">http://127.0.0.1:27701/msync/</span><br></pre></td></tr></table></figure><p>然后打开 <code>设置-&gt;AnkiDroid常用设置-&gt;AnkiWeb账户</code>，输入在服务器里面设置的账户和密码。PS：可在服务器重置密码。</p><table><tr><td><center><img src="/public/2022/04/14/anki_tips/IMG_20200424_010047.jpg">图1    </center></td><td><center><img src="/public/2022/04/14/anki_tips/IMG_20200424_011338.jpg">图2      </center></td></tr></table><p>coco20000 anki 包 <a href="https://www.dazhuanlan.com/2019/11/20/5dd54a6571f01/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/11/20/5dd54a6571f01/</a></p><h2 id="使用-Docker-安装"><a class="header-anchor" href="#使用-Docker-安装">¶</a>使用 Docker 安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ANKI_SYNC_DATA_DIR=<span class="variable">$HOME</span>/anki-sync-server</span><br><span class="line"><span class="built_in">export</span> HOST_PORT=27701</span><br><span class="line"></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$ANKI_SYNC_DATA_DIR</span>"</span></span><br><span class="line"><span class="comment">#export DOCKER_USER=root</span></span><br><span class="line"><span class="comment">#chown "$DOCKER_USER" "$ANKI_SYNC_DATA_DIR"</span></span><br><span class="line">chmod 700 <span class="string">"<span class="variable">$ANKI_SYNC_DATA_DIR</span>"</span></span><br><span class="line"></span><br><span class="line">docker run -itd \</span><br><span class="line">   -v <span class="string">"<span class="variable">$ANKI_SYNC_DATA_DIR</span>"</span>:/app/data \</span><br><span class="line">   -p <span class="string">"<span class="variable">$HOST_PORT</span>"</span>:27701 \</span><br><span class="line">   --name anki-container \</span><br><span class="line">   --restart always \</span><br><span class="line">   kuklinistvan/anki-sync-server:latest</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;anki使用-自建-anki-server&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#anki使用-自建-anki-server&quot;&gt;¶&lt;/a&gt;anki使用 - 自建 anki  server&lt;/h2&gt;
&lt;p&gt;当初想设计好用的英语背诵软件，现在发现了anki人家功能全部实现，还要啥自行车。&lt;/p&gt;
&lt;p&gt;我当时设计的单词勇士开源Android软件：
&lt;a href=&quot;https://github.com/talengu/WordWarrior&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/talengu/WordWarrior&lt;/a&gt;
现在已弃坑。&lt;/p&gt;
&lt;p&gt;我们当然选用docker compose 来安装，相当丝滑。&lt;/p&gt;
&lt;p&gt;在使用Anki过程中，主要工作是制作卡组，我们可以只关心内容而不关心技术。&lt;/p&gt;
    
    </summary>
    
      <category term="知识管理" scheme="https://talengu.github.io/public/categories/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="工具" scheme="https://talengu.github.io/public/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="anki" scheme="https://talengu.github.io/public/tags/anki/"/>
    
      <category term="技巧" scheme="https://talengu.github.io/public/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu完全教程</title>
    <link href="https://talengu.github.io/public/2022/04/01/linux/ubuntu_tour/"/>
    <id>https://talengu.github.io/public/2022/04/01/linux/ubuntu_tour/</id>
    <published>2022-04-01T18:00:04.000Z</published>
    <updated>2022-04-01T18:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ref:<a href="http://www.cnblogs.com/dutlei/archive/2012/11/20/2778327.html" target="_blank" rel="noopener">Ubuntu完全教程，让你成为Ubuntu高手！</a>todo整理</p></blockquote><h2 id="Ubuntu的发音"><a class="header-anchor" href="#Ubuntu的发音">¶</a>Ubuntu的发音</h2><p>Ubuntu，源于非洲祖鲁人和科萨人的语言，发作 oo-boon-too 的音。了解发音是有意义的，您不是第一个为此困惑的人，当然，也不会是最后一个：）</p><p>大多数的美国人读 ubuntu 时，将 u 作为元音发音，类似单词 who 或者 boo ，重音在第二个音节即 u'buntu ，oo-boon-too 。</p><p>如果您喜欢撒哈拉，喜欢它令人窒息的温柔、梦幻般的寂寥还有张扬恣肆的旷远，您大可在第一个 u，后面带些嗡嗡声： oom-boon-too。</p><p>Ubuntu的中文发音大约为： 乌班图</p><h3 id="Ubuntu的涵义"><a class="header-anchor" href="#Ubuntu的涵义">¶</a>Ubuntu的涵义</h3><p>Ubuntu这个单词源自非洲，意谓“班图精神”────谁都不是一座孤岛，自成一体。每个人都包孕于人类，因他人存在而存在，因他人幸福而幸福。</p><h3 id="Ubuntu当前版本"><a class="header-anchor" href="#Ubuntu当前版本">¶</a>Ubuntu当前版本</h3><p>Ubuntu Linux v6.06 LTS (Dapper Drake)</p><p>LTS：Long Term Support</p><p>Dapper Drake：当前版本的开发代号</p><h3 id="Ubuntu的特点"><a class="header-anchor" href="#Ubuntu的特点">¶</a>Ubuntu的特点</h3><p>Ubuntu 完全基于 Linux 操作系统， 可以免费得到社区及专业机构的支持。庞大的社区是它成长的沃土，请向这片动人的热忱敞开心扉。</p><p>Ubuntu 社区恪守 Ubuntu 理念：自由！软件应是自由的，应尊重人类的自由意志，它与人类之间不应有任何隔膜。本地语种，功能限制，自主改进的权利……都不应成为使用的障碍或负担。</p><p>自由，让 Ubuntu 与传统的私有软件从根本上不同: 免费不能用来遮羞，您有权修正它，直到满意为止。</p><p>Ubuntu 适合桌面和服务器。当前 Ubuntu 发布版支持 PC (Intel x86), 64-bit PC (AMD64) 和 PowerPC (Apple iBook 和 Powerbook, G4 和 G5) 架构。</p><p>Ubuntu 包涵了超过 16,000 种软件， 核心的桌面系统却只有一张光盘， Ubuntu 覆盖了所有的桌面应用程序,</p><p>从文字处理，电子表格到 web 服务器和开发设计环境一应俱全。 详情查看 Ubuntu 桌面 和 Ubuntu 服务器的介绍。</p><h3 id="Ubuntu相对其它Linux发行版的主要特点"><a class="header-anchor" href="#Ubuntu相对其它Linux发行版的主要特点">¶</a>Ubuntu相对其它Linux发行版的主要特点</h3><ul><li><p>基于Debian/Linux，使用 APT 包管理系统。</p></li><li><p>相对于Fedora Code： APT 包管理系统优雅地解决了依赖问题，并且可以从容的在线安装升级</p></li><li><p>相对于Debian：软件更新积极，而Debian较保守。</p></li><li><p>相对于Gentoo：基本无需编译，省力、省时、省心。</p></li></ul><a id="more"></a><h3 id="基本操作"><a class="header-anchor" href="#基本操作">¶</a>基本操作</h3><p><strong>进入系统</strong></p><p>在登录界面中输入您的用户名，然后系统将提问您的密码</p><p>输入您的密码后，回车，稍事等待，您便可以进入Ubuntu系统</p><p>点击桌面左上角的图标，您可以打开一个菜单（或者使用 Alt+F1 组合键）</p><p>如果您想退出系统，可以点击该图标</p><p>在桌面上方启动栏中，包含了一些常用程序的启动图标这些图标也可以在开始菜单中找到</p><p>现在点击FireFox图标，您便可以使用FireFox浏览器冲浪</p><p>或者按下 Alt+F2 组合键，弹出一个运行命令对话框。输入 firefox 后回车，同样可以启动FireFox</p><p>在菜单中找到 终端</p><p>点击它便开启了一个终端窗口，您可以在终端窗口中运行命令</p><p>也可以在控制台中输入命令。使用 Ctrl+Alt+[F1~F6] ，您可以切换到1~6号控制台</p><p>使用 Ctrl+Alt+F7 可以返回图形界面（您可以使用 Ctrl+Alt+BackSpace 将图形界面关闭）</p><p>命令行提示符</p><p>user@ubuntu:~$ 为命令提示符， @ 之前的部分为当前用户ID， @ 与 : 之间的部分，为您的主机名称， : 与 $ 之间的部分，为当前的路径。</p><p><strong>退出系统</strong></p><p>您可以点击这一个图标来退出系统</p><p>也可以在终端或者控制台中输入命令</p><p>sudo halt</p><p>系统会提问您密码，输入正确密码，便可以退出系统</p><p>在以后的章节中，如果我们提示您输入命令，那么您即可以在终端中输入，也可以在控制台中输入。如果只是启动应用程序，还可以使用 Alt+F2 组合键。</p><h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2><h3 id="分区概念"><a class="header-anchor" href="#分区概念">¶</a>分区概念</h3><p>首先我们需要知道，硬盘分区的存在，是由硬盘的物理特性决定的，并不会因为不同的操作系统而有所改变。</p><p>请您把一块硬盘想象为一本书……即便您不喜欢读书，您也一定非常熟悉它，所有的书都是相同的，包括我们使用的课本……您肯定非常熟悉</p><p>一本完整的书，通常包括书名、索引和正文。</p><p>如果您需要Linux，您首先需要找到一本书名为《linux》的书，书名相当于硬盘中的MBR，也就是主引导纪录。不同的是，MBR可以是几个书名合在一起，类似于《XX合订本》。这部分内容暂时还没有什么实用价值，您只需要大概的了解。</p><p>而正文，就是硬盘中纪录的数据，这也非常容易理解，且对于安装系统并没有什么影响，所以现在我们来了解索引</p><p>索引相当于硬盘中的分区表，书中的每一个章节，相当于硬盘中的一个分区，它起始和结束的页次，都可以在索引中找到。试想，如果阅读一本撕掉索引的书，您将很难找到您想阅读的部分。同样，如果没有分区表，操作系统也不能够在硬盘上定位数据的位置。</p><p>由于历史的原因，硬盘中的分区表大小受到了限制，最多只可以容纳四个分区（主分区）。如果一本书，它的索引最多只能有四个章节，那不是太可怕了么？很多书的内容远远不止四个章节啊！</p><p>于是聪明的人们想到了一个变通的办法，就是利用其中的一个章节，来存储其它部分的索引。比如第一章是前言，第二章是其它部分的索引，我们翻到第二章，呵呵，这里是第二个索引，因为只有第一个索引受四个章节的限制，所以这个索引的内容可以非常的详尽。第二个索引就是分区表中的扩展分区了，其中定义的章节，就是硬盘中的逻辑分区，不是很难理解吧？</p><p>明白了这一点，我们来看看Linux和Windows对于分区不同的表示方法：</p><p>可能您已经很熟悉Windows了，它使用盘符来表示分区，比如 C: D: E:，每一个分区使用一个盘符来标识，而且顺序可以颠倒， D:并不一定就是您系统中的第二个分区。（如果您给第二个分区分配最后一个硬盘盘符，把所有的盘符按顺序排列好，并且重装一次系统，您就会理解什么叫作“头疼”了：）</p><p>而在Linux中，分区是这样表示的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/hda        /dev/hda1      /dev/hda2       /dev/hda5/      dev/sdb1</span><br></pre></td></tr></table></figure><p>以 /dev/hda5 为例:</p><p>因为在Linux中，每一个设备都是用 /dev/ 文件夹下的一个文件来表示，所以 /dev/hda5 中， /dev/ 表示的是根目录下的dev目录，我们来看剩下的部分 hda5 。</p><p>前两位的字母 hd 表示这是一块IDE硬盘，如果是 sd ，则代表SATA硬盘，或者闪存等外设。</p><p>第三位的字母 a 表示这是该类型接口上的第一个设备。同理， b、c、d…… 分别代表该类型接口上的第二三四……个设备。例如 hdc 表示第二个IDE接口上的主硬盘（每个IDE接口上允许一个主设备和一个从设备）。</p><p>第四位的数字 5，并不表示这是该硬盘中的第5个分区，而是第一个逻辑分区。因为在Linux中，为了避免不必要的混乱，分区的顺序是不能改变的，分区标识则由它们在硬盘中的位置决定。系统又要为所有可能的主分区预留标识，所以 1-4 一定不会是逻辑分区， 5 则是第一个逻辑分区，以此类推。</p><h3 id="安装中的注意事项"><a class="header-anchor" href="#安装中的注意事项">¶</a>安装中的注意事项</h3><p>在Ubuntu系统的安装过程中，您需要选择系统目录的挂载点。</p><p>我们知道，安装Windows时，我们可以选择把系统安装在哪一个分区，把系统挂载到分区上。而在ubuntu/Linux中则相反，我们要把分区挂载到系统中。当我们使用Windows的安装方式，把系统挂载到分区上，我们就不可能把Windows目录放在C盘，而把<code>MyDocuments</code>目录放到其它分区。您或者出于习惯，或者出于数据安全方面的考虑，通常把文档放到其它分区中。但是Windows下很多软件保存文件的默认目录就是<code>MyDocument</code>目录，这就比较不方便。</p><p>在系统安装完成后，我们还是可以将<code>MyDocuments</code>目录转移到其它分区中，不过有点麻烦，可能许多朋友还不知道怎么去作……而任何一种Linux系统时，当然包括<code>Ubuntu</code>，我们可以在系统安装时就把分区挂载到目录下， <code>/home</code> 目录相当于Windows的<code>MyDocuments</code> ，我们可以把 <code>/dev/hda5</code> 挂载到此目录下，这样我们往 <code>/home</code>目录里存东西的时候，其实保存在第一个扩展分区中。如果再一次安装系统，只要把这个分区挂载到 <code>/home</code>目录下，那么进入新系统就像回家一样，真是太棒了。</p><p>理论上来讲，您可以将分区挂载到任何目录下面，您可以自定义挂载的路径。但是我们并不推荐您这么作，因为那没有任何意义。系统安装程序向您建议的挂载目录，通常也是我们向您建议的，现在我们来了解一下，这些目录通常都是用来作什么的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/    根目录，唯一必须挂载的目录。不要有任何的犹豫，选一个分区，挂载它！（在绝大多数情况下，有2G的容量应该是够用了。当然了，很多东西都是多多益善的：）</span><br><span class="line"></span><br><span class="line">Swap     交换分区，可能不是必须的，不过按照传统，并且照顾到您的安全感，还是挂载它吧。它的容量只要大于您的物理内存就可以了，如果超过了您物理内存两倍的容量，那绝对是一种浪费。</span><br><span class="line"></span><br><span class="line">/home    前面已经介绍过了，这是您的家目录，通常您自己创建的文件，都保存在这里，您最好给它分配一个分区</span><br><span class="line"></span><br><span class="line">/usr  应用程序目录。大部分的软件都安装在这里。如果您计划安装许多软件，建议您也给它分配一个分区</span><br><span class="line"></span><br><span class="line">/var      如果您要作一些服务器方面的应用，可以考虑给它分配一个较大的分区</span><br><span class="line"></span><br><span class="line">/boot     如果您的硬盘不支持LBA模式（我想那不太可能:），您最好挂载它，如果挂载硬盘的第一个分区，应该比较稳妥。一般来说，挂载的分区只要100M大小就足够了</span><br></pre></td></tr></table></figure><p>在文件系统这一环节中，我们建议您选择： <code>ReiserFS</code></p><p>也许您注意到了，Windows中，盘符既用于表示硬件（硬盘上的分区）,又用于表示系统中的路径。而Linux中，硬件就是硬件，路径就是路径，不会混淆在一起，简单直接！</p><h2 id="Linux基础"><a class="header-anchor" href="#Linux基础">¶</a>Linux基础</h2><h3 id="Shell"><a class="header-anchor" href="#Shell">¶</a>Shell</h3><p>可能您早已能够熟练的使用GUI（图形用户界面），例如您可以使用鼠标双击一个图标，来打开或者执行它。</p><p>我们来看这个过程: 您使用鼠标定位桌面上的一个程序图标，按下左键两次。系统读取鼠标指针的位置，并且判断该位置下图标的涵义，根据预设的双击动作，运行程序或者打开文件。</p><p>这一套GUI系统，便是一种Shell，它的作用是实现人机交互。如果我们不能够控制电脑，那么电脑还不如电视机好玩，不是么？电视机也可以选择频道（电视机的遥控器，也是一种人机交互的界面，不过相对于电脑，确实是相当简单了：）</p><p>易于上手、界面直观是GUI的优点，但是GUI为不意味着简单！或许您有类似经历: 桌面上有几十个程序的启动图标，也知道它们的名字，但是翻出一个来，并不是一件轻松的事情。</p><p>我的Windows系统中，桌面上摆满了各种图标，每当启动一个程序的时候，我都很是困扰。后来尝试了 音速启动 这类的程序启动管理器，效果还是差强人意。</p><p>在我的不懈努力下，这个难道最终得到了解决： 将快捷方式名称简化，放到特定目录下，使用 Win+R 组合键呼出 运行对话框，键入快捷方式的名称来运行该程序。比如 反恐精英 的快捷方式为 cs ，我把它放在 Windows 目录下; 运行 cs命令，就可以去维护世界和平了。</p><p>这么多快捷方式，统统放到 Windows 目录下，非常混乱。因此，我在D盘建立了一个名为 path的目录，并把它的路径加入到环境变量的 path 项中，快捷方式放在 <code>D:\path</code>目录中。即便重装系统，只要在环境变量中重新加入此路径，原来的程序大多可以直接以命令来运行……我的许多朋友强烈要示我帮他们设定这种启动方式，因为这确实很方便：）</p><p>其实在Linux下，所有的程序都可以通过命令运行。虽然Linux也有GUI，但是它并不比Windows的GUI更优秀！上面只是简单的介绍了CLI（命令行界面）相对GUI的优越之处，使用CLI还有更多的好处，您会慢慢体会到的。</p><p>当然了，在您的印象中，CLI一定非常的不友善，缺少亲和力，冷漠而拒人于千里之外……您和CLI之间甚至有代沟的存在：）</p><h4 id="命令"><a class="header-anchor" href="#命令">¶</a>命令</h4><p>坦白的说，冷不丁见到那么老长的一串命令，谁都会毛骨悚然。</p><p>也许您使用过DOS，留下这种印象：命令先放一边，光是正确的输入目录、文件名都够瞧的。而且DOS不区分大小写，要是像Linux一样区分大小写，那多恐怖啊！！！</p><p>其实Linux命令行具有补全功能，非常实用。假设有这样一个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> path/file</span><br></pre></td></tr></table></figure><p>如果只有一个以 c 起始的命令，键入 c ，再按一次 tab 键，系统将自动补全该命令余下的部分。 只要 c tab 两次按键，就可以完成 command 的输入。</p><p>如果不只一个 c 起始的命令，那么您可以按两次 tab 键，系统会列出所有符合条件的选项，也就是以 c 起始的所有命令。进一步输入 o ，如果只有一个以 co 起始的命令（一直输入，直到项符合条件的选项唯一），再按一次 tab ，命令就被补全完整。</p><p>路径和文件名也可以通过 tab 键来补全。还有一种 遍历补全 的方式，如果您的文件名是中文，而您不想切换输入法；甚至您的文件名中出现乱码，无法输入，这时 遍历补全 就可以大显身手了。这部分内容我们稍后再谈：）</p><p>现在我们来了解命令的语法结构，这一部分相当重要，您可得看仔细。</p><p>我们知道，任何语言都有特定的语法结构，以我们的中文为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们郑重地推荐您Ubuntu/Linux！</span><br></pre></td></tr></table></figure><p>这个句子的语法尽管简单，却是大部分的命令行采用的句型。让我们看一下，这个句子里都有些什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们</span><br></pre></td></tr></table></figure><p>主语，Linux命令的执行者只有一个，所以主语一概省略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">推荐</span><br></pre></td></tr></table></figure><p>一个动词，作为谓语而存在。Linux命令中，这一部分是必须的。这一部分也是不同命令之间最根本的区别方式，所以它通常作为命令名，写在最前面。键入 date 命令，您可以查看当前的时间日期。（ 应用程序-&gt;附件-&gt;终端 ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">郑重的</span><br></pre></td></tr></table></figure><p>状语，用来修饰谓语。与之相对应，Linux命令可以使用参数来精细调节程序的行为。为了与命令的操作对象相区别，参数前通常要加 - 或者 -- 符号。原则上，在命令名之后，参数的位置可以随意，但是为了养成一个良好的习惯，我们建议您在命令名后直接跟参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">您 Ubuntu/linux</span><br></pre></td></tr></table></figure><p>这两个部分都是宾语，它们是命令的操作对象。大部分的命令只有一个操作对象，也有一些命令是双宾语结构的，具有一个直接宾语和一个间接宾语。比如 拷贝 这个命令 cp (copy)</p><h4 id="分隔符"><a class="header-anchor" href="#分隔符">¶</a>分隔符</h4><p>我们的汉语是象形文字，没有分隔符。但是所有的拼音文字中都有分隔符，来分隔单词。Linux命令中同样使用空格作分隔符。</p><p>cp a /home 表示把当前目录下的 a 文件，拷贝到 /home 目录下。（命令的不同部分使用空格分隔，连续的空格视为一个空格）</p><p>上面的那句话，翻译成Linux的命令，应该是这个样子的：</p><p>推荐 --郑重的 您 Ubuntu/Linux （按照传统，“-”后跟简写为单个字母的参数，“--”后跟完整单词的参数。不过也有例外：）</p><p>哈，Linux的命令也蛮简单吧？</p><h3 id="Linux程序、进程"><a class="header-anchor" href="#Linux程序、进程">¶</a>Linux程序、进程</h3><p>或许您会这样想，Linux命令的句型确实不难，但是那么多命令，我怎么知道它们都是作什么的呢？而且不同的系统中，可以使用的命令似乎也不太一样，这真让人困惑……</p><p>其实Linux的命令，运行的是Linux系统中的程序。只要您已安装了程序，您就可以通过命令来运行它，并且可以使用参数来精细的调整它的运行状态。也可以通过点击启动图标来运行，不过启动图标不能够方便的调整参数，并不是很方便。</p><p>举一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplayer -shuffle -loop 3 -playlist mymp3.list</span><br></pre></td></tr></table></figure><p>可能您运行上面命令，系统会提示您 无法找到命令，那是因为您没有安装mplayer这个程序。mplayer是我见过的支持格式最多的播放器，几乎任何已知格式的多媒体文件，都可以使用mplayer来播放。它包含一个图形界面的前端，您可以在菜单中找到它，鼠标点击运行;也可以通过执行命令来运行它的命令行版本。</p><p>如果您的系统中没有mplayer播放器，我们建议您安装一个。关于程序的安装，请参阅 软件安装 。</p><p>上面命令中， mplayer 调用了mplayer播放器程序。参数 -shuffle 表示随机播放， -loop 表示循环播放，后面的3 为循环的次数，如果为 0 ,则一直播放。 -playlist 表示播放列表中的曲目。我们可以把mp3的路径放到 mymp3.list文件中，让mplayer来播放它们。</p><p><strong>进程</strong> 为运行中的程序，是程序在内存中的镜像。</p><p>好了，现在您已经了解了 Shell 、 命令 、 程序 、 进程 的概念，您基本上也就了解了Linux（Linux系统真是非常简洁，而且容易理解：）。</p><p>但只知道这些，您并不能顺畅使用。接下来的章节中，我们来进一步介绍它的细节。</p><h2 id="Linux系统简介"><a class="header-anchor" href="#Linux系统简介">¶</a>Linux系统简介</h2><h3 id="路径"><a class="header-anchor" href="#路径">¶</a>路径</h3><p>路径分为绝对路径和相对路径。</p><p><strong>绝对路径</strong>的起始点为根目录 <code>/</code> ，例如 <code>/usr/local/bin</code> 就是绝对路径，它指向系统中一个绝对的位置，不受其它因素影响。</p><p><strong>相对路径</strong>的起始点为当前目录，如果您现在位于 /usr 目录，那么相对路径 local/bin 所指示的位置为 <code>/usr/local/bin</code></p><p>也就是说，相对路径所指示的位置，除了相对路径本身，还受到当前位置的影响。例如Linux系统中常见的目录 <code>/bin</code> 、 <code>/usr/bin</code>、 <code>/usr/local/bin</code>，如果只有一个相对路径 bin，那么它指示的位置可能上面三个目录中的任意一个，也可能是其它目录。</p><p>如果我告诉您到 <code>bin</code> 目录寻找一个文件，您可能搞不清楚是哪一个 <code>bin</code> 目录。只有当前位置确定，相对路径指示的位置才能够确定。</p><p>现在我说， <code>/usr/local</code> 目录下，它的相对路径 <code>bin</code> 中有某个文件，这样就比较明确了。</p><p>在相对路径中 . 表示当前目录， .. 表示当前目录的上一级目录。</p><p>假设您安装了一个程序，它的主程序没有被放置到上面三个 bin 目录中的任何一个，或者其它系统能够找到的地方，您就得告诉系统，它的可执行文件在哪里。</p><blockquote><p>可以使用绝对路径，例如： <code>/home/user/bin/</code>可执行文件</p></blockquote><p>或者定位到 <code>/home/user/bin</code> 目录，使用相对目录来定位它 ./可执行文件</p><p>如果您定位到了它的子目录，比如 <code>/home/user/bin/gui</code>，您可以使用 <code>..</code> 来表示它的上级目录 <code>../</code>可执行文件</p><p>路径相关命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> (change directory) 更改目录。</span><br><span class="line"><span class="built_in">pwd</span> (<span class="built_in">print</span> working directory)显示当前路径。</span><br><span class="line">ls (list) 显示当前目录中的文件列表。</span><br></pre></td></tr></table></figure><p>请尝试以下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc 进入“/etc”目录，这里使用的是绝对路径</span><br><span class="line"></span><br><span class="line"><span class="built_in">pwd</span> 显示当前路径，这个命令返回结果“/etc”</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> init.d 进入“/etc”目录的子目录“init.d”，这里使用的是相对路径</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> .. 进入上一级目录“/etc”</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ../home “/etc” 目录的上一级目录为“/”，它的子目录“home”为“/home”</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> - 回到上一次的目录，我们在“/etc”目录跳转到“/home”目录，所以这次是回到“/etc”目录</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~ “~”代表当前用户的“<span class="variable">$HOME</span>”目录，也就是“/home/&#123;用户名&#125;”目录。</span><br><span class="line"></span><br><span class="line">ls 在任何时候，您都可以使用“ls”命令，来了解当前目录下都有哪些文件。</span><br></pre></td></tr></table></figure><p>远程路径：</p><p>远程路径的表示方法为 <code>协议://用户名:密码@位置/路径:端口</code></p><p>大多数的远程路径可以使用默认端口匿名访问，由此用户名、密码、端口通常不需要填写。例如：</p><p><code>http://www.ubuntu.org.cn/.../index.html</code></p><p>要求身份验证的远程路径，您可以使用下面的方式访问:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp://user:passwd@ftp.ubuntu.org.cn:21</span><br></pre></td></tr></table></figure><h3 id="软件"><a class="header-anchor" href="#软件">¶</a>软件</h3><p>Linux中没有***注册表***这个概念。安装软件，理论上讲，只要拷贝所有相关文件，并运行它的主程序就可以了。</p><p>按照传统，一个软件通常分别拷贝到同级目录下的 bin、etc、lib、share等文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Bin      可执行文件，程序的可执行文件通常在这个目录下。在环境变量中设定搜索路径，就可以直接执行，而不需要定位其路径。</span><br><span class="line"></span><br><span class="line">Etc       配置文件，大部分系统程序的配置文件保存于 /etc 目录，便于集中修改。</span><br><span class="line"></span><br><span class="line">Lib      库文件，集中在一起，方便共享给不同程序。相较不同的软件单独保存库文件，能够节约一些磁盘空间。</span><br><span class="line"></span><br><span class="line">Share    程序运行所需要的其它资源，例如图标、文本。这部分文件是专有的，不需要共享；而且目录结构相对复杂，混放在一起比较混乱，所以单独存放。</span><br></pre></td></tr></table></figure><p>还有一些软件，占用一个单独的目录，所有的资源都在这个目录中。类似于Windows下的绿色软件，不推荐在Linux系统下这样作。</p><ul><li><p>执行时，系统找不到可执行文件（搜索所有路径，资源开销过大，是不现实的），需要定位其位置，像这样 /home/user/bin/可执行文件 ，不够方便。</p></li><li><p>许多系统软件需要协作运行，配置文件分别保存，定位它们非常麻烦</p></li><li><p>如果程序使用的库文件，像图形库文件，都单独存放，那么磁盘空间的浪费会非常严重。</p></li></ul><p>有一些大型软件，或者您布署的重要应用，您可以将它们单独安装在一个文件夹下。（通常源码安装支持这种方式，将在 <a href="#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85">软件安装</a> 部分介绍）</p><h4 id="配置方式"><a class="header-anchor" href="#配置方式">¶</a>配置方式</h4><p>Linux下没有类似 注册表 的系统，系统和软件都可以通过纯文本的配置文件进行设置。</p><p>事实上，图形界面的配置工具，通常就是以图形界面的方式修改配置文件，适合设置一些比较简单的程序。如果软件有几千个可以配置的选项，全部作成菜单，想象一下……开始发抖吧……</p><p>图形界面的配置工具，可以看作特定配置文件专用编辑器。您一样可以使用通用文本编辑器来编辑配置文件，比如 Nano、Gedit、Knote、Vim或者Emacs等等。不考虑阅读、修改配置文本占用的时间，直接修改配置文件甚至更迅速。</p><p>如果只是要修改某一常用选项，而且时常修改，比如主机的IP地址。使用文本编辑器，您要找到相应的配置文件，还要在配置文件中找到相应的选项，会浪费掉您的时间和耐性。</p><p>图形配置工具经常会受各种因素制约，比如网络服务器中不提供图形服务，图形界面不够稳定……这时，您可以使用命令行的配置工具来完成这些工作。</p><p>例如： 修改主机IP地址，可以使用ifconfig这个程序，执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.0.1</span><br></pre></td></tr></table></figure><p>在以后的章节中，如果我们提示您修改某一文件，例如 /etc/fstab ，您可以使用任何顺手的文本编辑器打开它。</p><h3 id="隐藏文件"><a class="header-anchor" href="#隐藏文件">¶</a>隐藏文件</h3><p>Linux下，名称中第一个字符为 . 的文件或者文件夹，系统默认情况下将它们隐藏起来，</p><p>您可以尝试以下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ 进入您的用户目录</span><br><span class="line">ls 查看当前目录下的文件列表</span><br><span class="line">ls -a 查看所有文件的文件列表（包括隐藏文件）。</span><br></pre></td></tr></table></figure><p>现在，您可以看到许多文件名以 . 起始的文件或者文件夹了吧？使用 ls 命令无法显示它们</p><ul><li><p>如果您只想查看隐藏文件，而不包括这两个特殊目录，您可以使用 ls 命令的参数 -A （ls -A）</p></li><li><p>每个目录下都包含两个特殊目录 . 和 .. 。您也许猜到了， . 代表当前目录， .. 代表上一级目录。目录是一种特殊类型的文件！</p></li></ul><p>文件类型</p><p>Linux系统主要根据文件头信息来判断文件类型，扩展名并非决定因素。</p><p>现在使用 ls -l 命令，查看详细信息格式的文件列表，您将会看到如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total 5</span><br><span class="line">drwxr-x--- 4 user group 4096 Mar 10 00:37 filename</span><br><span class="line">drwxr-xr-x 21 user group 4096 Mar 10 20:16 文件名</span><br><span class="line">-rw------- 1 user group 524 Mar 10 00:40 a</span><br><span class="line">-rw-r--r-- 1 user group 24 Jun 11 2000 b</span><br><span class="line">drwx------ 2 user group 4096 Mar 9 11:06 c</span><br></pre></td></tr></table></figure><p>共显示了七列信息，从左至右依次为：权限、文件数、归属用户、归属群组、文件大小、创建日期、文件名称</p><p>其中要特别留意的是第一列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x</span><br></pre></td></tr></table></figure><p>一共有10个位置，可以分为4组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d    rwx  r-x  r-x</span><br></pre></td></tr></table></figure><p>第一组只有一个字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">** d* *文件夹*     ** -* *普通文件*        ** l* *链接*       ** b* *块设备文件*     ** c* *字符设备文件。*</span><br></pre></td></tr></table></figure><p>剩下的3组分别为归属用户、归属群组、其它用户或群组对于该文件的权限。我们看它的格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rwx rwx  rwx</span><br><span class="line"></span><br><span class="line">** r* *可读*       ** w* *可写*      ** x* *可执行*</span><br></pre></td></tr></table></figure><p>它们的顺便不能颠倒，某一位置为空(-)，则表示不具有相应的权限。</p><p>说明：Linux下的可执行文件并不是由扩展名（例如 .exe ）决定的，而是由其可执行权限位决定。</p><p>权限</p><p>我们已经知道了，文件的权限分为 <code>r</code> （可读）、 <code>w</code> （可写）、 <code>x </code>（可执行）三种类型，而一个文件可以针对归属用户，归属群组，其它用户用户或群组分别设定权限。</p><p>这种权限管理的方式灵活、简单、严密、明晰。尽管如此，在最初的阶段，可能会有一点小小的不适。因为它无所不在，而您习惯了的Windows的权限管理却不是这样（非常混乱，大多数时间形同虚设，偶尔用到却让人伤透脑筋）。</p><p>使用 <code>chmod</code> 命令更改文件的权限，使用 <code>chown</code> 来更改文件的归属。例如：</p><p>chmod 755 xxx</p><p>chmod a+x xxx</p><p>chown user:group xxx 用来更改文件的归属用户，也可以同时更改其归属群组</p><p>chgrp group xxx 用来更改文件的归属群组</p><p>上面命令中的 755 和 a+x 是两种类型的表达式</p><p>我们将后面章节中详细介绍 权限管理 用户管理</p><p>执行命令的权限</p><p>有一些命令，普通用户也可以执行，但是只有root用户才能执行成功，这是为什么呢？</p><p>例如在系统中增加一个新用户 useradd</p><p>ls -l /usr/sbin/useradd</p><p>可以看到：</p><p>-rwxr-xr-x 1 root root 56156 2006-04-03 21:37 /usr/sbin/useradd</p><p>明明所有的用户都可以执行嘛？</p><p>这是因为， useradd 命令是修改 /etc/passwd 文件的一个工具，来看看这个文件：</p><p>ls -l /etc/passwd</p><p>-rw-r--r-- 1 root root 1835 2006-06-24 17:58 /etc/passwd</p><p>原来只有root用户才能写入修改结果，非root用户执行 useradd 命令当然不会有结果。</p><p>执行命令的身份</p><p>默认情况下，您的命令提示符末位为 $ ，这表示您将以普通用户的身份执行命令。</p><p>您可以使用 su （switch user）这个命令来切换其它用户。</p><p>例如 su root ，切换到root用户，如果 su 命令后面没有切换目标，那么这个命令默认切换到root用户。</p><p>现在您执行 su 这个命令，系统会提示您输入密码，请输入管理员的密码。这个时候，您会发现命令提示符末位变成了 # ，您将以root用户的身份执行命令。</p><p>Ubuntu系统默认会随机设定系统的root密码，这样会更安全一些，这个时候您可以执行“sudo”命令，输入当前用户密码后，暂时以root</p><p>用户的身份执行命令。（前提是sudoer列表中要包含您的ID。您在安装Ubuntu系统时创建的用户，默认具有“sudo”权限）</p><p>如果您能够执行“sudo”命令，那么您也就拥有了root权限。在后面的章节中，如果我们提到了“root权限”，那么您可以通过以上两种方式来实现</p><h3 id="命令行"><a class="header-anchor" href="#命令行">¶</a>命令行</h3><p>Shell、Console、Terminal</p><p>在前面的章节中，我们曾提到，电视机的遥控器，也是一种人机交互的界面，算是一种Shell。</p><p>但是这个概念并不准确，遥控器只是向Shell发送指令的工具，Shell接收到遥控器发出指令后，将指令转换为系统命令，由系统来执行。</p><p>例如我们按的遥控器上的 数字键1 ,遥控器将 切换为1频道 的指令发送到Shell，Shell将指令转换为系统可以识别的 频道1 ，系统执行它，您就可以观看1频道的电视节目了。</p><p>通常每台电视机只有一种Shell，比如有的电视机系统具有“画中画”的功能，那么Shell中便有相应的功能定义，您可以通过遥控器上的“画中画”功能键来开启它。假设您的电视机没有此功能，Shell中也就没有相应的功能定义。拥有一个带“画中画”功能控制键的遥控器，即便信号兼容，您还是不能够使用这一功能：）</p><p>不用遥控器也可以控制电视机，假设您的遥控器丢了，您还可以走到电视机前，使用机身上的控制面板来控制它（相当于使用Linux的控制台）。但是您一定不喜欢这种方式，除非您想锻炼身体：）</p><p>在Linux系统中，由于图形界面和控制台的分辨率通常不一致，所以切换时要有一个延时。对于我们中文用户来讲，控制台下中文的显示也比较麻烦。而且控制台显示内容通常不如终端显示的全面。</p><p>所以我们推荐您使用终端来执行命令，它使用起来感觉很像遥控器：）</p><p>rxvt-unicode</p><p>通常情况下，您买一台电视机，只能获得一个遥控器。虽然它为您的电视机量身定作，能够最大限度发挥电视机的能力，但您却不一定喜欢它。说不定这个遥控器体形太大，持握不方便;或者它体形太小，容易失踪;又或者它的按键要么太硬，要么太软;它的键盘要么太大，要么太小……您一般也可以容忍，毕竟遥控器使用频率并不算高：）</p><p>如果您的终端有些地方不讨您喜欢，比如说响应太慢，或者不能正常显示中文……那就难以忍受了，您应该换一个其它的试试。</p><p>在前面的章节，我们介绍您使用的终端为Gnome-Termianl，它是系统默认使用的终端，显示中文不错，不过响应比较慢，您可能已经处于水深火热之中了。。。</p><p>我们推荐您使用urxvt（mlterm也是不错的选择）</p><p>您可以使用 <code>sudo apt-get install rxvt-unicode</code> 命令来安装它。</p><p>urxvt 启动它 （urxvt不支持控制台，您得在图形界面下启动它。终端、Alt+F2，建议您在启动栏里新建一个启动图标）</p><p>rxvt-unicode还支持“服务器/客户端”的运行模式：</p><p>urxvtd 启动一个守护进程daemon（支持控制台）</p><p>urxvtc 启动客户端client。多个客户端可以同时连接到一个urxvtd，以达到节省系统资源的目的。</p><p>或许您对rxvt的默认设置不满意，您可以修改用户配置文件 ~/.Xresources 来设定它。修改全局配置文件 /etc/X11/Xresources/Xresources ，则对所有用户生效，只有root才可以修改此文件。</p><p>这里有一些简单的选项：（以 ! 起始的行是注释，您可以直接拷贝此文件的内容）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">!!=============================================================================</span><br><span class="line">!! RXVT-unicode setting</span><br><span class="line">!!=============================================================================</span><br><span class="line">!设置字体分辨率</span><br><span class="line">Xft.dpi:96</span><br><span class="line"></span><br><span class="line">!窗口大小</span><br><span class="line">Rxvt.geometry: 80x40+80+80</span><br><span class="line"></span><br><span class="line">!颜色</span><br><span class="line">Rxvt.background:#333333</span><br><span class="line">Rxvt.foreground:antiquewhite</span><br><span class="line">Rxvt.inheritPixmap:False</span><br><span class="line">Rxvt.colorBD:yellow</span><br><span class="line">Rxvt.colorUL:antiquewhite</span><br><span class="line"></span><br><span class="line">!滚动条</span><br><span class="line">Rxvt.scrollBar:True</span><br><span class="line">Rxvt.scrollBar_left:True</span><br><span class="line">Rxvt.scrollBar_floating:False</span><br><span class="line">Rxvt.scrollstyle:next</span><br><span class="line">Rxvt.scrollColor:#999999</span><br><span class="line"></span><br><span class="line">!屏幕缓冲</span><br><span class="line">Rxvt.saveLines:30000</span><br><span class="line">Rxvt.color12:DodgerBlue</span><br><span class="line">Rxvt.font:7x14,xft:AR PL New Sung</span><br><span class="line"></span><br><span class="line">!输入法一般设置为xim</span><br><span class="line">!inputMethod:xim;Scim除外</span><br><span class="line">!输入法样式可选:Root(置底) OverTheSpot(跟随) OffTheSpot OnTheSpot，后两种不是所有的都支持</span><br><span class="line">Rxvt.preeditType:Root</span><br></pre></td></tr></table></figure><blockquote><p>Tip：右键点击启动栏， 添加自启动器 ， 自定义程序 ，便可以在添加自己的启动图标。</p></blockquote><h3 id="在线帮助系统"><a class="header-anchor" href="#在线帮助系统">¶</a>在线帮助系统</h3><p>您可以使用命令 man 或者 info 来阅读Linux命令的在线文档。命令的格式非常简单：</p><p>man xxx</p><p>大部分命令手册为英文版，如果您的英文不太好，或许有些困难。在后面的 系统管理 章节中，我们会尽力向您介绍命令的使用方法。</p><p>说明：在使用“man”浏览器的时候，一些快捷键您可能会用到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+f(orward) 向下翻一页 Ctrl+d(own) 向下翻半页</span><br><span class="line">Ctrl+b(ackward) 向上翻一页 Ctrl+u(p) 向上翻半页</span><br><span class="line">/ 查找 q(uit) 退出</span><br></pre></td></tr></table></figure><p>以上为VI风格的键绑定。您也可以使用Emacs风格的键绑定</p><h3 id="bash"><a class="header-anchor" href="#bash">¶</a>bash</h3><p>好了，现在我们换了一个遥控器，感觉顺手多了。现在来操练一下，下载一首mp3：</p><p>我们使用 wget 这个程序，它非常可靠，完全值得您信赖。</p><p>首先找到一个可以下载的地址，复制链接，在终端窗口内点击鼠标中键，把它粘贴进去。</p><p>现在终端中大概是这种情形：</p><p><a href="http://www.download.net/xxx.mp3" target="_blank" rel="noopener">http://www.download.net/xxx.mp3</a></p><p>按下 Ctrl+a 组合键，我们发现光标移动到了行首。输入 wget 和 空格</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.download.net/xxx.mp3</span><br></pre></td></tr></table></figure><p>回车后，终端中出现一些信息，不一会儿工夫，mp3便下载完成。</p><p>使用 Ctrl+a 组合键，我们就不需要使用方向键来移动光标，方向键每次只能移动一个字符，没有效率</p><p>您还可以使用 Ctrl+f 向前移动光标， Ctrl+b 向后移动光标， Ctrl+e 将光标移动到行末……………… （键绑定）</p><h3 id="Note"><a class="header-anchor" href="#Note">¶</a>Note</h3><p>Linux的图形界面中，鼠标中键通常执行“粘贴”的操作，如果您的鼠标没有中键，您可以左右键同时按下。</p><p>中止正在运行的程序</p><p>如果一个命令持续时间很长，以致于不能够进行其它操作，可以使用 Ctrl+c 来强行中止它。</p><p>Ctrl+s</p><p>出于意外，有时您会按下 Ctrl+s 这个组合键，Shell便被冻结。尝试使用 Ctrl+q 组合键，看能否恢复正常。</p><h3 id="键绑定"><a class="header-anchor" href="#键绑定">¶</a>键绑定</h3><p>等等，有必要记这么多快捷键么？都这么复杂！</p><p>我们强烈建议您记住，以大幅度的提高操作效率。而且这是readline控件的键绑定，在任何使用readline控件的程序中，您都可以使用它们。例如bash、lftp、gdb等程序;同时，Linux下最著名的Emacs编辑器，也是这种风格的键绑定（其实是readline使用了Emacs风格的键绑定才对），甚至FireFox中，也可以使用类似风格的快捷键！（Linux下主要有两种风格的键绑定，一种是VI风格，另一种是Emacs风格，我们会在 简明VIM教程中介绍）</p><p>现在列举一些ReadLine的键绑定，您可以自行尝试。（运行 man readline 命令，来查看ReadLine手册）</p><p>先来了解一些约定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">\C<span class="_">-a</span> 表示 Ctrl+a</span><br><span class="line">\M<span class="_">-a</span> 表示 Meta+a Meta键在PC中通常为ALT键</span><br><span class="line"></span><br><span class="line">A 表示 Shift+a</span><br><span class="line">（下面括号中的\A代表Alt，\S代表Shift）</span><br><span class="line"></span><br><span class="line">移动命令：</span><br><span class="line"></span><br><span class="line"> \C<span class="_">-a</span>  移动到行首  Aheah        \C<span class="_">-e</span>  移动到行末  End          \C<span class="_">-f</span>  向前移动一个字符  Forward </span><br><span class="line"></span><br><span class="line">*\C-b* *向后移动一个字符* *Backward        \M<span class="_">-f</span>* *向前移动一个单词*        *\M-b* *向后移动一个单词*</span><br><span class="line"></span><br><span class="line">*\C<span class="_">-l</span>* *清空屏幕* *cLear*      *这两个命令也可以理解为移动命令*        *\C-p* *上翻，前一条命令* *Previous*</span><br><span class="line"></span><br><span class="line">*\C-n* *下翻，后一条命令* *Next*        *编辑命令：*</span><br><span class="line"></span><br><span class="line">*\C<span class="_">-d</span>* *删除光标后的一个字符* *\M<span class="_">-d</span>* *删除光标后的一个单词* *Delete*</span><br><span class="line"></span><br><span class="line">*\BackSpace* *删除光标前的一个字符* *\M-BackSpace* *删除光标前的一个单词*</span><br><span class="line"></span><br><span class="line">*\C-k* *删除光标至行末的部分* *Kill         \C-u* *删除光标至行首的部分* *Unix-line-discard*</span><br><span class="line"></span><br><span class="line">*\C-w* *删除光标前的一个单词* *Word       \C-y* *粘贴（最后删除的对象）* *Yank      \C--* *撤消*</span><br><span class="line"></span><br><span class="line">搜索历史纪录：</span><br><span class="line"></span><br><span class="line">*\C-r* *连续使用* *``C-r``* *可以查找下一个*        *\M-p      \M-n*</span><br><span class="line"></span><br><span class="line">补全：</span><br><span class="line"></span><br><span class="line">*\Tab* *使用频率最高的功能！*        *\C-o* *遍历补全* *（未定义）*</span><br><span class="line"></span><br><span class="line">*\M-? M-=* *列出所有可能选项，相当于按两次**Tab**键（**M-**？* *实际按键为**\A+\S+/**）*</span><br><span class="line"></span><br><span class="line">*\M-<span class="comment">#* *注释掉当前命令，用于将当前命令暂存于历史纪录列表（**\A+\S+3**）*</span></span><br><span class="line"></span><br><span class="line">*\M-!* *补全命令，通常用来补全子命令，例如* *``sudo``* *的子命令（**\A+\S+1**）*</span><br><span class="line"></span><br><span class="line">*\M-~* *补全用户名（**\A+\S+`**）*       *\M-@* *补全主机名（**\A+\S+2**）*</span><br><span class="line"></span><br><span class="line">*\M-$* *补全变量（**\A+\S+4**）*         *\M-_* *补全历史纪录中的纪录（**\A+\S+-**）*</span><br><span class="line"></span><br><span class="line">*\M-** *将所有可能选项放到命令行中（**\A+\S+8**）*</span><br></pre></td></tr></table></figure><h4 id="自定义键绑定"><a class="header-anchor" href="#自定义键绑定">¶</a>自定义键绑定</h4><p>通过修改 <code>/etc/inputrc</code> 文件，可以更改键绑定。建议您使用默认的键绑定，以避免不必要的烦恼。当然了，Emacs风格的键绑定是通用的，随时都有可能用到。</p><p>在文件中添加该行，可以将ReadLine的键绑定设为VI风格。（Bash、Lftp等使用ReadLine的软件同时生效）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set editing-mode vi</span><br></pre></td></tr></table></figure><p>找到这一行：</p><p>$if mode=emacs</p><p>在它的下面添加如下内容</p><p>&quot;\C-o&quot;: menu-complete</p><p>###这两行不是必须的，视情况而定###</p><p>&quot;\c-p&quot;: non-incremental-reverse-search-history</p><p>&quot;\c-n&quot;: non-incremental-forward-search-history</p><p>重新登录Shell，您就可以使用 \C-o （Ctrl+o）来遍历补全。假如您的文件名为中文，或者出现乱码时，您可以使用 \M-*</p><p>将所有文件名放入命令行，再删除多余的，这真是麻烦极了！所以您可以使用 \C-o 遍历补全，将所有可能的选项轮流放入命令行。</p><p>或者使用Vim编辑器编辑 /etc/inputrc 文件，在插入模式下使用 Ctrl+v 组合键。按下 Ctrl+o ，这时编辑区新增一个 ^O 字符，等价于 \C-o</p><h3 id="通配符"><a class="header-anchor" href="#通配符">¶</a>通配符</h3><p>使用 <code>?</code> 代表任意单个字符。例如 <code>???lo</code> ，表示 <code>lo</code> 前有三个字符，它可以匹配 <code>Hello</code></p><p>使用 <code>*</code> 代表随意几个任意字符。例如<code>*.iso</code>，代表所有 <code>iso</code> 格式的文件。</p><p>说明：您可以将遍历补全和通配符结合使用，以提高效率。</p><p>例如：</p><p>cd */ 则遍历补全只补全文件夹</p><p>chmview *.chm 则遍历补全只补全chm文件</p><h3 id="任务管理"><a class="header-anchor" href="#任务管理">¶</a>任务管理</h3><p><code>&amp;</code> 在命令的末尾加上一个 <code>&amp;</code> 符号，表示背景任务，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.download.net/xxx/mp3 &amp;</span><br></pre></td></tr></table></figure><p><code>;</code> 使用 <code>;</code> 将多个命令连结起来，则表示任务按顺序执行</p><p><code>&amp;&amp;</code> 使用 <code>&amp;&amp;</code> 将多个命令连结起来，则表示只有前面的命令执行成功，后面的命令才能得以执行</p><p>`` `&lt;命令&gt;` ，如果一个命令中包含以 `` （Esc键下方的按键）括起来的子命令，那么子命令将被优先执行，执行结果被代入上一级命令继续执行，例如创建一个以当前时间命名的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch `date +%m.%d_%H:%M:%S`</span><br></pre></td></tr></table></figure><p><code>touch</code> 命令能够创建一个文件，它的操作对象，为 <code>date +%m%d%H%M%S 命令的输出 06.06_06:06:60</code></p><p>这样，我们创建了一个名为 <code>06.06_06:06:60</code> 的文件（六月六日六时六分刚过六十秒-_-!）</p><p>Ctrl+z</p><p>将当前Shell中的任务挂起</p><p>这个时候任务的状态为</p><p>[1]+ Stopped xxx</p><p>Bg-------------------------------------------------将挂起的任务背景运行。这时它的状态为[1]+ xxx &amp;</p><p>Fg-------------------------------------------------将背景任务调到前台执行jobs</p><p>方括号中的数字为命令的任务编号，您可以使用 jobs 命令来查看所有背景任务</p><p>如果后台运行多个任务，您可以在 bg 或者 fg 后跟任务编号，作为操作对象，例如：bg 2</p><p>管道、重定向</p><p>&gt;-----------------------重定向符号，它的作用是将命令的输出重定向到一个文件中。比如我们想把命令 ls 的结果保存为 FileList 文件，作一个清单，我们可以使用重定向符号来完成它：</p><p>ls -l &gt; FileList</p><p>&gt;&gt;----------------------作用与 &gt; 基本相同，不同点在于， &gt;&gt; 以追加的方式，将命令的输出写入文件的末尾。</p><p>&lt;-----------------------是从文件到命令的重定向，将文件的内容作为命令的输入。</p><p>|------------------------为管道符号，它的作用是将前一个命令的输出，作为下一个命令的输入。假设一个目录下的文件太多，使用 ls命令不能够在屏幕中完全显示，这个时候您可以将 ls 命令的输出，通过管道符号，作为浏览器 less 的输入。就可以使用浏览器的功能翻页、查找：ls -al | less</p><p>说明： less 浏览器的键绑定几乎与 man 相同，请参阅 在线帮助系统</p><h3 id="脱字符"><a class="header-anchor" href="#脱字符">¶</a>脱字符</h3><p>Shell中的一些功能是通过特殊符号作为控制字符来实现的，上面已经介绍了很多了。这产生一个问题，如果一个文件名中，刚好包含了这些字符，比如 ; ，就很难对它进行操作。使用 less 浏览这个文件</p><p>less ;xxx</p><p>less 会很快返回一个错误信息，因为并没有一个文件名作为操作对象。接着，Shell会报告，系统中没有 xxx 这个命令。</p><p>这是因为Shell将文件名中的 ; 解析为按顺序执行命令。</p><p>或者您的文件名以空白起始，而在Shell中，无论多少个空格，都将被解析为一个分隔符。您甚至不是使用命令重命名此文件。</p><p>这个时候就要用到脱字符 \ 了，它能够将一个具有特殊涵义的字符转换普通字符。上面的两个任务，可以在文件名中每个特殊字符前加一个 \ ，像这样</p><p>less ;xxx</p><p>less \ \xxx</p><p>less ;\ &amp;\xxx</p><p>说明：也可以使用 &quot; 将文件名括起来，例如 less &quot;; &amp;xxx&quot; ，在很多情况下，这样甚至更方便。</p><p>脱字符在Shell中也可以作为换行符，在一个命令的末尾添加一个 \ ，然后回车，在下一行继续输入命令剩余的部分，将一个命令拆分为多行且不影响它的执行（如果执行一个很长的命令，请将它拆分为多行以便于阅读）</p><p>事实上换行符也符合脱字符的定义。回车键有两个涵义，一个是 执行 （Enter），另一个 换行 （折线箭头）。在Shell中它作为控制字符 执行 ，使用脱字符后，它便代表排版字符 换行 了。</p><h3 id="Fish"><a class="header-anchor" href="#Fish">¶</a>Fish</h3><p>the friendly interactive shell</p><p>正如它的名字，Fish是一款非常友好的Shell，大力推荐！使用命令 sudo apt-get install fish 安装它。完成后，运行命令 fish 切换到fish， exit 返回bash。</p><p>简单介绍一下它的优点：</p><h4 id="1-自动补全、语法高亮"><a class="header-anchor" href="#1-自动补全、语法高亮">¶</a>1.自动补全、语法高亮</h4><p>bash的自动补全默认只是补全命令、路径，如果想补全变量、参数等，通常需要使用复杂的组合键（见上面bash的介绍），即便您能够记住它们，快</p><p>速准确的按下这些组合键，也是一种严峻的考验。而FISH的自动补全可以自动识别语法，补全正确的内容。并且具有语法高亮的功能，比如用MPLAYER放</p><p>MP3：</p><p>mpl<tab>(ayer) -l<tab>(oop) <tab>(0)</tab></tab></tab></p><p>-sh<tab>(uffle) -pl<tab>(aylist) <tab>(mp3_playlist)</tab></tab></tab></p><p>一阵猛按 <tab> 键，一个蛮长的命令就完成了。</tab></p><p>补全结果不唯一时给出的提示中含有简短的说明，这样通常也不用看帮助了：）比如：</p><p>mplayer -l</p><p><tab> 后，自动将参数补全为 -lo 然后给出提示</tab></p><p>-{lo}adidx (Load index from file) -{lo}op (Loop playback) {花括号中为青色文字}</p><p>它的语法高亮功能十分有用，如果你输入的命令是正确的，则用青色显示，正确的参数用白色显示，错误的则一律用红色。</p><h4 id="2-方便的历史纪录搜索"><a class="header-anchor" href="#2-方便的历史纪录搜索">¶</a>2.方便的历史纪录搜索</h4><p>还是上面的那个命令</p><p>mplayer -loop 0 -shuffle -playlist mp3_playlist</p><p>用上翻配合下翻浏览命令历史，直到找到这个命令，当然那样太慢了。</p><p>还可以输入以上命令中的某一部分，如 uffle 只要翻一次就可以找到了</p><p>（还可以META＋上翻在已输入部分中插入某一历史单词）</p><h4 id="3-文件夹历史纪录"><a class="header-anchor" href="#3-文件夹历史纪录">¶</a>3.文件夹历史纪录</h4><p>dirh （dir history）就可以显示当前会话中进入的文件夹纪录</p><p>使用 prevd 和 nextd 跳转</p><p>假如曾进入过1 2 3 4 5 这几个文件夹， prevd 4 可以让你在 5 中直接跳到 1</p><h4 id="4-其它的功能"><a class="header-anchor" href="#4-其它的功能">¶</a>4.其它的功能</h4><p>fish基本是兼容bash的。键绑定也非常的相似，少数的键绑定不尽一致，例如：</p><p>\C-h 删除光标前的一个字符（bash为退格键，不方便）</p><p>修改 /etc/fish_inputrc 这个文件，增加以下行：</p><p>&quot;\C-n&quot;: history-search-forward</p><p>&quot;\C-p&quot;: history-search-backward</p><p>现在使用Ctrl+p上翻，使用Ctrl+n下翻。如果已经在命令行中输入字符，那么Ctrl+p就是在历史纪录向上查找您输入的字符，Ctrl+n为向下查找，非常的方便。</p><p>设定您的默认Shell</p><p>如果能够拥有root权限，可以直接修改 /etc/passwd 文件。找到您用户ID起始的行</p><p>user:x:1000:112:user,,,:/home/user:/bin/bash</p><p>最后一个字段为登录后的默认Shell， /bin/bash 是程序 bash 的主程序路径。 fish 主程序的路径通常为 /usr/bin/fish 。</p><p>/etc/shells 中列出系统中所有可用Shell（ /bin/false 代表禁用Shell）</p><p>也可以使用如下命令更改您的默认Shell</p><p>chsh -s /usr/bin/fish</p><p>（需要输入您的密码）</p><p>Tip：可以使用 whereis xxx 命令，来查找 xxx 程序的安装位置，详见搜索</p><p>设定命令的搜索路径</p><p>使用 echo $PATH ，可以显示 $PATH 变量，输出如下：</p><p>/usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin /usr/bin/X11 /usr/games /usr/X11R6/bin</p><p>它是一个环境变量，代表执行命令时，Shell的搜索路径。</p><p>执行一个命令时，Shell会到 $PATH 变量定义的路径去搜索，并运行与命令同名的可执行文件。如果程序、脚本等可执行文件并不在上面的路径中，就必须使用绝对路径或者相对路径定位可执行文件。</p><p>例如：</p><p>/usr/local/mplayer -menu xxx.rmvb</p><p>/etc/init.d/powernowd start</p><p>cd /usr/local/ &amp;&amp; ./mplayer -menu xxx.rmvb</p><p>可以修改 /etc/environment 文件来设定您的命令搜索路径，找到 PATH 起始的行</p><p>PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin&quot;</p><p>在双引号中添加您的自定义路径，并以 : 分隔。</p><h2 id="Ubuntu系统简介"><a class="header-anchor" href="#Ubuntu系统简介">¶</a>Ubuntu系统简介</h2><h3 id="Ubuntu系统目录结构"><a class="header-anchor" href="#Ubuntu系统目录结构">¶</a>Ubuntu系统目录结构</h3><p>以下为Ubuntu目录的主要目录结构，您稍微了解它们都包含了哪些文件就可以了，不需要记忆。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/ 根目录</span><br><span class="line">│</span><br><span class="line">├boot/ 启动文件。所有与系统启动有关的文件都保存在这里</span><br><span class="line">│ └grub/ Grub引导器相关的文件</span><br><span class="line">│</span><br><span class="line">├dev/ 设备文件</span><br><span class="line">├proc/ 内核与进程镜像</span><br><span class="line">│</span><br><span class="line">├mnt/ 临时挂载</span><br><span class="line">├media/ 挂载媒体设备</span><br><span class="line">│</span><br><span class="line">├root/ root用户的<span class="variable">$HOME</span>目录</span><br><span class="line">├home/</span><br><span class="line">│ ├user/ 普通用户的<span class="variable">$HOME</span>目录</span><br><span class="line">│ └.../</span><br><span class="line">│</span><br><span class="line">├bin/ 系统程序</span><br><span class="line">├sbin/ 管理员系统程序</span><br><span class="line">├lib/ 系统程序库文件</span><br><span class="line">├etc/ 系统程序和大部分应用程序的全局配置文件</span><br><span class="line">│ ├init.d/ SystemV风格的启动脚本</span><br><span class="line">│ ├rcX.d/ 启动脚本的链接，定义运行级别</span><br><span class="line">│ ├network/ 网络配置文件</span><br><span class="line">│ ├X11/ 图形界面配置文件</span><br><span class="line">├usr/</span><br><span class="line">│ ├bin/ 应用程序</span><br><span class="line">│ ├sbin/ 管理员应用程序</span><br><span class="line">│ ├lib/ 应用程序库文件</span><br><span class="line">│ ├share/ 应用程序资源文件</span><br><span class="line">│ ├src/ 应用程序源代码</span><br><span class="line">│ ├<span class="built_in">local</span>/</span><br><span class="line">│ │ ├soft/ 用户程序</span><br><span class="line">│ │ └.../ 通常使用单独文件夹</span><br><span class="line">│ ├X11R6/ 图形界面系统</span><br><span class="line">│</span><br><span class="line">├var/ 动态数据</span><br><span class="line">│</span><br><span class="line">├temp/ 临时文件</span><br><span class="line">├lost+found/ 磁盘修复文件</span><br></pre></td></tr></table></figure><h3 id="启动流程"><a class="header-anchor" href="#启动流程">¶</a>启动流程</h3><p>Linux系统主要通过以下步骤启动：</p><h4 id="1-读取MBR的信息，启动Boot-Manager"><a class="header-anchor" href="#1-读取MBR的信息，启动Boot-Manager">¶</a>1.读取MBR的信息，启动Boot Manager</h4><p>Windows使用NTLDR作为Boot</p><p>Manager，如果您的系统中安装多个版本的Windows，您就需要在NTLDR中选择您要进入的系统。</p><p>Linux通常使用功能强大，配置灵活的GRUB作为Boot Manager，我们将在启动管理章节中向您介绍它的使用方式。</p><h4 id="2-加载系统内核，启动init进程"><a class="header-anchor" href="#2-加载系统内核，启动init进程">¶</a>2.加载系统内核，启动init进程</h4><p>init进程是Linux的根进程，所有的系统进程都是它的子进程。</p><h4 id="3-init进程读取-etc-inittab文件中的信息，并进入预设的运行级别，按顺序运行该运行级别对应文件夹下的脚本。脚本通常以-start-参数启动，并指向一个系统中的程序。"><a class="header-anchor" href="#3-init进程读取-etc-inittab文件中的信息，并进入预设的运行级别，按顺序运行该运行级别对应文件夹下的脚本。脚本通常以-start-参数启动，并指向一个系统中的程序。">¶</a>3.init进程读取 /etc/inittab文件中的信息，并进入预设的运行级别，按顺序运行该运行级别对应文件夹下的脚本。脚本通常以 start 参数启动，并指向一个系统中的程序。</h4><p>通常情况下， <code>/etc/rcS.d/</code> 目录下的启动脚本首先被执行，然后是 <code>/etc/rcN.d/</code> 目录。例如您设定的运行级别为<code>3</code>,那么它对应的启动目录为 <code>/etc/rc3.d/</code> 。</p><h4 id="4-根据-etc-rcS-d-文件夹中对应的脚本启动-Xwindow服务器-xorg"><a class="header-anchor" href="#4-根据-etc-rcS-d-文件夹中对应的脚本启动-Xwindow服务器-xorg">¶</a>4.根据 /etc/rcS.d/文件夹中对应的脚本启动 Xwindow服务器 xorg</h4><p>Xwindow为Linux下的图形用户界面系统。</p><h4 id="5-启动登录管理器，等待用户登录"><a class="header-anchor" href="#5-启动登录管理器，等待用户登录">¶</a>5.启动登录管理器，等待用户登录</h4><p>Ubuntu系统默认使用GDM作为登录管理器，您在登录管理器界面中输入用户名和密码后，便可以登录系统。（您可以在 <code>/etc/rc3.d/</code> 文件夹中找到一个名为 <code>S13gdm</code> 的链接）</p><h3 id="更改运行级别"><a class="header-anchor" href="#更改运行级别">¶</a>更改运行级别</h3><p>在 /etc/inittab 文件中找到如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The default runlevel.</span></span><br><span class="line">id:2:initdefault:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一行中的数字 2 ,为系统的运行级别，默认的运行级别涵义如下：</span></span><br><span class="line"><span class="comment"># 0 关机    1 单用户维护模式   2~5 多用户模式  6 重启</span></span><br></pre></td></tr></table></figure><h3 id="服务管理"><a class="header-anchor" href="#服务管理">¶</a>服务管理</h3><p>更改启动服务</p><p>在运行级别对应的文件夹中，您可以看到许多文件名以 <code>S##</code> 和 <code>K##</code> 起始的启动脚本链接。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/rcS.d/S35mountall.sh 挂载文件系统</span><br><span class="line">/etc/rcS.d/S40networking 启用网络支持</span><br><span class="line">/etc/rc2.d/S13gdm 启动登录管理器</span><br><span class="line">/etc/rc2.d/S20makedev 创建设备文件</span><br><span class="line">/etc/rc2.d/S23xinetd 启动超级进程</span><br></pre></td></tr></table></figure><p>init进程将以 start 为参数，按文件名顺序执行所有以 S## 起始的脚本。脚本名称中的数字越小，它将被越早执行。例如在</p><p>/etc/rc2.d/ 文件夹中， S13gdm 文件名中的数字小于 S23xinetd , S13gdm 将比 S23xinetd 先执行。</p><p>如果一个脚本链接，以 K## 起始，表示它将以 stop 参数被执行。如果相应服务没有启动，则不执行该脚本。例如：</p><p>/etc/rc2.d/K20powernowd 针对某种硬件的电源管理支持</p><p>如果您想禁止某一服务在启动时自动运行，您可以将相应运行级别中的脚本由 S##xxx 重命名为 K##xxx 。</p><p>手动控制服务</p><p>您也可以手动运行带有以下参数的启动脚本，来控制系统服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- start 启动    - stop 停止    - restart 重启</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc2.d/K20powernowd start</span><br></pre></td></tr></table></figure><p>有时您并不清楚当前运行级别，该运行级别下未必有相应脚本；而且此类脚本的前三位字符并不固定，不便于记忆。这时，可以直接使用</p><p>/etc/init.d/ 文件夹中的启动脚本（ /etc/rcX.d/ 中的启动脚本链接到 /etc/init.d/</p><p>文件夹下相应脚本），这也是推荐的方式。</p><p>例如：</p><p>/etc/init.d/powernowd start</p><blockquote><p>Note：以上命令的位置并没有包含在环境变量的搜索路径中，所以要输入完整路径。</p></blockquote><h3 id="常用系统服务"><a class="header-anchor" href="#常用系统服务">¶</a>常用系统服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">acpi-support 高级电源管理支持     acpid acpi守护程序.这两个用于电源管理，非常重要</span><br><span class="line"></span><br><span class="line">alsa 声音子系统          alsa-utils</span><br><span class="line"></span><br><span class="line">anacron cron的子系统，将系统关闭期间的计划任务，在下一次系统运行时执行。</span><br><span class="line"></span><br><span class="line">apmd acpi的扩展         atd 类似于cron的任务调度系统。建议关闭</span><br><span class="line"></span><br><span class="line">binfmt-support 核心支持其他二进制的文件格式。建议开启         bluez-utiles 蓝牙设备支持</span><br><span class="line"></span><br><span class="line">bootlogd 启动日志。开启它         cron 任务调度系统，建议开启</span><br><span class="line"></span><br><span class="line">cupsys 打印机子系统。       dbus 消息总线系统(message bus system)。非常重要</span><br><span class="line"></span><br><span class="line">dns-clean 使用拨号连接时，清除dns信息。        </span><br><span class="line"></span><br><span class="line">evms 企业卷管理系统（Enterprise Volumn Management system）</span><br><span class="line"></span><br><span class="line">fetchmail 邮件用户代理守护进程，用于收取邮件         gdm gnome登录和桌面管理器。</span><br><span class="line"></span><br><span class="line">Gdomap       gpm 终端中的鼠标支持。      halt 别动它。</span><br><span class="line"></span><br><span class="line">hdparm 调整硬盘的脚本，配置文件为 /etc/hdparm.conf。       hibernate 系统休眠</span><br><span class="line"></span><br><span class="line">hotkey-setup 笔记本功能键支持。支持类型包括： HP, Acer, ASUS, Sony, Dell, 和IBM</span><br><span class="line"></span><br><span class="line">hotplug and hotplug-net 即插即用支持，比较复杂，建议不要动它</span><br><span class="line"></span><br><span class="line">hplip HP打印机和图形子系统       ifrename 网络接口重命名脚本。如果您有十块网卡，您应该开启它</span><br><span class="line"></span><br><span class="line">inetd 在文件 /etc/inetd.conf 中，注释掉所有你不需要的服务。如果该文件不包含任何服务，那关闭它是很安全的。       klogd 重要。</span><br><span class="line"></span><br><span class="line">linux-restricted-modules-common 受限模块支持。 /lib/linux-restricted-modules/ 文件夹中的模块为受限模块。例如某些驱动程序，如果您没有使用受限模块，就不需要开启它。</span><br><span class="line"></span><br><span class="line">lvm 逻辑卷管理系统支持。         makedev 创建设备文件，非常重要。      mdamd 磁盘阵列</span><br><span class="line"></span><br><span class="line">module-init-tools 从/etc/modules加载扩展模块，建议开启。</span><br><span class="line"></span><br><span class="line">networking 网络支持。按 /etc/network/interfaces 文件预设激活网络，非常重要。</span><br><span class="line"></span><br><span class="line">ntpdate 时间同步服务，建议关闭。      pcmcia pcmcia设备支持。      powernowd 移动CPU节能支持</span><br><span class="line"></span><br><span class="line">ppp and ppp-dns 拨号连接          readahead 预加载库文件。     reboot 别动它      </span><br><span class="line"></span><br><span class="line">resolvconf 自动配置DNS      rmnologin 清除nologin         rsync rsync守护程序</span><br><span class="line"></span><br><span class="line">sendsigs 在重启和关机期间发送信号      single 激活单用户模式         ssh ssh守护程序。建议开启</span><br><span class="line"></span><br><span class="line">stop-bootlogd 在2，3，4，5运行级别中停止bootlogd服务          sudo 检查sudo状态。重要</span><br><span class="line"></span><br><span class="line">sysklogd 系统日志       udev &amp; udev-mab 用户空间dev文件系统（userspace dev filesystem）。重要</span><br><span class="line"></span><br><span class="line">umountfs 卸载文件系统        urandom 随机数生成器        usplash 开机画面支持</span><br><span class="line"></span><br><span class="line">vbesave 显卡BIOS配置工具。保存显卡的状态      xorg-common 设置X服务ICE socket。</span><br><span class="line"></span><br><span class="line">adjtimex 调整核心时钟的工具       dirmngr 证书列表管理工具,和gnupg一起工作。</span><br><span class="line"></span><br><span class="line">hwtools irqs优化工具          libpam-devperm 系统崩溃之后，用于修理设备文件许可的守护程序。</span><br><span class="line"></span><br><span class="line">lm-sensors 板载传感器支持         mdadm-raid 磁盘陈列管理器        </span><br><span class="line"></span><br><span class="line">screen-cleanup 清除开机屏幕的脚本       xinetd 管理其他守护进程的一个inetd超级守护程序</span><br></pre></td></tr></table></figure><h3 id="重要配置文件"><a class="header-anchor" href="#重要配置文件">¶</a>重要配置文件</h3><blockquote><p>无论任何情况下，修改配置文件之前，先备份它！</p></blockquote><p>建议使用这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp xxx xxx_`date +%y%m%d_%H:%M`</span><br></pre></td></tr></table></figure><p>当然这很麻烦，您可以新建一个名为 bak 的文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">sudo cp <span class="variable">$1</span> <span class="variable">$1_</span>`date +%y%m%d_%H:%M`</span><br></pre></td></tr></table></figure><p>把它放在您能够记住的目录下，比如 <code>/home</code> ，执行命令 <code>sh /home/bak xxx</code> ，就可以将当前文件夹下的文件 <code>xxx</code> 另存为 <code>xxx_yymmdd_HH:MM</code> 的格式了</p><p>全局配置文件</p><p>系统初始化</p><p>/etc/inittab 运行级别、控制台数量        /etc/timezone 时区        /etc/inetd.conf 超级进程</p><p>文件系统</p><p>/etc/fstab 开机时挂载的文件系统         /etc/mtab 当前挂载的文件系统</p><p>用户系统</p><p>/etc/passwd 用户信息          /etc/shadow 用户密码          /etc/group 群组信息</p><p>/etc/gshadow 群组密码         /etc/sudoers Sudoer列表（请使用“visudo”命令修改此文件，而不要直接编辑）</p><p>Shell</p><p>/etc/shell 可用Shell列表       /etc/inputrc ReadLine控件设定       /etc/profile 用户首选项</p><p>/etc/bash.bashrc bash配置文件</p><p>系统环境</p><p>/etc/environment 环境变量      /etc/updatedb.conf 文件检索数据库配置信息         /etc/issue 发行信息</p><p>/etc/issue.net         /etc/screenrc 屏幕设定</p><p>网络</p><p>/etc/iftab 网卡MAC地址绑定       /etc/hosts 主机列表       /etc/hostname 主机名</p><p>/etc/resolv.conf 域名解析服务器地址       /etc/network/interfaces 网卡配置文件</p><p>用户配置文件</p><p>/etc/ 目录下的文件，只有root用户才有权修改。应用软件的全局配置文件，通常普通用户也不能够修改，如果要通过配置软件，来适应特殊需求，您可以修改用户配置文件。</p><p>用户配置文件通常为全局配置文件的同名隐藏文件，放在$HOME目录下，例如：</p><p>/etc/inputrc /home/user/.inputrc</p><p>/etc/vim/vimrc /home/user/.vim/vimrc</p><p>也有少数例外，通常是系统程序</p><h3 id="软件安装"><a class="header-anchor" href="#软件安装">¶</a>软件安装</h3><h4 id="DPKG"><a class="header-anchor" href="#DPKG">¶</a>DPKG</h4><p>Linux系统中，软件通常以源代码或者预编译包的形式提供。</p><p>软件源代码需要编译为二进制的机器代码才能够使用，安装比较耗时，不过您可以自行调节编译选项，决定需要的功能或组件，或者针对硬件平台作一些优化。</p><p>预编译的软件包，通常是由软件的发布者进行编译，您只要将软件拷贝到系统中就可以了。考虑到预编译软件包的适用性，预编译软件包通常不会针对某种硬件平台优化。它所包含的功能和组件也是通用的组合。</p><p>Ubuntu系统中，软件通常以 deb 格式的包文件发布，它是一种预编译软件包。deb包中除了包含已编译的软件，通常还包括软件的拷贝路径、对其它软件包的依赖关系纪录、比较通用的配置文件以及软件的描述、版本、作者、类别、占用空间等信息。</p><p>deb软件包命令遵行如下约定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soft_ver-rev_arch.deb</span><br><span class="line">soft 软件包名称   ver 软件版本号    revUbuntu 修订版本号   arch 目标架构名称</span><br></pre></td></tr></table></figure><p>例如： azureus_2.4.0.2-0ubuntu2_all.deb</p><p>您需要使用 <code>dpkg</code> 命令来管理deb软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i | --install xxx.deb 安装deb软件包</span><br><span class="line"></span><br><span class="line">dpkg -r | --remove xxx.deb 删除软件包</span><br><span class="line"></span><br><span class="line">dpkg -r -P | --purge xxx.deb 连同配置文件一起删除</span><br><span class="line"></span><br><span class="line">dpkg -I | -info xxx.deb 查看软件包信息</span><br><span class="line"></span><br><span class="line">dpkg -L xxx.deb 查看包内文件</span><br><span class="line"></span><br><span class="line">dpkg -l 查看系统中已安装软件包信息</span><br><span class="line"></span><br><span class="line">dpkg-reconfigure xxx 重新配置软件包</span><br></pre></td></tr></table></figure><p>有些时候，您使用 dpkg 安装一个软件包，系统会提示您该软件包依赖其它软件包。这时，您先安装其它软件包，直到满足依赖关系为止。或者同时安装多个软件包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i aaa.deb bbb.deb ccc.deb</span><br></pre></td></tr></table></figure><h4 id="APT"><a class="header-anchor" href="#APT">¶</a>APT</h4><p>如果一个软件依赖关系过于复杂，使用 <code>dpkg</code></p><p>来安装它，并不是一个明智的选择，这个时候您就需要用到APT软件包管理系统。APT可以自动的检查依赖关系，通过您预设的方式来获得相关软件包，并自动</p><p>安装配置它。事实上，在多数情况下，我们推荐您使用APT软件包管理系统。</p><p>APT系统需要一个软件信息数据库和至少一个存放着大量deb包的软件仓库，我们称之为 <code>源</code> 。 <code>源</code> 可以是网络服务器，安装CD或者本地软件仓库。您需要修改 <code>/etc/apt/sources.list</code> 文件，使APT系统能够连接到 <code>源</code>。</p><p>从以下页面中获得网络安装源的列表，并且根据您的网络环境，选择速度较快的源。</p><p><a href="http://wiki.ubuntu.org.cn/%E5%BF%AB%E9%80%9F%25E" target="_blank" rel="noopener">http://wiki.ubuntu.org.cn/快速%E</a>......%97/DapperDrake</p><p>APT系统主要包括 <code>apt-get</code> 和 <code>apt-cache</code> 等命令。通常是复合命令，包含若干个子命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apt-get install xxx 安装xxx</span><br><span class="line"> -d 仅下载       -f  强制安装 </span><br><span class="line"></span><br><span class="line">apt-get remove xxx 卸载xxx</span><br><span class="line"></span><br><span class="line">apt-get update 更新软件信息数据库</span><br><span class="line"></span><br><span class="line">apt-get upgrade 进行系统升级</span><br><span class="line"></span><br><span class="line">apt-cache search 搜索软件包</span><br></pre></td></tr></table></figure><blockquote><p>说明：建议您经常使用 sudo apt-get update 命令来更新您的软件信息数据库</p></blockquote><blockquote><p>APT系统修复由于各种意外，APT系统可能会出现问题，使用如下命令，尝试进行修复：apt-get -f install</p></blockquote><h3 id="源码包"><a class="header-anchor" href="#源码包">¶</a>源码包</h3><p>对于绝大多数软件，我们建议您使用APT系统来安装它。在少数情况下，例如某软件没有以deb包的格式发布，或者需要定制适合自己的软件，您可以通过编译源代码的方式安装它。</p><p>首先需要下载软件的源码包，并且将它解包为一些源代码文件。并了便于管理，建议将下载的源码包移动到 <code>/usr/local/src/</code> 目录下，并在这里解包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mv xxx.tar.gz /usr/<span class="built_in">local</span>/src 移动源码包</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src 进入“/usr/<span class="built_in">local</span>/src/”目录</span><br><span class="line">sudo tar -xzvf xxx.tar.gz 解包源码</span><br><span class="line"><span class="built_in">cd</span> xxx_ver/ 进行解包后的源码目录</span><br></pre></td></tr></table></figure><p>源码目录中通常有一个 <code>configure</code> 脚本，用来配置即将开始的编译过程。您可以执行它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure [--prefix=/usr/loca/xxx ......]</span><br></pre></td></tr></table></figure><p>它会自动检测软件的编译环境和依赖关系，并且生成 <code>Makefile</code> 文件。</p><p>使用带参数的命令 <code>./configure --help</code> ，或者阅读 <code>INSTALL</code> 文件，查看该脚本允许的参数。例如使用</p><p><code>--prefix=/usr/local/xxx</code> 参数，将软件的安装目录设定为 <code>/usr/local/xxx/</code>。（如果一定要将软件安装在单独目录下，建议您安装在这里）</p><p>现在执行 <code>make</code> 命令，系统会根据 <code>Makefile</code> 文件中的设定，通过 make 工具调用编译器和所需资源文件，将源代码编译成目标文件。</p><p>sudo make</p><p>执行 <code>make install</code> 命令， <code>make</code> 工具会自动连接目标文件和库文件，将最终生成的文件拷贝到 <code>Makefile</code> 文件设定的路径中，并且完成更改文件的属性，删除残留文件等活动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>现在，编译安装已经完成，为了更方便的使用它，需要给程序的可执行文件作一个符号链接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -sf /usr/<span class="built_in">local</span>/xxx/可执行文件 /usr/<span class="built_in">local</span>/bin/可执行文件</span><br></pre></td></tr></table></figure><blockquote><p>Tip:为了顺利的进行编译，至少需要安装 build-essential 软件包。<code>sudo apt-get install build-essential</code></p></blockquote><h3 id="Xwindow简介"><a class="header-anchor" href="#Xwindow简介">¶</a>Xwindow简介</h3><p>Xwindow是工作站图形系统的工业标准，它有多种不同的实现，Ubuntu系统中使用的为Xorg。</p><p>（比较前卫的图形界面系统XGL，实际代替X服务器的作用，另外还有与之配套的窗口管理器）</p><h4 id="历史"><a class="header-anchor" href="#历史">¶</a>历史</h4><p>当然，Xwindow有悠久的历史和传统，不过那不在我们讨论的范围。您要注意的有两点：</p><ul><li><p>Xwindow 和 Xbox 中的“X”本意是不同的， X 只是 W 后的一个字母，差不多应该这样理解，Xwindow 是 Window 的接班人 （注意，Window不是Windows）</p></li><li><p>同样，也不要把 Xwindow 说成是 Xwindows，那是一种亵渎！一切伟大的创造，都应得到应有的理解和尊重。</p></li></ul><h4 id="架构及原理"><a class="header-anchor" href="#架构及原理">¶</a>架构及原理</h4><p>Xwindow使用服务器－客户端架构。无论本地图形界面，还是远程图形界面，都以同样的流程工作。这样便不需要分别进行设计和维护，极大的提高了网络透明性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本地X客户端 ┐ ┌ 键盘</span><br><span class="line">远程X客户端 ┼ X协议 ─ X服务器 ─ 硬件规范 ┼ 鼠标</span><br><span class="line">远程X客户端 ┘ └ 显示器</span><br></pre></td></tr></table></figure><h4 id="Xserver"><a class="header-anchor" href="#Xserver">¶</a>Xserver</h4><p>Xwindow系统服务器端，通过驱动程序（硬件规范）来管理硬件资源。</p><p>例如：当我们移动鼠标时，通过驱动程序，向 Xserver 发送信息：</p><p>“向右移动200点，向上移动100点”（向右上移动）；“按下左键”……</p><p>Xserver作出如下响应：</p><p>1、上一次鼠标停止的坐标为600,500</p><p>2、向右200，向上100。现在鼠标位于坐标800,600</p><p>3、坐标800,600处，为窗口Firefox的“关闭”按钮</p><p>4、根据预设动作，将 “点击Firefox窗口的关闭按钮” 翻译为 “关闭窗口Firefox”</p><p>5、向X客户端Firefox发送一个“退出”消息</p><p>6、Xserver通过显示子系统（显卡、显示器），全程显示鼠标的位置和移动</p><p>* 事实上，向程序发送“退出”信号，通常窗口管理器完成……为了描述方便，这里暂不区分。稍后，我们将向您介绍 窗口管理器 的其它一些细节。</p><p>大多数的鼠标不需要专门的驱动程序，因为它们符合某一硬件规范，例如：有四个移动方向和三个键</p><h4 id="Xclient"><a class="header-anchor" href="#Xclient">¶</a>Xclient</h4><p>Xwindow系统客户端，通过X协议，实现与Xserver 的交互。</p><p>例如：</p><p>1、Xclient （假设Firefox） 接收Xserver的消息： 输入焦点在地址栏的范围内，“<a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”，回车</p><p>2、Firefox根据预设动作，将这些消息识别为 “打开链接 <a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”</p><p>3、Firefox向域名服务器请求 链接 “<a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”。域名服务器将这个请求转换为 “<a href="http://ubuntu.org.cn/%E2%80%9D" target="_blank" rel="noopener">http://ubuntu.org.cn/”</a> 和 IP地址211.148.131.7，发送回 Firefox</p><p>4、Firefox将 “<a href="http://ubuntu.org.cn/%E2%80%9D%E6%98%BE%E7%A4%BA%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%EF%BC%88%E5%90%91Xserver%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%BD%8D%E7%BD%AE%E6%98%BE%E7%A4%BA%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%EF%BC%89" target="_blank" rel="noopener">http://ubuntu.org.cn/”显示在地址栏（向Xserver发送请求，在地址栏位置显示这个地址）</a></p><p>5、Firefox向地址 211.148.131.7 请示显示页面。</p><p>6、Firefox将服务器发送回的页面显示在主窗口中</p><h4 id="Xprotocol"><a class="header-anchor" href="#Xprotocol">¶</a>Xprotocol</h4><p>Xwindow系统协议，Xserver和Xclient之间进行通信的规则</p><h4 id="窗口管理器"><a class="header-anchor" href="#窗口管理器">¶</a>窗口管理器</h4><p>Window Manager，一种特殊的Xclient。</p><p>使用窗口管理器时，Xserver并不直接与其它Xclient通信，而是通过WM中转，当一些消息被定义为WM指令时，它们会被拦截。例如Alt+F4关闭窗口、拖动标题栏……</p><p>消息“打开链接 <a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”，具体内容如下：</p><p>输入焦点在地址栏的范围内，“<a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”，回车</p><p>Xserver并不能直接判断焦点，而是这样：</p><p>1、Xserver向WM发送位置和点击的信息，WM根据当前的“焦点策略”确定激活（最上层）的窗口为Firefox</p><p>2、Xserver将Firefox显示在最上层，高亮显示它的标题栏</p><p>3、在窗口Firefox内点击地址栏，或者 Ctrl+L，Xserver将位置信息发送给WM，WM再发送给Firefox</p><p>4、Firefox判断当前焦点后，显示一个闪动的文字输入光标</p><p>5、Firefox将输入光标通过WM发送给Xserver，Xserver在屏幕相应位置进行显示</p><p>那么，“窗口管理器”到底能作些什么呢？其实它所作的一切都是管理窗口。例如：</p><p>1.最上层的窗口会把其它窗口挡住</p><p>2.它通常是一个“已激活窗口”，根据不同的“焦点策略”，窗口管理器确定被激活的窗口。</p><p>激活窗口标题栏高亮显示，接收大部分的键盘消息和窗口内的鼠标点击消息。</p><p>3.为了美观和容易分辨，大多数窗口都要有标题栏和边框。</p><p>为了方便，标题栏上还要有一些按钮，比如：最小化，最大化，关闭（这些按钮是窗口管理器请求的小窗口）</p><p>4.一个窗口可以在另一个窗口旁边显示，而不一定完全被遮挡。为了实现这一点，就要控制窗口显示的位置</p><p>5.为了控制窗口的显示位置，需要将整个屏幕用座标描述，最好的办法是绘制一个填充整个屏幕的窗口，也就是根窗口。</p><p>6.因为根窗口是最大的，所以它可以严严实实的遮挡任何窗口，为了避免这一点，根窗口永远在最底层。</p><p>这很形象的说明了为什么它叫作“根窗口” ……root</p><p>7.根窗口不一定只有一个，大多数的窗口管理器可以使用 “工作区” ，来切换显示多个根窗口</p><p>8.根窗口固定位置上通常放置一些其它Xclient的窗口，例如底部面板，顶部面板，侧面板，程序启动图标</p><p>9.面板上又可以放一些其它的Xclient窗口，如任务条，启动栏，菜单……</p><p>任务条可以以图标显示正在运行的任务，还可以作其它的杂活，像自动挂载USB设备……</p><p>启动流程</p><p>我们知道 init 是linux的根进程，是所有进程的父进程。同样， xinit是所有Xwindow进程的根进程</p><p>Startx</p><p>startx 命令可以在命令行下启动图形界面。执行startx 命令时，实际执行这一命令：</p><p>xinit /etc/X11/xinit/xinitrc -- /etc/X11/xinit/xserverrc</p><p>根据脚本 /etc/X11/xinit/xserverrc 启动Xserver，同时根据脚本 /etc/X11/xinit/xinitrc 启动指定Xclient进程，例如窗口管理器</p><p>脚本 /etc/X11/xinit/xserverrc 以预设的参数运行程序 /usr/bin/X11/X</p><p>/etc/X11/xinit/xinitrc 脚本则指向 /etc/X11/Xsession ，依次启动 /etc/X11/Xsession.d 目录中的脚本</p><p>* 您可以在用户配置文件 ~/.Xsession 中定义使用的WM，它的优先级高于全局配置文件(对于GDM会话不起作用)</p><p>* startx启动时，并不会再进行身份认证。因为它启动的是 /etc/X11/Xsession.d/gnome-session ，而不是 GDM会话</p><p>GDM会话</p><p>Ubuntu系统启动时自动进入图形界面，不需要运行 startx 命令</p><p>在某些启动级别中，包含了gdm的启动脚本，例如 ： /etc/rc2.d/S13gdm</p><p>\1. 指向 /etc/gdm/gdm-cdd.conf 文件，加载预设视觉主题，启动 /usr/lib/gdm/gdmgreeter（登录屏幕）</p><p>\2. 用户身份认证完成后，启动 /etc/X11/default-display-manager 这个文件中设定的默认窗口管理器 /usr/sbin/gdm</p><p>gdm在启动时，会要求用户名和密码，也就是我们看到的登录屏幕（gdmgreeter）</p><p>* /usr/share/xsessions 目录下为所有可用登录会话的脚本</p><p>配置文件</p><p>X服务器</p><p>X服务器的主要配置文件为 /etc/X11/xorg.conf</p><p>布局</p><p>Section &quot;ServerLayout&quot;</p><p>Identifier &quot;Default Layout&quot;</p><p>Screen &quot;Default Screen&quot; 0 0</p><p>InputDevice &quot;Generic Keyboard&quot;</p><p>InputDevice &quot;Configured Mouse&quot;</p><p>EndSection</p><p>* 定义了 布局标识 、 屏幕标识 、 键盘标识 、 鼠标标识</p><p>模块</p><p>Section &quot;Module&quot;</p><p>Load &quot;i2c&quot;</p><p>Load &quot;bitmap&quot;</p><p>Load &quot;ddc&quot;</p><p>Load &quot;dri&quot;</p><p>Load &quot;extmod&quot;</p><p>Load &quot;freetype&quot;</p><p>Load &quot;glx&quot;</p><p>Load &quot;int10&quot;</p><p>Load &quot;type1&quot;</p><p>Load &quot;vbe&quot;</p><p>EndSection</p><p>X核心字体路径</p><p>Section &quot;Files&quot;</p><p>FontPath &quot;/usr/share/X11/fonts/75dpi&quot;</p><p>FontPath &quot;/usr/share/X11/fonts/100dpi&quot;</p><p>FontPath &quot;/usr/share/X11/fonts/misc&quot;</p><p>FontPath &quot;/usr/share/X11/fonts/cyrillic&quot;</p><p>FontPath &quot;/usr/share/X11/fonts/100dpi/:unscaled&quot;</p><p>FontPath &quot;/usr/share/X11/fonts/75dpi/:unscaled&quot;</p><p>FontPath &quot;/usr/share/X11/fonts/Type1&quot;</p><p>FontPath &quot;/usr/share/fonts/Chinese/wqy-bitmapfont&quot;</p><p>EndSection</p><p>屏幕</p><p>Section &quot;Screen&quot;</p><p>Identifier &quot;Default Screen&quot;</p><p>Device &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;</p><p>Monitor &quot;DELL E176FP&quot;</p><p>DefaultDepth 24</p><p>SubSection &quot;Display&quot;</p><p>Depth 1</p><p>Modes &quot;1280x1024&quot; &quot;1152x864&quot; &quot;1024x768&quot; &quot;800x600&quot; &quot;720x400&quot; &quot;640x480&quot;</p><p>………………</p><p>EndSubSection</p><p>EndSection</p><p>* DefaultDepth 24 默认色深</p><p>* SubSection 可用色深及分辨率</p><p>显卡</p><p>Section &quot;Device&quot;</p><p>Identifier &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;</p><p>Driver &quot;fglrx&quot;</p><p>Option &quot;KernelModuleParm&quot; &quot;agplock=0&quot;</p><p>VideoRam 131072</p><p>EndSection</p><p>* Identifier 显卡标识</p><p>* Driver 显卡驱动（如不同正常启用图形界面，首先尝试&quot;vesa&quot;）</p><p>* Option 显卡参数</p><p>* VideoRam 显存大小</p><p>显示器</p><p>Section &quot;Device&quot;</p><p>Identifier &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;</p><p>Driver &quot;fglrx&quot;</p><p>Option &quot;KernelModuleParm&quot; &quot;agplock=0&quot;</p><p>VideoRam 131072</p><p>EndSection</p><p>配置文件内部结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">├/ <span class="string">"ServerLayout"</span> 布局</span><br><span class="line">│├ <span class="string">"InputDevice"</span> keyboard 键盘</span><br><span class="line">│├ <span class="string">"InputDevice"</span> mouse 鼠标</span><br><span class="line">││</span><br><span class="line">│└/ <span class="string">"Screen"</span> 显示子系统</span><br><span class="line">│ ├ <span class="string">"Monitor"</span> 显示器</span><br><span class="line">│ ├ <span class="string">"Device"</span> videocard 显卡</span><br><span class="line">│</span><br><span class="line">│</span><br><span class="line">├ <span class="string">"Files"</span> 字体</span><br><span class="line">└ <span class="string">"Module"</span> 模块</span><br></pre></td></tr></table></figure><p>X客户端</p><p>在 /etc/X11/Xsession 文件中可以发现下列内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OPTIONFILE=/etc/X11/Xsession.options</span><br><span class="line">SYSRESOURCES=/etc/X11/Xresources</span><br><span class="line">USRRESOURCES=<span class="variable">$HOME</span>/.Xresources</span><br><span class="line">SYSSESSIONDIR=/etc/X11/Xsession.d</span><br><span class="line">USERXSESSION=<span class="variable">$HOME</span>/.xsession</span><br><span class="line">ALTUSERXSESSION=<span class="variable">$HOME</span>/.Xsession</span><br><span class="line">ERRFILE=<span class="variable">$HOME</span>/.xsession-errors</span><br></pre></td></tr></table></figure><ul><li><p><code>OPTIONFILE=/etc/X11/Xsession.options</code> 设定X进程的启动参数。例如允许用户进程<code>allow-user-xsession</code></p></li><li><p><code>Xresources X</code>资源文件。许多程序保留了X接口，允许X服务器管理一些视觉选项，例如窗口内的字体，配色等</p></li><li><p><code>xsession X</code>进程。可以设置一些启动时自动运行的程序，也可以用来设定自己的窗口管理器（窗口管理器和桌面环境或者登录管理器是无关的）</p></li></ul><p>字体</p><p>freetype渲染引擎</p><p>作为Xorg服务器的一个模块，freetype的功能包括读取Truetype字体信息，如大小、分辨率、编码等，并以之为依据渲染字体 -</p><p>freetype2.x相对于freetype1.x 增加了抗锯齿等功能 - ( /etc/X11/xorg/conf 的 Module</p><p>字段中，可以选择字体渲染模块，建议使用默认的 freetype )</p><p>freetype只负责渲染字体。而查找字体，则可以由X服务器、X客户端或者字体服务器来完成。找到字体后，使用freetype引擎就地渲染</p><p>X核心字体</p><p>X服务器根据X客户端的请求（字符编码），查找字体并进行渲染，然后显示，我们称之为</p><p>Xft字体</p><p>X客户端自行查找字体并进行渲染，X服务器只负责显示</p><p>由于Xft字体的渲染在客户端完成，所以它可以动态的加载，而不需要随同X服务器一同启动</p><p>字体服务器</p><p>另外还有一种字体服务器模式，例如 XFT字体：当客户端请求字体时，X服务器将请求转发到字体服务器，由字体服务器查找字体，并使用freetype引擎渲染，将结果传回X服务器，X服务器进行显示……</p><p>X核心字体</p><p>/etc/X11/xorg.conf 中可以配置X核心字体的搜索路径</p><p>Section &quot;Files&quot;</p><p>FontPath &quot;/usr/X11R6/lib/X11/fonts/misc/&quot;</p><p>FontPath &quot;/usr/X11R6/lib/X11/fonts/Type1/&quot;</p><p>FontPath &quot;/usr/X11R6/lib/X11/fonts/Speedo/&quot;</p><p>FontPath &quot;/usr/X11R6/lib/X11/fonts/100dpi/&quot;</p><p>FontPath &quot;/usr/X11R6/lib/X11/fonts/75dpi/&quot;</p><p>EndSection</p><ul><li></li></ul><p>当X客户端向X服务器请求显示文字的时候，X服务器会按上面列表的先后顺序查找字体</p><p>例如显示中文时，如果第一个路径中的字体不包含中文，则查找下面的路径，直到发现中文字体</p><ul><li></li></ul><p>请将您偏好的字体放在靠前的位置</p><p>要使安装的字体能够作为X核心字体使用，将字体的安装路径添加到上面的列表中，使用 mkfontscale 、 mkfontdir</p><p>扫瞄文件夹中的字体，并生成索引，就可以了（建议使用 ttmkfdir 生成 fonts.scale ，将其复制为 fonts.dir ）</p><p>字体的选择及显示风格，可以修改GTK1的配置文件，或者在Xresources文件中对程序单独进行定义</p><p>事实上，在我们的日常应用中，X核心字体环境并不常见，使用GTK1图形库的程序、某些类型的终端……</p><p>* Emacs也是这样一个老派的程序……不过Emacs23中刚刚加入了xft字体的支持</p><p>XFT字体</p><p>Xft字体相关选项在 /etc/fonts/fonts.conf 文件中配置</p><p>可以使用 fc-cache 命令，递归扫瞄以下目录中的字体（包括子文件夹中的字体），建立字体缓存</p><p>/usr/share/X11/fonts</p><p>/usr/share/fonts</p><p>/usr/local/share/fonts</p><p>~/.fonts</p><p>* /etc/fonts/fonts.conf 文件的 <dir> 字段</dir></p><p>多数支持GTK2或者Qt图形库的X客户端能够使用Xft字体渲染技术</p><p>* GTK2为Gnome使用的图形库，Qt为KDE使用的图形库。相对来说，GTK2图形库在程序的GUI设计中更加通用</p><p>安装字体，只要将字体拷贝到以上任意目录， fc-cache -fv 刷新字体缓存即可 （参数: -f 强制刷新; -v 显示过程）</p><p>使用命令 fc-list 列出所有可用字体</p><p>字体的选择及显示风格，可以修改GTK2或者Qt的配置文件，建议使用图形界面配置</p><p>* 一般情况下，桌面环境中附带了相关程序，例如 gnome-font-properties</p><h3 id="系统管理"><a class="header-anchor" href="#系统管理">¶</a>系统管理</h3><h4 id="一些细节"><a class="header-anchor" href="#一些细节">¶</a>一些细节</h4><ul><li><p>Linux是大小写敏感的系统，所有的命令、路径、参数、变量……都区分大小写</p></li><li><p>使用 <code>TAB</code> 键补全命令，无论任何时候，多按几次TAB总会有所帮助</p></li><li><p>Shell的功能键能够协助您更高效的编辑命令，请熟悉其键绑定，尽量使用它</p></li><li><p>命令由 <code>命令名</code> 、 <code>分隔符</code> 、 <code>参数</code> 、 <code>操作对象</code> 构成</p></li></ul><h4 id="命令名"><a class="header-anchor" href="#命令名">¶</a>命令名</h4><p>标识命令的功能，例如cp(copy)、mv(move)、rm(remove)……</p><p>有些命令包含一些子命令，您可以认为它的命令名由两个单词构成，例如<code>apt</code>软件包管理系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install <span class="comment"># 安装一个软件</span></span><br><span class="line">apt-get remove  <span class="comment"># 删除一个软件</span></span><br></pre></td></tr></table></figure><h4 id="分隔符-2"><a class="header-anchor" href="#分隔符-2">¶</a>分隔符</h4><p>通常为空格，<code>多个连续的空格视为一个空格</code>，下面两个命令相同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp a b</span><br><span class="line">cp   a   b</span><br></pre></td></tr></table></figure><p>有一些特殊符号也属于分隔符，例如 <code>管道 | 、重定向 &gt; 、 &gt;&gt; 、 &lt; 、后台运行 &amp; 、序列执行 &amp;&amp; 、 ; </code>。使用这些符号时，您不需要再使用<code>空格作为分隔符</code>，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al|less</span><br></pre></td></tr></table></figure><p>写为以下形式，是为了让您更容易的阅读它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al | less</span><br></pre></td></tr></table></figure><h4 id="参数"><a class="header-anchor" href="#参数">¶</a>参数</h4><p>精细调节命令的行为，以 <code>-</code> 引导，通常为参数名的首字母。许多软件都可以使用 <code>-h</code> 参数来阅读使用说明，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -h</span><br></pre></td></tr></table></figure><p>也可以使用参数的全名，一般以 -- 引导，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>多数命令中，使用 - 引导多个字符，将会被视为多个参数，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>系统会解读为以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -h -e -l -p</span><br></pre></td></tr></table></figure><p>少数命令的参数，不需要以 <code>-</code> 引导，或者使用 <code>-</code> 引导参数全名，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br><span class="line">/etc/init.d/gdm start</span><br><span class="line">mplayer -loop xxx</span><br></pre></td></tr></table></figure><p>需要对多个对象进行操作时，可以使用空格分隔符将它们隔开：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch 1 2 3 4 5 6</span><br></pre></td></tr></table></figure><p>使用空格分隔的多个对象，视为一个整体，作为命令的一个操作对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 1 2 3 4 5 6 /home/</span><br></pre></td></tr></table></figure><p>这个命令把<code>1 2 3 4 5 6</code>作为一个操作对象，移动到另一个操作对象，<code>/home/</code>目录</p><p>递归 表示在子层次中重复相同操作。例如递归复制某目录，不但复制当前目录及其下的所有文件；而且对当前目录的子目录，也进行递归复制的操作。</p><h4 id="格式约定"><a class="header-anchor" href="#格式约定">¶</a>格式约定</h4><p>使用 <code>[]</code> 表示可选项，实际输入为方括号中的内容，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [-al]</span><br></pre></td></tr></table></figure><ul><li><p><code>ls</code>是必须的，参数不需要以方括号括起来。</p></li><li><p>使用 <code>&lt;&gt;</code> 表示必需项，实际输入为尖括号中的内容</p></li><li><p>使用 | 表示 或 ，以 | 分隔的项目不能同时使用，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [-z|j c|x vf] &lt;归档文件&gt; [源文件]</span><br></pre></td></tr></table></figure></li></ul><p>参数通常紧跟命令名，除非必要，在命令格式中，我们通常省略它们</p><h3 id="系统信息"><a class="header-anchor" href="#系统信息">¶</a>系统信息</h3><h4 id="uptime"><a class="header-anchor" href="#uptime">¶</a>uptime</h4><p>联机信息-时间，显示如下</p><p>11:27pm up 9 days, 7:12, 3 user, load average: 0.07, 0.12, 0.14</p><p>当前系统时间 系统运行时间 当前在线用户数 系统负荷 1分钟前 5分钟前 15分钟前</p><h4 id="w"><a class="header-anchor" href="#w">¶</a>w</h4><p>联机信息-已登录用户，显示如下</p><p>01:04:10 up 1:34, 2 users, load average: 0.25, 0.16, 0.11</p><p>uptime 信息</p><p>USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT</p><p>user tty1 192.168.0.1 23:30 1:33 0.14s 0.12s -bash</p><p>用户名 登录方式 来源地址 登录时间 发呆时间 资源占用 当前任务</p><p>Tip：w [用户名称] : 显示某一用户相关信息</p><h4 id="who"><a class="header-anchor" href="#who">¶</a>who</h4><p>联机信息，常用参数</p><p>-r 运行级别</p><h4 id="whoami"><a class="header-anchor" href="#whoami">¶</a>whoami</h4><p>显示当前用户名</p><h4 id="last"><a class="header-anchor" href="#last">¶</a>last</h4><p>最近用户登录信息-&lt;数字&gt; 使用数字作为参数，控制显示条目。例如last -10 显示10条纪录</p><h4 id="uname"><a class="header-anchor" href="#uname">¶</a>uname</h4><p>系统信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s 内核名称（默认参数）    -a 全部        -p CPU 信息       -n 主机名     </span><br><span class="line">-r 内核发行信息（版本号）  -v 内核版本信息</span><br></pre></td></tr></table></figure><h4 id="date"><a class="header-anchor" href="#date">¶</a>date</h4><p>显示、设定系统时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-u 显示格林尼洛时间（UTC）</span><br><span class="line"></span><br><span class="line">MMDDhhmm[[CC]YY][.ss] 设定时间，需要管理员权限。例如： date 12292359</span><br><span class="line"></span><br><span class="line">MM 月份 DD 天数 hh 小时 mm 分钟 CC 年份前两位 YY 年份后两位 ss 秒钟</span><br><span class="line"></span><br><span class="line">秒钟、年份为可选，例如： date 122923592006.59</span><br><span class="line"></span><br><span class="line">+[%X]设定显示格式，以下为date默认输出格式：</span><br><span class="line"></span><br><span class="line">date +%Y年%m月%d日%A%H:%M:%S%Z</span><br><span class="line"></span><br><span class="line">格式控制      %n 换行       %t 制表符</span><br><span class="line"></span><br><span class="line">小时          %H(00~23) %I(01~12) %k(0~23) %l(1~12) %p(AM|PM)</span><br><span class="line"></span><br><span class="line">分、秒        %M分钟(00~59)         %S秒(00..61)       %T(hh:mm:ss) %r(hh:mm:ss [AM|PM])</span><br><span class="line"></span><br><span class="line">%s 从1970年1月1日00:00:00 UTC到目前为止的秒数       %X(%H:%M:%S)         %Z时区</span><br><span class="line"></span><br><span class="line">星期          %a(Sun~Sat) %A(Sunday~Saturday) %w : 一周中的第几天 (0..6)</span><br><span class="line"></span><br><span class="line">年份          %Y(0000~9999) %y(00~99)</span><br><span class="line"></span><br><span class="line">月份          %m(01~12) %b %h(Jan~Dec) %B(January~December)</span><br><span class="line"></span><br><span class="line">日期          %d(01~31) %j(001~366)</span><br><span class="line"></span><br><span class="line">%x(本地格式mm/dd/yy) %D(mm/dd/yy) %c</span><br><span class="line"></span><br><span class="line">一年中的第几周</span><br><span class="line"></span><br><span class="line">%U(00~53)以Sunday为一周的第一天 %W(00~53)以Monday为一周的第一天</span><br></pre></td></tr></table></figure><h4 id="cal"><a class="header-anchor" href="#cal">¶</a>cal</h4><p>显示日历</p><h3 id="文件管理"><a class="header-anchor" href="#文件管理">¶</a>文件管理</h3><p>一些细节</p><p><code>/</code> 目录为文件系统根目录，所有目录都是它的子目录</p><p>绝对路径以 <code>/</code> 起始，相对路径以当前所在目录起始</p><p>目录是一种特殊类型的文件，如果没有特别指明， 文件 包括文件和目录</p><p><code>..</code> 表示上一级目录， <code>.</code> 表示当前目录，它们是两个特殊目录</p><h4 id="链接"><a class="header-anchor" href="#链接">¶</a>链接</h4><p>为当前文件建立在其它路径中的访问方法。例如将系统中其它位置的可执行文件，链接到 <code>/usr/local/bin</code> 目录下，使用命令调用。</p><p>ls [路径]</p><p>显示当前目录文件列表</p><p>--color 不同属性以不同颜色显示（默认参数）</p><p><em>-a</em> <em>全部显示</em>        <em>-i</em> <em>显示<strong>inode</strong>值</em>     <em>-l</em> <em>详细信息</em></p><p><em>-F</em> <em>显示文件类型后缀</em> <em>目录</em>*/* <em>链接</em>*@* <em>可执行文件</em>*** <em>端口文件</em>*=* <em>管道文件</em>*| &gt;*</p><p><em>-A</em> <em>显示隐藏文件</em>         <em>-R</em> <em>递归显示子目录文件列表</em>        <em>-S</em> <em>按文件大小排序</em></p><p><em>-t</em> <em>按修改时间排序</em>       <em>-u</em> <em>按访问时间排序</em>       <em>-d</em> <em>只显示目录，不递归显示目录下的文件</em></p><p>cd [目录路径] | [特殊路径]</p><p>切换目录</p><p>目录路径可以使用绝对路径或者相对路径特殊路径：</p><p><em>~ $HOME**目录（默认值）</em>     <em>-</em> <em>上一次目录</em>       <em>..</em> <em>上一级目录</em>       <em>.</em> <em>当前目录</em></p><p>说明：您可以通过修改 /etc/environment 文件，来定义 $CDPATH 变量，设定“cd”命令的搜索路径。</p><p>pwd</p><p>显示当前路径</p><p>file &lt;文件名&gt;</p><p>显示文件类型</p><p>*<strong>-i*</strong> ***显示mime****<strong>类型*</strong></p><p>du [路径]</p><p>计算文件或目录空间占用</p><p><em>-h</em> <em>人性化显示。自动以<strong>G</strong>、<strong>M</strong>、<strong>K</strong>为单位显示占用空间大小</em>         <em>-l</em> <em>重复计算硬链接文件大小</em></p><p><em>-L</em> <em>计算符号链接文件大小</em>     <em>-a</em> <em>显示当前目录子目录中的文件</em>         <em>-c</em> <em>显示文件数</em></p><p>less &lt;文件名&gt;</p><p>浏览文件，使用VI和Emacs两种风格的键绑定。以下为VI风格键绑定</p><p><em>Ctrl+f(orward)</em> <em>向下翻一页</em> <em>Ctrl+d(own)</em> <em>向下翻半页</em></p><p><em>Ctrl+b(ackward)</em> <em>向上翻一页</em> <em>Ctrl+u(p)</em> <em>向上翻半页</em>       <em>/</em> <em>查找</em> <em>q(uit)</em> <em>退出</em></p><p>touch &lt;目标文件&gt;</p><p>触碰，在不修改文件的前提下，更改其时间属性。通常用来创建一个空文件</p><p>mkdir &lt;文件夹&gt;</p><p>创建文件夹</p><p><em>-p &lt;<strong>多级目录</strong>&gt;</em> <em>按路径创建多级目录</em>      <em>-m &lt;<strong>数字权限值</strong>&gt;</em> <em>设定权限</em></p><p>cp &lt;源文件&gt; &lt;目标目录|文件&gt;</p><p>将源文件复制为目录文件，或者将源文件复制到目标目录。多个源文件使用空格分隔</p><p>cp &lt;源目录&gt; &lt;目标目录&gt;</p><p>将源目录复制到目标目录中，如果复制多个源目录，需要使用 -R 参数</p><p><em>-a</em> <em>相当于</em>*-dpr**参数*       <em>-d</em> <em>保留链接</em>        <em>-f</em> <em>强制复制，覆盖目标文件</em>         <em>-i</em> <em>覆盖时询问用户</em></p><p><em>-p</em> <em>保留修改时间和访问权限</em>        <em>-r -R</em> <em>递归复制（目录</em>*=&gt;*<em>目录）</em>     <em>-l</em> <em>创建链接</em></p><p><em>-v</em> <em>显示过程</em></p><p>rm &lt;目标目录|文件&gt;</p><p>删除</p><p><em>-r -R</em> <em>递归删除</em>      <em>-f</em> <em>强制删除（无需确认，直接删除。慎用！）</em>        <em>-i</em> <em>交互式删除（询问用户）</em></p><p>rmdir &lt;目标目录&gt;</p><p>删除目录时，建议您使用“rm -r”命令</p><p>mv &lt;源文件&gt; &lt;目标目录|文件&gt;</p><p>相当于cp后删除源文件，也可以作为“重命名”使用。</p><p>mv &lt;源目录&gt; &lt;目标目录&gt;</p><p><em>-r -R</em> <em>递归</em></p><p>ln &lt;源文件&gt; &lt;链接&gt;</p><p>链接</p><p><em>-s</em> <em>符号链接</em>        <em>-f</em> <em>强制链接，覆盖目标文件</em>         <em>-i</em> <em>覆盖前询问用户</em></p><h3 id="文件操作"><a class="header-anchor" href="#文件操作">¶</a>文件操作</h3><p>nano</p><p>一个简单轻便的文本编辑器，使用Emacs风格的键绑定。</p><p>split &lt;源文件&gt; [目标文件名前缀]</p><p>将源文件按一定规则分割成若干个目标文件。默认文件名前缀为 x</p><p><em>-&lt;<strong>行数</strong>&gt;</em> <em>按行数分割文件</em>      <em>-l &lt;<strong>行数</strong>&gt;</em> <em>同上</em></p><p><em>-b &lt;<strong>字节</strong>&gt;</em> <em>按大小分割文件。可以使用<strong>b</strong>、<strong>k</strong>、<strong>m</strong>作单位，不指定单位的情况下，默认单位为**b</em></p><p><em>-C &lt;<strong>字节</strong>&gt;</em> <em>按大小分割文件，并尽量保持每行的完整</em></p><p>示例：split -C 100k file.split x</p><p>cat &lt;文件名&gt;</p><p>输出文件内容。用空格分隔多个文件名，可以将多个文件内容连接到一起输出。使用重定向合并为一个文件</p><p><em>-n</em> <em>在输出中添加行号</em>          <em>-b</em> <em>在输出中添加行号，空行不编号</em></p><p><em>-s</em> <em>将两行或以上的空行，合并为一个空行</em></p><p>示例：cat xaa xab xac &gt; file.split</p><p>sort [-o &lt;输出文件&gt;] [-t &lt;分隔字符&gt;] [+&lt;起始字段&gt; - &lt;结束字段&gt;] [文件]</p><p>对文本内容排序</p><p><em>-m</em> <em>合并文件</em>        <em>-c</em> <em>检查文件是否已按规则排序</em>      <em>-b</em> <em>忽略行首空格字符</em></p><p><em>-u</em> <em>忽略内容重复行</em>       <em>-f</em> <em>忽略大小写</em>       <em>-l</em> <em>忽略非打印字符</em>       <em>-M</em> <em>作为月份比较</em></p><p><em>-d</em> <em>按字典顺序排序，按照字母、数字、空格、制表符排序</em>      <em>-r</em> <em>逆序输出</em></p><p>more</p><p>查看文件内容，我们建议您使用 less</p><p>diff &lt;文件名&gt;</p><p>比较文件</p><p>cksum [文件名]</p><p>计算文件的CRC值。不指定文件名则从标准输入设备读入数据，例如：</p><p>echo xxx | cksum</p><p>md5sum [文件名] 计算文件的md5值。同上</p><h3 id="权限管理"><a class="header-anchor" href="#权限管理">¶</a>权限管理</h3><p>一些细节</p><p>一个文件主要包含下列属性， ls -l</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- rwx rwx rwx user group date filename</span><br><span class="line"></span><br><span class="line">111 101 101</span><br></pre></td></tr></table></figure><p>其中，第一组为归属用户的权限，第二组为归属群组的权限，第三组为其它用户群组的权限。user为文件的归属用户，group为文件的归属群组，date为日期信息，filename为文件名。</p><p>对于文件夹，必须拥有它的可执行权限，才能够使用 cd 命令进入该文件夹；拥有可读权限，才能够使用 ls 命令查看该文件夹的文件列表。</p><p>root用户拥有最高权限。</p><p>可以使用3位的二进制数字来描述一组权限，某一权限对应的数字为1,则表示具有该种权限，为0,则不具有该种权限。</p><p>使用二进制数字来描述一组权限，虽然非常直观，但是3组权限需要用9位数来表示，使用不够方便。因此我们将三组权限使用3位8进制数字来表示。它们的对应关系为：</p><p>r 100 4</p><p>w 010 2</p><p>x 001 1</p><p>将这三位8进制数字相加的结果，就可以表示该组权限的具体内容，例如：</p><p>7=4+2+1=rwx</p><p>5=4+1=rx</p><p>755=4+2+1 4+1 4+1=rwx r-x r-x</p><p>还可以使用 a 、 u 、 g 、 o 表示归属关系，使用 = 、 + 、 - 表示权限变化，使用 r 、 w 、 x 表示权限内容，</p><p>a 所有用户 u 归属用户 g 归属群组 o 其它用户</p><p>= 具有权限 + 增加权限 - 去除权限</p><p>r 可读权限 w 可写权限 x 可执行权限</p><p>例如：</p><p>a+x 给所有用户增加可执行权限</p><p>go-wx 将归属群组和其它用户的可写、可执行权限去掉</p><p>u=rwx 归属用户具有可读、可写、可执行权限</p><p>chmod &lt;权限表达式&gt; &lt;文件|目录&gt;</p><p>更改文件的权限。权限的表达式可以使用三位8进制数字表示，或者使用 augo +-= rxw-s 来表示</p><p>-R 递归</p><p>-v 显示过程</p><p>-c 类似“-v”，仅显示更改部分</p><p>--reference=&lt;参考文件或目录&gt; 以指定文件为参考更改权限</p><p>示例：</p><p>chmod -R a+x path</p><p>chmod -Rv 755 path</p><p>chown &lt;归属用户&gt;[:归属群组] &lt;文件|目录&gt;</p><p>更改文件的归属用户。可以使用用户名或者UID</p><p><em>-R</em> <em>递归</em>       <em>-v</em> <em>显示过程</em>        <em>-c</em> <em>类似</em> <em>-v</em> <em>，仅显示更改部分</em></p><p>--reference=&lt;参考文件或目录&gt; 以指定文件为参考更改权限</p><p>示例：</p><p>chown user:admin path          chown -R user.admin path       chown user path</p><p>chgrp &lt;归属群组&gt; &lt;文件|目录&gt;</p><p>更改文件的归属群组。可以使用群组名或者GID</p><p>参数同上</p><p>SUID、SGID、Sticky bit</p><p>某些情况下，需要以可执行文件归属用户的身份执行该文件，可以为该文件设置SUID。同样，设置SGID能够以该文件归属群组的身份执行它。</p><p>例如：用户自行设定密码。出于安全方面的考虑， /etc/shadow 只能由root用户直接修改。</p><p>-rw------- root root /etc/shadow</p><p>这个时候，可以为程序 /usr/bin/passwd</p><p>设置SUID，当普通用户执行“passwd”命令时，便能够以该程序归属用户root的身份修改 /etc/shadow</p><p>文件。而“passwd”程序自身带有身份验证机制，不能通过验证时拒绝执行，从而保证了安全。</p><p>ls -l /usr/bin/passwd</p><p>-r-s--x--x root root /usr/bin/passwd</p><p>我们发现，归属用户的可执行权限位使用 s ，表示SUID。同样，归属群组的可执行权限位使用 s ，表示SGID。任何用户或群组都拥有</p><p>其它用户 的权限，所以不需要以 其它用户 身份执行文件，其它用户的可执行权限位便不会出现 s 。该权限位可能出现的属性为 t</p><p>，也就是粘着位Sticky bit。</p><p>ls -ld /tmp</p><p>drwxrwxrwt root root /tmp</p><p>粘着位表示任何用户都可能具有写权限，但只有该归属用户或root用户才能够删除</p><p>SUID、SGID、Sticky bit也可以像权限一样，使用一个八进制数表示，如下：</p><p>4 SUID</p><p>2 SGID</p><p>1 Sticky bit</p><p>通过在“chmod”命令中使用4个八进制数的表达式，如 4755 ，用第一位表示SUID、SGID、或Sticky bit，便能够为文件设置这些特殊权限。示例：</p><p>chmod -R 4755 path</p><p>lsattr [路径]</p><p>查看文件的特殊属性</p><p><em>-a</em> <em>全部显示</em>        <em>-d</em> <em>只显示目录</em>      <em>-R</em> <em>递归</em></p><p>特殊属性包括：</p><p><em>a</em>*：仅供附加用途*         <em>b</em>*：不更新最后存取时间*       <em>c</em>*：压缩后存放*      <em>d</em>*：排除在倾倒操作之外*</p><p><em>i</em>*：不得任意更动文件或目录*        <em>s</em>*：保密性删除文件或目录*     <em>S</em>*：即时更新文件或目录*</p><p><em>u</em>*：预防以外删除*</p><p>chattr +|-|=&lt;属性&gt; &lt;路径&gt;</p><p>更改文件特殊属性</p><p><em>-R</em> <em>递归</em>       <em>-V</em> <em>显示过程</em></p><h3 id="压缩解压"><a class="header-anchor" href="#压缩解压">¶</a>压缩解压</h3><p>tar -c|x|u|r|t[z|j][v] -f &lt;归档文件&gt; [未打包文件]</p><p>将多个文件打包为一个归档文件，可以在打包的同时进行压缩。支持的格式为tar（归档）、gz（压缩）、bz2（压缩率更高，比较耗时）</p><p><em>-c</em> <em>创建</em>        <em>-x</em> <em>解包</em>        <em>-u</em> <em>更新</em>        <em>-r</em> <em>添加</em>        <em>-t</em> <em>查看</em></p><p><em>-d</em> <em>比较压缩包内文件和文件</em>        <em>-A</em> <em>将<strong>tar</strong>文件添加到归档文件中</em>         <em>-z</em> <em>使用<strong>gz</strong>压缩格式</em></p><p><em>-j</em> <em>使用<strong>bz2</strong>压缩格式</em>      <em>-v</em> <em>显示过程</em>        <em>-f &lt;<strong>文件名</strong>&gt;</em> <em>归档文件的文件名</em></p><p><em>-C &lt;<strong>解压路径</strong>&gt;</em> <em>将压缩包中的文件解压到指定目录</em></p><p>[未打包文件] 创建、更新时必须填写</p><p>示例：</p><p>tar -zcvf xxx.tar.gz xxx/ xxx1 xxx2 xxx3 多个待打包文件以空格分隔</p><p>tar -zcvf xxx.tar.gz /home/user/xxx/ 使用绝对路径打包，解包也使用绝对路径</p><p>tar -zxvf xxx.tar.gz 按相对路径解包到当前目录下，或按绝对路径解包</p><p>tar -zcvf xxx.tar.gz xxx | split -b 1m 打包后，使用split分割为1m大小的多个文件</p><p>其它参数</p><p><em>-P</em> <em>使用绝对路径压缩时，保留根目录</em>*“/”       -W* <em>校验</em>       <em>-p</em> <em>还原文件权限</em></p><p><em>-w</em> <em>询问用户</em>        <em>--totals</em> <em>统计</em>        <em>-T &lt;<strong>表达式</strong>&gt;</em> <em>处理符合条件的文件</em></p><p><em>-X &lt;<strong>表达式</strong>&gt;</em> <em>排除符合条件的文件</em></p><p>zip [参数] &lt;压缩包&gt; &lt;源文件&gt;</p><p>使用zip格式打包文件</p><p><em>-r</em> <em>递归，将指定目录下的所有文件和子目录一并处理</em>          <em>-S</em> <em>包含系统和隐藏文件</em></p><p><em>-y</em> <em>直接保存符号连接，而非该连接所指向的文件</em>         <em>-X</em> <em>不保存额外的文件属性</em></p><p><em>-m</em> <em>将文件压缩并加入压缩文件后，删除源文件</em></p><p>-&lt;压缩级别&gt; 1~9，数字越大，压缩率越高</p><p><em>-F</em> <em>尝试修复已损坏的压缩文件</em>      <em>-T</em> <em>检查备份文件内的每个文件是否正确无误</em></p><p><em>-q</em> <em>不显示指令执行过程</em>        <em>-g</em> <em>将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件</em></p><p><em>-u</em> <em>更新压缩包内文件</em></p><p><em>-f</em> <em>更新压缩包内文件。如果符合条件的文件没有包含在压缩包中，则压缩后添加</em></p><p><em>-$</em> <em>保存第一个被压缩文件所在磁盘的卷标</em>      <em>-j</em> <em>只保存文件名称及其内容</em></p><p><em>-D</em> <em>压缩文件内不建立目录名称</em>      <em>-i &lt;<strong>表达式</strong>&gt;</em> <em>压缩目录时，只压缩符合条件的文件</em></p><p><em>-x &lt;<strong>表达式</strong>&gt;</em> <em>排除符合条件的文件</em>        <em>-n &lt;<strong>文件名后缀</strong>&gt;</em> <em>排除指定文件名后缀的文件</em></p><p><em>-b &lt;<strong>缓存路径</strong>&gt;</em> <em>指定临时文件目录</em>        <em>-d &lt;<strong>表达式</strong>&gt;</em> <em>从压缩文件内删除指定的文件</em></p><p><em>-t &lt;<strong>日期时间</strong>&gt;</em> <em>把压缩文件的日期设成指定的日期</em></p><p><em>-o</em> <em>以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同</em></p><p><em>-A</em> <em>调整可执行的自动解压缩文件</em>         <em>-c</em> <em>替每个被压缩的文件加上注释</em></p><p><em>-z</em> <em>替压缩文件加上注释</em>        <em>-k</em> <em>使用<strong>MS-DOS</strong>兼容格式的文件名称。</em></p><p><em>-l</em> <em>压缩文件时，把<strong>LF</strong>字符置换成<strong>LF+CR</strong>字符。</em>         <em>-ll</em> <em>压缩文件时，把<strong>LF+CR</strong>字符置换成<strong>LF</strong>字符。</em></p><p>unzip [参数] &lt;压缩文件&gt; [压缩包中将被释放的文件]</p><p>解压zip压缩包文件</p><p><em>-P &lt;<strong>密码</strong>&gt; zip**压缩包的密码</em>         <em>-d &lt;<strong>路径</strong>&gt;</em> <em>指定解压路径</em>      <em>-n</em> <em>解压缩时不覆盖原有文件</em></p><p><em>-f</em> <em>覆盖原有文件</em>         <em>-o</em> <em>不经询问，直接覆盖原有文件</em></p><p><em>-u</em> <em>覆盖原有文件，并将压缩文件中的其他文件解压缩到目录中</em></p><p><em>-l</em> <em>显示压缩文件内所包含的文件</em>         <em>-t</em> <em>检查压缩文件是否正确</em>      <em>-z</em> <em>显示压缩包注释</em></p><p><em>-Z unzip -Z<strong>等于执行</strong>zipinfo**指令</em>          <em>-j</em> <em>不处理压缩文件中原有的目录路径</em></p><p><em>-C</em> <em>压缩文件中的文件名称区分大小写</em>         <em>-L</em> <em>将压缩文件中的全部文件名改为小写</em></p><p><em>-s</em> <em>将文件名中的空格转换下划线</em>         <em>-X</em> <em>解压缩时保留文件原来的**UID/GID</em></p><p><em>-q</em> <em>执行时不显示任何信息</em>               <em>-v</em> <em>执行是时显示详细的信息</em></p><p><em>-c</em> <em>将解压缩的结果显示到屏幕上，并对字符做适当的转换</em></p><p><em>-p</em> <em>与</em>*-c**参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换*</p><p><em>-a</em> <em>对文本文件进行必要的字符转换</em>            <em>-b</em> <em>不要对文本文件进行字符转换</em></p><p><em>-x &lt;<strong>表达式</strong>&gt;</em> <em>处理里排除压缩包中的指定文件</em>            <em>-M</em> <em>将输出结果送到<strong>more</strong>程序处理</em></p><p>7z|7za &lt;子命令&gt; [参数] &lt;压缩包&gt; [文件]</p><p>子命令</p><p><em>a</em> <em>添加</em>    <em>d</em> <em>删除</em>    <em>e</em> <em>解压</em>    <em>x</em> <em>带路径解压</em>  <em>l</em> <em>列表查看</em>     <em>t</em> <em>测试</em>    <em>u</em> <em>更新</em></p><p>参数</p><p><em>-m&lt;<strong>压缩方式</strong>&gt;      -m0=&lt;<strong>压缩算法</strong>&gt;</em> <em>默认使用**lzma         -mx=&lt;1~9&gt;</em> <em>压缩级别</em></p><p><em>-mfb=64 number of fast bytes for LZMA = 64      -md=&lt;<strong>字典大小</strong>&gt;</em> <em>设置字典大小，例如</em> <em>-md=32m</em></p><p><em>-ms=&lt;on|off&gt;</em> <em>是否固实压缩</em>        <em>-o&lt;<strong>输出目录</strong>&gt;</em> <em>设置输出目录</em>        <em>-p[<strong>密码</strong>]</em> <em>使用密码</em></p><p><em>-r[<strong>数字</strong>]</em> <em>递归，使用数字定义递归子目录的深度</em>          <em>-sfx[&lt;<strong>模块名称</strong>&gt;]</em> <em>使用自解压模块</em></p><p><em>-si</em> <em>从标准输入设备读入数据</em>        <em>-so</em> <em>将数据写入标准输出设备</em>       <em>-y</em> <em>所有询问均回答**Yes</em></p><p><em>-w&lt;<strong>工作目录</strong>&gt;</em></p><p>rar &lt;子命令&gt; [参数] &lt;压缩包&gt; [文件|文件列表|路径]</p><p>子命令</p><p><em>x</em> <em>带路径解压</em>       <em>e</em> <em>解压到当前目录</em>        <em>a</em> <em>将文件添加到压缩包内</em>      <em>d</em> <em>从压缩包中删除文件</em></p><p><em>u</em> <em>更新压缩包内文件</em>      <em>f</em> <em>更新压缩包内文件，并添加压缩包内不存在的文件</em>      <em>m</em> <em>添加并删除源文件</em></p><p><em>r</em> <em>修复</em>        <em>l</em> <em>列表查看压缩包内文件信息</em> <em>lt</em> <em>更详细信息</em> <em>lb</em> <em>简短信息</em>      <em>c</em> <em>添加压缩包注释</em></p><p>cf &lt;文件名&gt; 将文件内容添加为注释</p><p>cw &lt;文件名&gt; 将注释保存为文件</p><p>t 测试压缩包       rr 添加恢复纪录         rv 恢复到文件</p><p>参数</p><p>-p&lt;密码&gt; 设置密码</p><p>-m&lt;0~5&gt; 设置压缩级别，数字越大，压缩级别越高</p><h3 id="搜索"><a class="header-anchor" href="#搜索">¶</a>搜索</h3><p>whereis &lt;程序名称&gt;</p><p>查找软件的安装路径</p><p><em>-b</em> <em>只查找二进制文件</em>          <em>-m</em> <em>只查找帮助文件</em>      <em>-s</em> <em>只查找源代码</em>    <em>-u</em> <em>排除指定类型文件</em></p><p><em>-f</em> <em>只显示文件名</em>         <em>-B &lt;<strong>目录</strong>&gt;</em> <em>在指定目录下查找二进制文件</em></p><p><em>-M &lt;<strong>目录</strong>&gt;</em> <em>在指定目录下查找帮助文件</em>        <em>-S &lt;<strong>目录</strong>&gt;</em> <em>在指定目录下查找源代码</em></p><p>locate &lt;文件名称&gt;</p><p>在文件索引数据库中搜索文件</p><p>-d &lt;数据库路径&gt; 搜索指定数据库</p><p>updatedb 更新文件索引数据库</p><p>find [路径] &lt;表达式&gt;</p><p>查找文件</p><p>-name &lt;表达式&gt; 根据文件名查找文件</p><p>-iname &lt;表达式&gt; 根据文件名查找文件，忽略大小写</p><p>-path &lt;表达式&gt; 根据路径查找文件</p><p>-ipath &lt;表达式&gt; 根据路径查找文件，忽略大小写</p><p>-amin &lt;分钟&gt; 过去N分钟内访问过的文件</p><p>-atime &lt;天数&gt; 过去N天内访问过的文件</p><p>-cmin &lt;分钟&gt; 过去N分钟内修改过的文件</p><p>-ctime &lt;天数&gt; 过去N天内修改过的文件</p><p>-anewer &lt;参照文件&gt; 比参照文件更晚被读取过的文件</p><p>-cnewer &lt;参照文件&gt; 比参照文件更晚被修改过的文件</p><p>-size &lt;大小&gt; 根据文件大小查找文件，单位b c w k M G</p><p>-type &lt;文件类型&gt; 根据文件类型查找文件。b 块设备 c 字符设备 d 目录 p 管道文件 f 普通文件 l 链接 s 端口文件</p><p>-user &lt;用户名&gt; 按归属用户查找文件</p><p>-uid <uid> 按UID查找文件</uid></p><p>-group &lt;群组名&gt; 按归属群组查找文件</p><p>-gid <gid> 按GID查找文件</gid></p><p>-empty 查找空文件</p><p>grep &lt;字符串&gt;|&quot;&lt;正则表达式&gt;&quot; [文件名]</p><h3 id="其它"><a class="header-anchor" href="#其它">¶</a>其它</h3><p>echo &lt;字符串&gt;</p><p>回显。较复杂的字符串，可以使用 &quot; 括起来。</p><p><em>-n</em> <em>输出内容不换行</em>       <em>-E</em> <em>不解析脱字符</em>         <em>-e</em> <em>解析脱字符</em></p><p>控制字符</p><p>** <em>反斜线</em>       <em>a</em> <em>警告</em>        <em>b</em> <em>退格</em>        <em>n</em> <em>换行</em>        <em>r</em> <em>回车</em>        <em>t</em> <em>水平制表符</em></p><p>clear</p><p>消除屏幕</p><p>alias &lt;输入内容&gt; &lt;实际内容&gt;</p><p>别名，为命令指定一个别名，以简化输入。例如：</p><p>alias ls='ls --color=auto'</p><p>alias ls=&quot;l -CF&quot;</p><p>可以将您的定义保存在 ~/.bashrc 文件中。</p><p>export &lt;变量名称&gt;</p><p>将变量导出为环境变量，常写变量赋值一同使用，例如：</p><p>export PATH=&quot;$PATH:xxx&quot;</p><p>其中 $PATH 表示变量 PATH 原值</p><p>shutdown</p><p>关闭计算机，向根进程 init 发送信号，更改 runlevel 为 0 (halt)</p><p><em>-h</em> <em>关闭电源</em>        <em>-r</em> <em>重启</em>        <em>-n</em> <em>强行关机，不向</em> <em>init**进程</em> <em>发送信号</em></p><p><em>-k</em> <em>模拟关机，向登录者发送关机警告</em>          <em>-t &lt;<strong>秒</strong>&gt; N**秒后关机</em>       <em>time &lt;<strong>时间</strong>&gt;</em> <em>定时关机</em></p><p><em>-c [<strong>说明信息</strong>]</em> <em>取消关机</em>        <em>-f</em> <em>重启时忽略检测文件系统</em>         <em>-F</em> <em>重启时强制检测文件系统</em></p><p>halt</p><p>关闭计算机。 调用 shutdown -h ，结束系统进程，同步文件系统，停止内核。</p><p><em>-n</em> <em>不同步文件系统</em>       <em>-w</em> <em>模拟关机，写</em> <em>/var/log/wtmp</em> <em>纪录</em>     <em>-f</em> <em>不调用</em> *shutdown ,*<em>强行关机</em></p><p><em>-p</em> <em>默认选项，关机时调用</em> <em>poweroff       -i</em> <em>关机前断开网络</em></p><p>reboot</p><p>重新启动计算机。参数与 halt 相似</p><p>chroot &lt;路径&gt;</p><p>Change Root 更改根目录，重新定义会话的运行环境。</p><h3 id="用户管理"><a class="header-anchor" href="#用户管理">¶</a>用户管理</h3><p>一些细节</p><p>root 用户为根用户，也就是 系统管理员 拥有全部权限</p><p>一个用户只能拥有一个 GID ，但是还可以归属于其它附加群组</p><p>用户管理的重要配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd 用户名 密码位 UID 归属GID 姓名 $HOME目录 登录Shell</span><br><span class="line">/etc/shadow 用户名 已加密密码 密码改动信息 密码策略</span><br><span class="line">/etc/group 群组名 密码位 GID 组内用户</span><br><span class="line">/etc/gshadow 群组密码相关文件，不重要</span><br><span class="line">/etc/sudoers 用户名 权限定义 权限</span><br></pre></td></tr></table></figure><p>可以使用 pwconv 命令创建影子密码，将 /etc/passwd 文件中的密码转换到 /etc/shadow 文件</p><p>su [用户名]</p><p>切换到其它用户，默认切换到root用户。提示密码为将切换用户密码</p><p><em>-f</em> <em>快速切换，忽略配置文件</em>         <em>-l</em> <em>重新登录</em>         <em>-m</em> <em>，**-p</em> <em>不更改环境变量</em></p><p><em>-c &lt;<strong>命令</strong>&gt;</em> <em>切换后执行命令，并退出切换</em></p><p>sudo [命令]</p><p>以其它用户的身份执行命令，默认以root的身份执行。提示密码为当前用户密码</p><p><em>-s</em> <em>切换为**root shell       -i</em> <em>切换为<strong>root shell</strong>，并初始化</em>       <em>-u &lt;<strong>用户名</strong>|UID&gt;</em> <em>执行命令的身份</em></p><p><em>-l</em> <em>显示自己的权限</em></p><p>passwd [用户名]</p><p>设定用户密码</p><p><em>-d</em> <em>清除密码</em>        <em>-l</em> <em>锁定用户</em>         <em>-e</em> <em>使密码过期，在下次登录时更改密码</em></p><p><em>-S</em> <em>显示密码认证信息</em>          <em>-x &lt;<strong>天数</strong>&gt;</em> <em>密码过期，最大使用时间</em></p><p><em>-n &lt;<strong>天数</strong>&gt;</em> <em>冻结密码，最小使用时间</em>      <em>-s</em> <em>更改登录**Shell         -f</em> <em>更改用户信息</em></p><p>示例：</p><p>$passwd</p><p>Changing password for user</p><p>(current) UNIX password: 原密码</p><p>Enter new UNIX password: 新密码</p><p>Retype new UNIX password: 确认新密码</p><p>chsh [-s <shell>] [用户名]</shell></p><p>更改登录Shell</p><p>usermod &lt;用户名&gt;</p><p>修改用户账号</p><p><em>-d &lt;<strong>目录</strong>&gt;</em> <em>设定</em>*$HOME<em><em>目录*        <em>-m</em> <em>设定</em></em>$HOME</em>*目录时自动建立*</p><p><em>-s <shell></shell></em> <em>修改用户登录**Shell       -l &lt;<strong>新用户名</strong>&gt;</em> <em>修改为新用户名</em></p><p><em>-u <uid></uid></em> <em>修改用户**UID           -g &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属群组</em></p><p><em>-G &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属附加群组</em>     <em>-L</em> <em>锁定帐户</em>        <em>-U</em> <em>解除锁定</em></p><p><em>-e &lt;<strong>过期时间</strong>&gt;</em> <em>设定用户账号过期时间</em>         <em>-f &lt;<strong>缓冲天数</strong>&gt;</em> <em>设定密码过期后多长时间关闭账号</em></p><p><em>-c &lt;<strong>字符串</strong>&gt;</em> <em>修改用户备注</em></p><p>useradd &lt;用户名&gt;</p><p>新建用户</p><p><em>-d &lt;<strong>目录</strong>&gt;</em> <em>设定</em>*$HOME<em><em>目录*        <em>-m</em> <em>自动建立</em></em>$HOME</em><em>目录*      <em>-M</em> <em>不自动建立</em></em>$HOME**目录*</p><p><em>-s <shell></shell></em> <em>修改用户登录**Shell       -l &lt;<strong>用户名</strong>&gt;</em> <em>修改为新用户名</em>        <em>-u <uid></uid></em> <em>修改用户**UID</em></p><p><em>-g &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属群组</em>          <em>-G &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属附加群组</em></p><p><em>-n</em> <em>不建立以用户名为名称的群组</em>         <em>-e &lt;<strong>过期时间</strong>&gt;</em> <em>设定用户账号过期时间</em></p><p><em>-f &lt;<strong>缓冲天数</strong>&gt;</em> <em>设定密码过期后多长时间关闭账号</em>        <em>-c &lt;<strong>字符串</strong>&gt;</em> <em>修改用户备注</em></p><p><em>-D [<strong>表达式</strong>]</em> <em>更改预设值</em> <em>（预设值保存于</em> <em>/etc/default/useradd</em> <em>文件中）</em></p><p>新建用户规则保存于 /etc/login.defs 文件中</p><p>新建用户默认文件保存于 /etc/skel/ 目录中。新建用户时，系统自动拷贝此目录下的文件至新建用户的 $HOME 目录</p><p>userdel &lt;用户名&gt;</p><p>删除用户</p><p><em>-r</em> <em>删除用户相关文件和目录</em></p><p>id [用户名]</p><p>显示用户 UID GID 归属附加群组</p><p>finger [用户名]</p><p>显示用户信息</p><h3 id="进程管理"><a class="header-anchor" href="#进程管理">¶</a>进程管理</h3><p>一些细节</p><p>进程一般分为交互进程、批处理进程和守护进程三类。</p><p>守护进程总是活跃，在系统启动时通过脚本自动启动，或由root启动，通常在后台运行。</p><p>一个进程可以拥有子进程。当父进程终止时，它的子进程也随之终止；而子进程终止时，父进程通常可以继续运行。</p><p>init 进程为根进程，所有进程都是它的子进程</p><p>ps</p><p>显示进程信息，参数可省略 -</p><p><em>aux</em> <em>以<strong>BSD</strong>风格显示进程**(<strong>常用</strong>)          -efH</em> <em>以<strong>System V</strong>风格显示进程</em></p><p><em>-e , -A</em> <em>显示所有进程</em>      <em>a</em> <em>显示终端上所有用户的进程</em>       <em>x</em> <em>显示无终端进程</em></p><p><em>u</em> <em>显示详细信息</em>          <em>f</em> <em>树状显示</em>         <em>w</em> <em>完整显示信息</em>         <em>l</em> <em>显示长列表</em></p><p>示例：</p><p>ps alx 另一种常用输出格式</p><p>ps aux | less 将输出通过管道，使用 less 查看</p><p>ps aux | grep &lt;关键字&gt; 通过关键字查找进程</p><p>输出字段</p><p>USER 进程所有者        PID 进程ID        PPID 父进程       %CPU CPU占用率</p><p>%MEM 内存占用率      NI 进程优先级。数值越大，占用CPU时间越少         VSZ 进程虚拟大小</p><p>RSS 页面文件占用       TTY 终端ID       STAT 进程状态</p><p>D 不可中断 Uninterruptible sleep (usually IO)        R 正在运行，或在队列中的进程</p><p>S 处于休眠状态          T 停止或被追踪         Z 僵尸进程</p><p>W 进入内存交换（从内核2.6开始无效）      X 死掉的进程      &lt; 高优先级         N 低优先级</p><p>L 有些页被锁进内存     s 包含子进程       + 位于后台的进程组；</p><p>l 多线程，克隆线程 multi-threaded (using CLONE_THREAD, like NPTL pthreads do)</p><p>pstree</p><p>树状显示进程信息</p><p><em>-a</em> <em>显示完整命令及参数</em>        <em>-c</em> <em>重复进程分别显示</em>          <em>-c</em> <em>显示进程**ID PID  -n</em> <em>按</em> <em>PID</em> <em>排列进程</em></p><p>pgrep &lt;进程名&gt;</p><p>显示进程的PID</p><p><em>-l</em> <em>显示进程名和进程**PID      -o</em> <em>进程起始**ID      -n</em> <em>进程终止**ID</em></p><p>xkill</p><p>在图形界面中点杀进程。执行此命令后，鼠标指针变为骷髅图案（一定看过《加勒比海盗》吧）。在窗口中点击左键杀死进程，右键取消</p><p>pkill &lt;进程名&gt;</p><p>结束进程族。如果结束单个进程，请用 kill</p><p>kill [信号代码] &lt;进程PID&gt;</p><p>根据PID向进程发送信号，常用来结束进程，默认信号为 -9</p><p>-l [信号数字] 显示、翻译信号代码</p><p>-9 , -KILL 发送 kill 信号退出</p><p>-6 , -ABRT 发送 abort 信号退出</p><p>-15 , -TERM 发送 Termination 信号</p><p>-1 , -HUP 挂起</p><p>-2 , -INT 从键盘中断，相当于 Ctrl+c</p><p>-3 , -QUIT 从键盘退出，相当于 Ctrl+d</p><p>-4 , -ILL 非法指令</p><p>-11 , -SEGV 内存错误</p><p>-13 , -PIPE 破坏管道</p><p>-14 , -ALRM</p><p>-STOP 停止进程，但不结束</p><p>-CONT 继续运行已停止的进程</p><p>-9 -1 结束当前用户的所有进程</p><p>renice &lt;优先级表达式&gt; &lt;进程表达式&gt;</p><p>重新设定进程优先级（无此必要）</p><p>优先级表达式：</p><p>+|-|= &lt;nice值&gt;</p><p>nice取值范围： -20~19</p><p>进程表达式：</p><p>-p <pid> 通过进程ID进行设定</pid></p><p>-g <pgid> 通过进程群组ID</pgid></p><p>-u <uid> 通过进程拥有者UID设定</uid></p><p>top</p><p>动态、交互式进程管理器</p><p>-c 显示进程启动状态，包括参数、操作对象等；而不只是进程名</p><p>-d &lt;秒&gt; 刷新频率。 -d 5，表示5秒刷新一次</p><p>-n &lt;次&gt; 刷新次数，然后退出。 -n 5，表示刷新5次后退出；</p><p>-b 以批量模式运行，让输出能够使用管道或重定向。但不能进行交互，最好和 -n &lt;次&gt; 参数一同使用</p><p>-i 禁止显示空闲进程或僵尸进程；</p><p>-p PID 仅监视指定进程的ID；PID是一个数值；</p><p>-s 安全模式运行，禁用一些效互指令；</p><p>-S 累积模式，输出每个进程的总的CPU时间，包括已死的子进程；</p><p>交互命令：</p><p><space> 立即刷新</space></p><p>k 交互式杀死进程，提示输入进程 PID （默认发送信号15）</p><p>r 设定renice，提示输入PID和renice值</p><p>s 改变两次刷新时间间隔，以秒为单位</p><p>n 设定显示进程数， 0 为不作限制</p><p>i 隐藏空闲进程和僵尸进程</p><p>S 切换到累积时间模式</p><p>l 开关，在顶部显示 uptime 信息</p><p>t 开关，在顶部显示 进程和CPU状态</p><p>m 开关，在顶部显示 free 信息</p><p>c 显示方式切换： 进程名/进程启动状态</p><p>A 按进程启动顺序进行排序。由新到旧</p><p>M 按内存占用排序。由大到小</p><p>N 以进程ID排序。由大到小</p><p>P 按CPU占用排序。由大到小</p><p>T 按时间／累积时间排序</p><p>f ，F 设定显示字段。设定完成后空格退出</p><p>o,O 设定显示字段的排序。大写向前移动，小写向后移动，空格退出</p><p>h,? 显示有关安全模式和累积模式的帮助信息</p><p>W 把当前的配置写到~/.toprc中；</p><p>nohup &lt;命令&gt;</p><p>将任务提交到后台，输出附加到 ~/nohup.out 文件。即便用户退出登录，提交的命令仍继续执行。</p><p>&lt;命令&gt; &amp;</p><p>背景执行此命令，如果用户退出登录，则命令停止执行</p><p>&lt;命令1&gt; ; &lt;命令2&gt; ; ......</p><p>命令队列，从左向右，依次执行以 ; 分隔的命令</p><p>&lt;命令1&gt; &amp;&amp; &lt;命令2&gt; &amp;&amp; ......</p><p>命令队列，从左向右，依次执行以 &amp;&amp; 分隔的命令。前一个命令执行成功，后一个命令才能执行</p><p>&lt;命令&gt; &lt;Ctrl+z&gt;</p><p>&lt;Ctrl+z&gt; 挂起当前Shell中的任务</p><p>jobs</p><p>显示背景任务</p><p>bg [任务编号]</p><p>将挂起的任务背景执行</p><p>fg [任务编号]</p><p>将背景任务调到前台执行</p><p>计划任务</p><h3 id="磁盘和内存管理"><a class="header-anchor" href="#磁盘和内存管理">¶</a>磁盘和内存管理</h3><p>一些细节</p><p>Linux中，设备用/dev/目录下的文件表示。例如</p><p>/dev/hda1 第一块硬盘的第一主分区</p><p>/dev/hdb5 第二块硬盘的第一逻辑分区</p><p>/dev/sda4 第一块SATA硬盘的第四主分区，或者扩展分区</p><p>/dev/null 黑洞设备</p><p>关于磁盘设备，详见 分区概念</p><p>mount &lt;设备文件&gt; [挂载路径]</p><p>挂载文件系统</p><p>-t 指定文件系统的类型。通常不必指定，mount自动检测。下面是常用的格式</p><p>reiserfs ReiserFS 3.6版</p><p>jfs IBM技术</p><p>xfs SGI技术(适合高级服务器，桌面用户慎用)</p><p>ext3 Linux传统文件系统</p><p>vfat fat fat32</p><p>ext2 不带日志的ext3</p><p>ntfs WINNT</p><p>iso9660 光盘</p><p>smbfs Windows文件共享</p><p>-o [选项1] [选项2] ......</p><p>loop 环设备。光盘、ISO镜像等</p><p>ro | rw 只读readonly；可读写read-write</p><p>sync | async 同步模式|异步模式。决定修改是否立即写入文件系统</p><p>atime | noattime 读取时是否修改访问时间。对于写入敏感设备，例如闪存、软盘，建议使用 <em>noatime</em></p><p>auto | noauto 自动挂载模式</p><p>exec | noexec 是否允许可执行权限</p><p>defaults 使用预设的选项 rw, suid, dev, exec, auto, nouser, async</p><p>iocharset=UTF-8 指定字符集，可简写为 utf8</p><p>codepage=936 指定代码页，可简写为 cp936 西文系统代码页为 437</p><p>umask=&lt;权限掩码&gt; 设定权限掩码</p><p>uid=<uid> 设定归属用户</uid></p><p>gid=<gid> 设定归属群组</gid></p><p>remount 以不同选项重新挂载</p><p>-L &lt;卷标&gt; 将带有特殊卷标的分区</p><p>Tip</p><p>权限掩码</p><p>权限=777-权限掩码（三位） | 7777-权限掩码（四位）</p><p>假如权限掩码为 022 ，则新建对象权限为 755 rwxr-xr-x</p><p>可以使用 umask 命令设置权限掩码</p><p>mount -a</p><p>挂载 /etc/fstab 文件中定义的所有设备</p><p>示例：</p><p>sudo mount -t iso9660 -o loop /dev/cdrom0 /media/cdrom</p><p>sudo mount -t vfat -o remount iocharset=utf8,codepage=cp936 /dev/hda5 /media/hda5</p><p>umount &lt;设备文件&gt; | &lt;挂载路径&gt;</p><p>卸载已挂载文件系统</p><p>df</p><p>查看已挂载文件系统的磁盘空间占用</p><p>-a 显示所有文件系统的磁盘使用情况，包括0块（block）的文件系统，如/proc文件系统</p><p>-T 显示文件系统类型         -k 以k字节为单位显示        -i 显示i节点信息，而不是磁盘块</p><p>-t &lt;文件系统类型&gt; 显示指定类型的文件系统的磁盘空间使用情况</p><p>-x &lt;文件系统类型&gt; 列出不是某一指定类型文件系统的磁盘空间使用情况（与t选项相反）。</p><p>-l 只显示本地文件系统</p><p>free</p><p>查看内存、缓冲区、交换空间的占用</p><p>-b 以字节为单位显示数值      -k 以千字节为单位显示数值        -m 以兆字节为单位显示数值</p><p>-g 以吉字节为单位显示数值        -l 显示内存占用峰值     -o 不显示缓冲区占用          -t 统计结果</p><p>-s &lt;秒&gt; 刷新频率</p><p>sync</p><p>同步文件系统。将缓冲区中的数据写入文件系统</p><p>fdisk &lt;磁盘设备文件&gt;</p><p>分区表修改工具</p><p>交互命令：</p><p>m 使用帮助        l 查看已知文件系统类型       p 显示分区信息</p><p>n 新建分区 （p:主分区 l:扩展分区 参见 分区概念 )     d 删除分区         t 改变分区类型</p><p>w 将改动写入分区表          q 放弃改动并退出</p><p>* 磁盘设备名称为整块磁盘，而不是磁盘中的分区。例如 /dev/hda ，而不是 /dev/hda1</p><p><strong>fdisk -l</strong></p><p>查看所有磁盘分区信息</p><p>cfdisk</p><p>更加友善的分区表修改工具</p><p>mkfs.&lt;文件系统类型&gt; &lt;分区设备文件&gt;</p><p>将分区格式化为文件系统。 文件系统类型</p><p>示例：</p><p>sudo mkfs.reiserfs /dev/hda1</p><p>mkfs &lt;分区设备文件&gt;</p><p>-t &lt;文件系统类型&gt; 指定文件系统类型         -c 格式化前检查磁盘</p><p><strong>mkisofs -o &lt;<strong><strong>镜像文件</strong></strong>&gt; [<strong><strong>源文件目录</strong></strong>]</strong></p><p>用光盘或者文件制作iso镜像</p><p>-b 可启动镜像</p><p>hdparm &lt;磁盘设备文件&gt;</p><p>设置硬盘参数</p><p>-d &lt;0|1&gt; DMA模式开关       -a &lt;0|1&gt; 预计模式开关         -t 性能测试         -T 缓存性能测试</p><p>-c &lt;0|1|3&gt; 32位传输模式开关        -g 显示柱面，扇区等信息      -i -I 显示磁盘信息</p><h3 id="网络和硬件管理"><a class="header-anchor" href="#网络和硬件管理">¶</a>网络和硬件管理</h3><p>ifconfig</p><p>配置网络接口</p><p>-a 显示所有网络接口</p><p>ifconfig &lt;网卡&gt; up|down</p><p>激活|禁用网卡</p><p>示例： ::</p><p>sudo ifconfig eth0 up</p><p>ifconfig &lt;网卡&gt; add &lt;IP地址&gt; [ netmask &lt;子网掩码&gt; ]</p><p>给网卡指定IP地址或子网掩码</p><p>route</p><p>配置路由及网关</p><p>route add -net &lt;路由地址&gt; gw &lt;网关地址&gt; [ netmask &lt;子网掩码&gt; ] dev &lt;网卡&gt;</p><p>指定路由及网关</p><p>route del -net &lt;网关地址&gt; gw &lt;网关地址&gt; [ netmask &lt;子网掩码&gt; ]</p><p>删除路由及网关</p><p>ip</p><p>配置网络</p><p>子命令：</p><p>link 网卡配置       address 配置地址。相当于 ifconfig        route 配置路由。相当于 route</p><p>参数：</p><p>show 显示(默认)         set 设置       add 添加      del 删除</p><p>示例：</p><p>ip link show 显示网卡配置</p><p>ip link set eth0 name xxx 重命名网络接口</p><p>ping &lt;IP地址&gt;</p><p>向目标地址发送ICMP封包，常用来测试网络</p><p>-b &lt;广播地址&gt; ping整个网段        -c 发送封包次数         -s &lt;封包大小&gt; 默认为64字节</p><p>netstat</p><p>网络连接状态</p><p>-r 显示路由表，同 route       -a 所有连接        -t 只显示TCP协议      -U 只显示UDP协议</p><p>-l 只显示正在监听的端口      -p 显示PID和进程名         -c &lt;秒&gt; 刷新频率</p><p>* http/ftp/ssh…… 为应用层协议         * TCP/UDP为传输层协议      * IP/ICMP为网络层协议</p><p>lspci</p><p>查看PCI总线连接的设备</p><p>lsusb</p><p>查看USB接口连接的设备</p><p>lsmod</p><p>查看已加载模块</p><p>* /lib/modules/uname -r 目录下为所有可用模块</p><p>modprobe &lt;模块名称&gt;</p><h2 id="简明VIM教程"><a class="header-anchor" href="#简明VIM教程">¶</a>简明VIM教程</h2><h3 id="VIM简介"><a class="header-anchor" href="#VIM简介">¶</a>VIM简介</h3><p>我们使用的大多数编辑器，都可以直接在编辑区输入字符，并且能够通过一些快捷键来完成一些控制功能，比如使用方向键移动光标，使用</p><p>BackSpack 或者 Delete 键删除文字，使用 PgUp 和 PgDn 翻页，使用 Home 和 End 来定位行首和行末……</p><p>而Vim是一个带模式的编辑器，同样的按键，在不同模式下，具有不同的功能定义。例如 h j k l 在 编辑模式 下输入相应的字符，在 普通模式 下却相当于方向键的作用。</p><p>由于需要切换模式，Vim的使用起来略显繁琐。不过优点也显而易见：您只要把手安安稳稳的放在打字区就可以了，而不需要使用诸如方向键、排版键、小键盘等</p><p>需要挪开双手的键位，从而提高了您的效率和专注程度。事实上，Vim的前身Vi诞生的时候，键盘上还没有方向键、排版键和小键盘：）</p><h3 id="命令-2"><a class="header-anchor" href="#命令-2">¶</a>命令</h3><p>使用Vim编辑文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi [文件名]</span><br><span class="line">vim [文件名]</span><br></pre></td></tr></table></figure><p>教学模式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimtutor [语言]</span><br></pre></td></tr></table></figure><p>vim教程，相当于使用Vim编辑器以只读模式打开教程文件。您无论对这个文件作了什么，都会在退出后恢复原来的样貌。与只读模式的区别在于，它不会没有眼色的提醒您，现在的状态为只读模式。您可以使用它作一些练习</p><p>您可以指定教程文件的语言，如果使用本地语言(ZH_cn)出现乱码，您可以尝试使用英语</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimtutor en</span><br></pre></td></tr></table></figure><h3 id="使用Vim比较文件区别"><a class="header-anchor" href="#使用Vim比较文件区别">¶</a>使用Vim比较文件区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimdiff [文件1] [文件2] [其它文件]……</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a class="header-anchor" href="#配置文件">¶</a>配置文件</h3><p>Vim的全局配置文件为 /etc/vim/vimrc ，用户配置文件为 ~/.vimrc ， &quot; 起始的行为注释行。我们提供的配置项，您直接加入配置文件就可以了</p><p>您可以先对Vim进行一些简单的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&quot;设定文件编码</span><br><span class="line">set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span><br><span class="line"></span><br><span class="line">&quot;开启语法加亮</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">&quot;配色风格</span><br><span class="line">colorscheme pablo</span><br><span class="line"></span><br><span class="line">&quot;设定行距 GUI界面中生效</span><br><span class="line">set linespace=4</span><br><span class="line"></span><br><span class="line">&quot;设定GUI选项</span><br><span class="line">&quot;set guioptions=gmrLtT m:菜单 T:工具栏</span><br><span class="line">set guioptions=gmrLt</span><br><span class="line"></span><br><span class="line">&quot;设定Tab键缩进的空格数</span><br><span class="line">set tabstop=4</span><br><span class="line"></span><br><span class="line">&quot;设定编辑器将多少空格视为一个缩进</span><br><span class="line">set shiftwidth=4</span><br><span class="line"></span><br><span class="line">&quot;将缩进转换为空格</span><br><span class="line">&quot;set expandtab</span><br><span class="line"></span><br><span class="line">&quot;设定折叠方式</span><br><span class="line">&quot;set foldmethod=indent</span><br><span class="line"></span><br><span class="line">&quot;以下字符将被视为单词的一部分 (ASCII)：</span><br><span class="line">&quot;set iskeyword+=33-47,58-64,91-96,123-128</span><br></pre></td></tr></table></figure><h3 id="模式介绍"><a class="header-anchor" href="#模式介绍">¶</a>模式介绍</h3><p>Vim常见的模式有： <code>普通模式</code> 、 <code>插入模式</code> 、 <code>命令模式</code> ，另外我们也会经常用到 <code>可视模式</code> 。</p><p>Vim启动时进入 <code>普通模式</code> ；或者在其它模式下，按下 Esc 键，便可以回到<code>普通模式</code>。</p><p>使用 <code>vimtutor en</code> 命令进入教程，现在是普通模式。随便按几下 j 、 k 、 l 、 h 键，您会发现光标的位置发生改变。</p><p>按下 i 键，编辑器底部出现了 -- 插入 -- 或者 -- insert -- ，您进入了插入模式。随便按几下 j 、 k 、 l、 h，您会发现相应的字符出现在编辑区，现在还可以通过方向键来移动光标。可能您觉得使用方向键移动光标不是什么问题，但是习惯了Vim后，您会认为方向键太麻烦了，简直不能容忍！好了，现在按下 <code>Esc</code> 键回到普通模式，我们又可以使用 j 、 k 、 l 、 h 来移动光标了。</p><p>在<code>普通模式</code>下，按下 : 键（也就是 Shift+; ），在编辑器底部出现了一个 : ，您进入了命令模式。在 : 后输入一个命令 new ，回车后，编辑器被分割为上下两栏。为了方便起见，我们在命令前加一个 : 来表示命令模式下输入的命令，像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:vnew</span><br></pre></td></tr></table></figure><p>一个命令能够以一些规则简化，上面的命令也可以写为这种形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:vne</span><br></pre></td></tr></table></figure><p>现在您的编辑区一定弄的四分五裂，您可以使用命令<code>:quit</code>来关闭当前栏，直接用简写就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></table></figure><p>这个命令是退出编辑器，如果编辑区被分成多栏，则是退出当前栏。</p><p>执行完一个命令（按下回车后），编辑器会自动回到普通模式。如果您想不执行当前命令，直接回到普通模式，您可以按下Esc键。</p><p>按下 v 键，您进入了可视模式，可以使用 j 、 k 、 l 、 h 移动光标，高亮选取文本 。</p><p>事实上，可视模式相当于高亮选取文本后的普通模式。</p><p>可视模式具有子模式，以行为单位进行选取的可视行模式，使用 V 键进入（也就是 Shift+v ）；和以块为单位进行选取的可视块模式，使用 Ctrl+v 键进入。</p><h3 id="模式切换"><a class="header-anchor" href="#模式切换">¶</a>模式切换</h3><p>好了，现在我们总结一下模式间切换的方法</p><p>其它模式==&gt;普通模式</p><p>Esc</p><p>普通模式==&gt;插入模式</p><p>i 在光标前插入 I 在行首插入           a 在光标后插入 A 在行末插入</p><p>o 在当前行之下新建行 O 在当前行之上新建行          r 替换当前字符 R 从当前字符开始替换</p><p>普通模式==&gt;命令模式         普通模式==&gt;可视模式         v 可视模式         V 可视块模式</p><p>&lt;Ctrl+v&gt; 可视块模式</p><h3 id="移动"><a class="header-anchor" href="#移动">¶</a>移动</h3><p>在普通模式中，您可以使用以下方式移动光标</p><p>j 向下         k 向上        l 向右 h l      h 向左 j</p><p>您可以使用其它更有效率的方式移动光标</p><p>w 下一个单词词首 W 将特殊符号视为单词的一部分           b 上一个单词词首 B 同上</p><p>e 单词末尾 E 同上       0 行首 ^ 行首文字（行首空格之后）         $ 行末</p><p>H 页面顶部        M 页面中部        L 页面底部</p><p>在其它模式中，您可以使用方向键移动光标，不过我们不推荐您那样作，您可以在配置文件中绑定插入模式下的功能键</p><p>noremap! <m-j> <down></down></m-j></p><p>noremap! <m-k> <up></up></m-k></p><p>noremap! <m-h> <left></left></m-h></p><p>noremap! <m-l> <right></right></m-l></p><p>………………</p><p>&lt;作用范围&gt; &lt;键位&gt; &lt;功能&gt;</p><p>其中，map!绑定的键盘映射，作用于所有模式；inoremap!绑定的映射，仅作用于插入模式。</p><h3 id="数字参数"><a class="header-anchor" href="#数字参数">¶</a>数字参数</h3><p>您也可以使用数字参数，来重复执行。例如</p><p>100j 执行100次j键，向下100行</p><p>或者作为跳转的行号、百分比。见下面的浏览部分</p><p>&lt;行号&gt; Ctrl+g 按行号跳转</p><h3 id="标记"><a class="header-anchor" href="#标记">¶</a>标记</h3><p>您可以在当前光标处作一个标记，以便快速返回</p><p>m&lt;标记名称&gt; 定义标记。标记名称为一个字符</p><p>`&lt;标记名称&gt; 返回标记</p><p>mx 将当前光标处定义为标记 x</p><p>`x 返回标记 x</p><h3 id="浏览"><a class="header-anchor" href="#浏览">¶</a>浏览</h3><p>&lt;Ctrl+f&gt; 下翻一页 &lt;Ctrl+d&gt; 下翻半页        &lt;Ctrl+b&gt; 上翻一页 &lt;Ctrl+u&gt; 上翻半页</p><p>gg 文件首行        G 文件末行        &lt;行号&gt;G 按行号转到相应行</p><p>&lt;1~100&gt;% 按百分比转到相应的行数      zz 将光标所在行调整至页面中间</p><p>&lt;Ctrl+e&gt; 下卷一行       &lt;Ctrl+y&gt; 上卷一行</p><p>说明：gg 定位到文件首行， V 进入可视行模式， G 定位到文件末行，实现类似“全选”的功能。依次按下 g g V(Shift+v) G(Shift+g)</p><h3 id="编辑"><a class="header-anchor" href="#编辑">¶</a>编辑</h3><p>x 剪切当前字符              dd 剪切当前行      y 复制可视模式选取字符      yy 复制当前行</p><p>p 在光标后粘贴 P 在光标前粘贴        u 撤消        &lt;trl+r&gt; 重做</p><p>&lt;Ctrl+y&gt; 逐字克隆上一行内容           &lt;Ctrl+e&gt; 逐字克隆下一行内容</p><h3 id="寄存器操作"><a class="header-anchor" href="#寄存器操作">¶</a>寄存器操作</h3><p>Vim可以将不同字段剪切或复制到不同寄存器中，您可以从不同寄存器中取出内容后粘贴</p><p>&quot;&lt;寄存器名称&gt; 按下“&quot;”键和另一个字符键，便可以定义一个寄存器。例如：</p><p>&quot;a &quot;1</p><p>定义寄存器后直接进行操作</p><p>&quot;ayy 将当前行复制到寄存器 a 中</p><p>&quot;ap 将寄存器 a 中的内容粘贴到光标之后</p><p>* 通常情况下，寄存器 + ( &quot; + Shift+= )对应X下的剪贴板。您在其它程序中复制的内容，可以使用 &quot;+p 粘贴到Vim中；您在Vim中，可以使用 &quot;+y 将内容复制到剪贴板，再粘贴到其它程序中</p><p>* 没有指定寄存器时，Vim使用“无名寄存器”存储内容</p><h3 id="搜索和替换"><a class="header-anchor" href="#搜索和替换">¶</a>搜索和替换</h3><p>按下 / 键，编辑器底部会出现 / 符号，接着输入字符串，便可以进行搜索</p><p>/ 向下搜索 ? 向上搜索</p><p>n 搜索下一个</p><p>N 搜索上一个</p><p>:s/&lt;源字符串&gt;/&lt;目标字符串&gt; 将源字符串替换为目标字符串</p><p>:s/&lt;源字符串&gt;/&lt;目标字符串&gt;/g 替换当前行中所有符合条件的字符串</p><p>:&lt;行号1&gt;,&lt;行号2&gt;s/&lt;源字符串&gt;/&lt;目标字符串&gt;/g 在指定行中进行替换</p><p>:%s/&lt;源字符串&gt;/&lt;目标字符串&gt;/g 全文替换</p><h3 id="正则表达式"><a class="header-anchor" href="#正则表达式">¶</a>正则表达式</h3><p>在搜索和替换时，可以使用正则表达式进行匹配</p><h3 id="宏"><a class="header-anchor" href="#宏">¶</a>宏</h3><p>您可以将一系列的操作录制为一个宏，然后执行它</p><p>q&lt;宏名称&gt; 开始录制宏。宏名称为一个字符</p><p>q 录制中按下“q”键，结束录制</p><p>@&lt;宏名称&gt; 执行宏</p><p>插入模式下的快捷键</p><p>&lt;Ctrl+r&gt;&lt;寄存器名称&gt; 输入指定寄存器内容</p><p>&lt;Ctrl+k&gt;&lt;2个字符&gt; 输入二合字符</p><p>&lt;Ctrl+v&gt;&lt;数字&gt; 通过数字编码输入字符</p><p>&lt;Ctrl+v&gt;&lt;键位&gt; 输入键位的名称</p><h3 id="键绑定、缩写"><a class="header-anchor" href="#键绑定、缩写">¶</a>键绑定、缩写</h3><p>前面我们已经向您介绍了键绑定，</p><p>map! <m-j> <down></down></m-j></p><p>尖括号及其中的内容，为Vim配置文件的约定，分别描述了按键和功能，表示将功能编写到按键上。如果绑定的只是普通字符，例如：</p><p>map! xxx XXXXX</p><p>表示将 fXXXXX 绑定到 xxx 上。当您键入 xxx 时，编辑器会自动替换为 XXXXX 。</p><p>如果您只是想将字符串绑定为缩写，方便输入，我们建议您使用 iabbrev 来绑定。例如：</p><p>iabbrev ubt Ubuntu</p><p>在插入模式下键入 ubt ，编辑器会自动替换为 Ubuntu 。您可以将 iabbrev 命令缩写为 iab ，例如：</p><p>iab ubt Ubuntu</p><p>以上命令，您可以直接在命令模式下输入，临时启用。也可以写入配置文件，永久启用。</p><h3 id="单词补全"><a class="header-anchor" href="#单词补全">¶</a>单词补全</h3><p>&lt;Ctrl+n&gt; 下一个匹配项</p><p>&lt;Ctrl+p&gt; 上一个匹配项</p><p>您可以在配置文件中定义补全的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;自动补全方式：(使用逗号分隔)</span><br><span class="line">set complete=k,.</span><br><span class="line"></span><br><span class="line">&quot; . 当前文件</span><br><span class="line">&quot; b 已被装缓冲区,但是没有在窗口内的文件</span><br><span class="line">&quot; d 在当前的文件中定义和由#include包含进来的文件</span><br><span class="line">&quot; i 由#include包含进来的文件</span><br><span class="line">&quot; k 由dictionary选项定义的文件</span><br><span class="line">&quot; kfile 名为&#123;file&#125;的文件</span><br><span class="line">&quot; t 标记(tags)文件</span><br><span class="line">&quot; u 没有载入的缓冲区</span><br><span class="line">&quot; w 在其他窗口中的文件</span><br><span class="line">&quot;设定自动补全字典 ：</span><br><span class="line">set dictionary=path</span><br></pre></td></tr></table></figure><h3 id="命令模式"><a class="header-anchor" href="#命令模式">¶</a>命令模式</h3><p>前面介绍了普通模式和插入模式。我们发现，普通模式主要用来浏览和修改文本内容，而插入模式则用来向文本中添加内容。</p><p>而命令模式则多用于操作文本文件（而不是操作文本文件的内容），例如保存文件；或者用来更改编辑器本身的状态，例如设定多栏窗口、标签或者退出编辑器……</p><p>w(rote) 将更改写入文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w</span><br></pre></td></tr></table></figure><p>q(uit) 退出编辑器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></table></figure><p>某些情况下，编辑器会阻止命令的执行。例如您修改了文件，而没有保存，那么您使用 :q 命令退出时，编辑器就不会执行这条命令，而是提醒您保存文件。</p><p>这个时候，您可以在命令末尾追加 ! 来强制执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&lt;命令&gt;!</span><br></pre></td></tr></table></figure><p>例如 <code>:q!</code> ，即便您没有保存已修改的文件，使用此命令，编辑器也会放弃修改而强行退出</p><p>以 ! 引导一个Shell命令，则可以从Vim临时切换到Shell中，执行一个Shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!&lt;命令&gt;</span><br></pre></td></tr></table></figure><p>例如 :<code>!ls</code></p><h3 id="多栏窗口"><a class="header-anchor" href="#多栏窗口">¶</a>多栏窗口</h3><p>您可以使用以下命令，将当前窗口水平分为两栏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:new</span><br></pre></td></tr></table></figure><p>新建一栏空白窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:split</span><br></pre></td></tr></table></figure><p>将当前文件分两栏显示</p><p>同理，您可以使用下列命令，将当前窗口垂直分为两栏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:vnew</span><br><span class="line"></span><br><span class="line">:vsplit</span><br></pre></td></tr></table></figure><p>先按下 &lt;ctrl+w&gt; 键，再按下方向键 j 、 k 、 l 、 h ，您可以切换到其它栏；在当前栏中使用 :q 命令，可以退出当前栏，也可以使用其它命令，对当前栏作出修改</p><p>如果您希望当前命令在所有栏中生效，您可以在命令的末尾追加 all</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&lt;命令&gt;all</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:qall</span><br></pre></td></tr></table></figure><p>如果您希望这条命令强制执行，那么 ! 位于命令的最末</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&lt;命令&gt;all!</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:qall! 强行退出所有栏窗口</span><br></pre></td></tr></table></figure><h3 id="标签页"><a class="header-anchor" href="#标签页">¶</a>标签页</h3><p>Vim在7以后的版本，开始支持标签页的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:tabnew 新建一个标签</span><br><span class="line">:tabnext 转到下一个标签</span><br><span class="line">:tabprevious 转到上一个标签</span><br></pre></td></tr></table></figure><p>多数情况下，您可以使用鼠标点击标签进行切换。</p><h2 id="引导管理器Grub"><a class="header-anchor" href="#引导管理器Grub">¶</a>引导管理器Grub</h2><h3 id="硬件基础"><a class="header-anchor" href="#硬件基础">¶</a>硬件基础</h3><p>一块硬盘，它起始的一部分扇区为主引导扇区，包括MBR（主引导纪录）和DPT（分区表，您可以阅读分区概念章节中相关内容）</p><p>每个分区起始的一部分扇区，为分区引导扇区。</p><p>在分区引导扇区之后的部分，为文件系统的索引，文件系统通过它定位文件在硬盘上的位置。不同的文件系统采用不同的索引，例如FAT文件系统使用文件分配表和目录区。</p><p>绝大多数操作系统，对硬盘的读写操作，通过文件系统来完成，因此引导扇区中的内容，我们不能够在文件系统中进行操作，而需要专用软件，比如引导管理器。</p><p>我们对文件进行修改后，操作系统会将文件系统索引中的内容同步。</p><h3 id="系统引导流程"><a class="header-anchor" href="#系统引导流程">¶</a>系统引导流程</h3><p>1.系统启动时，首先引导至MBR，将控制权移交安装在MBR中的引导管理器</p><p>（Windows使用NTLDR，Linux通常用Grub）</p><p>2.引导管理器读取分区表</p><p>3.引导管理器读取分区中的配置文件，并按配置文件中预设的参数运行</p><p>例如，Grub读取“/boot/grub/menu.lst”文件中内容，将可引导系统通过菜单显示</p><p>4.引导管理器根据您的选择，可能会有如下活动</p><p>加载内核，启动Linux系统检查活动分区，并引导它（单一Windows系统）读取相应分区的引导扇区，将控制权移交该扇区中的引导管理器，Ubuntu系统在安装Grub时，会提问您安装在MBR或者分区引导扇区中。如果将Grub安装在分区引导纪录中，您必须确保MBR中的引导管理器能够正确的引导至分区引导扇区。</p><p>如果您在MBR中使用的是Windows的引导管理器NTLDR，完成这件工作会非常困难，因而我们推荐您使用Grub。</p><h3 id="Grub介绍"><a class="header-anchor" href="#Grub介绍">¶</a>Grub介绍</h3><p>Grub主要有以下功能：</p><ul><li>菜单式选择</li><li>命令行模式</li><li>支持开机画面</li><li>支持大硬盘</li></ul><p>其它的功能还有很多，就不一一介绍了。</p><p>您可以运行命令 grub 启动它。会显示一些版本信息和使用提示，当然还有命令提示符，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GNU GRUB version 0.97 (640K lower / 3072K upper memory)</span><br><span class="line">[ Minimal BASH-like line editing is supported. For the first word, TAB lists possible <span class="built_in">command</span> completions. Anywhere <span class="keyword">else</span> TAB lists the possible completions of a device/filename. ]</span><br><span class="line">grub&gt;</span><br></pre></td></tr></table></figure><p>您可以使用 TAB 键补全命令和路径，这非常重要，因为Grub中路径表示方式与操作系统是不同的，您可能比较陌生，所以尽量用TAB补全它，既方便，也不容易出错。</p><p>您可以在 grub&gt; 提示符后按 TAB 键，会将所有可用的命令显示出来。</p><p>呵呵，是不是有点晕，命令可真不少啊！！！</p><p>其实我们会用到的命令只有两个，</p><p>root</p><p>setup</p><h3 id="Grub术语"><a class="header-anchor" href="#Grub术语">¶</a>Grub术语</h3><p>在分区概念章节里，我们已经介绍了Linux系统中表示分区的方法 /dev/hda5</p><p>/dev/hdMN M为a起始的小写字母，表示硬盘序号；N为1起始的数字，表示分区序号</p><p>Grub中使用的表示方法为 hd0,1</p><p>hdX,Y X为0起始的数字，表示硬盘序号；Y为0起始的数字，表示分区序号</p><p>您得留意它们之间的区别：</p><p>N从1开始计数，X和Y从0开始计数</p><p>N为1~4，它是一个主分区；N为5或大于5，它是第(N-4)个逻辑分区。Y按分区在硬盘上排列的顺序排列，无论它表示的是主分区还是逻辑分区。</p><p>举例来说：</p><p>主 主 逻 逻 主</p><p>/dev/hdMN hda1 hda2 hda5 hda6 hda3</p><p>hdX,Y hd0,0 hd0,1 hd0,2 hd0,3 hd0,4</p><p>现在我们来看 root 和 setup 命令的使用：</p><p>grub&gt;root (hd0,1)</p><p>这个命令将Grub的根分区定位为 “(hd0,1)”</p><p>grub&gt;setup (hd0)</p><p>这个命令表示将Grub安装在“(hd0)”，因为没有指定安装的分区，所以安装位置为MBR</p><p>Grub的根分区 为Grub配置文件 /boot/grub/menu.lst 所在分区。假如您单独为 /boot 目录挂载了一个分区，那么Grub的根分区通常为您系统中 /boot 目录所在的分区。</p><p>搞错了根分区，Grub就不能正确读取配置文件，自然不能正确引导。</p><p>引导分区 ，Windows等系统的引导分区为它的安装分区，Linux系统的引导分区为它的 /boot 目录所在的分区</p><p>系统根目录所在分区 ，Linux根目录 / 的挂载分区。Linux系统的分区挂载信息保存在文件系统分配表 /etc/fstab 文件中</p><p>Grub首先读取根分区中的 /boot/grub/menu.lst</p><p>文件，并转到引导分区，如果是Windows等系统，则将控制权移动分区引导扇区中的启动管理器。如果是Linux系统，则加载内核和设备，并根据</p><p>/etc/fstab 文件的内容挂载文件系统。</p><p>看这个例子：（假设Grub安装在MBR中）</p><p>title Ubuntu</p><p>root (hd0,0)</p><p>kernel (hd0,1)/boot/vmlinuz-2.6.15-25-686 root=/dev/sda3 ro splash vga=0x31b</p><p>initrd (hd0,1)/boot/initrd.img-2.6.15-25-686</p><p>boot</p><p>Grub的安装位置为 (hd0)</p><p>root (hd0,0) ，这一行表示Grub的根分区为第一块硬盘的第一个分区 (hd0,0) ，它读取该分区中的配置文件 grub/menu.lst</p><p>kernel 和 initrd 行中的 (hd0,1) ，表示当前系统的 /boot 目录挂载到第一块硬盘的第二个分区 (hd0,1)</p><p>kernel 行的 root=/dev/sda3 ，表示当前系统的 / 目录挂载到第一块硬盘的第三个分区 (hd0,2) ，内核根据该分区中的 /etc/fstab 文件来挂载文件系统</p><h3 id="Grub配置文件"><a class="header-anchor" href="#Grub配置文件">¶</a>Grub配置文件</h3><p>/boot/grub/menu.lst 文件，主要由一些下面这样的块构成的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title Ubuntu</span><br><span class="line">root (hd0,2)</span><br><span class="line">kernel (hd0,2)/boot/vmlinuz-2.6.15-25-686 root=/dev/sda3 ro splash vga=0x31b</span><br><span class="line">initrd (hd0,2)/boot/initrd.img-2.6.15-25-686</span><br><span class="line">boot</span><br><span class="line">title Windows xp</span><br><span class="line">root (hd0,0)</span><br><span class="line">makeactive</span><br><span class="line">chainloader +1</span><br></pre></td></tr></table></figure><p>每一块代表一个操作系统，包含下面里几个部分</p><p>title xxx 标题，title和分隔符后的内容为Grub菜单中显示的条目</p><p>root (hdX,Y) 引导分区，可以留空，默认为 grub/menu.lst 所在分区（根分区），可以使用 grub&gt;root (hdX,Y) 命令设置，或者在您安装系统时自动设置</p><p>如果您计划引导至分区引导扇区，如Windows或者Unix系统（Unix和Linux系统，您需要选择将引导管理器安装到分区中），那么需要这样配置</p><p>makeactive 设置活动分区，系统默认设置，可以删除</p><p>chainloader +1 链式引导，不要动它。</p><p>如果以这种方式引导系统，上面 root (hdX,Y) 这一行通常需要配置， (hdX,Y) 为您的系统所在的分区。假如您的Windows在第一块硬盘的第一个分区，则这样写 root (hd0,0)</p><p>如果您引导的是Linux系统（没有在分区中安装引导管理器，而是安装到MBR），则需要这样配置</p><p>kernel (hd0,2)/boot/vmlinuz-2.6.15-25-686 root=/dev/sda2 ro splash vga=0x31b</p><p>initrd (hd0,2)/boot/initrd.img-2.6.15-25-686 设备镜像文件，与上一行保持一致</p><p>boot 不要动它</p><p>kernel 这一行最关键，它控制系统内核的加载。行末以 ro 起始的部分为参数（ro只读，splash显示启动画面，vga设定启动屏幕分辨率）</p><p>之前的部分可以写为这种形式：</p><p>kernel (hdX,Y)/boot/vmlinuz root=/dev/sdMN</p><p>(hdX,Y) 通常不是必须的，如果您安装了多个Linux系统，或者 /boot<code>目录与根目录 </code>/ 不在一个分区，则应把它写为 /boot 目录所在分区。而后面的 root=/dev/sdMN 为系统根目录 / 所在的分区。</p><p>initrd 这一行的 (hdX,Y) 与上一行保持一致。</p><h3 id="Grub安装"><a class="header-anchor" href="#Grub安装">¶</a>Grub安装</h3><p>上面已经向您介绍了Grub的安装，不过更多的侧重理论。现在我们来实践一下，假设您的系统不能引导，您可以尝试下面的方法：）</p><ol><li></li></ol><ul><li>找一张Ubuntu的LiveCD （Knoppix也是不错的选择）</li><li>也可以使用安装光盘，启动后在 boot 提示符后输入 linux rescue ，回车进入救援模式。</li><li>如果您拥有root权限，命令行提示符为 # ，如果是普通用户，则为 $ 。</li></ul><blockquote><p>在救援模式下，通常你已经具有了root权限</p></blockquote><blockquote><p>如果是LiveCD且没有root权限，请在终端中输入 su命令切换到root，会提问你root的密码。如果不知道root密码，可以使用这个命令 sudo su，只要你知道自己的密码，并且你在ID在sudoer列表中就可以了。</p></blockquote><ol start="2"><li>在终端中输入 grub ，会进入到Grub的提示符界面</li></ol><p>a. 输入命令 root (hd 后按 Tab 键，屏幕上就会列出所有可用选项。比如我的是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Possible disks are: hd0 hd1</span><br></pre></td></tr></table></figure><p>这表示我装了两块硬盘，如果你只有一块硬盘的话，那么一定是hd0。</p><p>在 root(hd 后输入 0 ,按 Tab ，会自动补上一个 , ，现在你输入的内容成为这样：</p><p>root(hd0,</p><p>再按 Tab 键，会列出所有可用选项，我的是这样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Possible partitions are:</span><br><span class="line">Partition num: 0, Filesystem type unknown, partition type 0x7</span><br><span class="line">Partition num: 1, Filesystem type is fat, partition type 0xc</span><br><span class="line">Partition num: 2, Filesystem type is reiserfs, partition type 0x83</span><br><span class="line">Partition num: 4, Filesystem type is reiserfs, partition type 0x83</span><br><span class="line">Partition num: 5, Filesystem type unknown, partition type 0x82</span><br><span class="line">Partition num: 6, Filesystem type unknown, partition type 0x7</span><br><span class="line">Partition num: 7, Filesystem type is fat, partition type 0xc</span><br></pre></td></tr></table></figure><p>输入你的选择，比如为 1 ， Tab 一次后，结果是这样的：</p><p>root (hd1,1)</p><p>现在回车</p><p>输入命令</p><p>setup (hd0)</p><p>将grub安装在mbr中</p><p>最后，quit 命令退出GRUB</p><h3 id="Grub使用"><a class="header-anchor" href="#Grub使用">¶</a>Grub使用</h3><p>命令行</p><p>在Grub启动菜单中，您可以选择您要的选项，按下 e 键，进入到命令行模式</p><p>修改您的启动参数，完成后回车</p><p>按 b 键，Grub将以您修改后的参数引导系统。</p><h3 id="其它-2"><a class="header-anchor" href="#其它-2">¶</a>其它</h3><p>在Grub启动菜单中，按下 c 进入命令行模式</p><p>按下 d 删除当前选中的项</p><h2 id="FAQ"><a class="header-anchor" href="#FAQ">¶</a>FAQ</h2><h3 id="我的D盘到哪里去了？"><a class="header-anchor" href="#我的D盘到哪里去了？">¶</a>我的D盘到哪里去了？</h3><p>在使用Linux最初的几天里，我感到有些不安。</p><p>Windows下，我可以把系统装在C盘，软件放在D盘，音乐放在E盘……如果系统出现问题，我只要重装系统就可以了，大部分软件都可以直接使用（养成使</p><p>用绿色软件是一种好习惯：），而我辛辛苦苦收集起来的电影和音乐，我总是把它们放在一个安全的地方，以免引发失眠的严重后果。</p><p>其实Linux下硬盘也具有分区的概念，这一点和Windows没有什么不同（分区的概念是由硬盘的物理特性产生的，而不是操作系统）。不同的是，Linux可以将分区挂载到任意的目录下，而不像Windows，您的分区只能够在“我的电脑”里面：）</p><p>那么这么作有什么好处么？</p><p>我们来看看Linux和Windows下路径的表示方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows C:\Documents and Settings\Users\Documents\MyDocument</span><br><span class="line"></span><br><span class="line">Linux /home/User/MyDocument</span><br></pre></td></tr></table></figure><p>您一定注意到了，在Windows下面，路径中含有盘符“C:”，它通常代表您硬盘上的第一个分区。也就是说，在使用这些文件时，您需要知道它们在硬盘上</p><p>存储的相关物理细节。而在Linux下，您不需要知道这些，或者说，只要您设定好了分区挂载的目录，您就不需要再去理会什么分区。</p><p>Windows下的路径包含有分区、目录和文件三部分内容;而Linux下的路径则只有目录和文件，不包含任何分区信息，它的硬件抽象度更高！</p><p>Linux下的目录用“/”表示，这不标准吧？？</p><p>完全相反，这才是标准的体现。您只是习惯了Windows的目录符号，但是那并不意味着它是标准的。</p><p>看看Winodws下，各种位置、路径的表示方法：</p><p><a href="http://www.ubuntu.org.cn" target="_blank" rel="noopener">http://www.ubuntu.org.cn</a></p><p><a href="ftp://192.168.0.1" target="_blank" rel="noopener">ftp://192.168.0.1</a></p><p>c:\Windows\</p><p>file:///C:/Windows/</p><p>\127.0.0.1$C</p><h3 id="操作系统是一种非常精密的高科技产品，怎么可能如此混乱！！！他们是怎么作到的？？？"><a class="header-anchor" href="#操作系统是一种非常精密的高科技产品，怎么可能如此混乱！！！他们是怎么作到的？？？">¶</a>操作系统是一种非常精密的高科技产品，怎么可能如此混乱！！！他们是怎么作到的？？？</h3><p>Linux下的病毒少，是因为Linux的使用者少，骇客显然不愿意浪费气力去攻击没有人使用的操作系统。</p><p>您可能已经知道了，互联网上用作重要用途的服务器，其中很大一部分是Linux系统，另外的一部分是Unix系统：）如果骇客能够搞掉Linux系统的话，那么整个互联网就会陷于瘫痪！效果似乎更好一些。</p><p>当然了，您一定会想：骇客也是人，他们也喜欢上网，兔子还不吃窝边草呢……兔子那么笨，连乌龟都跑不过……骇客们可比兔子要聪明的多了！</p><p>是的，我承认这一点……不过他们也不一定非得把互联网干掉。很多骇客作梦都想入侵美国军方的服务器，美军服务器中的绝密数据，只要1kb，应该就可以买一台顶级的个人电脑了：）</p><p>如果可以的话，骇客为什么不去入侵美军的服务器，而要入侵您的电脑呢？</p><p>这是一个很有意思的观点，与之相映成趣，另一种论调也使人侧目：Windows服务器占到了服务器操作系统xx%的份额。</p><p>或许这个现象可以用80：20法则来解释：）</p><p>占服务器总数80%的Windows提供了服务总量的20%！</p><p>请您务必注意，这只是举一个例子，Windows服务器可能永远也不会占到服务器总数的80%！它提供的服务，以我个人的角度，我不认为可以达到20%，而且永远不会有那一天。</p><h3 id="软件安装繁琐"><a class="header-anchor" href="#软件安装繁琐">¶</a>软件安装繁琐</h3><p>或许您已经看过一些关于Linux软件安装的文章，但是您也不要忽略，此类文章的数量，是不能够和同类Windows文章相比的。</p><p>当然，使用源码包安装软件确实有点麻烦，但却不一定比Windows下的某些软件复杂。特别要提到，Ubuntu的包管理系统，为您提供了一种高效快捷的</p><p>软件管理方式，您只要知道您需要什么软件就可以了，甚至不需要关心它存放在网络上的哪一台服务器中，而且绝大多数的软件都可以使用这种方式来安装。</p><p>详情请参阅 APT</p><p>如果您有如下需求，您也可以尝试以源码的形式安装软件：</p><p>您需要某些软件的技术预览版本</p><p>您想测试您的机器的运算能力</p><p>您找不到一种比安装软件更好的方式来消磨时间 | （试图通过编译源码安装来大幅提高系统性能，其结果很可能会让您失望）</p><h3 id="源码保密性不强，存在安全隐患"><a class="header-anchor" href="#源码保密性不强，存在安全隐患">¶</a>源码保密性不强，存在安全隐患</h3><p>既然Linux下软件都开放源代码，那么会不会造成一些安全隐患呢？比如说一名骇客会发现其中的漏洞，并利用它？</p><p>事实刚好相反，一个软件，即便它不开放源码，骇客一样可以找到其中的漏洞，雷蒙德的软件巨头就是最好的佐证。就像一把锁，无论如何坚固，它总是能被撬开！它的作用无外乎“聊备一格，以防君子”：）</p><p>而这把锁，防住的恰恰是能够改进它的工程师！工程师知道了它的漏洞，却不能够去改进它;骇客知道了它的漏洞，却可以利用它……这把锁正是封闭源码！</p><p>这岂不是不妙？</p><h3 id="软件功能不够强"><a class="header-anchor" href="#软件功能不够强">¶</a>软件功能不够强</h3><p>虽然您很愿意使用Linux系统，但是它的软件并不能使您满意，甚至使您多愁善感的心灵又蒙上了一层阴影，“长太息以掩涕……”</p><p>首先您别忘了，《泰坦尼克》的特效就是在Linux系统下完成的，连业界巨头SGI都在向Linux迁移（尽管SGI的IRIX本来就是一种Unix系统）。如果您不知道SoftImage，那么Maya您总听说过吧？它最初就是多平台的。</p><p>对于电影特效处理时需要的高吞吐量的数据（以TB计）和运算能力，Windows系统恐怕连崩溃的机会都没有=_=#(最新统计资料显示，Top500计算机中，使用Linux的占到73.4%，包括最快的前两名。其中Linux系统367部，Unix系统98部，混合操作系统24部，AppleMacOS系统5部,BSD系统4部，Windows系统，2部）类似于大气模拟、基因解码等等真正的科学运算……Windows……前几天我还在verycd.com上看到一套欧洲某天文台的天文学软件，只有Linux版！</p><p>当然了，Linux下功能强大的软件大多是命令行的，图形界面的程序只能视觉上强大，外强中干！建议您多使用man这个命令来查询各类软件的使用方法，它排版美观，格式工整，语法简明，意韵流畅，实在是学习英语难得的教材。</p><h3 id="界面不友好"><a class="header-anchor" href="#界面不友好">¶</a>界面不友好</h3><p>如果您指的是系统的美观程度。Gnome默认效果我认为与Windows处于同一水平线，而KDE的效果就要略好一点，很多高手用FVWM可以作出让人眼花瞭乱的效果来……而Novell的XGL，更是可以用“惊艳”来形容。</p><p>如果您指的是操作，这属于“易于上手难于精通”与“难于上手易于精通”两种理念的冲撞。</p><p>当然了，我指的精通主要针对效率而言。如果您经常玩Blizzard出品的游戏，您对于“易于上手难于精通”这种理念或许相当了解，甚至非常欣赏。</p><p>不过这一理念只适用于竞技游戏！竞技游戏要球能够吸引大量的玩家，所以要易于上手。但是竞技游戏是为竞技而生的，所以不可能人人是高手 ────事实上高手只是一小部分人！</p><p>而操作系统是给人们来用的，最好人人都成为高手，所以易于精通是很重要的……当然最好也能够易于上手。但是考虑到效率的问题，这很难解决……</p><h3 id="Linux怎么占用这么多内存？"><a class="header-anchor" href="#Linux怎么占用这么多内存？">¶</a>Linux怎么占用这么多内存？</h3><p>Linux会最大程度的利用物理内存，避免使用交换空间;而不是尽量的回收内存，使用页面文件。</p><p>又因为Linux系统的内存管理非常优秀，程序退出时可以高效的回收内存，所以更加没有必要在程序运行时就回收内存！</p><p>因此，Linux系统表面看来内存开销很大，实际上系统运行是很稳定的──Linux不会时而流畅，时而瘫痪。事实上，在正常情况下，它运行是非常流畅的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ref:&lt;a href=&quot;http://www.cnblogs.com/dutlei/archive/2012/11/20/2778327.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu完全教程，让你成为Ubuntu高手！&lt;/a&gt;
todo整理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Ubuntu的发音&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Ubuntu的发音&quot;&gt;¶&lt;/a&gt;Ubuntu的发音&lt;/h2&gt;
&lt;p&gt;Ubuntu，源于非洲祖鲁人和科萨人的语言，发作 oo-boon-too 的音。了解发音是有意义的，您不是第一个为此困惑的人，当然，也不会是最后一个：）&lt;/p&gt;
&lt;p&gt;大多数的美国人读 ubuntu 时，将 u 作为元音发音，类似单词 who 或者 boo ，重音在第二个音节即 u&#39;buntu ，oo-boon-too 。&lt;/p&gt;
&lt;p&gt;如果您喜欢撒哈拉，喜欢它令人窒息的温柔、梦幻般的寂寥还有张扬恣肆的旷远，您大可在第一个 u，后面带些嗡嗡声： oom-boon-too。&lt;/p&gt;
&lt;p&gt;Ubuntu的中文发音大约为： 乌班图&lt;/p&gt;
&lt;h3 id=&quot;Ubuntu的涵义&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Ubuntu的涵义&quot;&gt;¶&lt;/a&gt;Ubuntu的涵义&lt;/h3&gt;
&lt;p&gt;Ubuntu这个单词源自非洲，意谓“班图精神”────谁都不是一座孤岛，自成一体。每个人都包孕于人类，因他人存在而存在，因他人幸福而幸福。&lt;/p&gt;
&lt;h3 id=&quot;Ubuntu当前版本&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Ubuntu当前版本&quot;&gt;¶&lt;/a&gt;Ubuntu当前版本&lt;/h3&gt;
&lt;p&gt;Ubuntu Linux v6.06 LTS (Dapper Drake)&lt;/p&gt;
&lt;p&gt;LTS：Long Term Support&lt;/p&gt;
&lt;p&gt;Dapper Drake：当前版本的开发代号&lt;/p&gt;
&lt;h3 id=&quot;Ubuntu的特点&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Ubuntu的特点&quot;&gt;¶&lt;/a&gt;Ubuntu的特点&lt;/h3&gt;
&lt;p&gt;Ubuntu 完全基于 Linux 操作系统， 可以免费得到社区及专业机构的支持。庞大的社区是它成长的沃土，请向这片动人的热忱敞开心扉。&lt;/p&gt;
&lt;p&gt;Ubuntu 社区恪守 Ubuntu 理念：自由！软件应是自由的，应尊重人类的自由意志，它与人类之间不应有任何隔膜。本地语种，功能限制，自主改进的权利……都不应成为使用的障碍或负担。&lt;/p&gt;
&lt;p&gt;自由，让 Ubuntu 与传统的私有软件从根本上不同: 免费不能用来遮羞，您有权修正它，直到满意为止。&lt;/p&gt;
&lt;p&gt;Ubuntu 适合桌面和服务器。当前 Ubuntu 发布版支持 PC (Intel x86), 64-bit PC (AMD64) 和 PowerPC (Apple iBook 和 Powerbook, G4 和 G5) 架构。&lt;/p&gt;
&lt;p&gt;Ubuntu 包涵了超过 16,000 种软件， 核心的桌面系统却只有一张光盘， Ubuntu 覆盖了所有的桌面应用程序,&lt;/p&gt;
&lt;p&gt;从文字处理，电子表格到 web 服务器和开发设计环境一应俱全。 详情查看 Ubuntu 桌面 和 Ubuntu 服务器的介绍。&lt;/p&gt;
&lt;h3 id=&quot;Ubuntu相对其它Linux发行版的主要特点&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Ubuntu相对其它Linux发行版的主要特点&quot;&gt;¶&lt;/a&gt;Ubuntu相对其它Linux发行版的主要特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基于Debian/Linux，使用 APT 包管理系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相对于Fedora Code： APT 包管理系统优雅地解决了依赖问题，并且可以从容的在线安装升级&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相对于Debian：软件更新积极，而Debian较保守。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相对于Gentoo：基本无需编译，省力、省时、省心。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://talengu.github.io/public/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://talengu.github.io/public/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Ubuntu" scheme="https://talengu.github.io/public/tags/Ubuntu/"/>
    
  </entry>
  
</feed>
