<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一塘</title>
  
  
  <link href="/public/atom.xml" rel="self"/>
  
  <link href="https://talengu.github.io/public/"/>
  <updated>2022-01-09T16:49:44.000Z</updated>
  <id>https://talengu.github.io/public/</id>
  
  <author>
    <name>一塘</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>征服14座高峰：凡事皆有可能</title>
    <link href="https://talengu.github.io/public/2022/01/09/14peak/"/>
    <id>https://talengu.github.io/public/2022/01/09/14peak/</id>
    <published>2022-01-09T16:49:44.000Z</published>
    <updated>2022-01-09T16:49:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简介</strong></p><p>14 Peaks: Nothing Is Impossible (2021)</p><p>无畏的尼泊尔登山运动员尼姆斯·普贾开始了一项看似不可能完成的任务：在7个月内登顶全球14座8000米高峰。（2019年度完成的Possible plan）</p><p>最近，我看完了该记录片，摘录了些语句，鼓励自己不断进取，征服人生的一座座高峰，追寻梦想，不忘初心！</p><p><img src="/public/2022/01/09/14peak/2022-01-09-16-49-12.png" alt></p><a id="more"></a><h2 id="追寻梦想！"><a class="header-anchor" href="#追寻梦想！">¶</a>追寻梦想！</h2><p><img src="/public/2022/01/09/14peak/2022-01-09-17-20-35.JPG" alt></p><h2 id="不忘初心！"><a class="header-anchor" href="#不忘初心！">¶</a>不忘初心！</h2><p><img src="/public/2022/01/09/14peak/20220109_hello.JPG" alt></p><h2 id="最后"><a class="header-anchor" href="#最后">¶</a>最后</h2><p>山不向我走来，我便向他走去！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;14 Peaks: Nothing Is Impossible (2021)&lt;/p&gt;
&lt;p&gt;无畏的尼泊尔登山运动员尼姆斯·普贾开始了一项看似不可能完成的任务：在7个月内登顶全球14座8000米高峰。（2019年度完成的Possible plan）&lt;/p&gt;
&lt;p&gt;最近，我看完了该记录片，摘录了些语句，鼓励自己不断进取，征服人生的一座座高峰，追寻梦想，不忘初心！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/public/2022/01/09/14peak/2022-01-09-16-49-12.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="影视" scheme="https://talengu.github.io/public/categories/%E5%BD%B1%E8%A7%86/"/>
    
    
      <category term="记录片" scheme="https://talengu.github.io/public/tags/%E8%AE%B0%E5%BD%95%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>【转】一文看懂Linux内核！Linux内核架构和工作原理详解</title>
    <link href="https://talengu.github.io/public/2021/12/23/linux/linux_in_one/"/>
    <id>https://talengu.github.io/public/2021/12/23/linux/linux_in_one/</id>
    <published>2021-12-23T22:45:31.000Z</published>
    <updated>2021-12-23T22:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>全文导读</p><ul><li><a href>Linux 内核预备工作</a></li><li><a href>Linux 内核体系结构简析</a></li><li><a href>Linux 体系结构和内核结构区别</a></li><li><a href>Linux 驱动的 platform 机制</a></li><li><a href>Linux 内核体系结构</a></li><li><a href>内核模块</a></li><li><a href>Linux 内核学习经验总结</a></li><li><a href>结尾</a></li></ul><a id="more"></a><h2 id="Linux-内核预备工作"><a class="header-anchor" href="#Linux-内核预备工作">¶</a>Linux 内核预备工作</h2><p>理解 Linux 内核最好预备的知识点：</p><p>懂 C 语言<br>懂一点操作系统的知识<br>熟悉少量相关算法<br>懂计算机体系结构</p><p>Linux 内核的特点：</p><p>结合了 unix 操作系统的一些基础概念</p><img src="/public/2021/12/23/linux/linux_in_one/174749211_2_20191103041018392.jpeg" alt="174749211_2_20191103041018392" style="zoom:50%;"><img src="/public/2021/12/23/linux/linux_in_one/174749211_3_20191103041018455.jpeg" alt="174749211_3_20191103041018455" style="zoom:60%;"><p>Linux 内核的任务：</p><ol><li><p>从技术层面讲，内核是硬件与软件之间的一个中间层。作用是将应用层序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。</p></li><li><p>从应用程序的层面讲，应用程序与硬件没有联系，只与内核有联系，内核是应用程序知道的层次中的最底层。在实际工作中内核抽象了相关细节。</p></li><li><p>内核是一个资源管理程序。负责将可用的共享资源 (CPU 时间、磁盘空间、网络连接等) 分配得到各个系统进程。</p></li><li><p>内核就像一个库，提供了一组面向系统的命令。系统调用对于应用程序来说，就像调用普通函数一样。<br>内核实现策略：</p></li><li><p>微内核。最基本的功能由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信。</p></li><li><p>宏内核。内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。目前支持模块的动态装卸 (裁剪)。Linux 内核就是基于这个策略实现的。<br>哪些地方用到了内核机制？</p></li><li><p>进程（在 cpu 的虚拟内存中分配地址空间，各个进程的地址空间完全独立; 同时执行的进程数最多不超过 cpu 数目）之间进行通   信，需要使用特定的内核机制。</p></li><li><p>进程间切换 (同时执行的进程数最多不超过 cpu 数目)，也需要用到内核机制。</p></li></ol><p>进程切换也需要像 FreeRTOS 任务切换一样保存状态，并将进程置于闲置状态 / 恢复状态。</p><ol start="3"><li><p>进程的调度。确认哪个进程运行多长的时间。<br>Linux 进程</p></li><li><p>采用层次结构，每个进程都依赖于一个父进程。内核启动 init 程序作为第一个进程。该进程负责进一步的系统初始化操作。init 进程是进程树的根，所有的进程都直接或者间接起源于该进程。</p></li><li><p>通过 pstree 命令查询。实际上得系统第一个进程是 systemd，而不是 init（这也是疑问点）</p></li><li><p>系统中每一个进程都有一个唯一标识符 (ID), 用户（或其他进程）可以使用 ID 来访问进程。</p></li></ol><p>Linux 内核源代码的目录结构</p><p>Linux 内核源代码包括三个主要部分：</p><ol><li><p>内核核心代码，包括第 3 章所描述的各个子系统和子模块，以及其它的支撑子系统，例如电源管理、Linux 初始化等</p></li><li><p>其它非核心代码，例如库文件（因为 Linux 内核是一个自包含的内核，即内核不依赖其它的任何软件，自己就可以编译通过）、固件集合、KVM（虚拟机技术）等</p></li><li><p>编译脚本、配置文件、帮助文档、版权说明等辅助性文件</p></li></ol><p>使用 ls 命令看到的内核源代码的顶层目录结构，具体描述如下。</p><p>include/ ---- 内核头文件，需要提供给外部模块（例如用户空间代码）使用。</p><p>kernel/ ---- Linux 内核的核心代码，包含了 3.2 小节所描述的进程调度子系统，以及和进程调度相关的模块。</p><p>mm/ ---- 内存管理子系统（3.3 小节）。</p><p>fs/ ---- VFS 子系统（3.4 小节）。</p><p>net/ ---- 不包括网络设备驱动的网络子系统（3.5 小节）。</p><p>ipc/ ---- IPC（进程间通信）子系统。</p><p>arch// ---- 体系结构相关的代码，例如 arm, x86 等等。<br>    arch//mach- ---- 具体的 machine/board 相关的代码。<br>    arch//include/asm ---- 体系结构相关的头文件。<br>    arch//boot/dts ---- 设备树（Device Tree）文件。</p><p>init/ ---- Linux 系统启动初始化相关的代码。<br>block/ ---- 提供块设备的层次。<br>sound/ ---- 音频相关的驱动及子系统，可以看作 “音频子系统”。<br>drivers/ ---- 设备驱动（在 Linux kernel 3.10 中，设备驱动占了 49.4 的代码量）。</p><p>lib/ ---- 实现需要在内核中使用的库函数，例如 CRC、FIFO、list、MD5 等。<br>crypto/ ----- 加密、解密相关的库函数。<br>security/ ---- 提供安全特性（SELinux）。<br>virt/ ---- 提供虚拟机技术（KVM 等）的支持。<br>usr/ ---- 用于生成 initramfs 的代码。<br>firmware/ ---- 保存用于驱动第三方设备的固件。</p><p>samples/ ---- 一些示例代码。<br>tools/ ---- 一些常用工具，如性能剖析、自测试等。</p><p>Kconfig, Kbuild, Makefile, scripts/ ---- 用于内核编译的配置文件、脚本等。</p><p>COPYING ---- 版权声明。<br>MAINTAINERS ---- 维护者名单。<br>CREDITS ---- Linux 主要的贡献者名单。<br>REPORTING-BUGS ---- Bug 上报的指南。</p><p>Documentation, README ---- 帮助、说明文档。</p><h2 id="Linux-内核体系结构简析"><a class="header-anchor" href="#Linux-内核体系结构简析">¶</a>Linux 内核体系结构简析</h2><p><img src="/public/2021/12/23/linux/linux_in_one/174749211_4_20191103041018502.jpeg" alt="174749211_4_20191103041018502"></p><p>图 1 Linux 系统层次结构</p><p>最上面是用户（或应用程序）空间。这是用户应用程序执行的地方。用户空间之下是内核空间，Linux 内核正是位于这里。GNU C Library （glibc）也在这里。它提供了连接内核的系统调用接口，还提供了在用户空间应用程序和内核之间进行转换的机制。这点非常重要，因为内核和用户空间的应用程序使用的是不同的保护地址空间。每个用户空间的进程都使用自己的虚拟地址空间，而内核则占用单独的地址空间。</p><p>Linux 内核可以进一步划分成 3 层。最上面是系统调用接口，它实现了一些基本的功能，例如 read 和 write。系统调用接口之下是内核代码，可以更精确地定义为独立于体系结构的内核代码。这些代码是 Linux 所支持的所有处理器体系结构所通用的。在这些代码之下是依赖于体系结构的代码，构成了通常称为 BSP（Board Support Package）的部分。这些代码用作给定体系结构的处理器和特定于平台的代码。</p><p>Linux 内核实现了很多重要的体系结构属性。在或高或低的层次上，内核被划分为多个子系统。Linux 也可以看作是一个整体，因为它会将所有这些基本服务都集成到内核中。这与微内核的体系结构不同，后者会提供一些基本的服务，例如通信、I/O、内存和进程管理，更具体的服务都是插入到微内核层中的。每种内核都有自己的优点，不过这里并不对此进行讨论。</p><p>随着时间的流逝，Linux 内核在内存和 CPU 使用方面具有较高的效率，并且非常稳定。但是对于 Linux 来说，最为有趣的是在这种大小和复杂性的前提下，依然具有良好的可移植性。Linux 编译后可在大量处理器和具有不同体系结构约束和需求的平台上运行。一个例子是 Linux 可以在一个具有内存管理单元（MMU）的处理器上运行，也可以在那些不提供 MMU 的处理器上运行。</p><p>Linux 内核的 uClinux 移植提供了对非 MMU 的支持。</p><p>图 2 是 Linux 内核的体系结构</p><p><img src="/public/2021/12/23/linux/linux_in_one/174749211_5_20191103041018549.jpeg" alt="174749211_5_20191103041018549"></p><p>图 2 Linux 内核体系结构</p><p>Linux 内核的主要组件有：系统调用接口、进程管理、内存管理、虚拟文件系统、网络堆栈、设备驱动程序、硬件架构的相关代码。</p><p>（1）系统调用接口</p><p>SCI 层提供了某些机制执行从用户空间到内核的函数调用。正如前面讨论的一样，这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 ./linux/kernel 中您可以找到 SCI 的实现，并在 ./linux/arch 中找到依赖于体系结构的部分。</p><p>（2）进程管理</p><p>进程管理的重点是进程的执行。在内核中，这些进程称为线程，代表了单独的处理器虚拟化（线程代码、数据、堆栈和 CPU 寄存器）。在用户空间，通常使用进程 这个术语，不过 Linux 实现并没有区分这两个概念（进程和线程）。内核通过 SCI 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSIX] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSIX 机制）。</p><p>进程管理还包括处理活动进程之间共享 CPU 的需求。内核实现了一种新型的调度算法，不管有多少个线程在竞争 CPU，这种算法都可以在固定时间内进行操作。这种算法就称为 O(1) 调度程序，这个名字就表示它调度多个线程所使用的时间和调度一个线程所使用的时间是相同的。O(1) 调度程序也可以支持多处理器（称为对称多处理器或 SMP）。您可以在 ./linux/kernel 中找到进程管理的源代码，在 ./linux/arch 中可以找到依赖于体系结构的源代码。</p><p>（3）内存管理</p><p>内核所管理的另外一个重要资源是内存。为了提高效率，如果由硬件管理虚拟内存，内存是按照所谓的内存页 方式进行管理的（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。</p><p>（4）虚拟文件系统</p><p>虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 SCI 和内核所支持的文件系统之间提供了一个交换层（请参看图 4）。</p><p><img src="/public/2021/12/23/linux/linux_in_one/174749211_6_20191103041018596.jpeg" alt="174749211_6_20191103041018596"></p><p>图 3 Linux 文件系统层次结构</p><p>在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。它们是给定文件系统（超过 50 个）的插件。文件系统的源代码可以在 ./linux/fs 中找到。文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集（与具体文件系统无关）。这个缓存层通过将数据保留一段时间（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。</p><p>（5）网络堆栈</p><p>网络堆栈在设计上遵循模拟协议本身的分层体系结构。回想一下，Internet Protocol (IP) 是传输协议（通常称为传输控制协议或 TCP）下面的核心网络层协议。TCP 上面是 socket 层，它是通过 SCI 进行调用的。socket 层是网络子系统的标准 API，它为各种网络协议提供了一个用户接口。从原始帧访问到 IP 协议数据单元（PDU），再到 TCP 和 User Datagram Protocol (UDP)，socket 层提供了一种标准化的方法来管理连接，并在各个终点之间移动数据。内核中网络源代码可以在 ./linux/net 中找到。</p><p>（6）设备驱动程序</p><p>Linux 内核中有大量代码都在设备驱动程序中，它们能够运转特定的硬件设备。Linux 源码树提供了一个驱动程序子目录，这个目录又进一步划分为各种支持设备，例如 Bluetooth、I2C、serial 等。设备驱动程序的代码可以在 ./linux/drivers 中找到。</p><p>（7）依赖体系结构的代码</p><p>尽管 Linux 很大程度上独立于所运行的体系结构，但是有些元素则必须考虑体系结构才能正常操作并实现更高效率。./linux/arch 子目录定义了内核源代码中依赖于体系结构的部分，其中包含了各种特定于体系结构的子目录（共同组成了 BSP）。对于一个典型的桌面系统来说，使用的是 x86 目录。每个体系结构子目录都包含了很多其他子目录，每个子目录都关注内核中的一个特定方面，例如引导、内核、内存管理等。这些依赖体系结构的代码可以在 ./linux/arch 中找到。</p><p>如果 Linux 内核的可移植性和效率还不够好，Linux 还提供了其他一些特性，它们无法划分到上面的分类中。作为一个生产操作系统和开源软件，Linux 是测试新协议及其增强的良好平台。Linux 支持大量网络协议，包括典型的 TCP/IP，以及高速网络的扩展（大于 1 Gigabit Ethernet [GbE] 和 10 GbE）。Linux 也可以支持诸如流控制传输协议（SCTP）之类的协议，它提供了很多比 TCP 更高级的特性（是传输层协议的接替者）。</p><p>Linux 还是一个动态内核，支持动态添加或删除软件组件。被称为动态可加载内核模块，它们可以在引导时根据需要（当前特定设备需要这个模块）或在任何时候由用户插入。</p><p>Linux 最新的一个增强是可以用作其他操作系统的操作系统（称为系统管理程序）。最近，对内核进行了修改，称为基于内核的虚拟机（KVM）。这个修改为用户空间启用了一个新的接口，它可以允许其他操作系统在启用了 KVM 的内核之上运行。除了运行 Linux 的其他实例之外， Microsoft Windows 也可以进行虚拟化。惟一的限制是底层处理器必须支持新的虚拟化指令。</p><h2 id="Linux-体系结构和内核结构区别"><a class="header-anchor" href="#Linux-体系结构和内核结构区别">¶</a>Linux 体系结构和内核结构区别</h2><p>1．当被问到 Linux 体系结构（就是 Linux 系统是怎么构成的）时，我们可以参照下图这么回答：<br>从大的方面讲，Linux 体系结构可以分为两块：<br>（1）用户空间：用户空间中又包含了，用户的应用程序，C 库<br>（2）内核空间：内核空间包括，系统调用，内核，以及与平台架构相关的代码</p><p><img src="/public/2021/12/23/linux/linux_in_one/174749211_7_20191103041018642.jpeg" alt="174749211_7_20191103041018642"></p><p>2．Linux 体系结构要分成用户空间和内核空间的原因：</p><p>1）现代 CPU 通常都实现了不同的工作模式。</p><p>以 ARM 为例：ARM 实现了 7 种工作模式，不同模式下 CPU 可以执行的指令或者访问的寄存器不同：<br>（1）用户模式  usr<br>（2）系统模式  sys<br>（3）管理模式  svc<br>（4）快速中断  fiq<br>（5）外部中断  irq<br>（6）数据访问终止 abt<br>（7）未定义指令异常</p><p>以（2）X86 为例：X86 实现了 4 个不同级别的权限，Ring0—Ring3 ;Ring0 下可以执行特权指令，可以访问 IO 设备；Ring3 则有很多的限制</p><p>2）所以，Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了 2 部分；</p><p>3．用户空间和内核空间是程序执行的两种不同状态，我们可以通过 “系统调用” 和“硬件中断“来完成用户空间到内核空间的转移</p><p>4．Linux 的内核结构（注意区分 LInux 体系结构和 Linux 内核结构）</p><p><img src="/public/2021/12/23/linux/linux_in_one/174749211_8_20191103041018705.jpeg" alt="174749211_8_20191103041018705"></p><h2 id="Linux-驱动的-platform-机制"><a class="header-anchor" href="#Linux-驱动的-platform-机制">¶</a>Linux 驱动的 platform 机制</h2><p>Linux 的这种 platform driver 机制和传统的 device_driver 机制相比，一个十分明显的优势在于 platform 机制将本身的资源注册进内核，由内核统一管理，在驱动程序中使用这些资源时通过 platform_device 提供的标准接口进行申请并使用。这样提高了驱动和资源管理的独立性，并且拥有较好的可移植性和安全性。下面是 SPI 驱动层次示意图，Linux 中的 SPI 总线可理解为 SPI 控制器引出的总线：</p><p><img src="/public/2021/12/23/linux/linux_in_one/174749211_9_20191103041018752.jpeg" alt="174749211_9_20191103041018752"></p><p>和传统的驱动一样，platform 机制也分为三个步骤：</p><p>1、总线注册阶段：</p><p>内核启动初始化时的 main.c 文件中的 kernel_init()→do_basic_setup()→driver_init()→platform_bus_init()→bus_register(&amp;platform_bus_type)，注册了一条 platform 总线（虚拟总线，platform_bus）。</p><p>2、添加设备阶段：</p><p>设备注册的时候 Platform_device_register()→platform_device_add()→(pdev→dev.bus = &amp;platform_bus_type)→device_add()，就这样把设备给挂到虚拟的总线上。</p><p>3、驱动注册阶段：</p><p>Platform_driver_register()→driver_register()→bus_add_driver()→driver_attach()→bus_for_each_dev(), 对在每个挂在虚拟的 platform bus 的设备作__driver_attach()→driver_probe_device(), 判断 drv→bus→match() 是否执行成功，此时通过指针执行 platform_match→strncmp(pdev→name , drv→name , BUS_ID_SIZE), 如果相符就调用 really_probe(实际就是执行相应设备的 platform_driver→probe(platform_device)。) 开始真正的探测，如果 probe 成功，则绑定设备到该驱动。</p><p>从上面可以看出，platform 机制最后还是调用了 bus_register() , device_add() , driver_register() 这三个关键的函数。</p><p>下面看几个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span>           </span></span><br><span class="line"><span class="class">(/<span class="title">include</span>/<span class="title">linux</span>/<span class="title">Platform_device</span>.<span class="title">h</span>)</span></span><br><span class="line"><span class="class">&#123;</span>        </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>    * name;        </span><br><span class="line"><span class="keyword">int</span>        id;        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span>    <span class="title">dev</span>;</span>        </span><br><span class="line">u32        num_resources;        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span>    * <span class="title">resource</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Platform_device 结构体描述了一个 platform 结构的设备，在其中包含了一般设备的结构体 struct device  dev; 设备的资源结构体 struct resource   * resource; 还有设备的名字 const char * name。（注意，这个名字一定要和后面 platform_driver.driver àname 相同，原因会在后面说明。）</p><p>该结构体中最重要的就是 resource 结构，这也是之所以引入 platform 机制的原因。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span>                            </span></span><br><span class="line"><span class="class">( /<span class="title">include</span>/<span class="title">linux</span>/<span class="title">ioport</span>.<span class="title">h</span>)</span></span><br><span class="line"><span class="class">&#123;</span>        </span><br><span class="line"><span class="keyword">resource_size_t</span> start;        </span><br><span class="line"><span class="keyword">resource_size_t</span> end;        </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;        </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">其中 flags位表示该资源的类型，start和end分别表示该资源的起始地址和结束地址(/include/linux/Platform_device.h)：</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span>              </span></span><br><span class="line"><span class="class">&#123;</span>        </span><br><span class="line"><span class="keyword">int</span> (*probe)(struct platform_device *);        </span><br><span class="line"><span class="keyword">int</span> (*remove)(struct platform_device *);        </span><br><span class="line"><span class="keyword">void</span> (*shutdown)(struct platform_device *);        </span><br><span class="line"><span class="keyword">int</span> (*suspend)(struct platform_device *, <span class="keyword">pm_message_t</span> state);        </span><br><span class="line"><span class="keyword">int</span> (*suspend_late)(struct platform_device *, <span class="keyword">pm_message_t</span> state);        </span><br><span class="line"><span class="keyword">int</span> (*resume_early)(struct platform_device *);        </span><br><span class="line"><span class="keyword">int</span> (*resume)(struct platform_device *);        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">Platform_driver结构体描述了一个platform结构的驱动。其中除了一些函数指针外，还有一个一般驱动的device_driver结构。</span><br></pre></td></tr></table></figure><p>名字要一致的原因：</p><p>上面说的驱动在注册的时候会调用函数 bus_for_each_dev(), 对在每个挂在虚拟的 platform bus 的设备作__driver_attach()→driver_probe_device(), 在此函数中会对 dev 和 drv 做初步的匹配，调用的是 drv-&gt;bus-&gt;match 所指向的函数。platform_driver_register 函数中 drv-&gt;driver.bus = &amp;platform_bus_type，所以 drv-&gt;bus-&gt;match 就为 platform_bus_type→match, 为 platform_match 函数，该函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">platform_match</span><span class="params">(struct device * dev, struct device_driver * drv)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> = <span class="title">container_of</span>(<span class="title">dev</span>, <span class="title">struct</span> <span class="title">platform_device</span>, <span class="title">dev</span>);</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">strncmp</span>(pdev-&gt;name, drv-&gt;name, BUS_ID_SIZE) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是比较 dev 和 drv 的 name，相同则会进入 really_probe（）函数，从而进入自己写的 probe 函数做进一步的匹配。所以 dev→name 和 driver→drv→name 在初始化时一定要填一样的。</p><p>不同类型的驱动，其 match 函数是不一样的，这个 platform 的驱动，比较的是 dev 和 drv 的名字，还记得 usb 类驱动里的 match 吗？它比较的是 Product ID 和 Vendor ID。</p><p>个人总结 Platform 机制的好处：</p><p>1、提供 platform_bus_type 类型的总线，把那些不是总线型的 soc 设备都添加到这条虚拟总线上。使得，总线——设备——驱动的模式可以得到普及。</p><p>2、提供 platform_device 和 platform_driver 类型的数据结构，将传统的 device 和 driver 数据结构嵌入其中，并且加入 resource 成员，以便于和 Open Firmware 这种动态传递设备资源的新型 bootloader 和 kernel 接轨。</p><h2 id="Linux-内核体系结构"><a class="header-anchor" href="#Linux-内核体系结构">¶</a>Linux 内核体系结构</h2><p>因为 Linux 内核是单片的，所以它比其他类型的内核占用空间最大，复杂度也最高。这是一个设计特性，在 Linux 早期引起了相当多的争论，并且仍然带有一些与单内核固有的相同的设计缺陷。</p><img src="/public/2021/12/23/linux/linux_in_one/174749211_10_20191103041018783.jpeg" alt="174749211_10_20191103041018783" style="zoom:50%;"><p>为了解决这些缺陷，Linux 内核开发人员所做的一件事就是使内核模块可以在运行时加载和卸载，这意味着您可以动态地添加或删除内核的特性。这不仅可以向内核添加硬件功能，还可以包括运行服务器进程的模块，比如低级别虚拟化，但也可以替换整个内核，而不需要在某些情况下重启计算机。<br>想象一下，如果您可以升级到 Windows 服务包，而不需要重新启动……</p><h2 id="内核模块"><a class="header-anchor" href="#内核模块">¶</a>内核模块</h2><p>如果 Windows 已经安装了所有可用的驱动程序，而您只需要打开所需的驱动程序怎么办? 这本质上就是内核模块为 Linux 所做的。内核模块，也称为可加载内核模块 (LKM)，对于保持内核在不消耗所有可用内存的情况下与所有硬件一起工作是必不可少的。</p><p><img src="/public/2021/12/23/linux/linux_in_one/174749211_11_20191103041018908.jpeg" alt="174749211_11_20191103041018908"></p><p>模块通常向基本内核添加设备、文件系统和系统调用等功能。lkm 的文件扩展名是. ko，通常存储在 / lib/modules 目录中。由于模块的特性，您可以通过在启动时使用 menuconfig 命令将模块设置为 load 或 not load，或者通过编辑 / boot/config 文件，或者使用 modprobe 命令动态地加载和卸载模块，轻松定制内核。</p><p>第三方和封闭源码模块在一些发行版中是可用的，比如 Ubuntu，默认情况下可能无法安装，因为这些模块的源代码是不可用的。该软件的开发人员 (即 nVidia、ATI 等) 不提供源代码，而是构建自己的模块并编译所需的. ko 文件以便分发。虽然这些模块像 beer 一样是免费的，但它们不像 speech 那样是免费的，因此不包括在一些发行版中，因为维护人员认为它通过提供非免费软件 “污染” 了内核。</p><p>内核并不神奇，但对于任何正常运行的计算机来说，它都是必不可少的。Linux 内核不同于 OS X 和 Windows，因为它包含内核级别的驱动程序，并使许多东西 “开箱即用”。希望您能对软件和硬件如何协同工作以及启动计算机所需的文件有更多的了解。</p><h2 id="Linux-内核学习经验总结"><a class="header-anchor" href="#Linux-内核学习经验总结">¶</a>Linux 内核学习经验总结</h2><p>开篇</p><p>学习内核，每个人都有自己的学习方法，仁者见仁智者见智。以下是我在学习过程中总结出来的东西，对自身来说，我认为比较有效率，拿出来跟大家交流一下。</p><p>内核学习，一偏之见；疏漏难免，恳请指正。</p><p>为什么写这篇博客</p><p>刚开始学内核的时候，不要执着于一个方面，不要专注于一个子系统就一头扎到实际的代码行中去，因为这样的话，牵涉的面会很广，会碰到很多困难，容易产生挫败感，一个函数体中（假设刚开始的时候正在学习某个方面的某个具体的功能函数）很可能掺杂着其他各个子系统方面设计理念（多是大量相关的数据结构或者全局变量，用于支撑该子系统的管理工作）下相应的代码实现，这个时候看到这些东西，纷繁芜杂，是没有头绪而且很不理解的，会产生很多很多的疑问，（这个时候如果对这些疑问纠缠不清，刨根问底，那么事实上就是在学习当前子系统的过程中频繁的去涉足其他子系统，这时候注意力就分散了），而事实上等了解了各个子系统后再回头看这些东西的话，就简单多了，而且思路也会比较清晰。所以，要避免 “只见树木，不见森林”，不要急于深入到底层代码中去，不要过早研究底层代码。</p><p>我在大二的时候刚开始接触内核，就犯了这个错误，一头扎到内存管理里头，去看非常底层的实现代码，虽然也是建立在内存管理的设计思想的基础上，但是相对来说，比较孤立，因为此时并没有学习其它子系统，应该说无论是视野还是思想，都比较狭隘，所以代码中牵涉到的其它子系统的实现我都直接跳过了，这一点还算聪明，当然也是迫不得已的。</p><p>我的学习方法</p><p>刚开始，我认为主要的问题在于你知道不知道，而不是理解不理解，某个子系统的实现采用了某种策略、方法，而你在学习中需要做的就是知道有这么一回事儿，然后才是理解所描述的策略或者方法。</p><p>根据自己的学习经验，刚开始学习内核的时候，我认为要做的是在自己的脑海中建立起内核的大体框架，理解各个子系统的设计理念和构建思想，这些理念和思想会从宏观上呈献给你清晰的脉络，就像一个去除了枝枝叶叶的大树的主干，一目了然；当然，肯定还会涉及到具体的实现方法、函数，但是此时接触到的函数或者方法位于内核实现的较高的层次，是主（要）函数，已经了解到这些函数，针对的是哪些设计思想，实现了什么样的功能，达成了什么样的目的，混个脸熟的说法在这儿也是成立的。至于该主函数所调用的其它的辅助性函数就等同于枝枝叶叶了，不必太早就去深究。此时，也就初步建立起了内核子系统框架和代码实现之间的关联，关联其实很简单，比如一看到某个函数名字，就想起这个函数是针对哪个子系统的，实现了什么功能。</p><p>我认为此时要看的就是 LKD3，这本书算是泛泛而谈，主要就是从概念，设计，大的实现方法上描述各个子系统，而对于具体的相关的函数实现的代码讲解很少涉及 (对比于 ULK3，此书主要就是关于具体函数代码的具体实现的深入分析，当然，你也可以看，但是过早看这本书，会感觉很痛苦，很枯燥无味，基本上都是函数的实现)，很少，但不是没有，这就很好，满足我们当前的需求，还避免我们过早深入到实际的代码中去。而且本书在一些重要的点上还给出了写程序时的注意事项，算是指导性建议。主要的子系统包括：内存管理，进程管理和调度，系统调用，中断和异常，内核同步，时间和定时器管理，虚拟文件系统，块 I/O 层，设备和模块。（这里的先后顺序其实就是 LKD3 的目录的顺序）。</p><p>我学习的时候是三本书交叉着看的，先看 LKD3，专于一个子系统，主要就是了解设计的原理和思想，当然也会碰到对一些主要函数的介绍，但大多就是该函数基于前面介绍的思想和原理完成了什么样的功能，该书并没有就函数本身的实现进行深入剖析。然后再看 ULK3 和 PLKA 上看同样的子系统，但是并不仔细分析底层具体函数的代码，只是粗略地、不求甚解地看，甚至不看。因为，有些时候，在其中一本书的某个点上，卡壳了，不是很理解了，在另外的书上你可能就碰到对同一个问题的不同角度的描述，说不准哪句话就能让你豁然开朗，如醍醐灌顶。我经常碰到这种情况。</p><p>并不是说学习过程中对一些函数体的实现完全就忽略掉，只要自己想彻底了解其代码实现，没有谁会阻止你。我是在反复阅读过程中慢慢深入的。比如 VFS 中文件打开需要对路径进行分析，需要考虑的细节不少 (.././ 之类的)，但是其代码实现是很好理解的。再比如，CFS 调度中根据 shedule latency、队列中进程个数及其 nice 值(使用的是动态优先级) 计算出分配给进程的时间片，没理由不看的，这个太重要了，而且也很有意思。</p><p>ULK3 也会有设计原理与思想之类的概括性介绍，基本上都位于某个主题的开篇段落。但是更多的是对支持该原理和思想的主要函数实现的具体分析，同样在首段，一句话综述函数的功能，然后对函数的实现以 1、2、3，或者 a、b、c 步骤的形式进行讲解。我只是有选择性的看，有时候对照着用 source insight 打开的源码，确认一下代码大体上确实是按书中所描述的步骤实现的，就当是增加感性认识。由于步骤中掺杂着各种针对不同实现目的安全性、有效性检查，如果不理解就先跳过。这并不妨碍你对函数体功能实现的整体把握。</p><p>PLKA 介于 LKD3 和 ULK3 之间。我觉得 PLKA 的作者（看照片，真一德国帅小伙，技术如此了得）肯定看过 ULK，无论他的本意还是有意，总之 PLKA 还是跟 ULK 有所不同，对函数的仔细讲解都做补充说明，去掉函数体中边边角角的情况，比如一些特殊情况的处理，有效性检查等，而不妨碍对整个函数体功能的理解，这些他都有所交代，做了声明；而且，就像 LKD3 一样，在某些点上也给出了指导性编程建议。作者们甚至对同一个主要函数的讲解的着重点都不一样。这样的话，对我们学习的人而言，有助于加深理解。另外，我认为很重要的一点就是 PLKA 针对的 2.6.24 的内核版本，而 ULK 是 2.6.11，LKD3 是 2.6.34。在某些方面 PLKA 比较接近现代的实现。其实作者们之所以分别选择 11 或者 24，都是因为在版本发行树中，这两个版本在某些方面都做了不小的变动，或者说是具有标志性的转折点（这些信息大多是在书中的引言部分介绍的，具体的细节我想不起来了）。</p><p>Intel V3，针对 X86 的 CPU，本书自然是系统编程的权威。内核部分实现都可以在本书找到其根源。所以，在读以上三本书某个子系统的时候，不要忘记可以在 V3 中相应章节找到一些基础性支撑信息。</p><p>在读书过程中，会产生相当多的疑问，这一点是确信无疑的。大到搞不明白一个设计思想，小到不理解某行代码的用途。各个方面，各种疑问，你完全可以把不理解的地方都记录下来 (不过，我并没有这么做，没有把疑问全部记下来，只标记了很少一部分我认为很关键的几个问题)，专门写到一张纸上，不对，一个本上，我确信会产生这么多的疑问，不然内核相关的论坛早就可以关闭了。其实，大部分的问题（其中很多问题都是你知道不知道有这么一回事的问题）都可以迎刃而解，只要你肯回头再看，书读百遍，其义自现。多看几遍，前前后后的联系明白个七七八八是没有问题的。我也这么做了，针对某些子系统也看了好几遍，切身体会。</p><p>当你按顺序学习这些子系统的时候，前面的章节很可能会引用后面的章节，就像 PLKA 的作者说的那样，完全没有向后引用是不可能的，他能做的只是尽量减少这种引用而又不损害你对当前问题的理解。不理解，没关系，跳过就行了。后面的章节同样会有向前章节的引用，不过这个问题就简单一些了 ，你可以再回头去看相应的介绍，当时你不太理解的东西，很可能这个时候就知道了它的设计的目的以及具体的应用。不求甚解只是暂时的。比如说，内核各个子系统之间的交互和引用在代码中的体现就是实现函数穿插调用，比如你在内存管理章节学习了的内存分配和释放的函数，而你是了解内存在先的，在学习驱动或者模块的时候就会碰到这些函数的调用，这样也就比较容易接受，不至于太过茫然；再比如，你了解了系统时间和定时器的管理，再回头看中断和异常中 bottom half 的调度实现，你对它的理解就会加深一层。</p><p>子系统进行管理工作需要大量的数据结构。子系统之间交互的一种方式就是各个子系统各自的主要数据结构通过指针成员相互引用。学习过程中，参考书上在讲解某个子系统的时候会对数据结构中主要成员的用途解释一下，但肯定不会覆盖全部（成员比较多的情况，例如 task_struct），对其它子系统基于某个功能实现的引用可能解释了，也可能没做解释，还可能说这个变量在何处会做进一步说明。所以，不要纠结于一个不理解的点上，暂且放过，回头还可以看的。之间的联系可以在对各个子系统都有所了解之后再建立起来。其实，我仍然在强调先理解概念和框架的重要性。</p><p>等我们完成了建立框架这一步，就可以选择一个比较感兴趣的子系统，比如驱动、网络，或者文件系统之类的。这个时候你再去深入了解底层代码实现，相较于一开始就钻研代码，更容易一些，而且碰到了不解之处，或者忘记了某个方面的实现，此时你完全可以找到相应的子系统，因为你知道在哪去找，查漏补缺，不仅完成了对当前函数的钻研，而且可以回顾、温习以前的内容，融会贯通的时机就在这里了。</p><p>《深入理解 linux 虚拟内存》(2.4 内核版本)，LDD3，《深入理解 linux 网络技术内幕》，几乎每一个子系统都需要一本书的容量去讲解，所以说，刚开始学习不宜对某个模块太过深入，等对各个子系统都有所了解了，再有针对性的去学习一个特定的子系统。这时候对其它系统的援引都可以让我们不再感到茫然、复杂，不知所云。</p><p>比如，LDD3 中的以下所列章节：构造和运行模块，并发和竞态，时间、延迟及延缓操作, 分配内存，中断处理等，都属于驱动开发的支撑性子系统，虽说本书对这些子系统都专门开辟一个章节进行讲解，但是详细程度怎么能比得上 PLKA，ULK3，LKD3 这三本书，看完这三本书，你会发现读 LDD3 这些章节的时候简直跟喝白开水一样，太随意了，因为 LDD3 的讲解比之 LKD3 更粗略。打好了基础，PCI、USB、TTY 驱动，块设备驱动，网卡驱动，需要了解和学习的东西就比较有针对性了。这些子系统就属于通用子系统，了解之后，基于这些子系统的子系统的开发—驱动 (需进一步针对硬件特性) 和网络(需进一步理解各种协议)—相对而言，其学习难度大大降低，学习进度大大加快，学习效率大大提升。说着容易做来难。达到这样一种效果的前提就是：必须得静下心来，认真读书，要看得进去，PLKA，ULK3 厚得都跟砖头块儿一样，令人望之生畏，如果没有兴趣，没有热情，没有毅力，无论如何都是不行，因为需要时间，需要很长时间。我并不是说必须打好了基础才可以进行驱动开发，只是说打好了基础的情况下进行开发会更轻松，更有效率，而且自己对内核代码的驾驭能力会更强大。这只是我个人见解，我自己的学习方式，仅供参考。</p><p>语言</p><p>PLKA 是个德国人用德语写的，后来翻译成英文，又从英文翻译成中文，我在网上书店里没有找到它的纸质英文版，所以就买了中文版的。ULK3 和 LKD3 都是英文版的。大牛们写的书，遣词造句真的是简洁，易懂，看原版对我们学习计算机编程的程序员来说完全不成问题，最好原汁原味。如果一本书确实翻译地很好，我们当然可以看中文版的，用母语进行学习，理解速度和学习进度当然是很快的，不作他想。看英文的时候不要脑子里想着把他翻译成中文，没必要。</p><p>API 感想</p><p>“比起知道你所用技术的重要性，成为某一个特别领域的专家是不重要的。知道某一个具体 API 调用一点好处都没有，当你需要他的时候只要查询下就好了。” 这句话源于我看到的一篇翻译过来的博客。我想强调的就是，这句话针应用型编程再合适不过，但是内核 API 就不完全如此。</p><p>内核相当复杂，学习起来很不容易，但是当你学习到一定程度，你会发现，如果自己打算写内核代码，到最后要关注的仍然是 API 接口，只不过这些 API 绝大部分是跨平台的，满足可移植性。内核黑客基本上已经标准化、文档化了这些接口，你所要做的只是调用而已。当然，在使用的时候，最好对可移植性这一话题在内核中的编码约定烂熟于心，这样才会写出可移植性的代码。就像应用程序一样，可以使用开发商提供的动态库 API，或者使用开源 API。同样是调用 API，不同点在于使用内核 API 要比使用应用 API 了解的东西要多出许多。</p><p>当你了解了操作系统的实现—这些实现可都是对应用程序的基础性支撑啊—你再去写应用程序的时候，应用程序中用到的多线程，定时器，同步锁机制等等等等，使用共享库 API 的时候，联系到操作系统，从而把对该 API 的文档描述同自己所了解到的这些方面在内核中的相应支撑性实现结合起来进行考虑，这会指导你选择使用哪一个 API 接口，选出效率最高的实现方式。对系统编程颇有了解的话，对应用编程不无益处，甚至可以说是大有好处。</p><p>设计实现的本质，知道还是理解</p><p>操作系统是介于底层硬件和应用软件之间的接口，其各个子系统的实现很大程度上依赖于硬件特性。书上介绍这些子系统的设计和实现的时候，我们读过了，也就知道了，如果再深入考虑一下，为什么整体架构要按照这种方式组织，为什么局部函数要遵循这样的步骤处理，知其然，知其所以然，如果你知道了某个功能的实现是因为芯片就是这么设计的，CPU 就是这么做的，那么你的疑问也就基本上到此为止了。再深究，就是芯片架构方面的设计与实现，对于程序员来讲，无论是系统还是应用程序员，足迹探究到这里，已经解决了很多疑问，因为我们的工作性质偏软，而这些东西实在是够硬。</p><p>比如，ULK3 中讲解的中断和异常的实现，究其根源，那是因为 Intel x86 系列就是这么设计的，去看看 Intel V3 手册中相应章节介绍，都可以为 ULK3 中描述的代码实现方式找到注解。还有时间和定时器管理，同样可以在 Intel V3 对 APIC 的介绍中获取足够的信息，操作系统就是依据这些硬件特性来实现软件方法定义的。</p><p>又是那句话，不是理解不理解的问题，而是知道不知道的问题。有时候，知道了，就理解了。在整个学习过程中，知道，理解，知道，理解，知道……，交叉反复。为什么开始和结尾都是知道，而理解只是中间步骤呢？世界上万事万物自有其规律，人类只是发现而已，实践是第一位的，实践就是知道的过程，实践产生经验，经验的总结就是理论，理论源于实践，理论才需要理解。我们学习内核，深入研究，搞来搞去，又回到了芯片上，芯片是物质的，芯片的功用基于自然界中物质本有的物理和电子特性。追本溯源，此之谓也。</p><p>动手写代码</p><p>纸上得来终觉浅，绝知此事要躬行。只看书是绝对不行的，一定要结合课本给出的编程建议自己敲代码。刚开始就以模块形式测试好了，或者自己编译一个开发版本的内核。一台机器的话，使用 UML 方式调试，内核控制路走到哪一步，单步调试看看程序执行过程，比书上的讲解更直观明了。一定要动手实际操作。</p><p>参考书</p><p>LDD3          Linux Device Driver 3rd</p><p>LKD3          Linux Kernel Development 3rd</p><p>ULK3          Understanding the Linux Kernel 3rd</p><p>PLKA          Professional Linux Kernel Architecture</p><p>UML            User Mode Linux</p><p>Intel V3       Intel? 64 and IA-32 Architectures Software Developer’s Manual Volume 3 (3A, 3B &amp; 3C): System Programming Guide</p><p>作者在写书的时候，都是以自己的理解组织内容，从自己的观点看待一个主题，关注点跟作者自身有很大的关系。出书的时间有先后，后来人针对同一个主题想要出书而又不落入窠臼，最好有自己的切入方式，从自己的角度讲解相关问题，这才值得出这本书，千篇一律是个掉价的行为，书就不值钱了。</p><p>尽信书不如无书。</p><p><a href="http://lwn.net/Articles/419855/" target="_blank" rel="noopener">http://lwn.net/Articles/419855/</a> 此处是一篇关于 LKD3 的书评，指出了其中的错误，当你读完的时候，不妨去找找，看一下自己在其中所描述的地方有什么特别的印象。</p><p><a href="http://lwn.net/Articles/161190" target="_blank" rel="noopener">http://lwn.net/Articles/161190</a> / 此处是一篇对 ULK3 的介绍，我认为其中很关键的几句话就可以给本书定位：</p><blockquote><p>Many of the key control paths in the kernel are described, step by step;</p><p>一步一步地讲述内核控制路径的实现。</p><p>The level of detail sometimes makes it hard to get a sense for the big picture, but it does help somebody trying to figure out how a particular function works.</p><p>对代码讲解的详细程度有时候很难让读者把握住它的主旨大意，但是确实有助于读者理解一个特定的函数到底是如何工作的。</p><p>Indeed, that is perhaps the key feature which differentiates this book. It is very much a “how it works” book, designed to help people understand the code.</p><p>事实上，这也正是本书与众不同的地方。更像一个 “如何工作” 的书，帮助读者理解代码实现。</p><p>It presents kernel functions and data structures, steps the reader through them, but does not, for example, emphasize the rules for using them. UTLK is a study guide, not a programming manual.</p><p>本书描述了内核函数和数据结构，引导读者穿行于其间，但是，并没有着重强调使用它们的法则。UTLK 是一本学习指南，而不是编程手册。</p></blockquote><p>这几句话对本书的描述非常到位。基于此，作为指导性原则，我们就可以很有效率地使用它了。</p><p>看一本技术书籍，书中的序言部分绝对是首先应该翻阅的，其次就是目录。我发现在阅读过程中我会频繁的查看目录，甚至是喜欢看目录。</p><h2 id="结尾"><a class="header-anchor" href="#结尾">¶</a>结尾</h2><p>兴趣的力量是无穷的。兴趣能带来激情，如果工作可以和兴趣结合到一起，工作起来才会有热情，那么工作就不只是工作了，更是一种享受。</p><p>Linux，我的兴趣，我的动力，我的方向，我的未来！</p><p>原文连接多处：<br>图片来自：<a href="http://www.360doc.com/content/19/1103/16/36367108_870849346.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/19/1103/16/36367108_870849346.shtml</a><br> <a href="http://www.openpcba.com/web/contents/get?id=4638&amp;tid=15" target="_blank" rel="noopener">http://www.openpcba.com/web/contents/get?id=4638&amp;tid=15</a>【已失效】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文导读&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&gt;Linux 内核预备工作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;Linux 内核体系结构简析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;Linux 体系结构和内核结构区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;Linux 驱动的 platform 机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;Linux 内核体系结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;内核模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;Linux 内核学习经验总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;结尾&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://talengu.github.io/public/categories/Linux/"/>
    
    
      <category term="内核开发" scheme="https://talengu.github.io/public/tags/%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【转】《中华古籍资源库》中国国家图书馆</title>
    <link href="https://talengu.github.io/public/2021/12/16/readings/zhonghuaguji/"/>
    <id>https://talengu.github.io/public/2021/12/16/readings/zhonghuaguji/</id>
    <published>2021-12-16T22:45:31.000Z</published>
    <updated>2021-12-16T22:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简介</strong></p><p>“中华古籍资源库”是“中华古籍保护计划”的重要成果。2016年9月28日，“中华古籍资源库”正式开通运行，陆续发布国家图书馆藏善本和普通古籍、法国国家图书馆藏敦煌遗书、天津图书馆藏普通古籍、日本永青文库捐赠汉籍、云南省图书馆善本古籍、芷兰斋藏稿抄校本等古籍影像资源，总量超过3.3万部。</p><p>《中华古籍资源库》！！！<br>网址：<a href="http://www.nlc.cn/pcab/zy/zhgj_zyk/" target="_blank" rel="noopener">http://www.nlc.cn/pcab/zy/zhgj_zyk/</a><br>查询：<a href="http://read.nlc.cn/thematDataSearch/toGujiIndex" target="_blank" rel="noopener">http://read.nlc.cn/thematDataSearch/toGujiIndex</a></p><img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216225907506.png" alt="image-20211216225907506" style="zoom:30%;"><a id="more"></a><p>比如：《九章算数》的古籍</p><img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216231340351.png" alt="image-20211216231340351" style="zoom:30%;"><img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216231141739.png" alt="image-20211216231141739" style="zoom:30%;"><p>比如：卷第九的勾股</p><img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216232009068.png" alt="image-20211216232009068" style="zoom:50%;"><ul><li><p>数字古籍国家图书馆收藏古籍15万部，其中善本古籍直接继承了南宋缉熙殿、元翰林国史院、明文渊阁、清内阁大库等皇家珍藏，以及明清以来许多私人藏书家的毕生所聚。宋元旧椠、明清精刻琳琅满目。通过全彩影像数字化和缩微胶卷转化影像方式建设，从2016年9月28日起陆续在线发布，目前已发布馆藏古籍2万余部，国家图书馆超过三分之二的善本古籍实现了在线阅览。</p></li><li><p>数字方志地方志文献为我国所特有，也是国家图书馆独具特色的馆藏之一，所存文献数量与品质极高。该数据库以国家图书馆藏地方志文献建设，主要包括为清代（含清代）以前的方志资源6529种。</p></li><li><p>赵城金藏《赵城金藏》被誉为国家图书馆四大镇馆之宝之一。《赵城金藏》是在金代刻的一部大藏，因为它藏在赵城县（今属山西洪洞县）广胜寺，所以后人将它定名为《赵城金藏》。全藏约七千卷左右，六千多万字，现存四千余卷。2017年12月28日，国家图书馆《赵城金藏》1281件正式发布。</p></li><li><p>宋人文集国家图书馆精选所藏宋人文集善本二百七十五部，首选宋元刊本，次及明清精抄精刻，或经名家校勘题跋之本，通过缩微胶卷还原数字影像，并辅以详细书目建成本全文影像数据库，目前已发布275部，免费呈献公众利用。</p></li><li><p>碑帖菁华以国家图书馆藏有的历代甲骨、青铜器、石刻等类拓片二十三万余件为基础建设的数据库，内容涉及历史、地理、政治、经济、军事、民族、民俗、文学、艺术、科技、建筑等方面。2019年11月12日又新增发布2595种馆藏明清碑刻拓片数字资源，现有元数据2.5万余条，影像3.1万余幅。</p></li><li><p>甲骨世界被誉为二十世纪四大文献发现之一的甲骨文，集文献性、文物性、收藏性于一身，是研究我国商朝晚期不可多得的珍贵史料，该库包括甲骨实物元数据2964条，影像5932幅；甲骨拓片元数据2975条，影像3177幅。</p></li><li><p>西夏文献以国家图书馆保存的西夏、元代孤本及各种西夏的珍贵实物资料为基础建设的数据库。包括西夏文献书目数据124条，原件影像近5000拍。</p></li><li><p>西夏论著包括西夏研究论文篇名数据1200余条。</p></li><li><p>年画撷英国家图书馆收藏了杨柳青、朱仙镇等地制作的4000余幅年画作品，从中精选出一部分制作了该库，并为每种年画编写了内容说明，重点介绍了该年画的故事梗概、历史背景、制作特色和相关知识。目前发布元数据及影像302组。</p></li><li><p>前尘旧影该资源库收录了国家图书馆收藏的新旧照片3074组，真实生动地记录了过去的社会事件、历史人物、城乡面貌、名胜古迹和建筑服饰等，人们可从中解读出不同历史时期特定事物的形象特征和真实信息，具有十分重要的历史价值。</p></li><li><p>敦煌遗珍国际敦煌项目（IDP）建设的数据库，发布来自敦煌和丝绸之路上的写本、绘画、纺织品及器物的信息和图片，其中包括国家图书馆藏敦煌写卷影像18万余拍。</p></li><li><p>徽州善本家谱徽州善本家谱印刷资料数据库是中国国家图书馆与法国远东学院的合作项目，收录了中国国家图书馆藏善本古籍中徽州家谱243种286部，配有书影5437幅。</p></li><li><p>中华医药典籍资源库（测试版）图书馆收藏的文献典籍是整理研究的基础资料，为使读者能够通过互联网检索、利用中医文献资源，国家图书馆（国家古籍保护中心）将逐步建设中华医药典藏资源库，目前首批对221种中医古籍影像进行发布测试。</p></li><li><p>云南图书馆古籍云南省图书馆将该馆古籍数字资源共139种727册提供给国家图书馆（国家古籍保护中心），这批资源均是云南省图书馆所藏珍贵的、有代表性的古籍文献，特别是明代云南丽江木氏土司家族著述，更是明代少数民族汉文著述的代表。该批资源于2019年11月12日正式在线发布。</p></li><li><p>天津图书馆古籍为进一步丰富古籍数字资源品种和版本，满足广大读者使用需求，2014年底，天津图书馆向国家图书馆（国家古籍保护中心）提供总量约5,800余种300万拍明清古籍数字资源，该批资源经加工后，于2018年9月28日、2019年1月28日分两批发布。</p></li><li><p>上海图书馆家谱上海图书馆现藏有家谱近3万余种30余万册共计365个姓氏，收藏的家谱覆盖全国27个省、自治区及直辖市，是国内外收藏中国家谱原件最多的公藏机构，有着“全球中国家谱第一藏”之美誉。国家图书馆与上海图书馆合作，征集该馆所藏明清家谱资源2200余种，在国图网站发布使用。</p></li><li><p>中华古籍善本联合书目中华古籍善本国际联合书目系统是由中文善本书国际联合目录项目发展而来的新数据库，著录了三十余家海内外图书馆所藏古籍善本，数据达2万多条，并配有1.4万余幅书影。</p></li><li><p>东文研汉籍影像库东京大学东洋文化研究所收藏有大量中国古籍，其中包括东方文化学院东京研究所的旧藏以及大木幹一、长泽规矩也、仓石武四郎等各具特色的个人收藏。2009年11月，东洋文化研究所将所藏中文古籍4000余种，以数字化方式无偿提供给中国国家图书馆，在国图网站上面向读者提供服务。</p></li><li><p>哈佛大学善本特藏哈佛大学哈佛燕京图书馆藏中文善本古籍特藏，以其质量之高、数量之大著称于世。为了方便海内外学人便捷地利用这些资料进行研究，同时以数字化形式保存这些中华古籍精品，2009年国家图书馆与哈佛大学哈佛燕京图书达成协议，对哈佛燕京图书馆所藏中文善本和齐如山专藏进行数字化。目前在线发布经部和史部善本数字资源741部，另有齐如山戏曲小说专藏204种。</p></li><li><p>法藏敦煌遗书2015年，在法国国家图书馆与中国国家图书馆达成合作意向，由法国国家图书馆向中国国家图书馆赠送馆藏全部敦煌遗书高清数字资源。在双方共同努力下，实现了这批敦煌遗书的数字化回归，并于2018年3月5日正式在线发布，共计5300余号3.1万余拍。</p></li><li><p>中华寻根网中华寻根网是国家图书馆与澳门基金会开展的文化合作项目，是以提供姓氏源流和家谱资源服务为核心、方便海内外华人寻根问祖活动的网络平台。“中华寻根网”目前提供500多个姓氏源流、2000多部家谱和6000种其他文献的阅览，以及自建家谱，交流联谊的互动服务。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“中华古籍资源库”是“中华古籍保护计划”的重要成果。2016年9月28日，“中华古籍资源库”正式开通运行，陆续发布国家图书馆藏善本和普通古籍、法国国家图书馆藏敦煌遗书、天津图书馆藏普通古籍、日本永青文库捐赠汉籍、云南省图书馆善本古籍、芷兰斋藏稿抄校本等古籍影像资源，总量超过3.3万部。&lt;/p&gt;
&lt;p&gt;《中华古籍资源库》！！！&lt;br&gt;
网址：&lt;a href=&quot;http://www.nlc.cn/pcab/zy/zhgj_zyk/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.nlc.cn/pcab/zy/zhgj_zyk/&lt;/a&gt;&lt;br&gt;
查询：&lt;a href=&quot;http://read.nlc.cn/thematDataSearch/toGujiIndex&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://read.nlc.cn/thematDataSearch/toGujiIndex&lt;/a&gt;&lt;/p&gt;
&lt;img src=&quot;/public/2021/12/16/readings/zhonghuaguji/image-20211216225907506.png&quot; alt=&quot;image-20211216225907506&quot; style=&quot;zoom:30%;&quot;&gt;
    
    </summary>
    
      <category term="书籍" scheme="https://talengu.github.io/public/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="资源" scheme="https://talengu.github.io/public/tags/%E8%B5%84%E6%BA%90/"/>
    
      <category term="古籍" scheme="https://talengu.github.io/public/tags/%E5%8F%A4%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>2021 年科隆游戏展奖项提名名单</title>
    <link href="https://talengu.github.io/public/2021/09/01/2021games/"/>
    <id>https://talengu.github.io/public/2021/09/01/2021games/</id>
    <published>2021-09-01T12:00:00.000Z</published>
    <updated>2021-09-01T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>帝国时代3，现在帝国4！<br>2021 年科隆游戏展奖项提名名单正式公布</p><a id="more"></a><p>8 月 23 日，2021 年科隆游戏展的奖项提名名单已经全部揭晓，本次直接涉及游戏的奖项有 21 个，其中获得提名的游戏分别为：</p><p>最佳微软 Xbox 游戏：《艾尔登法环》（万代南梦宫娱乐）；《孤岛惊魂 6》（育碧）；《光环无限》（微软）</p><p>最佳任天堂 Switch 游戏：《舞力全开 2022》（育碧）；《马里奥 + 疯狂兔子星耀之愿》 (育碧)</p><p>最佳 PC 游戏：《帝国时代 4》(微软)；《艾尔登法环》（万代南梦宫娱乐）；《塞伯利亚之谜: 世界之前》 (Astragon Entertainment)</p><p>最佳索尼 PlayStation 游戏：《艾尔登法环》（万代南梦宫娱乐）；《破晓传说》（万代南梦宫娱乐）；《黑相集：灰冥界》 (万代南梦宫娱乐)</p><p>最佳动作冒险游戏：《艾尔登法环》（万代南梦宫娱乐）；《马里奥 + 疯狂兔子星耀之愿》 (育碧)；《塞伯利亚之谜: 世界之前》 (Astragon Entertainment)</p><p>最佳动作游戏：《孤岛惊魂 6》（育碧）；《光环：无限》（微软）；《彩虹六号：异种》（育碧）</p><p>最佳家庭游戏：《舞力全开 2022》（育碧）；《Run Prop, Run!》（PlayTogether Studio）；《Super Dungeon Maker》 (Rokaplay)</p><p>最佳独立游戏：《Dorfromantik》（Toukana Interactive）；《Inua》（Arte France）；《Lost in Random》（EA）</p><p>最佳角色扮演游戏：《艾尔登法环》（万代南梦宫娱乐）；《Encased》（科赫传媒）；《破晓传说》（万代南梦宫娱乐）</p><p>最佳模拟游戏：《攀登者：天空是极限》(Art Games Studio)；《模拟农场 22》 (Astragon Entertainment)</p><p>最佳体育游戏：《攀登者：天空是极限》(Art Games Studio)；《FIFA22》（EA）；《Riders Republic》（育碧）</p><p>最佳策略游戏：《帝国时代 4》 (微软)；《英雄连 3》 (世嘉)；《马里奥 + 疯狂兔子星耀之愿》 (育碧)</p><p>最佳多人游戏：《光环无限》（微软）；《Riders Republic》（育碧）；《黑相集：灰冥界》 (万代南梦宫娱乐)</p><p>持续时间最长游戏：《Apex 游戏》（EA）；《黑色沙漠》 (Pearl Abyss Corp.)；《末日地带: 隔离的世界》 (Assemble Entertainment)</p><p>最具原创性的游戏：《骰子遗产》（科赫传媒/Destinybit）；《Riders Republic》（育碧）；《Terrorbane》 (轻语互动)</p><p>2021 年科隆游戏展将会于 8 月 25 日至 8 月 29 日举办，将保留现场展览的形式，同时线上数字展形式也将同步举行。</p><hr><p><strong>参考</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;帝国时代3，现在帝国4！&lt;br&gt;
2021 年科隆游戏展奖项提名名单正式公布&lt;/p&gt;
    
    </summary>
    
      <category term="游戏" scheme="https://talengu.github.io/public/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="日常杂记" scheme="https://talengu.github.io/public/tags/%E6%97%A5%E5%B8%B8%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【转】在 C/C++ 程序中打印当前函数调用栈</title>
    <link href="https://talengu.github.io/public/2021/08/25/c_debug/"/>
    <id>https://talengu.github.io/public/2021/08/25/c_debug/</id>
    <published>2021-08-25T23:18:52.000Z</published>
    <updated>2021-08-25T23:18:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>背景</strong></p><p>2011 年 6 月 11 日 <a href="http://www.wuzesheng.com/?author=2" title="由 小武哥 发布" target="_blank" rel="noopener">小武哥</a></p><p>前几天帮同事跟踪的一个程序莫名退出，没有 core dump(当然 ulimit 是打开的) 的问题。我们知道，正常情况下，如果程序因为某种异常条件退出的话，应该会产生 core dump，而如果程序正常退出的话，应该是直接或者间接的调用了 exit() 相关的函数。基于这个事实，我想到了这样一个办法，在程序开始时，通过系统提供的 atexit()，向系统注册一个回调函数，在程序调用 exit() 退出的时候，这个回调函数就会被调用，然后我们在回调函数中打印出当前的函数调用栈，由此便可以知道 exit() 是在哪里调用，从而上述问题便迎刃而解了。上述方法用来解决类似问题是非常行之有效的。在上面，我提到了在 “回调函数中打印出当前的函数调用栈”，相信细心的朋友应该注意到这个了，本文的主要内容就是详细介绍，如何在程序中打印中当前的函数调用栈。</p><a id="more"></a><p>我之前写过一篇题目为《<a href="http://www.wuzesheng.com/?p=1123" target="_blank" rel="noopener">介绍几个关于 C/C++ 程序调试的函数</a>》的文章，看到这里，请读者朋友先看一下前面这篇，因为本文是以前面这篇文章为基础的。我正是用了 backtrace() 和 backtrace_symbols() 这两个函数实现的，下面是一个简单的例子，通过这个例子我们来介绍具体的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo .h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio .h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib .h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stacktrace</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stackstrace begin:\n"</span>);</span><br><span class="line">    print_stacktrace();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun1();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stacktrace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">void</span> * <span class="built_in">array</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> stack_num = backtrace(<span class="built_in">array</span>, size);</span><br><span class="line">    <span class="keyword">char</span> ** stacktrace = backtrace_symbols(<span class="built_in">array</span>, stack_num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stack_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, stacktrace[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(stacktrace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（说明：下面的介绍采用的环境是 ubuntu 11.04, x86_64, gcc-4.5.2）</p><ol><li><p>通过下面的方式编译运行：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ gcc test.cc -o test1</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ ./test1</span><br><span class="line">stackstrace begin:</span><br><span class="line">./test1() [0x400645]</span><br><span class="line">./test1() [0x400607]</span><br><span class="line">./test1() [0x400612]</span><br><span class="line">./test1() [0x40061d]</span><br><span class="line">./test1() [0x4005ed]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xff) [0x7f5c59a91eff]</span><br><span class="line">./test1() [0x400529]</span><br></pre></td></tr></table></figure><p>从上面的运行结果中，我们的确看到了函数的调用栈，但是都是 16 进制的地址，会有点小小的不爽。当然我们可以通过反汇编得到每个地址对应的函数，但这个还是有点麻烦了。不急，且听我慢慢道来，看第 2 步。</p></li><li><p>通过下面的方式编译运行：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ gcc test.cc -rdynamic -o test2</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ ./test2</span><br><span class="line">stackstrace begin:</span><br><span class="line">./test2(_Z16print_stacktracev+0x26) [0x4008e5]</span><br><span class="line">./test2(_Z4fun1v+0x13) [0x4008a7]</span><br><span class="line">./test2(_Z4fun2v+0x9) [0x4008b2]</span><br><span class="line">./test2(_Z4fun3v+0x9) [0x4008bd]</span><br><span class="line">./test2(main+0x9) [0x40088d]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xff) [0x7f9370186eff]</span><br><span class="line">./test2() [0x4007c9]</span><br></pre></td></tr></table></figure><p>这下终于可以看到函数的名字了，对比一下 2 和 1 的编译过程，2 比 1 多了一个 <strong>- rdynamic</strong> 的选项，让我们来看看这个选项是干什么的 (来自 gcc mannual 的说明):</p><pre><code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rdynamic</span><br><span class="line">Pass the flag -export-dynamic to the ELF linker, on targets that support it. This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. This option is needed for some uses of "dlopen" or to allow obtaining backtraces from within a program.</span><br></pre></td></tr></table></figure></code></pre><p>从上面的说明可以看出，它的主要作用是让链接器把所有的符号都加入到动态符号表中，这下明白了吧。不过这里还有一个问题，这里的函数名都是 mangle 过的，需要 demangle 才能看到原始的函数。关于 c++ 的 mangle/demangle 机制，不了解的朋友可以在搜索引擎上搜一下，我这里就不多就介绍了。这里介绍如何用命令来 demangle，通过 c++filt 命令便可以:</p><pre><code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ c++filt &lt; &lt;&lt; "_Z16print_stacktracev"</span><br><span class="line">print_stacktrace()</span><br></pre></td></tr></table></figure></code></pre><p>写到这里，大部分工作就 ok 了。不过不知道大家有没有想过这样一个问题，同一个函数可以在代码中多个地方调用，如果我们只是知道函数，而不知道在哪里调用的，有时候还是不够方便，bingo，这个也是有办法的，可以通过 address2line 命令来完成，我们用第 2 步中编译出来的 test2 来做实验 (address2line 的 - f 选项可以打出函数名, -C 选项也可以 demangle)：</p><pre><code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ addr2line -a 0x4008a7 -e test2 -f</span><br><span class="line">0x00000000004008a7</span><br><span class="line">_Z4fun1v</span><br><span class="line">??:0</span><br></pre></td></tr></table></figure></code></pre><p>Oh no，怎么打出来的位置信息是乱码呢？不急，且看我们的第 3 步。</p><ol start="3"><li><p>通过下面的方式编译运行：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ gcc test.cc -rdynamic -g -o test3</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ ./test3</span><br><span class="line">stackstrace begin:</span><br><span class="line">./test3(_Z16print_stacktracev+0x26) [0x4008e5]</span><br><span class="line">./test3(_Z4fun1v+0x13) [0x4008a7]</span><br><span class="line">./test3(_Z4fun2v+0x9) [0x4008b2]</span><br><span class="line">./test3(_Z4fun3v+0x9) [0x4008bd]</span><br><span class="line">./test3(main+0x9) [0x40088d]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xff) [0x7fa9558c1eff]</span><br><span class="line">./test3() [0x4007c9]</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ addr2line -a 0x4008a7 -e test3 -f -C</span><br><span class="line">0x00000000004008a7</span><br><span class="line">fun1()</span><br><span class="line">/home/wuzesheng/work/test/test.cc:20</span><br></pre></td></tr></table></figure></li></ol><p>看上面的结果，我们不仅得到了调用栈，而且可以得到每个函数的名字，以及被调用的位置，大功告成。在这里需要说明一下的是，第 3 步比第 2 步多了一个 - g 选项，-g 选项的主要作用是生成调试信息，位置信息就属于调试信息的范畴，经常用 gdb 的朋友相信不会对这个选项感到陌生。</p><h3 id="在-C-C-程序里打印调用栈信息"><a class="header-anchor" href="#在-C-C-程序里打印调用栈信息">¶</a>在 C/C++ 程序里打印调用栈信息</h3><p>我们知道，GDB 的 backtrace 命令可以查看堆栈信息。但很多时候，GDB 根本用不上。比如说，在线上环境中可能没有 GDB，即使有，也不太可能让我们直接在上面调试。如果能让程序自己输出调用栈，那是最好不过了。本文介绍和调用椎栈相关的几个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">    backtrace, backtrace_symbols, backtrace_symbols_fd - support <span class="keyword">for</span> application self-debugging</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">void</span> **buffer, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> **<span class="title">backtrace_symbols</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">const</span> *buffer, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace_symbols_fd</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">const</span> *buffer, <span class="keyword">int</span> size, <span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>以上内容源自这几个函数的 man 手册。</p><p>先简单介绍一下这几个函数的功能：<strong>backtrace</strong>：获取当前的调用栈信息，结果存储在 buffer 中，返回值为栈的深度，参数 size 限制栈的最大深度，即最大取 size 步的栈信息。<strong>backtrace_symbols</strong>：把 backtrace 获取的栈信息转化为字符串，以字符指针数组的形式返回，参数 size 限定转换的深度，一般用 backtrace 调用的返回值。<strong>backtrace_symbols_fd</strong>：它的功能和 backtrace_symbols 差不多，只不过它不把转换结果返回给调用方，而是写入 fd 指定的文件描述符。</p><p>Man 手册里，给出了一个简单的实例，我们看一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  SIZE 100 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, nptrs;</span><br><span class="line">    <span class="keyword">void</span> *buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span> **strings;</span><br><span class="line">    nptrs = backtrace(buffer, SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"backtrace() returned %d addresses\n"</span>, nptrs);</span><br><span class="line">      </span><br><span class="line"> <span class="comment">/* The call backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)  </span></span><br><span class="line"><span class="comment">  *  would produce similar output to the following: */</span></span><br><span class="line">        strings = backtrace_symbols(buffer, nptrs);</span><br><span class="line">    <span class="keyword">if</span> (strings == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"backtrace_symbols"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nptrs; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strings[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(strings);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* "static" means don't export the symbol... */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myfunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myfunc3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> ncalls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ncalls &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        myfunc(ncalls - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        myfunc2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">if</span>  (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s num-calls\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);  </span><br><span class="line">    &#125;</span><br><span class="line">    myfunc(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cc prog.c -o prog</span></span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./prog 0</span></span><br><span class="line">backtrace() returned 6 addresses</span><br><span class="line">./prog() [0x80485a3]</span><br><span class="line">./prog() [0x8048630]</span><br><span class="line">./prog() [0x8048653]</span><br><span class="line">./prog() [0x80486a7]</span><br></pre></td></tr></table></figure><p>这样，是输出了调用栈，不过只是以十六进制输出函数地址而已，可读性很差。仔细看下 man 手册，原来很简单，编译时加上个参数：</p><p>重新编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cc -rdynamic  prog.c -o prog</span></span><br></pre></td></tr></table></figure><p>通过 gcc 手册，我们可以也解下参数的说明:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rdynamic</span><br><span class="line">        Pass the flag -export-dynamic to the ELF linker, on targets that support it. This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. This option is needed for some uses of "dlopen" or to allow obtaining backtraces from within a program.</span><br></pre></td></tr></table></figure><p>再执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./prog 0</span></span><br><span class="line">backtrace() returned 6 addresses</span><br><span class="line">./prog(myfunc3+0x1f) [0x8048763]</span><br><span class="line">./prog() [0x80487f0]</span><br><span class="line">./prog(myfunc+0x21) [0x8048813]</span><br><span class="line">./prog(main+0x52) [0x8048867]</span><br><span class="line">/lib/libc.so.6(__libc_start_main+0xe6) [0xaf9cc6]</span><br><span class="line">./prog() [0x80486b1]</span><br></pre></td></tr></table></figure><p>这回，可以看到函数名了。是不是很酷呢？把它封装到你的调试代码中吧。</p><hr><p><strong>原地址</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2011 年 6 月 11 日 &lt;a href=&quot;http://www.wuzesheng.com/?author=2&quot; title=&quot;由 小武哥 发布&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小武哥&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前几天帮同事跟踪的一个程序莫名退出，没有 core dump(当然 ulimit 是打开的) 的问题。我们知道，正常情况下，如果程序因为某种异常条件退出的话，应该会产生 core dump，而如果程序正常退出的话，应该是直接或者间接的调用了 exit() 相关的函数。基于这个事实，我想到了这样一个办法，在程序开始时，通过系统提供的 atexit()，向系统注册一个回调函数，在程序调用 exit() 退出的时候，这个回调函数就会被调用，然后我们在回调函数中打印出当前的函数调用栈，由此便可以知道 exit() 是在哪里调用，从而上述问题便迎刃而解了。上述方法用来解决类似问题是非常行之有效的。在上面，我提到了在 “回调函数中打印出当前的函数调用栈”，相信细心的朋友应该注意到这个了，本文的主要内容就是详细介绍，如何在程序中打印中当前的函数调用栈。&lt;/p&gt;
    
    </summary>
    
      <category term="c语言" scheme="https://talengu.github.io/public/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://talengu.github.io/public/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>RSS跟踪github文件更新</title>
    <link href="https://talengu.github.io/public/2021/07/24/rss_github_file/"/>
    <id>https://talengu.github.io/public/2021/07/24/rss_github_file/</id>
    <published>2021-07-24T12:00:00.000Z</published>
    <updated>2021-07-24T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>好久没有更新博客了。RSS这种形式的信息获取方式，似乎又流行起来。github上面有很多不错的资源。我的流程是：github readme文件更新-&gt;svn下载对应文件-&gt;生成rss文件。</p><p>这里为什么要这么复杂，因为github仓库更新多了好多不需要的rss信息，而且github文件下载比较慢。</p><p>最后效果，获取《经济学人》和《纽约客》的更新～</p><p><img src="/public/2021/07/24/rss_github_file/rss_result.png" alt="image-20210724005152399"></p><a id="more"></a><h2 id="下载脚本"><a class="header-anchor" href="#下载脚本">¶</a>下载脚本</h2><p>解析readme中的地址，自动下载，并生成rss源。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># /etc/cron.hour </span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> rfeed <span class="keyword">import</span> * <span class="comment"># 为生成rss.xml的库</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line">URL=<span class="string">"https://raw.githubusercontent.com/hehonghui/the-economist-ebooks/master/README.md"</span></span><br><span class="line">BASE_URL=<span class="string">"http://your_vps_host/download/"</span></span><br><span class="line"></span><br><span class="line">SVN_BASE_URL=<span class="string">"https://github.com/hehonghui/the-economist-ebooks/trunk/"</span></span><br><span class="line"></span><br><span class="line">s=<span class="string">"""</span></span><br><span class="line"><span class="string">* [经济学人 - 周刊, 点击这里下载最新一期](01_economist/te_2021.02.27) , 每周五十一点更新</span></span><br><span class="line"><span class="string">* [纽约客 - 周刊, 点击这里下载最新一期](02_new_yorker/2021.03.01) , 每周六上午更新</span></span><br><span class="line"><span class="string">* [卫报 - 每周两期](09_guardian/), 每周三、周日更新</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">s = request.urlopen(URL).read().decode(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">res= re.findall(<span class="string">r"\[.+\]\((0.+)\)"</span>,s)[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># generate xml</span></span><br><span class="line">res_list=[]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">res_list+=sorted(glob(item.split(<span class="string">'/'</span>)[<span class="number">0</span>]+<span class="string">"/*"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">item_list=[]</span><br><span class="line">print(item_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> res_list:</span><br><span class="line">    _one = Item(</span><br><span class="line">title = item[<span class="number">3</span>:],</span><br><span class="line">        link = BASE_URL+item,</span><br><span class="line">description = <span class="string">'pdf etc. &lt;a href="%s"&gt;link&lt;/a&gt; '</span>% (BASE_URL+item),</span><br><span class="line">        author = <span class="string">"hehonghui"</span>,</span><br><span class="line">        guid = Guid(BASE_URL+item),</span><br><span class="line">        pubDate = datetime.datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>)) <span class="comment"># year, month, date, hh, mm, ss</span></span><br><span class="line">    item_list+=[_one]</span><br><span class="line"></span><br><span class="line">feed = Feed(</span><br><span class="line">        title = <span class="string">"经济学人+纽约客更新"</span>,</span><br><span class="line">        link = <span class="string">"https://www.xxxxx.biz/atom/updated.xml"</span>,</span><br><span class="line">        description = <span class="string">"更新经济学人，纽约客"</span>,</span><br><span class="line">        language = <span class="string">"en-US"</span>,</span><br><span class="line">        lastBuildDate = datetime.datetime.now(),</span><br><span class="line">        items = item_list)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_file</span><span class="params">(file_name, contents)</span>:</span></span><br><span class="line">    fh = open(file_name, <span class="string">'w'</span>)</span><br><span class="line">    fh.write(contents)</span><br><span class="line">    fh.close()</span><br><span class="line"></span><br><span class="line">save_to_file(<span class="string">'test.xml'</span>, feed.rss())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># start downing </span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> res_list:</span><br><span class="line">    print(<span class="string">"downing %s"</span>%item)</span><br><span class="line">    os.popen(<span class="string">"svn checkout %s %s"</span>%(SVN_BASE_URL+item,item))</span><br><span class="line"></span><br><span class="line">    _now=sorted(glob(item.split(<span class="string">'/'</span>)[<span class="number">0</span>]+<span class="string">"/*"</span>))</span><br><span class="line">    print(_now)</span><br><span class="line">    <span class="keyword">if</span> len(_now)&gt;=<span class="number">5</span>: <span class="comment"># 最多5个，免得服务器下载过多。</span></span><br><span class="line">        <span class="keyword">for</span> _d <span class="keyword">in</span> _now[:<span class="number">-5</span>]:</span><br><span class="line">            os.popen(<span class="string">"rm -rf %s"</span>%_d)</span><br></pre></td></tr></table></figure><p>在linux亦可使用<a href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html" target="_blank" rel="noopener">crontab</a>定时启动下载任务。在 <code>/etc/cron.hourly/</code> 设置即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">date &gt;&gt; test.log</span><br><span class="line">python3 down_ecomic.py &gt;&gt;test.log</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>从youtube下载音频，自动转成mp3格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">#</span><br><span class="line"># 2020-04-18</span><br><span class="line"># /etc/cron.hour # https://www.runoob.com/w3cnote/linux-crontab-tasks.html</span><br><span class="line">from urllib import request</span><br><span class="line">import datetime</span><br><span class="line">from rfeed import *</span><br><span class="line">import re</span><br><span class="line">import os</span><br><span class="line">from glob import glob</span><br><span class="line">import feedparser</span><br><span class="line">import pprint</span><br><span class="line">URL=&quot;https://www.youtube.com/feeds/videos.xml?channel_id=UCFhp6N5z8W9Ann2eyHAzbbA&quot;</span><br><span class="line">rss = feedparser.parse(URL)</span><br><span class="line">entries=rss[&apos;entries&apos;][:3]</span><br><span class="line"></span><br><span class="line">BASE_URL=&quot;http://xxxxx/down_youtube/&quot;</span><br><span class="line"></span><br><span class="line">item_list=[]</span><br><span class="line">for entry in entries:</span><br><span class="line">    print(entry[&apos;title&apos;])</span><br><span class="line">    print(entry[&apos;published&apos;])</span><br><span class="line">    print(entry[&apos;link&apos;])</span><br><span class="line">    #print(entry[&apos;summary&apos;])</span><br><span class="line">    new_link=BASE_URL+&quot;book_audios/%s.mp3&quot;%entry[&apos;yt_videoid&apos;]</span><br><span class="line">    _one = Item(</span><br><span class="line">title = entry[&apos;title&apos;],</span><br><span class="line">        link = new_link,</span><br><span class="line">description = &apos;audio: &lt;a href=&quot;%s&quot;&gt;mp3&lt;/a&gt; %s&apos;% (new_link,entry[&apos;summary&apos;]),</span><br><span class="line">        author = &quot;Youtube&quot;,</span><br><span class="line">        guid = Guid(new_link),</span><br><span class="line">        pubDate = datetime.datetime(2020, 1, 1, 4, 0)) # year, month, date, hh, mm, ss</span><br><span class="line">    item_list+=[_one]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">feed = Feed(</span><br><span class="line">        title = &quot;知乎读书会更新&quot;,</span><br><span class="line">        link = &quot;https://www.xxxxx.biz/atom/updated.xml&quot;,</span><br><span class="line">        description = &quot;更新Youtube知乎读书会&quot;,</span><br><span class="line">        language = &quot;en-US&quot;,</span><br><span class="line">        lastBuildDate = datetime.datetime.now(),</span><br><span class="line">        items = item_list)</span><br><span class="line"></span><br><span class="line">def save_to_file(file_name, contents):</span><br><span class="line">    fh = open(file_name, &apos;w&apos;)</span><br><span class="line">    fh.write(contents)</span><br><span class="line">    fh.close()</span><br><span class="line"></span><br><span class="line">save_to_file(&apos;audio.xml&apos;, feed.rss())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">from os import rename</span><br><span class="line">import youtube_dl</span><br><span class="line"></span><br><span class="line"># start downing </span><br><span class="line">if not os.path.exists(&quot;book_audios/&quot;):</span><br><span class="line">    os.makedirs(&quot;book_audios/&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def audio_download(youtube_url):</span><br><span class="line">    # 定义某些下载参数</span><br><span class="line">    ydl_opts = &#123;</span><br><span class="line">        &apos;format&apos;: &apos;bestaudio/best&apos;,</span><br><span class="line">     #   &apos;download_archive&apos;: &apos;downloaded_songs.txt&apos;,</span><br><span class="line">        &apos;outtmpl&apos;: &apos;book_audios/%(id)s.%(ext)s&apos;,</span><br><span class="line">        &apos;postprocessors&apos;: [&#123;</span><br><span class="line">            &apos;key&apos;: &apos;FFmpegExtractAudio&apos;,</span><br><span class="line">            &apos;preferredcodec&apos;: &apos;mp3&apos;,</span><br><span class="line">            &apos;preferredquality&apos;: &apos;192&apos;,</span><br><span class="line">            &#125;],</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    with youtube_dl.YoutubeDL(ydl_opts) as ydl:</span><br><span class="line">        ydl.download([youtube_url])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#download(&apos;https://www.youtube.com/watch?v=JElpSrsmbTU&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for entry in entries:</span><br><span class="line">    if entry[&apos;yt_videoid&apos;]+&apos;.mp3&apos; not in os.listdir(&apos;book_audios&apos;):</span><br><span class="line">        print(&quot;downing %s, %s&quot;%(entry[&apos;title&apos;], entry[&apos;link&apos;]))</span><br><span class="line">        audio_download(entry[&apos;link&apos;])</span><br><span class="line">   </span><br><span class="line">    _now=sorted(glob(&quot;book_audios/*&quot;),key=os.path.getctime)</span><br><span class="line">    print(_now)</span><br><span class="line">    if len(_now)&gt;=6: # 多余删除</span><br><span class="line">        for _d in _now[:-5]:</span><br><span class="line">            os.popen(&quot;rm -rf %s&quot;%_d)</span><br></pre></td></tr></table></figure><p>祝大家使用愉快！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好久没有更新博客了。RSS这种形式的信息获取方式，似乎又流行起来。github上面有很多不错的资源。我的流程是：github readme文件更新-&amp;gt;svn下载对应文件-&amp;gt;生成rss文件。&lt;/p&gt;
&lt;p&gt;这里为什么要这么复杂，因为github仓库更新多了好多不需要的rss信息，而且github文件下载比较慢。&lt;/p&gt;
&lt;p&gt;最后效果，获取《经济学人》和《纽约客》的更新～&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/public/2021/07/24/rss_github_file/rss_result.png&quot; alt=&quot;image-20210724005152399&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://talengu.github.io/public/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="RSS" scheme="https://talengu.github.io/public/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>选择困难者的福音？层次分析法</title>
    <link href="https://talengu.github.io/public/2021/04/02/math_AHP/"/>
    <id>https://talengu.github.io/public/2021/04/02/math_AHP/</id>
    <published>2021-04-02T12:00:00.000Z</published>
    <updated>2021-04-02T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong></p><p>日常生活中，我们面临很多的选择，选择工作offer，选择买哪个牌子的手机，选择哪个地方旅行等等。这些选择难以定量的衡量，有很多不确定性。内心小纠结，我选择了这个，万一那个好呢，怎么办？请看层次分析法。</p><p>层次分析法(Analytic Hierarchy Process，简称 AHP)是对一些较为复杂、较为模糊的问题作出决策的简易方法，它特别适用于那些难于完全定量分析的问题。它是美国运筹学家 T. L. Saaty 教授于上世纪 70 年代初期提出的一种简便、灵活而又实用的多准则决策方法。</p><p>运用层次分析法建模，大体上可按下面四个步骤进行</p><ul><li>建立递阶层次结构模型</li><li>构造出各层次中的所有判断矩阵</li><li>层次单排序及一致性检验</li><li>层次总排序及一致性检验。（一般不用）</li></ul><a id="more"></a><p>让我们从offer大佬的例子开始吧！</p><p>举个栗子，今年有位大学生，有三个offer，C1 C2 C3。</p><p>第一步，建立层次模型。</p><ul><li>目标层A：找工作的目标，自己满意程度。<ul><li>这个程度怎么计算呢？比如工作1。</li></ul></li><li>准则层B：研究课题、发展前途、待遇、同事情况、地理位置、单位名气等等。<ul><li>尽量列全一点，不需要排列重要顺序。</li><li>小于等于9个，后面要两两拍脑袋给出相对的重要层度，给多了不得把脑袋拍疼了。</li><li>也可以有子准则层，比如待遇中的放假、工作环境等等，列出也小于9个。</li></ul></li><li>方案层C：就是我们的offer</li></ul><img src="/public/2021/04/02/math_AHP/image-20200406145535585.png" alt="image-20200406145535585" style="zoom:50%;"><h2 id="构造-A-B-之间判断矩阵"><a class="header-anchor" href="#构造-A-B-之间判断矩阵">¶</a>构造 A B 之间判断矩阵</h2><p>准则层B与目标A之间的关系。为了求出准则层中(B1-6) 对目标的重要层度的排序。比如对于该生工作满意度第一重要是待遇，然后是地点，其实该生自己也很模糊。就是固定A，然后求B中准则，对A重要性的排序。</p><h3 id="我们怎么对B中的准则们的重要排序呢？"><a class="header-anchor" href="#我们怎么对B中的准则们的重要排序呢？">¶</a>我们怎么对B中的准则们的重要排序呢？</h3><p>直接给每一个准则，0-1的评分，然后排序。经常会想，给完分之后，这个不合理呀要不我再给哪个准则加加分。所以这样的方法常常会因考虑不周全、顾此失彼而使决策者提出与他实际认为的重要性程度不相一致的数据。</p><p>我们可以将这个过程细化，我就比较两个准则对于目标的重要性，然后通过下面的矩阵方法，求出优先顺序。</p><p>还能通过一个一致性检验，来检验在你评分的过程中，有没有自相矛盾的地方，当然这种方法允许一些自相矛盾。反正评分的时候尊从内心拍脑袋就对了。</p><p>所以我们拿出一个B1 与 B2 对于目标的重要，想一想然后给出B2/B1，填入下面的表格中的(2,1)的位置。</p><p>整个矩阵i,j 与j，i 是取倒数的关系，所以只要做一半。</p><p>在找工作的目标下，准则i与j相对的重要性表示，B2/B1 的值。采用9个标度。而相比不重要刻度取倒数就可以了</p><table><thead><tr><th>准则i比j的比较</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td></td><td>相同重要</td><td></td><td>比较重要</td><td></td><td>明显重要</td><td></td><td>强烈重要</td><td></td><td>极端重要</td></tr></tbody></table><p>最后的两两相对重要表格</p><img src="/public/2021/04/02/math_AHP/image-20200406145640316.png" alt="image-20200406145640316" style="zoom:50%;"><p>对角线对称的两个数互为倒数，即 $$a_{ji}=\frac{1}{a_{ij}}$$  B1/B2 不就是和 B2/B1互为倒数嘛</p><p>从心理学观点来看，分级太多会超越人们的判断能力，既增加了作判断的难度， 又容易因此而提供虚假数据。Saaty 等人还用实验方法比较了在各种不同标度下人们判断结果的正确性，实验结果也表明，采用 1~9 标度最为合适。</p><p>判断矩阵的一致性指标步骤：</p><ul><li>1）计算一致性指标 CI 。$$CI=\frac{ \lambda_{max}-n}{n-1}$$</li><li>2）查表，平均随机一致性指标 RI。</li></ul><table><thead><tr><th>n</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>RI</td><td>0</td><td>0</td><td>0.58</td><td>0.90</td><td>1.12</td><td>1.24</td><td>1.32</td><td>1.41</td><td>1.45</td></tr></tbody></table><blockquote><p><em>RI</em> 的值是这样得到的，用随机方法构造500个样本矩阵:随机地从1~9及其倒数中抽取数字构造正互反矩阵，求得最大特征根的平均值 $$\bar \lambda_{max}$$ 并定义$$RI=\frac{\bar \lambda_{max}-n}{n-1}$$</p></blockquote><ul><li>3）计算一致性比例CR。 $$CR=\frac{CI}{RI}$$，当$$CR&lt;0.10$$ 时，认为判断矩阵的一致性是可以接受的，否则应对判断矩阵作适当修正。</li></ul><p>如果一个矩阵满足上面的条件，那么它最大特征值对应的特征向量就可以认为是每个维度的重要性权重。</p><h2 id="构造-B-C-之间判断矩阵"><a class="header-anchor" href="#构造-B-C-之间判断矩阵">¶</a>构造 B C 之间判断矩阵</h2><p>相同的方法，在同一B准则下，考虑不同工作的优先顺序。求工作排序的方法，和上面一样。</p><img src="/public/2021/04/02/math_AHP/image-20200406162644137.png" alt="image-20200406162644137" style="zoom:50%;"><p>python代码<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AHP</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, criteria, b)</span>:</span></span><br><span class="line">        self.RI = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.58</span>, <span class="number">0.9</span>, <span class="number">1.12</span>, <span class="number">1.24</span>, <span class="number">1.32</span>, <span class="number">1.41</span>, <span class="number">1.45</span>, <span class="number">1.49</span>)</span><br><span class="line">        self.criteria = criteria</span><br><span class="line">        self.b = b</span><br><span class="line">        self.num_criteria = criteria.shape[<span class="number">0</span>]</span><br><span class="line">        self.num_project = b[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cal_weights</span><span class="params">(self, input_matrix)</span>:</span></span><br><span class="line">        input_matrix = np.array(input_matrix)</span><br><span class="line">        n, n1 = input_matrix.shape</span><br><span class="line">        <span class="keyword">assert</span> n == n1, <span class="string">'不是一个方阵'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> np.abs(input_matrix[i, j] * input_matrix[j, i] - <span class="number">1</span>) &gt; <span class="number">1e-7</span>:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(<span class="string">'不是反互对称矩阵'</span>)</span><br><span class="line"></span><br><span class="line">        eigenvalues, eigenvectors = np.linalg.eig(input_matrix)</span><br><span class="line"></span><br><span class="line">        max_idx = np.argmax(eigenvalues)</span><br><span class="line">        max_eigen = eigenvalues[max_idx].real</span><br><span class="line">        eigen = eigenvectors[:, max_idx].real</span><br><span class="line">        eigen = eigen / eigen.sum()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">9</span>:</span><br><span class="line">            CR = <span class="literal">None</span></span><br><span class="line">            warnings.warn(<span class="string">'无法判断一致性'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            CI = (max_eigen - n) / (n - <span class="number">1</span>)</span><br><span class="line">            CR = CI / self.RI[n]</span><br><span class="line">        <span class="keyword">return</span> max_eigen, CR, eigen</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        max_eigen, CR, criteria_eigen = self.cal_weights(self.criteria)</span><br><span class="line">        print(<span class="string">'准则层：最大特征值&#123;:&lt;5f&#125;,CR=&#123;:&lt;5f&#125;,检验&#123;&#125;通过'</span>.format(max_eigen, CR, <span class="string">''</span> <span class="keyword">if</span> CR &lt; <span class="number">0.1</span> <span class="keyword">else</span> <span class="string">'不'</span>))</span><br><span class="line">        print(<span class="string">'准则层权重=&#123;&#125;\n'</span>.format(criteria_eigen))</span><br><span class="line"></span><br><span class="line">        max_eigen_list, CR_list, eigen_list = [], [], []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.b:</span><br><span class="line">            max_eigen, CR, eigen = self.cal_weights(i)</span><br><span class="line">            max_eigen_list.append(max_eigen)</span><br><span class="line">            CR_list.append(CR)</span><br><span class="line">            eigen_list.append(eigen)</span><br><span class="line"></span><br><span class="line">        pd_print = pd.DataFrame(eigen_list,</span><br><span class="line">                                index=[<span class="string">'准则'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num_criteria)],</span><br><span class="line">                                columns=[<span class="string">'方案'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num_project)],</span><br><span class="line">                                )</span><br><span class="line">        pd_print.loc[:, <span class="string">'最大特征值'</span>] = max_eigen_list</span><br><span class="line">        pd_print.loc[:, <span class="string">'CR'</span>] = CR_list</span><br><span class="line">        pd_print.loc[:, <span class="string">'一致性检验'</span>] = pd_print.loc[:, <span class="string">'CR'</span>] &lt; <span class="number">0.1</span></span><br><span class="line">        print(<span class="string">'方案层'</span>)</span><br><span class="line">        print(pd_print)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 目标层</span></span><br><span class="line">        obj = np.dot(criteria_eigen.reshape(<span class="number">1</span>, <span class="number">-1</span>), np.array(eigen_list))</span><br><span class="line">        print(<span class="string">'\n目标层'</span>, obj)</span><br><span class="line">        print(<span class="string">'最优选择是方案&#123;&#125;'</span>.format(np.argmax(obj)))</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 准则重要性矩阵</span></span><br><span class="line">    criteria = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">7</span>, <span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span> / <span class="number">3</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">5</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">5</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对每个准则，方案优劣排序</span></span><br><span class="line">    b1 = np.array([[<span class="number">1</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span> / <span class="number">8</span>], [<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">3</span>], [<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>]])</span><br><span class="line">    b2 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span> / <span class="number">5</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">    b3 = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span>]])</span><br><span class="line">    b4 = np.array([[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">    b5 = np.array([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span> / <span class="number">2</span>], [<span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">4</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    b = [b1, b2, b3, b4, b5]</span><br><span class="line">    a = AHP(criteria, b).run()</span><br></pre></td></tr></table></figure><h2 id="层次分析法与控制变量法"><a class="header-anchor" href="#层次分析法与控制变量法">¶</a>层次分析法与控制变量法</h2><p>我们的任务是选择工作，最后使得我们满意，直接选择我们当然一头雾水。所以我们设立一些准则，然后对这些准则对于目标的重要性排序。</p><p>这又有点像概率图模型，只是赋权的方法，是相互比较的方法。</p><h2 id="选择困难者的福音？"><a class="header-anchor" href="#选择困难者的福音？">¶</a>选择困难者的福音？</h2><p>层次分析法对人们的思维过程进行了加工整理，提出了一套系统分析问题的方法，为科学管理和决策提供了较有说服力的依据。</p><p>在应用层次分析法研究问题时，遇到的主要困难有两个:(1) 如何根据实际情况抽象出较为贴切的层次结构;(2) 如何将某些定性的量作比较接近实际定量化处理。</p><p>层次分析法的其局限性<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：(1) 它在很大程度上依赖于人们的经验，主观因素的影响很大，它至多只能排除思维过程中的严重非一致性，却无法排除决策者个人可能存在的严重片面性。(2) 比较、 判断过程较为粗糙，不能用于精度要求较高的决策问题。</p><p>所以，AHP 至多只能算是一种半定量(或定性与定量结合)的方法。本文仅供参考，不负法律责任，哈哈。</p><p>参考</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>幼鹰me 知乎 <a href="https://zhuanlan.zhihu.com/p/101505929" target="_blank" rel="noopener">层次分析法原理与Python实现</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>司守奎《数学建模算法与程序》第八章 层次分析法 P167 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;日常生活中，我们面临很多的选择，选择工作offer，选择买哪个牌子的手机，选择哪个地方旅行等等。这些选择难以定量的衡量，有很多不确定性。内心小纠结，我选择了这个，万一那个好呢，怎么办？请看层次分析法。&lt;/p&gt;
&lt;p&gt;层次分析法(Analytic Hierarchy Process，简称 AHP)是对一些较为复杂、较为模糊的问题作出决策的简易方法，它特别适用于那些难于完全定量分析的问题。它是美国运筹学家 T. L. Saaty 教授于上世纪 70 年代初期提出的一种简便、灵活而又实用的多准则决策方法。&lt;/p&gt;
&lt;p&gt;运用层次分析法建模，大体上可按下面四个步骤进行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立递阶层次结构模型&lt;/li&gt;
&lt;li&gt;构造出各层次中的所有判断矩阵&lt;/li&gt;
&lt;li&gt;层次单排序及一致性检验&lt;/li&gt;
&lt;li&gt;层次总排序及一致性检验。（一般不用）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数学" scheme="https://talengu.github.io/public/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="https://talengu.github.io/public/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="层次分析法" scheme="https://talengu.github.io/public/tags/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>地表最强大的还有这 14 位程序员</title>
    <link href="https://talengu.github.io/public/2020/04/09/cs_fonters/"/>
    <id>https://talengu.github.io/public/2020/04/09/cs_fonters/</id>
    <published>2020-04-09T12:39:04.000Z</published>
    <updated>2020-04-09T12:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>原标题：除了 Linus，地表最强大的还有这 14 位程序员，速来膜拜！</p><p>导语：IT world 曾经做过一次调查，这个世界上最强大的 15 位程序员，到底是？</p><blockquote><p>文 / IT world</p></blockquote><blockquote><p>译 / 优达菌</p><p>转自 / 优达学城 2018</p><p>原文地址 <a href="https://www.sohu.com/a/223302790_700886" target="_blank" rel="noopener">https://www.sohu.com/a/223302790_700886</a></p></blockquote><p>当和技术基友谈论起 “谁是世界上最顶级的程序员” 的话题时，总是分分钟能引发骂战，优秀的程序员太多了，要评出最优秀的，貌似真的不容易。</p><p>IT world 曾经就做过一次调查，当说到谁是世界上健在且最顶级的程序员时，这 15 个人的名字总是能浮现出来，是公认的还是有争议的，是真 · 大神还是伪 · 大神？一起来看看吧~</p><img src="/public/2020/04/09/cs_fonters/3e28c4606b644378b652dc9c3716da02.jpeg" style="zoom:33%;"><a id="more"></a><h2 id="Margaret-Hamilton"><a class="header-anchor" href="#Margaret-Hamilton">¶</a>Margaret Hamilton</h2><img src="/public/2020/04/09/cs_fonters/264f0ac3e2254ea8b1f91eac42632e1c.jpeg" style="zoom:33%;"><p>作为 15 位上榜者中唯一女性，玛格丽特被誉为是 “<strong>阿波罗飞行控制软件背后的大脑</strong>”。</p><p>作为查尔斯 · 斯塔克 · 德雷珀实验室（Charles Stark Draper Laboratory）软件工程部的老大，她组建了一个团队，负责设计和制造阿波罗舰载飞行控制器软件和空间实验室。</p><p>基于这段经历，她开发了通用系统语言（Universal Systems Language）和开发先于事实（ Development Before the Fact）的范例，首先提出异步软件、优先调度和高可信度的软件设计理念。“软件工程（ software engineering）” 这个名字，公认是由她首先发明的。</p><p>1986 年，玛格丽特获得了奥古斯塔 · 埃达 · 洛夫莱斯奖，2003 年获得 NASA 卓越太空行动奖。</p><p><strong>世人评价：</strong></p><p>“她发明了测试，很大程度上规范了美国的计算机工程” —— ford_beeblebrox</p><p>“在她之前，计算机编程只是个数学分支。然而这个宇宙空间的飞行控制系统，清晰地将编程引入到一个截然不同的领域。” —— Dan Allen</p><p>“... 她发明了‘软件工程’这个词，并作出了最好的示范。” —— David Hamilton</p><h2 id="Donald-Knuth"><a class="header-anchor" href="#Donald-Knuth">¶</a>Donald Knuth</h2><img src="/public/2020/04/09/cs_fonters/e964fa2bfe7d4e0784b4d1dcc84dd883.jpeg" style="zoom:33%;"><p>唐纳德 · 克努斯的中文名叫 “高德纳”，几乎是中国程序员永远的偶像之一。他最主要的成就，<strong>就是《计算机编程艺术》的作者。</strong></p><p>高德纳写出了计算机编程领域的红宝书，发明了 Tex 数字排版系统，获得了无数的荣耀。1971 年，他获得了第一届葛丽丝 · 穆雷 · 霍普奖（Grace Murray Hopper Award） 奖。1974 年获得了图灵奖，当时他才 36 岁....1979 年又获得了美国国家科学奖章，95 年解锁 IEEE 约翰 · 冯 · 诺依曼奖章，98 年，他入选为计算机历史博物馆名人堂的成员之一。</p><p><strong>世人评价：</strong></p><p>“... 《计算机编程艺术》这本书，估计是有史以来关于计算机编程最牛逼的贡献。”—— 匿名</p><p>“他发明的 TeX ，是我所用过的唯一一个几乎没有 bug 的计算机软件，真让人心悦诚服”—— Jaap Weel</p><p>“如果你要问我的话，他简直是前无古人后无来者！” —— Mitch Rees-Jones</p><h2 id="Ken-Thompson"><a class="header-anchor" href="#Ken-Thompson">¶</a>Ken Thompson</h2><img src="/public/2020/04/09/cs_fonters/71e925e1580c419fbae8df0829706e92.jpeg" style="zoom:33%;"><p><strong>作为 “Unix 之父”，肯 · 汤普森足够在这个榜单占据一席之地。</strong></p><p>他与丹尼斯 · 里奇（Dennis Ritchie）共同创造了 Unix 操作系统。此外，他还发明了 B 语言、UTF-8 字符编码规范、ed 文本编辑器，同时也是 Go 语言的共同开发者之一。</p><p>肯 · 汤普森获奖无数，1983 年他获得图灵奖，1994 年获得 IEEE 计算机先锋奖，1998 年获颁美国国家科技奖章。在 1997 年入选成为计算机历史博物馆名人堂的一员。</p><p><strong>世人评论：</strong></p><p>“... 他可能是有史以来最具成就的程序员了。Unix 内核，Unix 工具，国际象棋程序世界冠军 Belle，Plan 9，Go 语言，无人可比” —— Pete Prokopowicz</p><p>“他所做出的贡献影响深刻，而且经得住时间的考验，时至今日，我们还在享受着他的智慧成果。” —— Jan Jannink</p><h2 id="Richard-Stallman"><a class="header-anchor" href="#Richard-Stallman">¶</a>Richard Stallman</h2><img src="/public/2020/04/09/cs_fonters/efe61b0807d541e3b1c3e8c77210d977.jpeg" style="zoom:33%;"><p><strong>作为 Emacs 和 GCC 的缔造者，是他最大的成就之一。</strong></p><p>理查德是 GNU 项目的创立者，为其开发了很多核心工具，如 Emacs、GCC、GDB 和 GNU Make 等等。他还创办了自由软件基金会。1990 年荣获葛丽丝 · 穆雷 · 霍普奖，1998 年获得 EFF 先锋奖.</p><p><strong>世人评论：</strong></p><p>“他在编程上的造诣和思想，形成了一整套计算机编程的亚文化。” —— Dan Dunay</p><p>“我并不百分百认同他，但不可否认，他的确是足够载入史册的伟大的程序员。” —— Marko Poutiainen</p><p>“假设 Linux 写出来的时候，如果没有 GNU 工程的前期工作会怎么样。多亏了他！” —— John Burnette</p><h2 id="Anders-Hejlsberg"><a class="header-anchor" href="#Anders-Hejlsberg">¶</a>Anders Hejlsberg</h2><img src="/public/2020/04/09/cs_fonters/a1a41004e6af4e9390d7a6aa0b85acf6.jpeg" style="zoom:33%;"><p>身为 <strong>Turbo Pascal 的缔造者兼 C# 之父</strong>，安德斯也是非常牛逼的！Turbo Pascl 可谓是历史上最受欢迎的编译器之一，也是首个集成开发环境（IDE）。他还主导开发了 Turbo Pascal 的继任者 Delphi ，他还是 C# 的首席架构师。</p><p>2001 年，他荣获了 Dr. Dobb 的杰出编程奖</p><p>生平： Turbo Pascal 的原作者，是最流行的 Pascal 编译器和第一个集成开发环境。而后，领导了 Turbo Pascal 的继任者 Delphi 的构建。C# 的主要设计师和架构师。2001 年荣获 Dr. Dobb’s 杂志颁发的 “杰出编程奖”。</p><p><strong>世人评论：</strong></p><p>“他用汇编语言写了 Pascal 编译器，支持当时 PC 端的两种主流操作系统（DOS 和 CP/M）。用它来编译链接程序并运行的时间，从几分钟减少到了几秒钟。” —— Steve Wood</p><h2 id="Doug-Cutting"><a class="header-anchor" href="#Doug-Cutting">¶</a>Doug Cutting</h2><img src="/public/2020/04/09/cs_fonters/239b715dcfaf4c4e9800dbdbd68009b2.jpeg" style="zoom:33%;"><p>康婷开发了 Lucene 搜索引擎、 网络爬虫 Nutch 和分布式大型数据处理工具 Hadoop。此外，他还是一位坚定而热情的开源支持者（Lucene、Nutch 以及 Hadoop 都是开源的）。他还担任过前 Apache 软件基金的理事。</p><p><strong>世人评论：</strong></p><p>“... 他写出了杰出的搜索引擎框架（Lucene/solr），为世界开启大数据之门（Hadoop）。” —— Rajesh Rao</p><h2 id="Sanjay-Ghemawat"><a class="header-anchor" href="#Sanjay-Ghemawat">¶</a><strong>Sanjay Ghemawat</strong></h2><img src="/public/2020/04/09/cs_fonters/b9ba05338ce64e1e893af0cb86e8af6e.jpeg" style="zoom:33%;"><p>这位谷歌核心架构师，参与设计和实现了一些谷歌大型分布式系统的功能，包括 MapReduce、BigTable、Spanner 和谷歌文件系统。还编写了 Unix 的 ical 日历系统。</p><p>他于 2009 年入选美国国家工程院。2012 年荣获 ACM 计算机科学奖。</p><p><strong>世人评论：</strong></p><p>“Jeff Dean 的左膀右臂。” —— Ahmet Alp Balkan</p><h2 id="Jeff-Dean"><a class="header-anchor" href="#Jeff-Dean">¶</a>Jeff Dean</h2><img src="/public/2020/04/09/cs_fonters/a2e2f5bed1484e2ea60d7e84f1a9c5de.jpeg" style="zoom:33%;"><p>身为谷歌搜索索引的大脑，他参与设计和实现了许多谷歌大型分布式系统的功能，包括网页爬虫，索引搜索，AdSense，MapReduce，BigTable 和 Spanner。</p><p>2009 年，杰夫获得美国国家工程院奖。2012 年荣获 ACM SIGOPS 马克 · 维瑟奖和 ACM 计算机科学奖。</p><p><strong>世人评论：</strong></p><p>“... 他在数据挖掘领域（GFS、MapReduce、BigTable）上取得了重大突破。” —— Natu Lauchande</p><h2 id="Linus-Torvalds"><a class="header-anchor" href="#Linus-Torvalds">¶</a>Linus Torvalds</h2><img src="/public/2020/04/09/cs_fonters/5bc1912d08ad47b3be77809a49a6d532.jpeg" style="zoom:33%;"><p>他是 Linux 的缔造者，创建了 Linux 内核与开源的版本控制系统 Git。</p><p>1998 年，他获得了 EFF 先锋奖，2000 年荣获英国电脑学会授予的洛夫莱斯勋章，2012 年的千禧技术奖，2014 年 IEEE 计算机学会授予的计算机先锋奖。他同样入选了 2008 年的计算机历史博物馆名人堂。</p><p><strong>世人评论：</strong></p><p>“他只花了几年，就写出了 Linux 内核，而 GNU Hurd（一个 GNU 开发的内核项目）历经 25 年，却还是一个 demo。” —— Erich Ficker</p><p>“他是程序员的程序员。” —— Dan Allen</p><h2 id="John-Carmack"><a class="header-anchor" href="#John-Carmack">¶</a>John Carmack</h2><img src="/public/2020/04/09/cs_fonters/939e4ce41e844230a7481f54271d6969.jpeg" style="zoom:33%;"><p>他是 《毁灭战士》Doom 之父， ID Software 的联合创始人，开发了一系列极具影响力的 FPS 游戏，比如《德军总部 3D》（Wolfenstein 3D）、《毁灭战士》（Doom）和《雷神之锤》（Quake）等。</p><p>他还是计算机图形技术领域的先锋，在图形学上多次取得重要突破：包括自适应性图块刷新（adaptive tile refresh），二叉空间分割（BSP），以及表面缓存技术等等。</p><p>他在 2001 年入选交互式艺术与科学学院名人堂，并在 2007 年和 2008 年两次获得艾美奖工程和技术类奖项，并于 2010 年获得游戏开发者选择终身成就奖。</p><p><strong>世人评价：</strong></p><p>“他写第一个渲染引擎的时候不到 20 岁。真是个天才。” —— Alex Dolinsky</p><p>“... 德军总部 3D、毁灭战士还有雷神之锤，这些革命性的游戏，影响了一代游戏设计师。” —— dniblock</p><p>“给他一个周末，他可以写出任何东西....” —— Greg Naughton</p><p>“他是编程界的莫扎特...” —— Chris Morris</p><h2 id="Fabrice-Bellard"><a class="header-anchor" href="#Fabrice-Bellard">¶</a>Fabrice Bellard</h2><img src="/public/2020/04/09/cs_fonters/75c0a9b71a5c4209ae5bceeab7a5d7f9.jpeg" style="zoom:33%;"><p>他是 QEMU 之父，是众多著名开源软件的作者，包括硬件模拟和虚拟化的平台 QEMU，处理多媒体数据的 FFmpeg，还有 Tiny C 编译器和 LZEXE，这是一个执行文件压缩的软件。</p><p>他是 2000 年和 2001 年 C 语言混乱代码大赛的冠军，2011 年 荣获 Google-O'Reilly 开源奖。此外，他还解锁了计算圆周率小数点后位数最多的世界纪录成就。</p><p><strong>世人评价：</strong></p><p>“我觉得他的工作实在是太伟大了。” —— raphinou</p><p>“他简直是世界上最高产的程序员...” —— Pavan Yara</p><h2 id="Jon-Skeet"><a class="header-anchor" href="#Jon-Skeet">¶</a>Jon Skeet</h2><img src="/public/2020/04/09/cs_fonters/35fc5db1746e495da75a89f408d92e3e.jpeg" style="zoom:33%;"><p>“他根本不需要调试器，他盯下代码，bug 便会羞愧地原形毕露。” 这是世人对他的评价，他作为 Stack Overflow 传说级贡献者，保持着有史以来在 Stack Overflow 上最高的声誉，要知道，他平均每月解答高达 390 个问题！！！</p><p>此外，他还是 Google 工程师，《C# in Depth》的作者。</p><p>“如果他的代码没有通过编译，那么编译器应该道歉。” —— Dan Dyer</p><p>“他根本不需要什么编程规范，他的代码本身就是编程规范。” —— 匿名</p><h2 id="Adam-D-Angelo"><a class="header-anchor" href="#Adam-D-Angelo">¶</a>Adam D'Angelo</h2><img src="/public/2020/04/09/cs_fonters/8cb005da7eb146e9a32b8ed72c07012d.jpeg" style="zoom:33%;"><p>他是” 海外知乎 “—— Quora 的创始人之一，他最早是 Facebook 工程师时，为其搭建了 News Feeds 的基础功能，成为了 Facebook 的 CTO 和 工程 VP。后面离职创办了现在的 Quora 。</p><p>他的经历很传奇，2001 年以还是一名高中生的他，在美国计算机奥林匹克竞赛排名上第八位。在 2004 年 ACM 国际大学生编程大赛获得银牌。2005 年闯入了 Topcoder 大学生算法编程挑战赛的决赛。</p><p>他是马克 · 扎克伯格的所谓的 6 个人之一（不懂请 Google）</p><p><strong>世人评论：</strong></p><p>“这是一位万能的程序员。” —— 匿名</p><h2 id="Petr-Mitrechev"><a class="header-anchor" href="#Petr-Mitrechev">¶</a><strong>Petr Mitrechev</strong></h2><img src="/public/2020/04/09/cs_fonters/a526c7c7edc04910bed60b68bb36990f.jpeg" style="zoom:33%;"><p>他被誉为 <strong>“有史以来最具竞赛能力的程序员”</strong>，的确，看看他的履历就知道了：2000 年和 2002 年，他在国际信息学奥林匹克竞赛中两次获得金牌。2006 年，赢得 Google 代码挑战赛和 TopCoder 公开算法大赛冠军。他还是两次 Facebook 黑客杯的冠军。</p><p><strong>世人评价：</strong></p><p>“他简直是竞技程序员的偶像，即使是在我们印度” —— Kavish Dwivedi</p><h2 id="Gennady-Korotkevich"><a class="header-anchor" href="#Gennady-Korotkevich">¶</a><strong>Gennady Korotkevich</strong></h2><img src="/public/2020/04/09/cs_fonters/75da2050fc004f0d84956dc62fdd4dae.jpeg" style="zoom:33%;"><p>榜单最后一位，是位竞技编程小神童，他是国际信息学奥林匹克竞赛的历史中，年纪最小参赛者（11 岁），并且 6 次获得金牌 (2007~2012)。2013 年，他在 ACM 国际大学生编程大赛获胜，同时还是 2014 Facebook 黑客杯的获胜者。</p><p>写这篇文章的时候，他在 Codeforces 榜排名第一 （ID：Tourist）、TopCoder 榜也是第一。</p><p><strong>世人评价：</strong></p><p>“当之无愧的编程神童！” —— Prateek Joshi</p><p><strong>大神级别的程序员太多了！并不是一篇文章就能说明白道清楚，如果你还有推荐的大神，欢迎在本文评论中和大家分享下。</strong></p><p>— 完 —</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原标题：除了 Linus，地表最强大的还有这 14 位程序员，速来膜拜！&lt;/p&gt;
&lt;p&gt;导语：IT world 曾经做过一次调查，这个世界上最强大的 15 位程序员，到底是？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文 / IT world&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;译 / 优达菌&lt;/p&gt;
&lt;p&gt;转自 / 优达学城 2018&lt;/p&gt;
&lt;p&gt;原文地址 &lt;a href=&quot;https://www.sohu.com/a/223302790_700886&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.sohu.com/a/223302790_700886&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当和技术基友谈论起 “谁是世界上最顶级的程序员” 的话题时，总是分分钟能引发骂战，优秀的程序员太多了，要评出最优秀的，貌似真的不容易。&lt;/p&gt;
&lt;p&gt;IT world 曾经就做过一次调查，当说到谁是世界上健在且最顶级的程序员时，这 15 个人的名字总是能浮现出来，是公认的还是有争议的，是真 · 大神还是伪 · 大神？一起来看看吧~&lt;/p&gt;
&lt;img src=&quot;/public/2020/04/09/cs_fonters/3e28c4606b644378b652dc9c3716da02.jpeg&quot; style=&quot;zoom:33%;&quot;&gt;
    
    </summary>
    
      <category term="计算机科学" scheme="https://talengu.github.io/public/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="人物" scheme="https://talengu.github.io/public/tags/%E4%BA%BA%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>博客模版</title>
    <link href="https://talengu.github.io/public/2019/07/25/template/"/>
    <id>https://talengu.github.io/public/2019/07/25/template/</id>
    <published>2019-07-25T12:00:00.000Z</published>
    <updated>2020-02-11T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>前言主要说明文章的写作意图，概要介绍文中涉及的背景、主要内容、与其他文章关系等。对于长文，这个部分可以写摘要。</p><p>本文为Hexo博客模版文件，以Markdown语言书写。<a href="#%E9%99%84%EF%BC%9Amarkdown%E8%AF%AD%E6%B3%95">模版markdown语法</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前言一般放到主页，可利用 &lt;!-- more --&gt; 隔断。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="构思与起草"><a class="header-anchor" href="#构思与起草">¶</a>构思与起草</h2><ul><li>对文章的阅读群体、写作意图和反馈（Audience Intention Response AIR）要有一个清楚的认识。照顾沟通对象的需要、你的意图（信息）以及希望的反馈。</li><li>在思维导图上，放上你需要的关键名词，然后依次在它基础上添加动词，在加上形容词。最后以一定顺序组织你将要阐述的信息。比如重要性排序，对比优势劣势，方案的不同层面，时间上逻辑上的因果性等等。</li></ul><h2 id="主体内容"><a class="header-anchor" href="#主体内容">¶</a>主体内容</h2><p>文章的主要内容，包括你对跟进过程或发现成果的描述，以数据、事实证据以及其他的信息支撑主要内容。在你的论说中，你应该把对客观事实的描述和写作者对事情的主管阐述区分开来。</p><p>当你在报告中对一个观点进行陈述的时候，你需要记住以下几点：</p><ul><li>清晰的呈现事实</li><li>有逻辑地提出论据</li><li>引用相关的语录、简明易懂的事实和例子来支持你的论点</li><li>给出支持或反对该行为的理由</li><li>始终围绕主要观点进行讨论</li><li>处理好重要的假设关系</li><li>区分说明（具体阐述）和论证（有理有据）</li></ul><h2 id="写作检查"><a class="header-anchor" href="#写作检查">¶</a>写作检查</h2><p>主体内容完成后，要进行写作检查。</p><ul><li>保证信息的准确性，时间地点等信息的准确。</li><li>确保语法规范性</li><li>段落写作<ul><li>主题句，核心思想</li><li>使用关联词，但勿滥<ul><li>表示转折：虽然，尽管，但是，相反的是，另一方面</li><li>对已阐述观点的强调：此外，与此同时，除此以外，再补充一点</li><li>阐述结果：结果是，相应的结果是，因此</li></ul></li><li>简单的句子 15-25</li></ul></li><li>精心选择词语<ul><li>同一个意思，换一下说法</li><li>少用名词，多用动词。我们想用名词表达意思，采用动名组合，或者一个意群搭配上动词会更有力。</li><li>多用主动动词，少用被动动词</li></ul></li><li>核对标点符号，逗号，与分号。英文的话，检查一下拼写</li><li>注意行为的语气</li><li>保持连贯性，使用一种统一的方式表达。</li></ul><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><p>一个清晰的总结应该概括全部论点。</p><h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2><ul><li>逻辑清楚，达情切意<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。准备看一些基础的逻辑学。</li><li>写完要读两遍，修改错别字，标点，语序连接等等。</li><li>修改可以反着读，正着读对熟悉的材料会有一种连贯性忽略掉错误或者不顺的地方。</li></ul><h2 id="附：markdown语法"><a class="header-anchor" href="#附：markdown语法">¶</a>附：markdown语法</h2><h3 id="head"><a class="header-anchor" href="#head">¶</a>head</h3><p>文件head，设置标题、日期、分类、标签、评论、版权、是否使用公式，如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 模版文件</span><br><span class="line">date: 2019-07-25 12:00:00</span><br><span class="line">updated: 2019-07-25 12:00:00</span><br><span class="line">categories:</span><br><span class="line">  - 博客搭建</span><br><span class="line">  - 模版文件</span><br><span class="line">tags:</span><br><span class="line">  - Writing</span><br><span class="line">comments: true</span><br><span class="line">copyright: true</span><br><span class="line">math: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="图"><a class="header-anchor" href="#图">¶</a>图</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 使用标准markdown</span><br><span class="line">![GDP](http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用html</span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png"</span> <span class="attr">width</span>=<span class="string">"60%"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 图1 2019年国内生产总值及其增速度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 白色图片用table提供辨识度</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png"</span> <span class="attr">width</span>=<span class="string">"60%"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 图1 2019年国内生产总值及其增速度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两行代码生成下面的图和标题。</p><center><img src="http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png" width="60%"></center><p>图 1 展示的是2015-2019年的GDP和增长速度<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，直方图数据反应国内生产总值在2015-2019年度均平稳增长。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png"</span>&gt;</span>图1     <span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png"</span>&gt;</span>图2 <span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><table><tr><td><center><img src="http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png">图1     </center></td><td><center><img src="http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png">图2 </center></td></tr></table><h3 id="表"><a class="header-anchor" href="#表">¶</a>表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align=&apos;center&apos;&gt; 表1 2018年年末人口数及其构成&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">| 指标       | 年末数（万人） | 比重（%） |</span><br><span class="line">| ---------- | -------------- | --------- |</span><br><span class="line">| 全国总人口 | 139538         | 100.0     |</span><br><span class="line">| 其中：城镇 | 83137          | 59.58     |</span><br><span class="line">| 乡村       | 56401          | 40.42     |</span><br></pre></td></tr></table></figure><p>这两行代码生成下面的表和标题。</p><div align="center">表1 2018年年末人口数及其构成</div><table><thead><tr><th>指标</th><th>年末数（万人）</th><th>比重（%）</th></tr></thead><tbody><tr><td>全国总人口</td><td>139538</td><td>100.0</td></tr><tr><td>城镇</td><td>83137</td><td>59.58</td></tr><tr><td>乡村</td><td>56401</td><td>40.42</td></tr></tbody></table><p>从表1得出2018年年末，城镇人口占总人口的59.58%，乡村人口占总人口的40.42%，城镇人口已大比例超过乡村人口。</p><h3 id="公式"><a class="header-anchor" href="#公式">¶</a>公式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">f=w_1 x_1 + w_2 x_2</span><br><span class="line">\tag&#123;1&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>在Markdown中可用Tex代码渲染数学公式，渲染效果为公式（1）。如图2，Tex公式可以在<a href="http://latex.codecogs.com/eqneditor/editor.php" target="_blank" rel="noopener">Latex编辑器网站</a> 可视化编写$$f=w_1 x_1 + w_2 x_2\tag{1}$$</p><center><img src="https://img-blog.csdnimg.cn/20200425095309901.png" width="60%"><div> 图2 Latex在线编辑器</div></center><h3 id="定理证明"><a class="header-anchor" href="#定理证明">¶</a>定理证明</h3><p><strong>定理 3.1</strong> 如果时域混合场积分方程是时域电场积分方程与时域磁场积分方程的线性组合……</p><p><strong>证明：</strong></p><p>首先，由于 ……</p><p>……</p><p>根据 ……，结论得证。                        ■</p><h3 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h3><p>参考的分类：</p><ul><li>链接直接在原文中给出。</li><li>引用他人文章中的段落或者意识给出引用的链接。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">**参考**</span><br><span class="line"></span><br><span class="line">[^statics_report_2019]: 国家统计局 [2019年国民经济和社会发展统计公报](http://www.stats.gov.cn/tjsj/zxfb/202002/t20200228_1728913.html) 2020-02-28</span><br><span class="line"></span><br><span class="line">[^hetang]: 朱自清《荷塘清韵》北京大学出版社  2010-1</span><br></pre></td></tr></table></figure><h3 id="添加iframes"><a class="header-anchor" href="#添加iframes">¶</a>添加iframes</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &#123;&#125;替换为视频id，同时去掉&#123;&#125; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 小破站 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://player.bilibili.com/player.html?bvid=&#123;&#125;"</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"430"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 腾讯视频 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://v.qq.com/iframe/player.html?vid=&#123;&#125;"</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"430"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 优酷视频 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">src</span>=<span class="string">'https://player.youku.com/embed/&#123;&#125;'</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"430"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- PDF --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">src</span>=<span class="string">'https://arxiv.org/pdf/1406.2661.pdf'</span> <span class="attr">width</span>=<span class="string">"800"</span> <span class="attr">height</span>=<span class="string">"450"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">src</span>=<span class="string">'https://www.sohu.com/a/287817933_100118081'</span> <span class="attr">width</span>=<span class="string">"800"</span> <span class="attr">height</span>=<span class="string">"450"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><iframe src="https://player.bilibili.com/player.html?bvid=BV1Wb411v7WN" width="640" height="430"></iframe><iframe src="https://v.qq.com/txp/iframe/player.html?vid=u0951gpf8u2" width="640" height="430"></iframe><p>TODO:markdown 空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;</span><br></pre></td></tr></table></figure><hr><p><strong>参考</strong></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>朱自清《荷塘清韵》北京大学出版社  2010-1 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>国家统计局 <a href="http://www.stats.gov.cn/tjsj/zxfb/202002/t20200228_1728913.html" target="_blank" rel="noopener">2019年国民经济和社会发展统计公报</a> 2020-02-28 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前言主要说明文章的写作意图，概要介绍文中涉及的背景、主要内容、与其他文章关系等。对于长文，这个部分可以写摘要。&lt;/p&gt;
&lt;p&gt;本文为Hexo博客模版文件，以Markdown语言书写。&lt;a href=&quot;#%E9%99%84%EF%BC%9Amarkdown%E8%AF%AD%E6%B3%95&quot;&gt;模版markdown语法&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;前言一般放到主页，可利用 &amp;lt;!-- more --&amp;gt; 隔断。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://talengu.github.io/public/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="工具" scheme="https://talengu.github.io/public/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="博客模版" scheme="https://talengu.github.io/public/tags/%E5%8D%9A%E5%AE%A2%E6%A8%A1%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>机器学习系列</title>
    <link href="https://talengu.github.io/public/2019/07/23/AI/ML_summary/"/>
    <id>https://talengu.github.io/public/2019/07/23/AI/ML_summary/</id>
    <published>2019-07-23T12:00:00.000Z</published>
    <updated>2019-07-23T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>路漫漫其修远兮，吾将上下而求索。2013年，大二接触人工智能课，讲逻辑推理，专家系统等等，神经网络只是一部分，打开当时老师的ppt，还能看到BP等算法。接着在2015年，上了模式识别课程，有一些启发式算法，KNN K-means等算法，同时神经网络也已经有了 GoogLeNet 等深层网络，热门的GAN网络也在2014年被提出。后面，机遇巧合，本科毕业时选了人工智能的坑，直到3年后的现在算是明白了一点。接下来的三年的目标还是<a href="https://talengu.github.io/public/2018/10/01/AI/how_algorithm_engineer/">【成为一名优秀的算法工程师】</a>。</p><p>回望入坑 <strong>机器学习</strong>，没有系统地整理过相关知识。于是想着手整理一份自己笔记系列。本文为序。</p><blockquote><p>雄关漫道真如铁，而今迈步从头越。</p></blockquote><p><img src="/public/2019/07/23/AI/ML_summary/1564034058070.png" alt="1564034058070"></p><div align="center"> 图1 机器学习知识框架</div>如图1 所示，整个系列将由五个部分组成。<a id="more"></a><h2 id="一、机器学习基础"><a class="header-anchor" href="#一、机器学习基础">¶</a>一、机器学习基础</h2><h2 id="二、监督学习"><a class="header-anchor" href="#二、监督学习">¶</a>二、监督学习</h2><img src="/public/2019/07/23/AI/ML_summary/1564034419203.png" alt="1564034419203" style="zoom:67%;"><div align="center"> 图 监督学习</div><h2 id="三、无监督学习"><a class="header-anchor" href="#三、无监督学习">¶</a>三、无监督学习</h2><img src="/public/2019/07/23/AI/ML_summary/1564034460034.png" alt="1564034460034" style="zoom:67%;"><div align="center"> 图 无监督学习</div><h2 id="四、学习理论"><a class="header-anchor" href="#四、学习理论">¶</a>四、学习理论</h2><img src="/public/2019/07/23/AI/ML_summary/xuexililun.png" alt="xuexililun" style="zoom:67%;"><div align="center"> 图 学习理论</div><h3 id="4-1-正则化"><a class="header-anchor" href="#4-1-正则化">¶</a>4.1 <a href="regulation_baysian.md">正则化</a></h3><h2 id="五、强化学习"><a class="header-anchor" href="#五、强化学习">¶</a>五、强化学习</h2><h2 id="六、参考与规划"><a class="header-anchor" href="#六、参考与规划">¶</a>六、参考与规划</h2><p><strong>目标</strong>通过阅读以上基本书，打牢自己的理论基础。</p><p><strong>书籍</strong></p><ul><li>PRML Bishop</li><li>机器学习 周志华</li><li>统计学习 李航</li><li>深度学习 Goodfellow</li><li>模式识别 张学工</li></ul><p><strong>课程</strong></p><p><a href="https://www.bilibili.com/video/av70839977" target="_blank" rel="noopener">https://www.bilibili.com/video/av70839977</a></p><p><strong>博客编写</strong></p><ul><li>前言介绍，包括作者，背景，原始paper，和以上基本书的对应章节。</li><li>原理阐述，算法步骤写出。</li><li>案例分析</li><li>利用python写出代码，先用scilearn写。</li><li>总结，预告。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路漫漫其修远兮，吾将上下而求索。2013年，大二接触人工智能课，讲逻辑推理，专家系统等等，神经网络只是一部分，打开当时老师的ppt，还能看到BP等算法。接着在2015年，上了模式识别课程，有一些启发式算法，KNN K-means等算法，同时神经网络也已经有了 GoogLeNet 等深层网络，热门的GAN网络也在2014年被提出。后面，机遇巧合，本科毕业时选了人工智能的坑，直到3年后的现在算是明白了一点。接下来的三年的目标还是&lt;a href=&quot;https://talengu.github.io/public/2018/10/01/AI/how_algorithm_engineer/&quot;&gt;【成为一名优秀的算法工程师】&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;回望入坑 &lt;strong&gt;机器学习&lt;/strong&gt;，没有系统地整理过相关知识。于是想着手整理一份自己笔记系列。本文为序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;雄关漫道真如铁，而今迈步从头越。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/public/2019/07/23/AI/ML_summary/1564034058070.png&quot; alt=&quot;1564034058070&quot;&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt; 图1 机器学习知识框架&lt;/div&gt;
如图1 所示，整个系列将由五个部分组成。
    
    </summary>
    
      <category term="机器学习" scheme="https://talengu.github.io/public/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://talengu.github.io/public/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://talengu.github.io/public/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>《形象美学》摘录笔记</title>
    <link href="https://talengu.github.io/public/2019/07/21/readings/xingxiangmeixue/"/>
    <id>https://talengu.github.io/public/2019/07/21/readings/xingxiangmeixue/</id>
    <published>2019-07-21T12:00:00.000Z</published>
    <updated>2019-07-21T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p><img src="/public/2019/07/21/readings/xingxiangmeixue/book_cover.png" alt="book_cover"></p><p><a href="https://book.douban.com/subject/30434860/" target="_blank" rel="noopener">《形象美学》</a>这本书是我偶然间看到的，本人很少买衣服，自认为衣品极差，被老妈诟病。以前的观点是多买，买一些品牌好的。每当要去买衣服的时候（计划一年两次），总是有很多困扰。图书馆看到此书，恰合我意，翻阅全书，或许有望提高衣品，提升人生品味了，哈哈哈。</p><p>此书的作者是一位研究人物形象设计的大学教师，并有着多年服装顾问的实战经验。书前四章有很多服装的基础理论，搭配等技巧，书后两章给出驭装的细节方法和一个必备的衣服仓库的采购整理建议。本博文中将整理书中的重点，供各位同好们参考。</p><p>此书历经10 年完成（书中官方介绍），分为<strong>塑型、悦色、妆饰、驭装、理橱、博雅</strong>六个章节。书本主要分析了衣服的材质、款式、色彩、场合，以期帮助读者从尊重、认识、爱上自己的长相与身材开始，到认识与识别商品进行实践，最终达到人衣匹配，内外合一的境界。</p><a id="more"></a><p>本博文将此书内容分为两个部分阐述。博文第一部分为塑型、悦色、妆饰、驭装，代表着从材质、款式、色彩和场合四个角度分析衣服，为衣服的基本原理；博文第二部分理橱、博雅，为实践部分，即整理衣服鞋帽，合理配置。</p><h2 id="一、基本理论"><a class="header-anchor" href="#一、基本理论">¶</a>一、基本理论</h2><p>衣服的基本理论分为材质、款式、色彩和场合四个方面。</p><h3 id="1-材质"><a class="header-anchor" href="#1-材质">¶</a>1. 材质</h3><p><strong>按面料材质分</strong>：天然纤维面料、化学纤维、混纺面料。</p><table><thead><tr><th>天然纤维面料</th><th></th><th></th></tr></thead><tbody><tr><td>棉织物</td><td>易掉色</td><td>日常休闲、随和温柔、平实、易于亲近</td></tr><tr><td>麻织物</td><td>易折皱</td><td>随性率真、污垢易除</td></tr><tr><td>丝织物</td><td>比较难打理</td><td></td></tr><tr><td>毛织物</td><td>毛衣</td><td>丝毛洗涤剂</td></tr><tr><td>丝织物</td><td>少见</td><td></td></tr></tbody></table><table><thead><tr><th>化学纤维</th><th></th><th></th></tr></thead><tbody><tr><td>再生纤维</td><td>易掉色</td><td></td></tr><tr><td></td><td>天丝纤维</td><td>随性率真、污垢易除</td></tr><tr><td></td><td>莫代尔纤维</td><td>木材、内衣</td></tr><tr><td></td><td>醋酯纤维</td><td>光泽感、[天鹅绒织锦]</td></tr><tr><td>合成纤维</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><table><thead><tr><th>混纺面料</th><th></th><th></th></tr></thead><tbody><tr><td>比如</td><td>毛衣</td><td>涤纶（30%-40%）、氨纶（3%-7%）</td></tr></tbody></table><p><strong>按纺织工艺分</strong>：梭织、针织。</p><table><thead><tr><th>纺织工艺</th><th></th><th></th></tr></thead><tbody><tr><td>梭织</td><td></td><td>斜纹、平纹、缎纹</td></tr><tr><td>针织</td><td></td><td>手感好，不保形，挺括</td></tr></tbody></table><p><strong>面料档次</strong></p><table><thead><tr><th>档</th><th></th><th></th></tr></thead><tbody><tr><td>低</td><td></td><td>普通化学</td></tr><tr><td>普通</td><td></td><td>棉、麻</td></tr><tr><td>中档</td><td></td><td>天丝、氨纶</td></tr><tr><td>高档</td><td></td><td>羊毛织物、桑蚕丝织物、小牛皮、小羊皮</td></tr><tr><td>顶级</td><td></td><td>羊绒织物、羊驼毛织物</td></tr></tbody></table><p><strong>材料小结</strong>：相近材料越轻越好（羊毛&lt;羊绒），材料对齐格子和条纹。</p><blockquote><p>Tip: 与其花便宜价钱买回一堆无用的东西，不如花一些心思在辨别服装的档次和价值上。购回衣服一定要试穿（材质和版型）。</p></blockquote><h3 id="2-款式"><a class="header-anchor" href="#2-款式">¶</a>2. 款式</h3><p>款式，即衣服的型。包括轮廓、量感、比例。</p><h4 id="2-1-轮廓"><a class="header-anchor" href="#2-1-轮廓">¶</a>2.1 轮廓</h4><table><thead><tr><th>轮廓</th><th></th><th></th></tr></thead><tbody><tr><td>直线</td><td>粗：力量，霸气 细：秀气，敏锐灵动</td><td></td></tr><tr><td>直线+曲线</td><td></td><td></td></tr><tr><td>曲线</td><td>大曲线：浪漫、妩媚、经典、奢华、或熟惑。小曲线：可爱、秀美、温柔、年轻化。</td><td></td></tr></tbody></table><p>配饰、衣物上图案中也有直 中 曲。</p><ul><li>直线：格子、条纹、几何形。</li><li>中：动物纹、字母、波普艺术图案。</li><li>曲：波点（圆点）、花卉、波纹线，佩花纹理线</li></ul><h4 id="2-2-量感"><a class="header-anchor" href="#2-2-量感">¶</a>2.2 量感</h4><table><thead><tr><th>描述</th><th>面料</th><th>配饰</th></tr></thead><tbody><tr><td>重型 多变</td><td>牛仔布/皮革</td><td>夸张</td></tr><tr><td>适中 线形柔和</td><td>棉麻、针织、磨砂皮</td><td>适中</td></tr><tr><td>轻 平实 常见 变化少</td><td>真丝、纱、薄针织</td><td>小巧可爱</td></tr></tbody></table><h4 id="2-3-比例"><a class="header-anchor" href="#2-3-比例">¶</a>2.3 比例</h4><p><strong>服装轮廓对应身材，服装图案和装饰对应人脸。</strong></p><p>“型”形式美法则</p><ol><li>统一与变化</li><li>节奏与韵律。宽窄：上宽下窄。长短：内外。上长下短，不要一样。</li></ol><p>经典款式上融入当季流行的元素。</p><h3 id="3-色彩"><a class="header-anchor" href="#3-色彩">¶</a>3. 色彩</h3><h4 id="3-1-色彩分类"><a class="header-anchor" href="#3-1-色彩分类">¶</a>3.1 色彩分类</h4><table><thead><tr><th>色彩分类</th><th></th><th></th></tr></thead><tbody><tr><td>无彩色</td><td>黑白灰</td><td></td></tr><tr><td>有彩色</td><td>红橙黄绿蓝紫</td><td>明快艳丽</td></tr><tr><td></td><td>+白</td><td>轻快爽朗</td></tr><tr><td></td><td>+灰</td><td>优雅含蓄</td></tr><tr><td></td><td>+黑</td><td>沉稳庄重</td></tr><tr><td>独立色</td><td>金银</td><td>不建议日常</td></tr></tbody></table><p><strong>色彩三要素</strong>：色相、明度（亮度）、纯色（彩度）</p><p>色相：基础色，色系。冷暖。 <a href="http://blog.sina.com.cn/s/blog_4b933df90102x35r.html" target="_blank" rel="noopener">伊登色相环</a> 色立体</p><p>明度：加白色，亮暗，浅深。</p><p>纯度：色彩饱和和纯净程度。常用鲜艳，浑浊或艳。鲜与灰。</p><blockquote><p>平常说的亮，指的是明度而非纯度。色相，冷与暖；明度，亮与暗（浅与深）；纯度，鲜艳与浑浊（鲜与灰）。</p></blockquote><p><img src="/public/2019/07/21/readings/xingxiangmeixue/sexianghuan.png" alt="sexianghuan"></p><h4 id="3-2-肤色"><a class="header-anchor" href="#3-2-肤色">¶</a>3.2 肤色</h4><table><thead><tr><th>肤色</th><th></th><th></th></tr></thead><tbody><tr><td>肤色色相</td><td>冷暖</td><td>冷：泛青，或黄至青灰的肤色，如小麦色，古铜色，橄榄色。暖：偏黄或偏红的肤色，如象牙色，黄橙色，咖啡色</td></tr><tr><td>肤色色明</td><td>黑白</td><td>高明度：偏白偏亮。低明度：偏黑偏暗。</td></tr><tr><td>肤色纯度</td><td>轻薄透明，密实紧致</td><td>低纯度：；皮肤较薄，晶莹剔透，面部较易泛红印。高纯度：密实紧致，给人厚重感，光泽度较强。</td></tr></tbody></table><p><a href="https://jingyan.baidu.com/article/020278116a838c1bcc9ce529.html" target="_blank" rel="noopener">肤色选颜色</a> 肤色的四季理论。此部分来自百度。</p><p><strong>Spring 春季型</strong></p><p>肤色特征：浅象牙色，暖米色，细腻而有透明感。眼睛特征：眼珠为亮茶色，黄玉色，眼白感觉有湖兰色。发色特征：明亮如绢的茶色，柔和的棕黄色、栗色。发质柔软。</p><p>春季型人的色彩搭配原则——最适合自己颜色的要点是：不能太旧，太暗。春季型人的服饰基调属于暖色系中的明亮色调，在色彩搭配上应遵循鲜明、对比的突出自己的俏丽。使用范围最广的颜色是黄色，选择红色时，以橙红、桔红为主。特别提示：对春季型人来说，黑色是最不适合的颜色，过深过重的颜色会与春季型人白色的肌肤、飘逸的黄发出现不和谐音，会使春季型人看上去显得暗淡。春季型人的特点是明亮、鲜艳。属于春季型的人用明亮、鲜艳的颜色打扮自己，会比实际年龄显得年轻。</p><p><strong>Summer 夏季型</strong></p><p>肤色特征：粉白，乳白色皮肤，带蓝色调的褐色皮肤，小麦色皮肤。眼睛特征：目光柔和，眼珠呈焦茶色，深棕色。发色特征：轻柔的黑色、灰黑色，柔和的棕色或深棕色。</p><p>夏季型人的色彩搭配原则——拥有健康的肤色，水粉色的红晕，浅玫瑰色的嘴唇，柔软的黑发，给人以非常柔和优雅的整体印象。夏季型人适合以蓝色为底调的柔和淡雅的颜色，这样才能衬托出她们温柔、恬静的个性。夏季型人适合穿深浅不同的各种粉色、蓝色和紫色，以及有朦胧感的色调，在色彩搭配上，最好避免反差大的色调，适合在同一色相里进行浓淡搭配。</p><p>特别提示：选择适合自己的颜色的要点是：颜色一定要柔和、淡雅。夏季型人不适合穿黑色，过深的颜色会破坏夏季型人的柔美，可用一些浅淡的灰蓝色、蓝灰色、紫色来代替黑色。夏季型人穿灰色会非常高雅，但注意选择浅至中度的灰，但注意夏季型人不太适合藏蓝色。</p><p><strong>Autumn 秋季型</strong></p><p>肤色特征：瓷器般的象牙色皮肤，深桔色、暗驼色或黄橙色。肤色匀整，色泽偏橘，无透明感，肤质密实，肤质的纯度较高。不易出现红晕，肤色偏深，也有少部分人肤色呈现瓷器般浅象牙白色眼睛特征：深棕色、焦茶色、眼白呈暖白色。发色特征：有光泽的褐色、棕色或者铜色、巧克力色。</p><p>秋季型人的色彩搭配原则—— 是四季色中最成熟而华贵的代表，最适合的颜色是金色，苔绿色，橙色等深而华丽的颜色。选择红色时，一定要选择砖红色和与暗桔红相近的颜色。秋季型人的服饰基调是暖色系中的沉稳色调。浓郁而华丽的颜色可衬托出秋季型人成熟高贵的气质，越浑厚的颜色也越能衬托秋季型人陶瓷般的皮肤。</p><p>特别提示：选择适合自己的颜色的要点是：颜色要温暖，浓郁。秋季型人穿黑色会显得皮肤发黄，可用深棕色来代替。</p><p>最佳用色：金色，姜黄，橄榄绿，土红，土黄，咖啡色，深褐色，等浓郁而温暖的色彩。</p><p><strong>Winter 冬季型</strong></p><p>肤色特征：青白或略带橄榄色，带青色的黄褐色。冷调的看不到红晕的肤色。眼睛特征：眼睛黑白分明，目光锐利，眼珠为深黑色，焦茶色。发色特征：乌黑发亮，黑褐色，银灰、深酒红。</p><p>冬季型人的色彩搭配原则—— 最适合纯色，选择红色时，可选正红、酒红和纯正的玫瑰红。在四季颜色中，只有冬季型人最适合使用黑、纯白、灰这三种颜色，藏蓝色也是冬季型人的专利色。但在选择深重颜色的时候一定要有对比色出现。</p><p>特别提示：选择适合自己的颜色的要点是：颜色要鲜明，光泽度高。冬季型人着装一定要注意色彩的对比，只有对比搭配才能显得惊艳、脱俗</p><blockquote><p>如何确定自己的肤色为冷暖色？找一个审美较好的朋友陪着去逛街，试穿五件以上不同暖色调的衣服，再试穿五件以上不同冷色调的衣服。</p></blockquote><h4 id="3-3-色彩的错觉"><a class="header-anchor" href="#3-3-色彩的错觉">¶</a>3.3 色彩的错觉</h4><ul><li>色彩的膨胀与收缩。冷，暗，低纯度收缩。暖，亮，高纯度膨胀。</li><li>色彩的硬和软。灰黑，深蓝，是硬朗，坚强的色彩，用于职场谈判，强调严谨，强势，理性的态度。粉红，粉黄，为相对温和柔软的色彩，与朋友约会，家庭亲子活动，强调关心，关怀。同时与面料的质感有很大关系。当然也要善用流行色。</li></ul><h4 id="3-4-衣服配色原理"><a class="header-anchor" href="#3-4-衣服配色原理">¶</a>3.4 衣服配色原理</h4><ol><li>色相和谐法。色相类似，明纯改变。冷暖一样，上明下暗。</li><li>明度和谐法。明度类似，色相纯度改变。上冷下暖。</li><li>纯度和谐法。纯度相近。色相明度不同。</li><li>有色彩，无彩搭配。黑白灰</li><li>色彩面积大小和谐法。主次，点缀。</li><li>色彩的呼应。A、图案与服装色彩的呼应，外花内单，外单内花，单是花中的一个颜色。花色：花卉，格子，条纹，圆点，动物纹，火腿纹，电脑抽像图。B、配饰，帽子与上衣颜色一致，领带、围巾也相呼应。</li><li>面料质地与色彩。同色不同质。同质不同色。</li><li>面料与肤质。面料粗细，与脸部很相关。</li></ol><h3 id="4-场合"><a class="header-anchor" href="#4-场合">¶</a>4. 场合</h3><p>TPO法则：Time Place Object。Time主要为季节。Place为地点，室内还是室外，办公场所还是在家里。Object 穿着的目的，为了什么事情而穿。接下来两个常用场景来说一说。</p><h4 id="职场"><a class="header-anchor" href="#职场">¶</a>职场</h4><p>与个人职业气质相契合，与个人年龄相契合，与工作环境、工作特点、行业要求相契合。</p><p>领带分为小中大结，身材瘦小适合小结，身材适中适合中结，身材高大适合大结。领结搭配礼服多一点。衬衫要过腕，斜纹代表勇敢，波纹线代表活泼跳跃，圆点代表关怀。带鞋带的皮鞋很正式。</p><h4 id="休闲"><a class="header-anchor" href="#休闲">¶</a>休闲</h4><ol><li>旅游：舒适。颜色红黄绿，游山玩水；颜色黑白，城市。</li><li>逛街，访友，约会。不穿太正式，体现自我风格。遇见春节等喜庆节日穿红色。</li><li>日常运动健身</li><li>家居：休闲家居服，睡衣。圆点卡通，有利于休息，全家尽量一致，和谐。</li></ol><h2 id="二、理橱博雅"><a class="header-anchor" href="#二、理橱博雅">¶</a>二、理橱博雅</h2><h3 id="衣服类别："><a class="header-anchor" href="#衣服类别：">¶</a>衣服类别：</h3><ol><li><p>职业装上班或适合上班，商务，公务活动穿着的服装，多为正装，套装。</p></li><li><p>便装逛街，聚会，旅行，郊游时穿着的服装，比正装、套装稍显随意，休闲些的服装。</p></li><li><p>家居休闲服买菜，散步，接送孩子时穿着轻松自在的外出服。</p></li><li><p>运动服打球、跑步、游泳、健身时穿着的服装，因运动的不同而具有不同功能和特性的服装。</p></li><li><p>礼仪服参加典礼、庆功宴、年会、酒会，音乐会，高规格的戏剧演出等社交活动时穿着的服装。</p></li><li><p>睡衣睡眠时穿着的有利于人身心放松的服装。</p></li><li><p>内衣</p></li></ol><blockquote><p>周一至周五的上班族，衣橱中一半为职业服，平时注意将各类服装备齐。</p></blockquote><h3 id="整理技巧"><a class="header-anchor" href="#整理技巧">¶</a>整理技巧</h3><ol><li>清理衣橱中现存的服饰，旧的打包。</li><li>检查衣橱中留下的服饰，检查是否污渍，掉色，掉线。</li><li>系统、规律地吊挂，摆放衣服饰品。比如：按 春夏 秋冬，按上下装，按功能分。</li></ol><blockquote><p>大而厚的衣服要用大衣架。裤子用夹。丝质用有海绵垫肩的衣架。针织服装不用吊挂，容易变形。</p></blockquote><ol start="4"><li>为衣橱中现有的服饰做搭配。发现新搭配。</li><li>列出衣橱中缺少的单品清单。在搭配时发现缺少的清单。列出购物时的清单。（在商场中可以带上自己想要搭配的衣物，或者存在手机上）</li><li>将衣橱中的服装拍照留存，求助一些专业的朋友，或者设计师。</li></ol><blockquote><p>洗涤时，检查口袋！！！分开洗涤！！！棉麻反面晒，拉平一下。羽绒服晒到一半干，要拍打一下。买一些合适的晾衣架。</p></blockquote><h3 id="理智购买"><a class="header-anchor" href="#理智购买">¶</a>理智购买</h3><ol><li>购买服装需定位。衣橱中缺少的是哪一种类型，哪一个季节，哪一种场合穿着的衣服鞋帽。</li><li>买衣之前试穿。</li><li>不买贵的或便宜的，只买合适的。</li><li>贵精不贵多，重质不重量。</li><li>购衣时，检查衣服。是否需要“干洗”，比如正装。颜色，条纹是否对齐，勾线齐整等等</li></ol><blockquote><p>怎样才能避免使白衬衫的领口，腋下因汗渍而发黄？穿衬衫前将蜡质止汗膏涂抹在衬衫领口及腋下部位，可以隔绝汗液侵蚀，延长白衬衫的寿命。油渍，用纸巾吸一下，然后用牙膏处理一哈。</p></blockquote><h3 id="博雅-明礼修身提升综合素养"><a class="header-anchor" href="#博雅-明礼修身提升综合素养">¶</a>博雅 明礼修身提升综合素养</h3><blockquote><p>“若要有优美的嘴唇，请讲亲切的话；若要有优雅的姿态，请记住走路时行人不止你一个。“---奥黛丽·赫本</p></blockquote><p>走路可选择带节奏感的旋律，如414拍的音乐，踏着音乐不停地练习，增强走路的节奏感和律动。</p><p>心中盛满美好之人，脚步时轻盈的；心理盛满爱心的人，脚步是温柔的；心理盛满阳光的人，脚步是快乐的；心里盛满信念之人，步伐也会因此而变得坚定。</p><p>适宜香水：闻香识人，听语知人。</p><p>读万卷书，行万里路，与万人谈。</p><p>美不自美，因人而彰。</p><p>世物自美，需要生活的艺术家运用慧眼发现美。通过丰富多彩的载体创造美，在人和人之间传递美。</p><h2 id="三、总结"><a class="header-anchor" href="#三、总结">¶</a>三、总结</h2><p>买衣服考虑四个方面，材质（棉麻为主要）、款式（轮廓、量感、比例）、颜色（色相、明度、纯度）、场合（工作、休闲）。<a href="#%E6%95%B4%E7%90%86%E6%8A%80%E5%B7%A7">整理衣橱</a>，<a href="#%E7%90%86%E6%99%BA%E8%B4%AD%E4%B9%B0">理智购买</a>。</p><p><strong>最后，真诚地感谢《形象美学》的作者，黄焱冰老师！！！也希望自己有更好的衣品</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/public/2019/07/21/readings/xingxiangmeixue/book_cover.png&quot; alt=&quot;book_cover&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/30434860/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《形象美学》&lt;/a&gt;这本书是我偶然间看到的，本人很少买衣服，自认为衣品极差，被老妈诟病。以前的观点是多买，买一些品牌好的。每当要去买衣服的时候（计划一年两次），总是有很多困扰。图书馆看到此书，恰合我意，翻阅全书，或许有望提高衣品，提升人生品味了，哈哈哈。&lt;/p&gt;
&lt;p&gt;此书的作者是一位研究人物形象设计的大学教师，并有着多年服装顾问的实战经验。书前四章有很多服装的基础理论，搭配等技巧，书后两章给出驭装的细节方法和一个必备的衣服仓库的采购整理建议。本博文中将整理书中的重点，供各位同好们参考。&lt;/p&gt;
&lt;p&gt;此书历经10 年完成（书中官方介绍），分为&lt;strong&gt;塑型、悦色、妆饰、驭装、理橱、博雅&lt;/strong&gt;六个章节。书本主要分析了衣服的材质、款式、色彩、场合，以期帮助读者从尊重、认识、爱上自己的长相与身材开始，到认识与识别商品进行实践，最终达到人衣匹配，内外合一的境界。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://talengu.github.io/public/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="个人管理" scheme="https://talengu.github.io/public/tags/%E4%B8%AA%E4%BA%BA%E7%AE%A1%E7%90%86/"/>
    
      <category term="《形象美学》" scheme="https://talengu.github.io/public/tags/%E3%80%8A%E5%BD%A2%E8%B1%A1%E7%BE%8E%E5%AD%A6%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>正则化【一】机器学习中的正则化</title>
    <link href="https://talengu.github.io/public/2019/07/17/AI/regulation_baysian/"/>
    <id>https://talengu.github.io/public/2019/07/17/AI/regulation_baysian/</id>
    <published>2019-07-17T12:00:00.000Z</published>
    <updated>2019-07-17T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>本<strong>正则化系列</strong>文章我们将讨论<strong>正则化技术在机器学习和深度学习的应用</strong>。本文为该系列的第一篇，主要介绍<strong>机器学习正则化的概念，原理和应用实例</strong>。</p><p><a href="https://en.wikipedia.org/wiki/Regularization_(mathematics)" target="_blank" rel="noopener">正则化</a> 技术广泛应用在机器学习和深度学习算法中，本质作用是<strong>防止过拟合、提高模型泛化能力</strong>。其中过拟合的简单理解就是训练的算法模型太过复杂，模型过分考虑了当前样本的结构。</p><p>在早期的机器学习领域一般只是将范数惩罚叫做正则化技术，而在深度学习领域认为，能够显著减少方差，而不过度增加偏差的策略都可以认为是正则化技术。故<strong>推广的正则化技术</strong>还有：扩增样本集、早停止、Dropout、集成学习、多任务学习、对抗训练、参数共享等。(具体见“花书 第七章 <a href="http://www.deeplearningbook.org/contents/regularization.html" target="_blank" rel="noopener">Regularization for Deep Learning</a>”），关于<strong>深度学习正则化</strong>会在下一篇正则化文章中重点分析。</p><p>转载自：<a href="https://blog.csdn.net/BigData_Mining/article/details/81631249" target="_blank" rel="noopener">https://blog.csdn.net/BigData_Mining/article/details/81631249</a></p><a id="more"></a><h2 id="1-多角度看机器学习正则化"><a class="header-anchor" href="#1-多角度看机器学习正则化">¶</a>1. 多角度看机器学习正则化</h2><p><strong>机器学习领域正则化</strong>可以从以下三个角度进行理解：</p><p><strong>(1)</strong> <strong>正则化等价于结构风险最小化，其是通过在经验风险项后加上表示模型复杂度的正则化项或惩罚项，达到选择经验风险和模型复杂度都较小的模型目的</strong>。</p><p>​<strong>经验风险</strong>：机器学习中的风险是指模型与真实解之间的误差的积累，经验风险是指使用训练出来的模型进行预测或者分类，存在多大的误差，可以简单理解为训练误差，经验风险最小化即为训练误差最小。</p><p>​<strong>结构风险</strong>：结构风险定义为经验风险与置信风险(置信是指可信程度)的和，置信风险越大，模型推广能力越差。可以简单认为结构风险是经验风险后面多加了一项表示模型复杂度的函数项，从而可以同时控制模型训练误差和测试误差，结构风险最小化即为在保证模型分类精度(经验风险)的同时，降低模型复杂度，提高泛化能力。</p><p>​<strong>公式表达</strong>$$R(f)=\frac{1}{n}\sum_{i=1}^{n}L(y_i,f(x_i)) + \lambda \Omega (f)\tag{1}$$​其中，$R(f)$表示结构风险，$L(y_i,f(x_i))$表示第 $i$ 个样本的经验风险，$\Omega(f)$是表征模型复杂度的正则项，$\lambda$ 是正则化参数。根据奥姆剃刀定律，“如无必要，勿增实体”，即认为相对简单的模型泛化能力更好。而模型泛化能力强、泛化误差小，即表示模型推广能力强，通俗理解就是在训练集中训练得到的优秀模型能够很好的适用于实际测试数据，而不仅仅是减少训练误差或者测试误差。泛化误差定义如下：$$E={Bias}^2(X) + {Var}(X) +{Noise}\tag{2}$$​其中，$E$ 表示泛化误差，${Bias}$ 代表偏差，${Var}$ 代表方差， ${Noise}$ 代表噪声。</p><p>​<strong>关系图</strong></p><p><img src="/public/2019/07/17/AI/regulation_baysian/1563350068097.png" alt="1563350068097"></p><div align="center"> Fig 1. 泛化误差与偏差和方差的关系</div>​从 Fig 1 可以看出，随着训练程度加深，模型复杂度会增加，偏差减少，方差增大，而泛化误差呈现U型变化。对于一个“好的系统”通常要求误差小，正则化的作用即为适当的控制模型复杂度，从而使得**泛化误差曲线**取最小值。<p><strong>(2)</strong> <strong>正则化等价于带约束的目标函数中的约束项</strong></p><p>以平方误差损失和L2范数为例，优化问题的数学模型如下：$$J(\theta)=\sum_{i=1}^{n}(y_i-\theta^Tx_i)^2\tag{3}$$$${s.t.}{|| \theta ||}_2^2 \leq C\<br>\tag{4}$$</p><p>针对上述约束条件的优化问题，采用拉格朗日乘积算子法可以转化为无约束化问题，即$$J(\theta)=\sum_{i=1}^{n}(y_i-w^Tx_i)^2 + \lambda({|| \theta ||}_2^2-C)\tag{5}$$</p><p>由于参数 $C$ 为常数，可以忽略，故上述公式和标准的正则化 公式完全一致。</p><p><strong>(3)</strong> <strong>从贝叶斯角度考虑</strong></p><p>正则项等价于引入参数的模型先验概率，可以简单理解为对最大似然估计引入先验概率，从而转化为最大后验估计，其中的先验概率即对于正则项（这部分内容后面详细讲解）。</p><h2 id="2-基本概念"><a class="header-anchor" href="#2-基本概念">¶</a>2 基本概念</h2><p>正则化也可以成为规则化、权重衰减技术，不同的领域叫法不一样，数学上常用范数实现，例如L1和L2范数，统计学领域叫做惩罚项、罚因子。</p><p>下面给出范数的数学公式，方便以后分析：</p><p>​(1) $p$ 范数：$$Lp=(\sum_{i=1}^{n}{|| x_i ||}^p)^{\frac{1}{p}}\tag{6}$$​(2) $L0$ 范数：0 范数表示向量中非零元素的个数（即为其稀疏度）</p><p>​(3) $L1$ 范数：即向量元素绝对值之和，$p$ 范数取1，即为1范数$${||x||}_1=\sum^n_1 {|| x_i || }\tag{7}$$</p><p>​(4) $L2$ 范数：即向量元素绝对值的平方和再开发，也称欧几里得距离，$p$ 范数取2，即为2范数$${||x||}_{2}=\sqrt{\sum^{n}_1|| x_i ||^2}\tag{8}$$</p><p>​(5) $\infty $ 范数：即所有向量元素的绝对值中的最大值，$p$ 范数取 $\infty $，即为 $\infty $ 范数$${||x  ||}_{\infty }=\underset{i}{\max}{\left | x_i \right |}\tag{9}$$</p><p>​(6) $-\infty $ 范数：即所有向量元素绝对值中的最小值，$p$ 范数取$-\infty $，即为 $-\infty $ 范数$${||x  ||}_{-\infty }=\underset{i}{\min}{\left | x_i \right |}\tag{10}$$<strong>图形描述</strong></p><p>​从 Fig 2、Fig 3 图可以看出：q(p)越小，曲线越贴近坐标轴，q(p)越大，曲线越远离坐标轴，并且棱角越明显，当q(p)取0时候，是完全和坐标轴贴合，当q(p)取无穷的时候，呈现正方体形状。同时也可以看出，采用不同的范数作为正则项，会得到完全不同的算法模型结果，故而对于不同要求的模型，应该采用不同的范数作为正则项。</p><p><img src="/public/2019/07/17/AI/regulation_baysian/1563354053269.png" alt="1563354053269"></p><div align="center"> Fig 2. 向量长度为2维的范数约束</div>![1563354456894](regulation_baysian/1563354456894.png)<div align="center"> Fig 3. 向量长度为3维的范数约束</div>## 3 深度理解<p>​为了更好的理解正则化技术原理，下面从4个方面进行深度分析，希望对大家理解有帮助。</p><h3 id="3-1-简单数值假设分析法"><a class="header-anchor" href="#3-1-简单数值假设分析法">¶</a>3.1 简单数值假设分析法</h3><p>​此处以L2范数讲解，下面的各图形来自吴恩达的机器学习课程。</p><p><img src="/public/2019/07/17/AI/regulation_baysian/image-20190619002115576.png" alt="image-20190619002115576"></p><div align="center"> Fig 4. 不同参数下的曲线拟合结果</div>​左边的曲线拟合是欠拟合，中间的曲线拟合是刚好合适，右边的曲线拟合是过拟合。对于右边的拟合曲线，有$$h_{\theta}(x)={\theta}_0+{\theta}_0 x_1 +{\theta}_2 x_2^2 +{\theta}_3 x_3^3 +{\theta}_4 x_4^4\tag{11}$$​从上式可以看出，由于$\theta_3$和$\theta_4$对应了高阶，导致拟合曲线是4阶曲线，出现了过拟合。正则化的目的为适当缩减$\theta_3$和$\theta_4$的值，例如都为0.0001，则上述曲线本质上等价与$$h_{\theta}(x)={\theta}_0 + {\theta}_1 x_1 +{\theta}_2 x_2^2\tag{12}$$​也就是变成了中间的刚好合适的拟合曲线。对于$\theta_3$ 和$\theta_4$增加 L2 正则项后的代价函数表达式为：$$J(\theta)= \underset{\theta}{\min}\frac{1}{n}\sum_{i=1}^{n}((h_{\theta}(x_i)-y_i)+1000{\theta}_3^2 + 1000 {\theta}_4^2)\tag{13}$$​从上式可以看出，$\theta_3^2$ 和 $\theta_4^2$ 均大于 0，其乘上了1000，要 $J(\theta)$ 是最小，则会迫使模型学习到的$\theta_3$ 和 $\theta_4$ 会非常小，因为只有在$\theta_3$ 和 $\theta_4$ 会非常小的情况下整个代价函数值才会取的较小值。在实际开发中，是对所有参数进行正则化，为了使代价函数尽可能的小，所有的参数 $\theta$ 的值（不包括 $\theta_0$）都会在一定程度上减小，但是减小程度会不一样，从而实现了权重衰减、简化模型复杂度的作用。<h3 id="3-2-图形分析法"><a class="header-anchor" href="#3-2-图形分析法">¶</a>3.2 图形分析法</h3><p>​此处采用L1和L2范数讲解：<strong>(1) L2 范数正则</strong>$$J(\beta)=\sum_{i=1}^{n}(y_i-{\beta}^T x_i)^2 + \lambda {|| {\beta} ||}_2^2\tag{14}$$<img src="/public/2019/07/17/AI/regulation_baysian/1563366078400.png" alt="1563366078400"></p><div align="center"> Fig 5. L2 范数与代价函数的寻优图示</div>​在 Fig 5 中，蓝色的圆形空间表示 L2 范数空间，设为 $\beta_1^2 + \beta_2^2 = r^2$，可以看出，当 $r$ 从 0 逐渐增大时候，该圆形也逐渐增大，红色的线表示原始代价函数解空间即 $\sum_{i=1}^{n}(y_i-\beta^T x_i)^2$，此处为了方便绘图，设参数只有2维。红色圆环上的任何一点都表示一个可行解即代表一组$\beta_1$、$\beta_2$，其中任何一个红色圆环上面的$\beta_1$，$\beta_2$对应的代价函数值一样（可以简单理解为等值线），$\hat{\beta}$ 代表最佳解空间。<h2 id="4-贝叶斯角度分析"><a class="header-anchor" href="#4-贝叶斯角度分析">¶</a>4. 贝叶斯角度分析</h2><p>​以L1和L2范数为例，所得结论可以推广到P范数中，首先需要知道：整个最优化问题从贝叶斯观点来看是一种贝叶斯最大后验估计，其中正则化项对应后验估计中的先验信息，损失函数对应后验估计中的似然函数，两者的乘积即对应贝叶斯最大后验估计的形式。针对L1和L2范数还有结论：<strong>L2 范数相当于给模型参数设置一个协方差为1/alpha的零均值高斯先验分布，L1 范数相当于给模型参数 设置一个参数为1/alpha 拉普拉斯先验分布</strong>。</p><p>​为了讲清楚上述结论，需要具备几点前置知识点：(1) 高斯分布和拉普拉斯分布的定义和形状；(2) 贝叶斯定理；(3) 最大似然估计；(4) 最大后验估计。下面我对这4个知识点进行解释。</p><p><strong>(1)</strong> <strong>高斯分布和拉普拉斯分布</strong></p><p><img src="/public/2019/07/17/AI/regulation_baysian/0.png" alt="0?wx_fmt=png"></p><p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610163845194.png" alt="0?wx_fmt=png"></p><p><strong>(2)</strong> <strong>最大似然估计</strong></p><p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610163845276.png" alt="0?wx_fmt=png"></p><p>​如果上述公式不能理解，请各位读者去复习一下大学课程《概率论与数理统计》中的参数估计章节，为了更方便理解，下面举一个例子：假设我要统计出整个大学内所有同学的身高分布情况，设全校一共20000人，数量庞大，所有人都去问一遍不太靠谱，所以我打算采用抽样方法来估计，假设我已经知道身高分布服从高斯分布，但是我不知道高斯分布中的均值和方差参数，现在我打算采用最大似然估计方法来确定这两个参数。首先需要明确，全校20000即为总体X，我随机从各个班抽取10名同学，假设一共抽了2000个同学，那么2000同学就构成了样本空间，由于每个样本的概率密度函数已知，则很容易写出似然函数，对数求导即可求解参数。</p><p><strong>(3)</strong> <strong>最大后验估计</strong></p><p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610163845259.png" alt="0?wx_fmt=png"></p><p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610163845297.png" alt="0?wx_fmt=png"></p><p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610163845289.png" alt="0?wx_fmt=png"></p><h2 id="5-例子"><a class="header-anchor" href="#5-例子">¶</a>5. 例子</h2><h3 id="5-1-逻辑回归"><a class="header-anchor" href="#5-1-逻辑回归">¶</a>5.1 逻辑回归</h3><p>​二分类逻辑回归使用Sigmoid作为决策函数进行分类，该函数可以将任意的输入映射到[0,1]区间，当预测结果小于0.5，则表示负类，当预测结果大于0.5.则表示正类，其模型本质是求最大似然估计，具体求解似然函数通常使用梯度下降法，而前面说过：最大似然估计法没有考虑训练集以外的因素，很容易造成过拟合，故而逻辑回归一般采用L2范数进行正则化操作，Sigmoid函数定义和图形如下：</p><p><img src="/public/2019/07/17/AI/regulation_baysian/0.jpeg" alt="0?wx_fmt=png"></p><h3 id="5-2-岭回归-Ridge-Regression"><a class="header-anchor" href="#5-2-岭回归-Ridge-Regression">¶</a>5.2 岭回归(Ridge Regression)</h3><p>​岭回归本质上是针对线性回归问题引入了L2范数正则，通过缩减回归系数避免过拟合问题，最先用来处理特征数多于样本数的情况(高维小样本问题)，现在也用于在估计中加人偏差，从而得到更好的估计，加了正则化后的代价函数如下：</p><p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610174921016.png" alt="0?wx_fmt=png"></p><h3 id="5-3-Lasso-回归"><a class="header-anchor" href="#5-3-Lasso-回归">¶</a>5.3 Lasso 回归</h3><p>​拉索回归(lasso回归)本质上是针对线性回归问题引入了L1范数正则，通过缩减回归系数避免过拟合问题，其不同于L2范数，其可以将某些系数缩减为0即所谓的具备稀疏性(稀疏性的好处是简化计算、容易理解模型、减少存储空间、不容易出现过拟合等等)，加了正则化后的代价函数如下：</p><p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610174920968.png" alt="0?wx_fmt=png"></p><p>​其中，参数函数和岭回归中相同。L1范数罚有一个问题：由于|X|函数在0处不可导，故而直接使用最小二乘法、梯度下降法等方法均失效，但是由于其为第一类间断点中的可去间断点，可以通过补充该点的定义解决，通常，对于线性回归中的lasso回归可以采用近似的前向逐步回归替代。</p><h3 id="5-4-SVM"><a class="header-anchor" href="#5-4-SVM">¶</a>5.4 SVM</h3><p>​支持向量机SVM优化目的为寻找一个超平面，使得正负样本能够以最大间隔分离开，从而得到更好的泛化性能，其通过引入核函数来将低维线性不可分的样本映射到高维空间从而线性可分，通过引入惩罚参数C(类似于正则化参数)来对错分样本进行惩罚，从而减少模型复杂度，提高泛化能力，其优化目标如下：</p><p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610174921029.png" alt="0?wx_fmt=png"></p><p>​大家如果不知道上面公式的推导，不用紧张，对于本次内容不是重点，只需要关注后面正则项部分，惩罚参数C作用和正则化参数作用一致，只是反相关而已。需要明白以下结论：</p><p>​<strong>(1)</strong> C越大，正则化参数越小，表示对分错样本的惩罚程度越大，正则化作用越小，偏差越小，方差越大，越容易出现过拟合(通俗理解，原本将低维空间映射到5维空间正好线性可分，但是由于惩罚过于严重，任何一个样本分错了都不可原谅，结果系统只能不断提高维数来拟合样本，假设为10维，最终导致映射维数过高，出现过拟合样本现象，数学上称为VC维较大)；</p><p>​<strong>(2)</strong> C越小，正则化参数越大，表示对分错样本的惩罚程度越小，正则化作用越大，偏差越大，方差越小，越容易出现欠拟合(通俗理解，原本将低维空间映射到5维空间正好线性可分，但是由于惩罚过小，分错了好多样本都可以理解，比较随意，结果系统也采用简化版来拟合样本，假设为3维，最终导致映射维数过低，出现欠拟合样本现象，数学上称为VC维较小)。</p><h2 id="6-总结"><a class="header-anchor" href="#6-总结">¶</a>6. 总结</h2><p>根本目的本质：防止过拟合，提高模型泛化能力。</p><p>正则化技术分类：<strong>狭义上</strong>（不同地方叫法不同）</p><ul><li>在早期的机器学习领域一般只是将范数惩罚叫做正则化技术</li><li>规则化、权重衰减</li><li>从贝叶斯角度考虑，正则项等价于引入参数的模型先验概率</li></ul><p><strong>广义上</strong>：能够显著减少方差，而不过度增加偏差的策略都可以认为是正则化技术，推广的正则化技术还有：扩增样本集、早停止、Dropout、集成学习、多任务学习、对抗训练、参数共享等。</p><h2 id="Reference"><a class="header-anchor" href="#Reference">¶</a>Reference</h2><p><a href="https://blog.csdn.net/BigData_Mining/article/details/81631249" target="_blank" rel="noopener">正则化总结的比较好比较全面的文章</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;
本&lt;strong&gt;正则化系列&lt;/strong&gt;文章我们将讨论&lt;strong&gt;正则化技术在机器学习和深度学习的应用&lt;/strong&gt;。本文为该系列的第一篇，主要介绍&lt;strong&gt;机器学习正则化的概念，原理和应用实例&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Regularization_(mathematics)&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;正则化&lt;/a&gt; 技术广泛应用在机器学习和深度学习算法中，本质作用是&lt;strong&gt;防止过拟合、提高模型泛化能力&lt;/strong&gt;。其中过拟合的简单理解就是训练的算法模型太过复杂，模型过分考虑了当前样本的结构。&lt;/p&gt;
&lt;p&gt;在早期的机器学习领域一般只是将范数惩罚叫做正则化技术，而在深度学习领域认为，能够显著减少方差，而不过度增加偏差的策略都可以认为是正则化技术。故&lt;strong&gt;推广的正则化技术&lt;/strong&gt;还有：扩增样本集、早停止、Dropout、集成学习、多任务学习、对抗训练、参数共享等。(具体见“花书 第七章 &lt;a href=&quot;http://www.deeplearningbook.org/contents/regularization.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Regularization for Deep Learning&lt;/a&gt;”），关于&lt;strong&gt;深度学习正则化&lt;/strong&gt;会在下一篇正则化文章中重点分析。&lt;/p&gt;
&lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/BigData_Mining/article/details/81631249&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/BigData_Mining/article/details/81631249&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://talengu.github.io/public/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="正则化" scheme="https://talengu.github.io/public/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    
    
      <category term="人工智能" scheme="https://talengu.github.io/public/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://talengu.github.io/public/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>这哈儿是重庆</title>
    <link href="https://talengu.github.io/public/2019/04/25/trips/chongqing/"/>
    <id>https://talengu.github.io/public/2019/04/25/trips/chongqing/</id>
    <published>2019-04-25T12:00:00.000Z</published>
    <updated>2019-04-25T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>重庆，旅游纪实。20190422 - 20190424</p><a id="more"></a><h2 id="四月二十二"><a class="header-anchor" href="#四月二十二">¶</a>四月二十二</h2><img src="/public/2019/04/25/trips/chongqing/tiankongzhicheng.jpg" alt="tiankongzhicheng" width="50%"><div align="center"> <b>天空之城旅店的临江阳台</b></div><p>今天刚来到重庆。前天查天气说是多云，但是来这之后，天气极好。早上9点从成都出发，12点左右到达重庆北站，然后做地铁10号线倒到6号线的小什坊。在解放广场附近，中午吃了个碗杂面很不错，对于我来说有点辣，说是重庆排行第五的小面。</p><p>下午就准备午休一哈，今早上很早起来要赶到成都的市中心乘火车。在江边，也是在洪崖洞旁边，找了一家叫做天空之城的青年旅舍。晚上走在千厮大桥上，脚感受着下面的地铁穿过抖动。从青年旅馆房间里面刚好可以看到江边的夜景，管理人是个可爱的老人家。里面的床单是没有铺上的，得自己铺，老人家解释免得被认为不好，你也可以自己带睡袋。老人家在铁路上工作，与他聊了很久，谈到他在铁路站工作的经历，当然还有很多打理旅舍时的故事。</p><h2 id="四月二十三"><a class="header-anchor" href="#四月二十三">¶</a>四月二十三</h2><img src="/public/2019/04/25/trips/chongqing/guojiang1.jpeg" alt="guojiang1" width="50%"><div align="center"> <b>排队2小时，乘过江索道</b></div><img src="/public/2019/04/25/trips/chongqing/goujiang2.jpeg" alt="goujiang2" width="50%"><div align="center"> <b>过江索道，晃晃悠悠在路上</b></div><p>早上起来，去楼下买了个早餐，有八宝粥和一个米团（块），那个团米上面加了两个半枣。吃完早饭，阳光正照进那个青年公寓。四月底，节气谷雨过后，算还不是很热，在那个临江的阳台晒了会儿阳光。然后很困，大概是吃饱的缘故，我又回去睡了一个回笼觉。下午出发去白公馆，搭的是轻轨2号线，到大坪换到去烈士墓的地铁上，轻轨是一路沿江跑的，欣赏着嘉陵江的美景，羡慕着重庆人的立体公交系统。嘉陵江水比较清澈，也见到有人在游泳。过会儿就经过网红景点李子坝，轻轨穿房而过。白公馆旁边是四川外国语大学，没有去逛，直接去了白公馆，香山别墅，然后去了渣滓洞，白公馆的地势比较陡，台阶比较多，旁边是歌乐山。</p><img src="/public/2019/04/25/trips/chongqing/eling.jpg" alt="eling" width="50%"><div align="center"> <b>鹅岭公园有个塔，从塔上望去</b></div><p>接着到了鹅岭公园，可直接做地铁鹅岭站，进门处分左右路线，我选了左转，然后绕了一大圈到了那个塔，其实可以右转沿着汽车的道往上到那个塔。到了塔顶，可以看到面向朝天门方向，左边是嘉陵江，右边是长江，然后各种大桥，轻轨地铁尽收眼底。吹着微风，站在那个塔上，可见重庆各种摩天大楼，然后就是更远处的山。离开鹅岭公园后，继续搭地铁去了上新街站，下车后往南岸区走，南岸发展比较慢，可以看到明显和渝中区的不同，路边找了一家店，选了几个小菜，吃了个晚饭。晚饭后，去了南山一棵树，人很多，夜景倒是很漂亮，有水有山，两水相交，滋润了这个大都市，今天的行程不错。</p><img src="/public/2019/04/25/trips/chongqing/yejing.jpg" alt="yejing" width="50%"><div align="center"> <b>南山一棵松</b></div><h2 id="四月二十四"><a class="header-anchor" href="#四月二十四">¶</a>四月二十四</h2><img src="/public/2019/04/25/trips/chongqing/caotianmen.jpg" alt="caotianmen" width="50%"><div align="center"> <b>朝天门码头，水清黄分明</b></div><p>今天也是懒懒起床，吃了个早饭，豆浆是放在那种果冻的包装袋里。今天差不多，就准备看看朝天门，然后回成都。去朝天门还是比较奇怪，随着百度地图导航走，到了一个商城里面，从地面进去是商城的8楼，下了电梯，走了一个商品批发的地方，然后向朝天门赶，今天太阳超级满足，比较热。岸边停了好多游船。到了朝天门，水分了两个颜色，黄的长江，清的嘉陵江。休息一刻，搭了公交车，沿着长江岸跑，居然到了李子坝，然后地铁转到重庆北火车站，这一趟重庆算是画上了一个句号。</p><p>【转载请联系 博主。】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重庆，旅游纪实。20190422 - 20190424&lt;/p&gt;
    
    </summary>
    
      <category term="旅游" scheme="https://talengu.github.io/public/categories/%E6%97%85%E6%B8%B8/"/>
    
    
      <category term="重庆" scheme="https://talengu.github.io/public/tags/%E9%87%8D%E5%BA%86/"/>
    
      <category term="游记" scheme="https://talengu.github.io/public/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>茅盾文学奖、诺贝尔文学奖</title>
    <link href="https://talengu.github.io/public/2019/02/05/readings/nobel_maodun_literature/"/>
    <id>https://talengu.github.io/public/2019/02/05/readings/nobel_maodun_literature/</id>
    <published>2019-02-05T16:00:04.000Z</published>
    <updated>2019-02-05T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>世界和民族的优秀作品。漫漫长路，读书成长。</p><h2 id="茅盾文学奖"><a class="header-anchor" href="#茅盾文学奖">¶</a>茅盾文学奖</h2><p><strong>第十届茅盾文学奖获奖篇目 (2015—2018)</strong></p><table><thead><tr><th>作品</th><th>作者</th><th>出版单位</th></tr></thead><tbody><tr><td>《人世间》</td><td>梁晓声</td><td>中国青年出版社</td></tr><tr><td>《牵风记》</td><td>徐怀中</td><td>人民文学出版社</td></tr><tr><td>《北上》</td><td>徐则臣</td><td>北京十月文艺出版社</td></tr><tr><td>《主角》</td><td>陈 彦</td><td>北京十月文艺出版社</td></tr><tr><td>《应物兄》</td><td>李 洱</td><td>人民文学出版社</td></tr></tbody></table><p><a href="https://mp.weixin.qq.com/s/j-siAAyFx2wa2sc4k0qZyQ" target="_blank" rel="noopener"> 中国作家网 第十届茅盾文学奖揭晓（附5位获奖作家介绍）</a></p><a id="more"></a><p><strong>第九届茅盾文学奖获奖篇目 (2011—2014)</strong></p><table><thead><tr><th>作品</th><th>作者</th><th>出版单位</th></tr></thead><tbody><tr><td>《江南三部曲》</td><td>格　非</td><td>上海文艺出版社</td></tr><tr><td>《这边风景》</td><td>王　蒙</td><td>花城出版社</td></tr><tr><td>《生命册》</td><td>李佩甫</td><td>作家出版社</td></tr><tr><td>《繁花》</td><td>金宇澄</td><td>上海文艺出版社</td></tr><tr><td>《黄雀记》</td><td>苏　童</td><td>作家出版社</td></tr></tbody></table><p><strong>第八届茅盾文学奖获奖篇目 (2007—2010)</strong></p><table><thead><tr><th>作品</th><th>作者</th><th>出版单位</th></tr></thead><tbody><tr><td>《你在高原》</td><td>张　炜</td><td>作家出版社</td></tr><tr><td>《天行者》</td><td>刘醒龙</td><td>人民文学出版社</td></tr><tr><td>《蛙》</td><td>莫　言</td><td>上海文艺出版社</td></tr><tr><td>《推拿》</td><td>毕飞宇</td><td>人民文学出版社</td></tr><tr><td>《一句顶一万句》</td><td>刘震云</td><td>长江文艺出版社</td></tr></tbody></table><p><strong>第七届茅盾文学奖获奖篇目 (2003—2006)</strong></p><table><thead><tr><th>作品</th><th>作者</th><th>出版单位</th></tr></thead><tbody><tr><td>《秦腔》</td><td>贾平凹</td><td>作家出版社</td></tr><tr><td>《额尔古纳河右岸》</td><td>迟子建</td><td>北京十月文艺出版社</td></tr><tr><td>《湖光山色》</td><td>周大新</td><td>作家出版社</td></tr><tr><td>《暗算》</td><td>麦　家</td><td>世界知识出版社、人民文学出版社</td></tr></tbody></table><p><strong>第六届茅盾文学奖获奖篇目 (1999—2002)</strong></p><table><thead><tr><th>作品</th><th>作者</th><th>出版单位</th></tr></thead><tbody><tr><td>《张居正》</td><td>熊召政</td><td>长江文艺出版社</td></tr><tr><td>《无字》</td><td>张　洁</td><td>北京十月文艺出版社</td></tr><tr><td>《历史的天空》</td><td>徐贵祥</td><td>人民文学出版社</td></tr><tr><td>《英雄时代》</td><td>柳建伟</td><td>人民文学出版社</td></tr><tr><td>《东藏记》</td><td>宗　璞</td><td>人民文学出版社</td></tr></tbody></table><p><strong>第五届茅盾文学奖获奖篇目 (1995—1998)</strong></p><table><thead><tr><th>作品</th><th>作者</th><th>出版单位</th></tr></thead><tbody><tr><td>《抉择》</td><td>张　平</td><td>人民文学出版社</td></tr><tr><td>《尘埃落定》</td><td>阿　来</td><td>人民文学出版社</td></tr><tr><td>《长恨歌》</td><td>王安忆</td><td>作家出版社</td></tr><tr><td>《茶人三部曲》(一、二)</td><td>王旭烽</td><td>浙江文艺出版社</td></tr></tbody></table><p><strong>第四届茅盾文学奖获奖篇目 (1989—1994)</strong></p><table><thead><tr><th>作品</th><th>作者</th><th>出版单位</th></tr></thead><tbody><tr><td>《战争和人》(一、二、三)</td><td>王　火</td><td>人民文学出版社</td></tr><tr><td>《白鹿原》（修订本）</td><td>陈忠实</td><td>人民文学出版社</td></tr><tr><td>《白门柳》(一、二)</td><td>刘斯奋</td><td>中国青年出版社</td></tr><tr><td>《骚动之秋》</td><td>刘玉民</td><td>人民文学出版社</td></tr></tbody></table><p><strong>第三届茅盾文学奖获奖篇目 (1985—1988)</strong></p><table><thead><tr><th>作品</th><th>作者</th><th>出版单位</th></tr></thead><tbody><tr><td>《平凡的世界》</td><td>路　遥</td><td>中国文联出版公司</td></tr><tr><td>《少年天子》</td><td>凌　力</td><td>北京十月文艺出版社</td></tr><tr><td>《都市风流》</td><td>孙力、余小惠</td><td>浙江文艺出版社</td></tr><tr><td>《第二个太阳》</td><td>刘白羽</td><td>人民文学出版社</td></tr><tr><td>《穆斯林的葬礼》</td><td>霍　达</td><td>北京十月文艺出版社</td></tr><tr><td>荣　誉　奖</td><td></td><td></td></tr><tr><td>《浴血罗霄》</td><td>萧　克</td><td>解放军文艺出版社</td></tr><tr><td>《金瓯缺》</td><td>徐兴业</td><td>海峡文艺出版社</td></tr></tbody></table><p><strong>第二届茅盾文学奖获奖篇目 (1982—1984)</strong></p><table><thead><tr><th>作品</th><th>作者</th><th>出版单位</th></tr></thead><tbody><tr><td>《黄河东流去》</td><td>李　准</td><td>北京出版社</td></tr><tr><td>《沉重的翅膀》（修订本）</td><td>张　洁</td><td>人民文学出版社</td></tr><tr><td>《钟鼓楼》</td><td>刘心武</td><td>人民文学出版社</td></tr></tbody></table><p><strong>第一届茅盾文学奖获奖篇目 (1977—1981)</strong></p><table><thead><tr><th>作品</th><th>作者</th><th>出版单位</th></tr></thead><tbody><tr><td>《许茂和他的女儿们》</td><td>周克芹</td><td>百花文艺出版社</td></tr><tr><td>《东方》</td><td>魏　巍</td><td>人民文学出版社</td></tr><tr><td>《将军吟》</td><td>莫应丰</td><td>人民文学出版社</td></tr><tr><td>《李自成》 （第二卷）</td><td>姚雪垠</td><td>中国青年出版社</td></tr><tr><td>《芙蓉镇》</td><td>古　华</td><td>人民文学出版社</td></tr><tr><td>《冬天里的春天》</td><td>李国文</td><td>人民文学出版社</td></tr></tbody></table><h2 id="诺贝尔文学奖"><a class="header-anchor" href="#诺贝尔文学奖">¶</a>诺贝尔文学奖</h2><p><a href="https://zh.wikipedia.org/wiki/%E8%AB%BE%E8%B2%9D%E7%88%BE%E6%96%87%E5%AD%B8%E7%8D%8E%E5%BE%97%E4%B8%BB%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">link</a></p><p>2017年得主：黑石一雄</p><p>日裔英国作家</p><p>代表作：《长日留痕》《无可慰藉》《上海孤儿》《被掩埋的巨人》</p><p>获奖理由：他的小说带有强大的情感力量，解开了我们与世界连接的虚幻深渊。</p><p>2016年得主：鲍勃·迪伦</p><p>美国作家</p><p>代表作：《答案在风中飘》、《像一块滚石》、《时光慢慢流逝》</p><p>获奖理由：在伟大的美国民谣传统中创造出新的诗歌意境</p><p>2015年</p><p>得主：斯韦特兰娜·阿列克谢耶维奇（女）</p><p>白俄罗斯作家</p><p>代表作：《切尔诺贝利的回忆：核灾难口述史》</p><p>获奖理由：世界文坛最高水准的感人作品，讲述了这个时代的苦难和勇气。</p><p>2014年得主：帕特里克·莫迪亚诺</p><p>法国作家</p><p>代表作：《暗店街》《星形广场》《青春咖啡馆》</p><p>获奖理由：唤醒了对最难以捕捉的人类命运的记忆和揭露了对人类生活的占领。</p><p>2013年得主：艾丽斯·芒罗(女)</p><p>代表作：《快乐影子舞》《逃离》</p><p>获奖理由：当代短篇小说大师。</p><p>2012年得主：莫言</p><p>中国作家</p><p>代表作：《红高粱》《丰乳肥臀》《蛙》</p><p>获奖理由：用魔幻现实主义的写作手法，将民间故事、历史事件与当代背景融为一体。</p><p>2011年得主：托马斯·特兰斯特勒默</p><p>瑞典诗人</p><p>代表作：《十七首诗》《途中的秘密》</p><p>获奖理由：他以凝炼、简洁的形象，以全新视角带我们接触现实。</p><p>2010年得主：马里奥·巴尔加斯·略萨</p><p>秘鲁与西班牙双重国籍的作家及诗人</p><p>代表作：《绿房子》《世界末日之战》《城市与狗》</p><p>获奖理由：他“对权力结构的制图般的描绘和对个人反抗的精致描写”。</p><p>2009年得主：赫塔·米勒</p><p>罗马尼亚裔的德国女性小说家、诗人、散文家。</p><p>代表作：《呼吸钟摆》《河水奔流》《行走界线》《狐狸那时已是猎人》</p><p>获奖理由：专注于诗歌以及散文的率真，描写了失业人群的生活图景。</p><p>2008年得主：勒·克莱齐奥</p><p>代表作：《战争》</p><p>获奖理由：展现了新的起点、诗意的冒险和感官狂喜；作为探险者，发掘了隐藏于主流文明底部和外部的人性。</p><p>2007年得主：多丽丝·莱辛（女）</p><p>英国作家</p><p>代表作：《金色笔记》</p><p>获奖理由：她用怀疑、热情、构想的力量来审视一个分裂的文明，其作品如同一部女性经验的史诗。</p><p>2006年得主：奥尔罕·帕慕克</p><p>土耳其作家</p><p>代表作：《我的名字叫红》</p><p>获奖理由：在寻找故乡的忧郁灵魂时，发现了文化碰撞和融合中的新象征。</p><p>2005年得主：哈罗德·品特</p><p>英国剧作家。</p><p>代表作：《看房者》《生日晚会》《归家》</p><p>获奖理由：他的戏剧以诗和画的创造性，深入表现了人类长期置身其中的处境。</p><p>2004年得主：埃尔弗里德·耶利内克（女）</p><p>奥地利女作家。</p><p>代表作：《钢琴教师》《死者的孩子》</p><p>获奖理由：因为她的小说和戏剧具有音乐般的韵律，她的作品以非凡的充满激情的语言揭示了社会上的陈腐现象及其禁锢力的荒诞不经。</p><p>2003年得主：约翰·马克斯韦尔·库切</p><p>南非作家。</p><p>代表作：《耻》《幽暗之乡》</p><p>获奖理由：精准地刻画了众多假面具下的人性本质。</p><p>2002年得主：凯尔泰斯·伊姆雷</p><p>匈牙利作家。</p><p>代表作：《无形的命运》</p><p>获奖理由：表彰他对脆弱的个人在对抗强大的野蛮强权时痛苦经历的深刻刻画以及他独特的自传体文学风格。</p><p>2001年得主：维·苏·奈保尔</p><p>印度裔英国作家</p><p>代表作：《神秘的按摩师》《米格尔街》</p><p>获奖理由：其著作将极具洞察力的叙述与不为世俗左右的探索融为一体，是驱策我们从扭曲的历史中探寻真实的动力。</p><p>2000年得主：高行健</p><p>法籍华人，剧作家、小说家。</p><p>代表作：《灵山》</p><p>获奖理由：其作品的普遍价值，刻骨铭心的洞察力和语言的丰富机智，为中文小说和艺术戏剧开辟了新的道路。</p><p>1999年得主：君特·格拉斯</p><p>德国作家。</p><p>代表作：《铁皮鼓》</p><p>获奖理由：其嬉戏之中蕴含悲剧色彩的寓言描摹出了人类淡忘的历史面目。</p><p>1998年得主：若泽·萨拉马戈</p><p>葡萄牙记者、作家</p><p>代表作：《失明症漫记》</p><p>获奖理由：由于他那极富想象力、同情心和颇具反讽意味的作品,我们得以反复重温那一段难以捉摸的历史。</p><p>1997年得主：达里奥·福</p><p>意大利讽刺剧作家</p><p>代表作：《喜剧的神秘》《一个无政府主义者的死亡》</p><p>获奖理由：其在鞭笞权威，褒扬被蹂躏者可贵的人格品质方面所取得的成就堪与中世纪《弄臣》一书相媲美。</p><p>1996年得主：维斯瓦娃·辛波丝卡（女）</p><p>波兰诗人</p><p>代表作：《向自己提出问题》《呼唤雪人》</p><p>获奖理由：由于其在诗歌艺术中警辟精妙的反讽，挖掘出了人类一点一滴的现实生活背后历史更迭与生物演化的深意。</p><p>1995年得主：谢默斯·希尼</p><p>爱尔兰诗人</p><p>代表作：《通向黑暗之门》《在外过冬》</p><p>获奖理由：由于其作品洋溢着抒情之美,包容着深邃的伦理,揭示出日常生活和现实历史的奇迹。</p><p>1994年得主：大江健三郎</p><p>日本小说家</p><p>代表作：《个人的体验》《万延元年的足球队》</p><p>获奖理由：通过诗意的想象力,创造出一个把现实与神话紧密凝缩在一起的想象世界，描绘现代的芸芸众生相，给人们带来了冲击。</p><p>1993年得主：托妮·莫里森（女）</p><p>美国作家</p><p>代表作：《最蓝的眼睛》《所罗门之歌》</p><p>获奖理由：其作品想象力丰富,富有诗意，显示了美国现实生活的重要方面。</p><p>1992年得主：德里克·沃尔科特</p><p>圣卢西亚诗人</p><p>代表作：《西印度群岛》</p><p>获奖理由：他的作品具有巨大的启发性和广阔的历史视野，是其献身多种文化的结果。</p><p>1991年得主：纳丁·戈迪默（女）</p><p>南非作家</p><p>代表作：《七月的人民》</p><p>获奖理由：以强烈而直接的笔触，描写周围复杂的人际与社会关系，其史诗般壮丽的作品，对人类大有裨益。</p><p>1990年得主：奥克塔维奥·帕斯</p><p>墨西哥诗人</p><p>代表作：《太阳石》</p><p>获奖理由：他的作品充满激情，视野开阔，渗透着感悟的智慧并体现了完美的人道主义。</p><p>1989年得主：卡米洛·何塞·塞拉</p><p>代表作：《为亡灵弹奏》</p><p>获奖理由：带有浓郁情感的丰富而精简的描写，对人类弱点达到的令人难以企及的想象力。</p><p>1988年得主：纳吉布·马哈富兹</p><p>埃及作家。</p><p>代表作：《街魂》</p><p>获奖理由：他通过大量刻画入微的作品—洞察一切的现实主义，唤起人们树立雄心—形成了全人类所欣赏的阿拉伯语言艺术。</p><p>1987年得主：约瑟夫·布罗茨基</p><p>苏裔美籍诗人</p><p>代表作：《从彼得堡到斯德哥尔摩》</p><p>获奖理由：他的作品超越时空限制，无论在文学上或是敏感问题方面都充分显示出他广阔的思想及浓郁的诗意。</p><p>1986年得主：沃莱·索因卡</p><p>尼日利亚剧作家、诗人、小说家、评论家</p><p>代表作：《雄狮与宝石》</p><p>获奖理由：他以广博的文化视野创作了富有诗意的关于人生的戏剧。</p><p>1985年得主：克洛德·西蒙</p><p>法国小说家</p><p>代表作：《弗兰德公路·农事诗》</p><p>获奖理由：由于他善于把诗人和画家的丰富想象与深刻的时间意识融为一 体，对人类的生存状况进行了深入的描写。</p><p>1984年得主：雅罗斯拉夫·塞弗尔特</p><p>捷克诗人</p><p>代表作：《紫罗兰》</p><p>获奖理由：他的诗富于独创性、新颖、栩栩如生，表现了人的不屈不挠精神和多才多艺的渴求解放的形象。</p><p>1983年得主：威廉·戈尔丁</p><p>英国作家</p><p>代表作：《蝇王·金字塔》</p><p>获奖理由：具有清晰的现实主义叙述技巧以及虚构故事的多样性与普遍性，阐述了今日世界人类的状况。</p><p>1982年得主：加夫列尔·加西亚·马尔克斯</p><p>哥伦比亚记者、作家</p><p>代表作：《百年孤独》《霍乱时期的爱情》</p><p>获奖理由：由于其长篇小说以结构丰富的想象世界，其中糅混着魔幻与现实，反映出一整个大陆的生命矛盾。</p><p>1981年得主：埃利亚斯·卡内蒂</p><p>英国德语作家</p><p>代表作：《迷茫》</p><p>获奖理由：作品具有宽广的视野、丰富的思想和艺术力量。</p><p>1980年得主：切斯拉夫·米沃什</p><p>波兰诗人</p><p>代表作：《拆散的笔记簿》</p><p>获奖理由：不妥协的敏锐洞察力，描述了人在激烈冲突的世界中的暴露状态。</p><p>1979年得主：奥德修斯·埃里蒂斯</p><p>希腊诗人</p><p>代表作：《英雄挽歌》</p><p>获奖理由：他的诗，以希腊传统为背景，用感觉的力量和理智的敏锐，描写现代人为自由和创新而奋斗。</p><p>1978年得主：艾萨克·巴什维斯·辛格</p><p>美国作家</p><p>代表作：《魔术师·原野王》</p><p>获奖理由：他的充满激情的叙事艺术，这种既扎根于波兰人的文化传统，又反映了人类的普遍处境。</p><p>1977年得主：阿莱克桑德雷·梅洛</p><p>西班牙诗人</p><p>代表作：《天堂的影子》</p><p>获奖理由：他的作品继承了西班牙抒情诗的传统和吸取了今天流派的风格，描述了人在宇宙和当今社会中的状况。</p><p>1976年得主：索尔·贝娄</p><p>美国作家</p><p>代表作：《赫索格》</p><p>获奖理由：由于他的作品对人性的了解，以及对当代文化的敏锐透视。</p><p>1975年得主：埃乌杰尼奥·蒙塔莱</p><p>意大利诗人</p><p>代表作：《生活之恶》</p><p>获奖理由：由于他杰出的诗歌拥有伟大的艺术性，在不适合幻想的人生里，诠释了人类的价值。</p><p>1974年得主1：哈里·埃德蒙·马丁逊</p><p>瑞典诗人</p><p>代表作：《露珠里的世界》</p><p>获奖理由：他的作品透过一滴露珠反映出整个世界。</p><p>得主2：埃温特·约翰逊</p><p>瑞典作家</p><p>代表作：《乌洛夫的故事》</p><p>获奖理由：以自由为目的，而致力于历史的、现代的广阔观点之叙述艺术。</p><p>1973年得主：帕特里克·怀特</p><p>澳大利亚小说家、剧作家</p><p>代表作：《风暴眼》</p><p>获奖理由：由于他史诗与心理叙述艺术，并将一个崭新的大陆带进文学中。</p><p>1972年得主： 亨利希·伯尔</p><p>德国作家</p><p>代表作：《女士及众生相》</p><p>获奖理由：为了表扬他的作品，这些作品兼具有对时代广阔的透视和塑造人物的细腻技巧，并有助于德国文学的振兴。</p><p>1971年得主： 巴勃鲁·聂鲁达</p><p>智利诗人</p><p>代表作：《情诗·哀诗·赞诗》</p><p>获奖理由：诗歌具有自然力般的作用，复苏了一个大陆的命运与梦想。</p><p>1970年得主：亚历山大·索尔仁尼琴</p><p>苏联作家</p><p>代表作：《癌症楼》《古拉格群岛》</p><p>获奖理由：由于他作品中的道德力量，籍著它，他继承了俄国文学不可或缺的传统。</p><p>1969年得主：萨缪尔·贝克特</p><p>法国作家</p><p>代表作：《等待戈多》</p><p>获奖理由：他那具有奇特形式的小说和戏剧作品，使现代人从精神困乏中得到振奋。</p><p>1968年得主：川端康成</p><p>日本小说家</p><p>代表作：《雪国·千只鹤·古都》</p><p>获奖理由：由于他高超的叙事性作品以非凡的敏锐表现了日本人精神特质。</p><p>1967年得主：安赫尔·阿斯图里亚斯</p><p>危地马拉诗人、小说家</p><p>代表作：《玉米人》</p><p>获奖理由：因为他的作品落实于自己的民族色彩和印第安传统，而显得鲜明生动。</p><p>1966年得主1：奈莉·萨克斯（女）</p><p>瑞典诗人</p><p>代表作：《逃亡》</p><p>获奖理由：因为她杰出的抒情与戏剧作品，以感人的力量阐述了以色列的命运。</p><p>得主2：萨缪尔·约瑟夫·阿格农以色列作家</p><p>代表作：《行为之书》</p><p>获奖理由：他的叙述技巧深刻而独特，并从犹太民族的生命汲取主题。</p><p>1965年得主：米哈伊尔·亚历山大罗维奇·肖洛霍夫</p><p>苏联作家</p><p>代表作：《静静的顿河》</p><p>获奖理由：由于这位作家在那部关于顿河流域农村之史诗作品中所流露的活力与艺术热忱——他籍这两者在那部小说里描绘了俄罗斯民族生活之某一历史层面。</p><p>1964年得主：让·保罗·萨特</p><p>法国哲学家、作家</p><p>代表作：《词语》</p><p>获奖理由：因为他那思想丰富、充满自由气息和探求真理精神的作品对我们时代发生了深远影响。</p><p>1963年得主：乔治·塞菲里斯</p><p>希腊诗人</p><p>代表作：《“画眉鸟”号》</p><p>获奖理由：他的卓越的抒情诗作，是对希腊文化的深刻感受的产物。</p><p>1962年得主：约翰·斯坦贝克</p><p>美国作家</p><p>代表作：《人鼠之间》</p><p>获奖理由：通过现实主义的、寓于想象的创作，表现出富于同情的幽默和对社会的敏感观察。</p><p>1961年得主：伊沃·安德里奇</p><p>南斯拉夫小说家</p><p>代表作：《桥·小姐》</p><p>获奖理由：由于他作品中史诗般的力量——他籍著它在祖国的历史中追寻主题，并描绘人的命运。</p><p>1960年得主：圣琼·佩斯</p><p>法国诗人和剧作家</p><p>代表作：《蓝色恋歌》</p><p>获奖理由：由于他高超的飞越与丰盈的想象，表达了一种关于如今这个时代之富于意象的沉思。</p><p>1959年得主：萨瓦多尔·夸西莫多</p><p>意大利诗人</p><p>代表作：《水与土》</p><p>获奖理由：由于他的抒情诗，以古典的火焰表达了我们这个时代中，生命的悲剧性体验。</p><p>1958年得主：鲍里斯·列昂尼多维奇·帕斯捷尔纳克</p><p>苏联俄罗斯诗人、小说家</p><p>代表作：《日瓦戈医生》</p><p>获奖理由：在当代抒情诗和俄国的史诗传统上，他都获得了极为重大的成就。</p><p>1957年得主：阿尔贝·加缪</p><p>法国作家</p><p>代表作：《局外人》</p><p>获奖理由：由于他重要的著作，在这著作中他以明察而热切的眼光照亮了我们这时代人类良心的种种问题。</p><p>1956年得主：胡安·拉蒙·希梅内斯</p><p>西班牙诗人</p><p>代表作：《悲哀的咏叹调》</p><p>获奖理由：由于他的西班牙抒情诗，成了高度精神和纯粹艺术的最佳典范。</p><p>1955年得主：赫尔多尔·奇里扬·拉斯克内斯</p><p>冰岛作家</p><p>代表作：《渔家女》</p><p>获奖理由：为了他在作品中所流露的生动、史诗般的力量，使冰岛原已十分优秀的叙述文学技巧更加瑰丽多姿。</p><p>1954年得主：欧内斯特·海明威</p><p>美国作家</p><p>代表作：《老人与海》</p><p>获奖理由：因为他精通于叙事艺术，突出地表现于其近著《老人与海》之中；同时也因为他对当代文体风格之影响。</p><p>1953年得主：温斯顿·丘吉尔</p><p>英国政治家、历史学家、传记作家</p><p>代表作：《不需要的战争》</p><p>获奖理由：由于他在描述历史与传记方面的造诣，同时由于他那捍卫崇高的人的价值的光辉演说。</p><p>1952年得主：弗朗索瓦·莫里亚克</p><p>法国小说家</p><p>代表作：《爱的荒漠》</p><p>获奖理由：因为他在他的小说中剖析了人生的戏剧，对心灵的深刻观察和紧凑的艺术。</p><p>1951年得主：帕尔·费比安·拉格奎斯特</p><p>瑞典诗人、戏剧家、小说家</p><p>代表作：《大盗巴拉巴》</p><p>获奖理由：由于他在作品中为人类面临的永恒的疑难寻求解答所表现出的艺术活力和真正独立的见解。</p><p>1950年得主：帕特兰·亚瑟·威廉·罗素</p><p>英国数学家、哲学家</p><p>代表作：《哲学—数学—文学》</p><p>获奖理由：表彰他所写的捍卫人道主义理想和思想自由的多种多样意义重大的作品。</p><p>1949年得主：威廉·福克纳</p><p>美国作家</p><p>代表作：《我弥留之际》《喧哗与骚动》</p><p>获奖理由：因为他对当代美国小说做出了强有力的和艺术上无与伦比的贡献。</p><p>1948年得主：托马斯·斯特恩斯·艾略特</p><p>英美诗人、剧作家、批评家</p><p>代表作：《四个四重奏》</p><p>获奖理由：对于现代诗之先锋性的卓越贡献。</p><p>1947年得主：安德烈·纪德</p><p>法国作家、评论家</p><p>代表作：《田园交响曲》《背德者》</p><p>获奖理由：为了他广泛的与有艺术质地的著作，在这些著作中，他以无所畏惧的对真理的热爱，并以敏锐的心理学洞察力，呈现了人性的种种问题与处境。</p><p>1946年得主：赫尔曼·黑塞</p><p>德国作家</p><p>代表作：《荒原狼》</p><p>获奖理由：他那些灵思盎然的作品——它们一方面具有高度的创意和深刻的洞见，一方面象征古典的人道理想与高尚的风格。</p><p>1945年得主：加夫列拉·米斯特拉尔（女）</p><p>智利诗人</p><p>代表作：《柔情》</p><p>获奖理由：她那由强烈感情孕育而成的抒情诗，已经使得她的名字成为整个拉丁美洲世界渴求理想的象征。</p><p>1944年得主：约翰内斯·威廉·扬森</p><p>丹麦小说家、诗人</p><p>代表作：《漫长的旅行》</p><p>获奖理由：由于籍著丰富有力的诗意想象，将胸襟广博的求知心和大胆的、清新的创造性风格结合起来。</p><p>1940年-1943年   未颁奖</p><p>1939年得主：弗兰斯·埃米尔·西兰帕</p><p>芬兰作家</p><p>代表作：《少女西丽亚》</p><p>获奖理由：由于他在描绘两样互相影响的东西——他祖国的本质，以及该国农民的生活时——所表现的深刻了解与细腻艺术。</p><p>1938年得主：赛珍珠（女）</p><p>美国作家</p><p>代表作：《大地》三部曲</p><p>获奖理由：她对于中国农民生活的丰富和真正史诗气概的描述，以及她自传性的杰作。</p><p>1937年得主：罗杰·马丁·杜·加尔</p><p>法国小说家</p><p>代表作：《蒂伯—家》</p><p>获奖理由：由于在他的长篇小说《蒂伯一家》中表现出来的艺术魅力和真实性。这是对人类生活面貌的基本反映。</p><p>1936年得主：尤金·奥尼尔</p><p>美国剧作家</p><p>代表作：《天边外》</p><p>获奖理由：由于他剧作中所表现的力量、热忱与深挚的感情——它们完全符合悲剧的原始概念。</p><p>1935年   未颁奖</p><p>1934年得主：路伊吉·皮兰德娄</p><p>意大利说家、戏剧家</p><p>代表作：《寻找自我》《六个寻找剧作家的角色》</p><p>获奖理由：他果敢而灵巧地复兴了戏剧艺术和舞台艺术。</p><p>1933年得主：伊凡·亚历克塞维奇·蒲宁</p><p>俄国作家</p><p>代表作：《米佳的爱》</p><p>获奖理由：由于他严谨的艺术才能，使俄罗斯古典传统在散文中得到继承。</p><p>1932年得主：约翰·高尔斯华绥</p><p>英国小说家、剧作家</p><p>代表作：《有产者》</p><p>获奖理由：为其描述的卓越艺术——这种艺术在《福尔赛世家》中达到高峰。</p><p>1931年得主：埃利克·阿克塞尔·卡尔费尔德</p><p>瑞典诗人</p><p>代表作：《荒原和爱情》</p><p>获奖理由：由于他在诗作的艺术价值上，从没有人怀疑过。</p><p>1930年得主：辛克莱·刘易斯</p><p>美国作家</p><p>代表作：《巴比特》</p><p>获奖理由：由于他充沛有力、切身和动人的叙述艺术，和他以机智幽默去开创新风格的才华。</p><p>1929年得主：保尔·托马斯·曼</p><p>德国作家</p><p>代表作：《布登勃洛克一家》《魔山》</p><p>获奖理由：由于他那在当代文学中具有日益巩固的经典地位的伟大小说《布登勃洛克一家》。</p><p>1928年得主：西格里德·温塞特（女）</p><p>挪威作家</p><p>代表作：《新娘—主人—十字架》</p><p>获奖理由：主要是由于她对中世纪北国生活之有力描绘。</p><p>1927年得主：亨利·柏格森</p><p>法国哲学家</p><p>代表作：《创造进化论》</p><p>获奖理由：因为他那丰富的且充满生命力的思想，以及所表现出来的光辉灿烂的技巧。</p><p>1926年得主：格拉齐亚·黛莱达（女）</p><p>意大利作家</p><p>代表作：《邪恶之路》</p><p>获奖理由：为了表扬她由理想主义所激发的作品，以浑柔的透彻描绘了她所生长的岛屿上的生活；在洞察人类一般问题上，表现的深度与怜悯。</p><p>1925年得主：乔治·萧伯纳</p><p>爱尔兰戏剧家</p><p>代表作：《圣女贞德》</p><p>获奖理由：由于他那些充满理想主义及人情味的作品——它们那种激动性讽刺，常涵蕴着一种高度的诗意美。</p><p>1924年得主：弗拉迪斯拉夫·莱蒙特</p><p>波兰作家</p><p>代表作：《福地》《农夫们》</p><p>获奖理由：我们颁奖给他，是因为他的民族史诗《农夫们》写得很出色。</p><p>1923年得主：威廉·勃特勒·叶芝</p><p>爱尔兰诗人、剧作家</p><p>代表作：《丽达与天鹅》</p><p>获奖理由：由于他那永远充满着灵感的诗，它们透过高度的艺术形式展现了整个民族的精神。</p><p>1922年得主：哈辛特·贝纳文特·伊·马丁内斯</p><p>西班牙作家</p><p>代表作：《不吉利的姑娘》</p><p>获奖理由：由于他以适当方式，延续了戏剧之灿烂传统。</p><p>1921年得主：阿纳托尔·法郎士</p><p>法国作家、文学评论家、社会活动家</p><p>代表作：《苔依丝》</p><p>获奖理由：他辉煌的文学成就，乃在于他高尚的文体、怜悯的人道同情、迷人的魅力，以及一个真正法国性情所形成的特质。</p><p>1920年得主：克努特·汉姆生</p><p>挪威小说家、戏剧家、诗人</p><p>代表作：《大地硕果—畜牧曲》</p><p>获奖理由：为了他划时代的巨著《土地的成长》。</p><p>1919年得主：卡尔·施皮特勒</p><p>瑞士诗人、小说家</p><p>代表作：《奥林帕斯之春》</p><p>获奖理由：特别推崇他在史诗《奥林帕斯之春》的优异表现。</p><p>1918年  未颁奖</p><p>1917年得主1：亨利克·彭托皮丹</p><p>丹麦小说家</p><p>代表作：《天国》</p><p>获奖理由：由于他对当前丹麦生活的忠实描绘。</p><p>得主2：卡尔·耶勒鲁普</p><p>丹麦作家</p><p>代表作：《磨坊血案》</p><p>获奖理由：因为他多样而丰富的诗作——它们蕴含了高超的理想。</p><p>1916年得主：魏尔纳·海顿斯坦姆</p><p>瑞典诗人、小说家</p><p>代表作：《朝圣年代》</p><p>获奖理由：褒奖他在瑞典文学新纪元中所占之重要代表地位。</p><p>1915年得主：罗曼·罗兰</p><p>法国作家、音乐评论家</p><p>代表作：《约翰·克利斯朵夫》</p><p>获奖理由：文学作品中的高尚理想和他在描绘各种不同类型人物时所具有的同情和对真理的热爱。</p><p>1914年    未颁奖</p><p>1913年得主：罗宾德拉纳特·泰戈尔</p><p>印度诗人、社会活动家主</p><p>代表作：《吉檀枷利—饥饿石头》</p><p>获奖理由：由于他那至为敏锐、清新与优美的诗；这诗出之于高超的技巧，并由于他自己用英文表达出来，使他那充满诗意的思想业已成为西方文学的一部分。</p><p>1912年得主：盖哈特·霍普特曼</p><p>德国剧作家、诗人</p><p>代表作：《群鼠》</p><p>获奖理由：欲以表扬他在戏剧艺术领域中丰硕、多样的出色成就。</p><p>1911年得主：莫里斯·梅特林克</p><p>比利时剧作家、诗人、散文家</p><p>代表作：《花的智慧》</p><p>获奖理由：由于他在文学上多方面的表现，尤其是戏剧作品，不但想象丰富，充满诗意的奇想，有时虽以神话的面貌出现，还是处处充满了深刻的启示。这种启示奇妙地打动了读者的心弦，并且激发了他们的想象。</p><p>1910年得主：保尔·约翰·路德维希·冯·海塞</p><p>德国作家</p><p>代表作：《特雷庇姑娘》</p><p>获奖理由：表扬这位抒情诗人、戏剧家、小说家以及举世闻名的短篇小说家，在他漫长而多产的创作生涯中，所达到的充满理想主义精神之艺术至境。</p><p>1909年得主：西尔玛·拉格洛夫(女)</p><p>瑞典作家</p><p>代表作：《尼尔斯骑鹅旅行记》</p><p>获奖理由：由于她作品中特有的高贵的理想主义、丰富的想象力、平易而优美的风格。</p><p>1908年得主：鲁道尔夫·欧肯</p><p>德国哲学家</p><p>代表作：《精神生活漫笔》</p><p>获奖理由：他对真理的热切追求、他对思想的贯通能力、他广阔的观察，以及他在无数作品中，辩解并阐释一种理想主义的人生哲学时，所流露的热诚与力量。</p><p>1907年得主：约瑟夫·鲁德亚德·吉卜林</p><p>英国小说家、诗人</p><p>代表作：《老虎！老虎！》</p><p>获奖理由：这位世界名作家的作品以观察入微、想象独特、气概雄浑、叙述卓越见长。</p><p>1906年得主：乔祖埃·卡尔杜齐</p><p>意大利诗人、文艺批评家</p><p>代表作：《青春诗》</p><p>获奖理由：不仅是由于他精深的学识和批判性的研究，更重要是为了颂扬他诗歌杰作中所具有的特色、创作气势，清新的风格和抒情的魅力。</p><p>1905年得主：亨利克·显克维支</p><p>波兰小说家</p><p>代表作：《第三个女人》《你往何处去》</p><p>获奖理由：由于他在历史小说写作上的卓越成就。</p><p>1904年得主1：何塞·埃切加赖</p><p>西班牙戏剧家、诗人</p><p>代表作：《伟大的牵线人》</p><p>获奖理由：由于它那独特和原始风格的丰富又杰出，作品恢复了西班牙喜剧的伟大传统。</p><p>得主2：弗雷德里克·米斯塔尔</p><p>法国诗人</p><p>代表作：《金岛》</p><p>获奖理由：他的诗作蕴涵之清新创造性与真正的感召力，它忠实地反映了他民族的质朴精神。</p><p>1903年得主：比昂斯滕·比昂松</p><p>挪威戏剧家、诗人、小说家</p><p>代表作：《挑战的手套》</p><p>获奖理由：他以诗人鲜活的灵感和难得的赤子之心，把作品写得雍容、华丽而又缤纷。</p><p>1902年得主：特奥多尔·蒙森</p><p>德国历史学家</p><p>代表作：《罗马史》</p><p>获奖理由：今世最伟大的纂史巨匠，此点于其巨著《罗马史》中表露无疑。</p><p>1901年得主：苏利·普吕多姆</p><p>法国诗人</p><p>代表作：《孤独与深思》</p><p>获奖理由：是高尚的理想、完美的艺术和罕有的心灵与智慧的实证。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;
世界和民族的优秀作品。
漫漫长路，读书成长。&lt;/p&gt;
&lt;h2 id=&quot;茅盾文学奖&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#茅盾文学奖&quot;&gt;¶&lt;/a&gt;茅盾文学奖&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;第十届茅盾文学奖获奖篇目 (2015—2018)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;作品&lt;/th&gt;
&lt;th&gt;作者&lt;/th&gt;
&lt;th&gt;出版单位&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;《人世间》&lt;/td&gt;
&lt;td&gt;梁晓声&lt;/td&gt;
&lt;td&gt;中国青年出版社&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;《牵风记》&lt;/td&gt;
&lt;td&gt;徐怀中&lt;/td&gt;
&lt;td&gt;人民文学出版社&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;《北上》&lt;/td&gt;
&lt;td&gt;徐则臣&lt;/td&gt;
&lt;td&gt;北京十月文艺出版社&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;《主角》&lt;/td&gt;
&lt;td&gt;陈 彦&lt;/td&gt;
&lt;td&gt;北京十月文艺出版社&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;《应物兄》&lt;/td&gt;
&lt;td&gt;李 洱&lt;/td&gt;
&lt;td&gt;人民文学出版社&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/j-siAAyFx2wa2sc4k0qZyQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; 中国作家网 第十届茅盾文学奖揭晓（附5位获奖作家介绍）&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://talengu.github.io/public/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="文学" scheme="https://talengu.github.io/public/tags/%E6%96%87%E5%AD%A6/"/>
    
      <category term="信息类" scheme="https://talengu.github.io/public/tags/%E4%BF%A1%E6%81%AF%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>[译] Face Detection – OpenCV, Dlib and Deep Learning ( C++ / Python )</title>
    <link href="https://talengu.github.io/public/2018/11/12/cv/FaceDetectionComparison/"/>
    <id>https://talengu.github.io/public/2018/11/12/cv/FaceDetectionComparison/</id>
    <published>2018-11-12T18:00:00.000Z</published>
    <updated>2018-11-12T18:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>本文为翻译文章。原文地址 <a href="https://www.learnopencv.com/face-detection-opencv-dlib-and-deep-learning-c-python/" target="_blank" rel="noopener">https://www.learnopencv.com/face-detection-opencv-dlib-and-deep-learning-c-python/</a></p><p>在这篇文章中，作者讨论使用了OpenCV或Dlib的多种人脸检测的代码，并给出性能分析。作者使用的 Face Detector 包括以下四个，后面分别给出 c++ 和 python 实现。</p><ol><li>OpenCV 的 Haar Cascade Face Detector</li><li>OpenCV 的 Deep Learning based Face Detector</li><li>Dlib 的 HoG Face Detector</li><li>Dlib 的 Deep Learning based Face Detector</li></ol><p>作者限于篇幅没有对对理论进行深入解读，只讨论框架的使用，同时分享一些应用上的选择权衡的经验。</p><p>结论：在多数场景中，我们提前不知道图片大小，因此 选用 OpenCV – DNN 相当快也很精确，甚至对于小人脸也不错，各种人脸角度也可以。选用这个在大多情况下是最优的。</p><p><a href="https://github.com/spmallick/learnopencv/tree/master/FaceDetectionComparison" target="_blank" rel="noopener">code FaceDetectionComparison</a> 说明：为了使文章显得简洁一些，在文中只提供关键的代码片段。在github项目中详细代码，包括每个方法独立的代码和整合在一起的cpp和py文件（<a href="http://run-all.py" target="_blank" rel="noopener">run-all.py</a> 和 run-all.cpp），同时里面也有运行代码所使用的人脸检测模型。</p><a id="more"></a><center><iframe width="100%" height="360" frameborder="0" src="http://v.qq.com/iframe/player.html?vid=k07615vrzj8&tiny=0&auto=0" allowfullscreen></iframe></center>> 实验的图片尺寸是  image size 300×300<h2 id="1-OpenCV-Haar"><a class="header-anchor" href="#1-OpenCV-Haar">¶</a>1. OpenCV-Haar</h2><p>在2001年，Viola 和 Jones提出Haar Cascade 特征为基础的 Face Detector，在以后的多年内都是最优的人脸检测算法。以他们的算法为基础人们做了很多改进。OpenCV提供了很多Haar特征的模型算法，更多的Haar特征模型 <strong><a href="https://github.com/opencv/opencv/tree/master/data/haarcascades" target="_blank" rel="noopener">here</a></strong></p><h3 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h3><h4 id="Python"><a class="header-anchor" href="#Python">¶</a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">faceCascade = cv2.CascadeClassifier(<span class="string">'./haarcascade_frontalface_default.xml'</span>)</span><br><span class="line">faces = faceCascade.detectMultiScale(frameGray)</span><br><span class="line"><span class="keyword">for</span> face <span class="keyword">in</span> faces:</span><br><span class="line">    x1, y1, w, h = face</span><br><span class="line">    x2 = x1 + w</span><br><span class="line">    y2 = y1 + h</span><br></pre></td></tr></table></figure><h4 id="C"><a class="header-anchor" href="#C">¶</a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">faceCascadePath = <span class="string">"./haarcascade_frontalface_default.xml"</span>;</span><br><span class="line">faceCascade.load( faceCascadePath )</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Rect&gt; faces;</span><br><span class="line">faceCascade.detectMultiScale(frameGray, faces);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; faces.size(); i++ )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> x1 = faces[i].x;</span><br><span class="line">  <span class="keyword">int</span> y1 = faces[i].y;</span><br><span class="line">  <span class="keyword">int</span> x2 = faces[i].x + faces[i].width;</span><br><span class="line">  <span class="keyword">int</span> y2 = faces[i].y + faces[i].height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对图片灰度变化（grayscale）后，再应用 haar cascade 特征，输出是脸的list。list中每个item有四个element 分别为 top-left corner的(x, y) 、检测出来脸的大小(width, height) 。</p><h3 id="优点"><a class="header-anchor" href="#优点">¶</a>优点</h3><ol><li>在CPU上几乎是实时的（real-time）</li><li>简单的框架 （Simple Architecture）</li><li>能检测不同大小的脸 （different scales）</li></ol><h3 id="缺点"><a class="header-anchor" href="#缺点">¶</a>缺点</h3><ol><li>主要缺点是有很多错误的预测（False predictions），会多预测出人脸。</li><li>人脸非正面效果不好 （non-frontal）</li><li>人脸遮挡效果不好 （under occlusion）</li></ol><h2 id="2-OpenCV-DNN"><a class="header-anchor" href="#2-OpenCV-DNN">¶</a>2. OpenCV-DNN</h2><p>在 OpenCV 3.3 中引入这个方法。DNN模型使用SSD **<a href="https://arxiv.org/abs/1512.02325" target="_blank" rel="noopener">Single-Shot-Multibox detector</a>**框架和  ResNet-10 特征提取网络（backbone）。这个模型喂的数据是从网上采集的，但是训练的源代码没有公开。OpenCV提供了2个模型文件。</p><ol><li>Float 16 位版本模型，使用原始的 caffe 训练  (5.4 MB)</li><li>8 bit quantized 版本模型，使用 Tensorflow 训练 (2.7 MB)</li></ol><p>代码 <a href="https://github.com/spmallick/learnopencv/tree/master/FaceDetectionComparison" target="_blank" rel="noopener">FaceDetectionComparison</a>  里面放了这两个模型文件。</p><h3 id="代码-2"><a class="header-anchor" href="#代码-2">¶</a>代码</h3><h4 id="Python-2"><a class="header-anchor" href="#Python-2">¶</a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DNN = <span class="string">"TF"</span></span><br><span class="line"><span class="keyword">if</span> DNN == <span class="string">"CAFFE"</span>:</span><br><span class="line">    modelFile = <span class="string">"res10_300x300_ssd_iter_140000_fp16.caffemodel"</span></span><br><span class="line">    configFile = <span class="string">"deploy.prototxt"</span></span><br><span class="line">    net = cv2.dnn.readNetFromCaffe(configFile, modelFile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    modelFile = <span class="string">"opencv_face_detector_uint8.pb"</span></span><br><span class="line">    configFile = <span class="string">"opencv_face_detector.pbtxt"</span></span><br><span class="line">    net = cv2.dnn.readNetFromTensorflow(modelFile, configFile)</span><br></pre></td></tr></table></figure><h4 id="C-2"><a class="header-anchor" href="#C-2">¶</a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> caffeConfigFile = <span class="string">"./deploy.prototxt"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> caffeWeightFile = <span class="string">"./res10_300x300_ssd_iter_140000_fp16.caffemodel"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> tensorflowConfigFile = <span class="string">"./opencv_face_detector.pbtxt"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> tensorflowWeightFile = <span class="string">"./opencv_face_detector_uint8.pb"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> CAFFE</span></span><br><span class="line"></span><br><span class="line">  Net net = cv::dnn::readNetFromCaffe(caffeConfigFile, caffeWeightFile);</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  Net net = cv::dnn::readNetFromTensorflow(tensorflowWeightFile, tensorflowConfigFile);</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>caffe 和 Tensorflow 框架加载模型的代码。使用 Float 16 的 Caffe 模型，需要 caffemodel 和 prototxt 文件。使用 8 bit quantized 的 Tensorflow 模型，需要 Tensorflow 配置文件和模型。</p><h4 id="Python-3"><a class="header-anchor" href="#Python-3">¶</a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">blob = cv2.dnn.blobFromImage(frameOpencvDnn, <span class="number">1.0</span>, (<span class="number">300</span>, <span class="number">300</span>), [<span class="number">104</span>, <span class="number">117</span>, <span class="number">123</span>], <span class="literal">False</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">net.setInput(blob)</span><br><span class="line">detections = net.forward()</span><br><span class="line">bboxes = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(detections.shape[<span class="number">2</span>]):</span><br><span class="line">    confidence = detections[<span class="number">0</span>, <span class="number">0</span>, i, <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> confidence &gt; conf_threshold:</span><br><span class="line">        x1 = int(detections[<span class="number">0</span>, <span class="number">0</span>, i, <span class="number">3</span>] * frameWidth)</span><br><span class="line">        y1 = int(detections[<span class="number">0</span>, <span class="number">0</span>, i, <span class="number">4</span>] * frameHeight)</span><br><span class="line">        x2 = int(detections[<span class="number">0</span>, <span class="number">0</span>, i, <span class="number">5</span>] * frameWidth)</span><br><span class="line">        y2 = int(detections[<span class="number">0</span>, <span class="number">0</span>, i, <span class="number">6</span>] * frameHeight)</span><br></pre></td></tr></table></figure><h4 id="C-3"><a class="header-anchor" href="#C-3">¶</a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAFFE</span></span><br><span class="line">cv::Mat inputBlob = cv::dnn::blobFromImage(frameOpenCVDNN, inScaleFactor, cv::Size(inWidth, inHeight), meanVal, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">cv::Mat inputBlob = cv::dnn::blobFromImage(frameOpenCVDNN, inScaleFactor, cv::Size(inWidth, inHeight), meanVal, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">net.setInput(inputBlob, <span class="string">"data"</span>);</span><br><span class="line">cv::Mat detection = net.forward(<span class="string">"detection_out"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">cv::Mat <span class="title">detectionMat</span><span class="params">(detection.size[<span class="number">2</span>], detection.size[<span class="number">3</span>], CV_32F, detection.ptr&lt;<span class="keyword">float</span>&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; detectionMat.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">float</span> confidence = detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (confidence &gt; confidenceThreshold)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">int</span> x1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">3</span>) * frameWidth);</span><br><span class="line">         <span class="keyword">int</span> y1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">4</span>) * frameHeight);</span><br><span class="line">         <span class="keyword">int</span> x2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">5</span>) * frameWidth);</span><br><span class="line">         <span class="keyword">int</span> y2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">6</span>) * frameHeight);</span><br><span class="line"></span><br><span class="line">        cv::rectangle(frameOpenCVDNN, cv::Point(x1, y1), cv::Point(x2, y2), cv::Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码里面，图像转为blob输入进network里，利用前向传播函数forward()，得到一个4-D matrix。 #TODO :这里不是很理解，代码跑起来看一下？？？</p><ul><li>The 3rd dimension iterates over the detected faces. (i is the iterator over the number of faces)</li><li>The fourth dimension contains information about the bounding box and score for each face. For example, detections[0,0,0,2] gives the confidence score for the first face, and detections[0,0,0,3:6] give the bounding box.</li></ul><p>The output coordinates of the bounding box are normalized between [0,1]. Thus the coordinates should be multiplied by the height and width of the original image to get the correct bounding box on the image.</p><h3 id="优点（merits）"><a class="header-anchor" href="#优点（merits）">¶</a>优点（merits）</h3><ol><li>在本文四个方法中最精确（Most accurate）</li><li>可以在CPU上实时运行（real-time）</li><li>人脸不同方向效果不错（上下左右，侧脸等）up, down, left, right, side-face etc</li><li>人脸不同大小效果不错哦（various scales, big and tiny OK）</li></ol><p>OpenCV的这个DNN方法克服了 Haar cascade 方法的不足，同时精度也不比它差。暂时没有发现这个方法其他有不足地方，除了比后面的 Dlib HoG 方法速度慢一点以外。</p><p>作者建议，在使用OpenCV时，比Haar方法，可以优先考虑DNN方法。</p><h2 id="3-Dlib-HoG"><a class="header-anchor" href="#3-Dlib-HoG">¶</a>3. Dlib-HoG</h2><p>HoG 人脸检测方法被广泛的使用，基于 HoG 特征和 SVM 分类。作者还写了一篇 HoG 的博客 <a href="https://www.learnopencv.com/histogram-of-oriented-gradients/" target="_blank" rel="noopener">post</a>。模型有5个 HOG filters 滤波器（ front looking, left looking, right looking, front looking but rotated left, and a front looking but rotated right），模型直接放在了头文件里面 <strong><a href="https://github.com/davisking/dlib/blob/master/dlib/image_processing/frontal_face_detector.h" target="_blank" rel="noopener">header file</a></strong>。</p><p>训练模型的数据库，来自LFW dataset，由 Davis King (Dlib的作者) 手工标记 （manually annotated）共2825张。需要的话，数据库从这里可以下载 <strong><a href="http://dlib.net/files/data/dlib_face_detector_training_data.tar.gz" target="_blank" rel="noopener">dlib_face_detector_training_data.tar.gz</a></strong>.</p><h3 id="代码-3"><a class="header-anchor" href="#代码-3">¶</a>代码</h3><h4 id="Python-4"><a class="header-anchor" href="#Python-4">¶</a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hogFaceDetector = dlib.get_frontal_face_detector()</span><br><span class="line">faceRects = hogFaceDetector(frameDlibHogSmall, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> faceRect <span class="keyword">in</span> faceRects:</span><br><span class="line">    x1 = faceRect.left()</span><br><span class="line">    y1 = faceRect.top()</span><br><span class="line">    x2 = faceRect.right()</span><br><span class="line">    y2 = faceRect.bottom()</span><br></pre></td></tr></table></figure><h4 id="C-4"><a class="header-anchor" href="#C-4">¶</a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">frontal_face_detector hogFaceDetector = get_frontal_face_detector();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert OpenCV image format to Dlib's image format</span></span><br><span class="line"><span class="function">cv_image&lt;bgr_pixel&gt; <span class="title">dlibIm</span><span class="params">(frameDlibHogSmall)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect faces in the image</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dlib::rectangle&gt; faceRects = hogFaceDetector(dlibIm);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; faceRects.size(); i++ )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> x1 = faceRects[i].left();</span><br><span class="line">  <span class="keyword">int</span> y1 = faceRects[i].top();</span><br><span class="line">  <span class="keyword">int</span> x2 = faceRects[i].right();</span><br><span class="line">  <span class="keyword">int</span> y2 = faceRects[i].bottom();</span><br><span class="line">  cv::rectangle(frameDlibHog, Point(x1, y1), Point(x2, y2), Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), (<span class="keyword">int</span>)(frameHeight/<span class="number">150.0</span>), <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，首先加载 face detector，然后将图像输入给 detector 。其中第二个参数代表，想要上采样图片的倍数（times of upscale）。你给的数字越大，小脸检测出的概率越大。但是upscaling 会在计算上花费可观的时间（ substantial impact on the computation speed）。输出是脸的list， 框框对角的坐标（diagonal corners）。</p><h3 id="优点-2"><a class="header-anchor" href="#优点-2">¶</a>优点</h3><ol><li>在cpu上最快的方法（在四个方法中）</li><li>对正面和轻微非正面的方法效果很不错</li><li>模型比较少对于其他三个的文件来说</li><li>轻微遮挡下可以检测</li></ol><p>大概以上，这个方法多数情况可以工作，除了下面的情况。</p><h3 id="缺点-2"><a class="header-anchor" href="#缺点-2">¶</a>缺点</h3><ol><li>主要缺点对小人脸不识别。由于训练在最小 80×80 的数据集上，要确保你的使用环境，不然的话你要自己再训练一下小人脸。</li><li>人脸框经常去掉了人额头一部分，有时脸颊一部分。（part of forehead and even part of chin sometimes）</li><li>在明显的遮挡情况下效果不好</li><li>在测量和极端不正面的脸情况不工作，像向上看，和向下看的情况。</li></ol><h2 id="4-Dlib-CNN"><a class="header-anchor" href="#4-Dlib-CNN">¶</a>4. Dlib-CNN</h2><p>这个模型使用了**<a href="https://arxiv.org/pdf/1502.00046.pdf" target="_blank" rel="noopener">Maximum-Margin Object Detector (MMOD)</a>** 加CNN的特征的方法。训练过程相当简单，也不需要大量的数据去训练一个新的 object detector。更多的训练套路，在这个网站上 <strong><a href="http://blog.dlib.net/2016/10/easily-create-high-quality-object.html" target="_blank" rel="noopener">website</a></strong>.</p><p>使用的模型可以从 <strong><a href="https://github.com/davisking/dlib-models" target="_blank" rel="noopener">dlib-models repository</a></strong> 下载。</p><p>训练使用的数据库是dlib的作者 Davis King 手工标的，7220张从  ImageNet, PASCAL VOC, VGG, WIDER, Face Scrub等数据库里面挑的。这个数据库可以下载到。<a href="http://dlib.net/files/data/dlib_face_detection_dataset-2016-09-30.tar.gz" target="_blank" rel="noopener"><strong>dlib_face_detection_dataset-2016-09-30.tar.gz</strong></a></p><h3 id="代码-4"><a class="header-anchor" href="#代码-4">¶</a>代码</h3><h4 id="Python-5"><a class="header-anchor" href="#Python-5">¶</a>Python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dnnFaceDetector = dlib.cnn_face_detection_model_v1(<span class="string">"./mmod_human_face_detector.dat"</span>)</span><br><span class="line">faceRects = dnnFaceDetector(frameDlibHogSmall, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> faceRect <span class="keyword">in</span> faceRects:</span><br><span class="line">    x1 = faceRect.rect.left()</span><br><span class="line">    y1 = faceRect.rect.top()</span><br><span class="line">    x2 = faceRect.rect.right()</span><br><span class="line">    y2 = faceRect.rect.bottom()</span><br></pre></td></tr></table></figure><h4 id="C-5"><a class="header-anchor" href="#C-5">¶</a>C++</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String mmodModelPath = <span class="string">"./mmod_human_face_detector.dat"</span>;</span><br><span class="line">net_type mmodFaceDetector;</span><br><span class="line">deserialize(mmodModelPath) &gt;&gt; mmodFaceDetector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert OpenCV image format to Dlib's image format</span></span><br><span class="line"><span class="function">cv_image&lt;bgr_pixel&gt; <span class="title">dlibIm</span><span class="params">(frameDlibMmodSmall)</span></span>;</span><br><span class="line">matrix&lt;rgb_pixel&gt; dlibMatrix;</span><br><span class="line">assign_image(dlibMatrix, dlibIm);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect faces in the image</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dlib::mmod_rect&gt; faceRects = mmodFaceDetector(dlibMatrix);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; faceRects.size(); i++ )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> x1 = faceRects[i].rect.left();</span><br><span class="line">  <span class="keyword">int</span> y1 = faceRects[i].rect.top();</span><br><span class="line">  <span class="keyword">int</span> x2 = faceRects[i].rect.right();</span><br><span class="line">  <span class="keyword">int</span> y2 = faceRects[i].rect.bottom();</span><br><span class="line">  cv::rectangle(frameDlibMmod, Point(x1, y1), Point(x2, y2), Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), (<span class="keyword">int</span>)(frameHeight/<span class="number">150.0</span>), <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码和  HoG detector 差不多，除了下载的 CNN face detection 的模型文件。</p><h3 id="优点-3"><a class="header-anchor" href="#优点-3">¶</a>优点</h3><ol><li>不同的脸朝向效果不错 （face orientations）</li><li>遮挡比较稳定 （occlusion）</li><li>在GPU上很快</li><li>训练模型过程很简单</li></ol><h3 id="缺点-3"><a class="header-anchor" href="#缺点-3">¶</a>缺点</h3><ol><li>CPU上很慢</li><li>脸大小于 80×80  检测不出，因为模型在小脸训练的。所以要考虑你应用的具体场景脸的大小，当然也可以对小脸数据库再训练一下。</li><li>人脸框 bounding box 甚至比 HoG detector 还小。</li></ol><h2 id="5-精度比较"><a class="header-anchor" href="#5-精度比较">¶</a>5. 精度比较</h2><p>（Accuracy Comparison）</p><p>作者评估这四个模型使用的是 FDDB 数据库，其中评估OpenCV-DNN 脚本为 <a href="https://github.com/opencv/opencv/blob/master/modules/dnn/misc/face_detector_accuracy.py" target="_blank" rel="noopener">OpenCV face_detector_accuracy.py</a>.</p><p>作者发现奇怪的结果。Dlib 的结果比 Haar OpenCV还要低，然而实际从图片上效果比较好。下图是这四个方法的精度得分（ Precision scores）。</p><p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/face-detection-coco-comparison.jpg" alt></p><p>指标说明（Metric）：AP_50 = Precision when overlap between Ground Truth and predicted bounding box is at least 50% (IoU = 50%)AP_75 = Precision when overlap between Ground Truth and predicted bounding box is at least 75% (IoU = 75%)AP_Small = Average Precision for small size faces (Average of IoU = 50% to 95%)AP_medium = Average Precision for medium size faces (Average of IoU = 50% to 95%)AP_Large = Average Precision for large size faces (Average of IoU = 50% to 95%)mAP = Average precision across different IoU (Average of IoU = 50% to 95%)</p><p><strong>作者最近的发现评估过程对 Dlib 不够公平，科学。</strong></p><h3 id="5-1-评估过程出错了，分析的二个原因！"><a class="header-anchor" href="#5-1-评估过程出错了，分析的二个原因！">¶</a>5.1. 评估过程出错了，分析的二个原因！</h3><p>根据我们的分析，Dlib拿到低的精度的原因如下：<strong>第一个主要原因是训练dlib的是标准数据库没有加标签（annotations）</strong>。数据库图片是由dlib作者自己切的，因此可以发现同样是人脸检测的框，同OpenCV 中的两个方法 OpenCV-Haar 或者 OpenCV-DNN 相比，dlib的方法会裁掉额头一部分或者脸颊一部分（forehead chin）。下面的图中可以看到。</p><p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-acc-result1-e1539872861105.jpg" alt></p><p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-acc-result2-e1539872827875.jpg" alt></p><p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-acc-result3-e1539872783684.jpg" alt></p><p>这个问题可以导致 在上个柱状图中 dlib 分数会低。AP_X 代表着  X% 预测框和真实框交叠的面积占合起来面积的比率。dlib 的 AP_75 的得分为0，尽管有在 AP_75 比 Haar 还高。这个就意味着：<strong>Dlib 模型可以预测更多的人脸比 Haar 特征，但是dlib的框的 AP_75 得分比较低</strong>。</p><p><strong>第二个原因是 dlib 不能检测小的人脸，进一步拉低了得分。</strong></p><p><strong>因此，比较 OpenCV 和 Dlib 精确性的一个相对合理的指标是 AP_50 （或者可以使用小于50%的指标，我们只是设阈值用来计算人头的个数）</strong> 以上分析大家使用 Dlib 的时候注意一下。</p><h2 id="6-速度比较"><a class="header-anchor" href="#6-速度比较">¶</a>6. 速度比较</h2><p>Speed Comparison</p><p>我们使用 300x300 图像做的对比实验。Dlib 的 MMOD 模型可以利用上GPU，但是OpenCV方法对 NVIDIA GPUs 支持还没有。所以我们评估对比这些方法在CPU上，但我们也给出 GPU 版本 MMOD 结果。</p><p>(这段话以后写论文的时候可以用到，保留:cat:) We used a 300×300 image for the comparison of the methods. The MMOD detector can be run on a GPU, but the support for NVIDIA GPUs in OpenCV is still not there. So, we evaluate the methods on CPU only and also report result for MMOD on GPU as well as CPU.</p><h3 id="硬件的配置"><a class="header-anchor" href="#硬件的配置">¶</a>硬件的配置</h3><p>Processor : Intel Core i7 6850K – 6 CoreRAM : 32 GBGPU : NVIDIA GTX 1080 Ti with 11 GB RAMOS : Linux 16.04 LTSProgramming Language : Python</p><p>我们跑了10次，每次对图片进行10000趟测试得总时间，然后对这10次取平均。下面的柱状图是结果。We run each method 10000 times on the given image and take 10 such iterations and average the time taken. Given below are the results.</p><p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/face-detection-speed-comparison.jpg" alt></p><p>从图中可以看到，对于 300x300 的图片，除了 MMOD。MMOD 在GPU上还是很快的，CPU上就是渣渣了。As you can see that for the image of this size, all the methods perform in real-time, except MMOD. MMOD detector is very fast on a GPU but is very slow on a CPU.</p><p>以上的结果在不同电脑硬软件环境下可能不一样。</p><h2 id="7-多种情况讨论"><a class="header-anchor" href="#7-多种情况讨论">¶</a>7. 多种情况讨论</h2><p>除了速度和精度外，我们在选择哪个模型来使用还有一些因素可以考虑。在这节中，将考虑这些情况下的选择。主要为人脸大小变化、非正脸、遮挡。</p><h3 id="7-1-人脸大小变化"><a class="header-anchor" href="#7-1-人脸大小变化">¶</a>7.1. 人脸大小变化</h3><p>Detection across scale</p><p>下面有一个例子视频，这位帅哥在做一个前后的健身动作，使得脸部区域变大变小。可以看到OpenCV DNN 检测出了所有的脸，而 Dlib 的方法只有在大于某个 size 的时候才被检测出来。</p><p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/face-detection-scale-comparison.gif" alt></p><p>我们测试后，脸大于 70×70 才能被 dlib检测出。正如在前面说到的，对小人脸检测是dlib方法的一个大的缺点。我们也可以将图片上采样，但这样的话速度的话相对于 OpenCV-DNN 就太慢了。</p><p>It can be seen that dlib based methods are able to detect faces of size upto ~(70×70) after which they fail to detect. As we discussed earlier, I think this is the major drawback of Dlib based methods. Since it is not possible to know the size of the face before-hand in most cases. We can get rid of this problem by upscaling the image, but then the speed advantage of dlib as compared to OpenCV-DNN goes away.</p><h3 id="7-2-非正脸"><a class="header-anchor" href="#7-2-非正脸">¶</a>7.2. 非正脸</h3><p>Non-frontal Face</p><p>对于非正脸的测试，我们选用了 looking towards right, left, up, down。为了对 dlib 公平，我们选择了face 大于 80×80 的图片。下面是一些例子。</p><p>Non-frontal can be looking towards right, left, up, down. Again, to be fair with dlib, we make sure the face size is more than 80×80. Given below are some examples.</p><p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result7.jpg" alt></p><p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result6.jpg" alt></p><p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result5.jpg" alt></p><p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result4.jpg" alt></p><p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result2.jpg" alt></p><p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result1.jpg" alt></p><p>和预期的一样，OpenCV Haar 方法完全败了。Dlib HoG能检测出 left 或 right looking faces，但是精度不如那些DNN方法。</p><p>As expected, Haar based detector fails totally. HoG based detector does detect faces for left or right looking faces (since it was trained on them) but not as accurately as the DNN based detectors of OpenCV and Dlib.</p><h3 id="7-3-遮挡"><a class="header-anchor" href="#7-3-遮挡">¶</a>7.3. 遮挡</h3><p>Occlusion</p><p>接下来看一下遮挡的情况。Let us see how well the methods perform under occlusion.</p><p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-occlusion-result1.jpg" alt></p><p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-occlusion-result2.jpg" alt></p><p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-occlusion-result3.jpg" alt></p><p>再一次看到，DNN方法比其他方法更优，OpenCV-DNN 比  Dlib-MMOD 还好一点。这是因为CNN 特征 比 HoG or Haar 更加鲁棒，稳定。</p><p>Again, the DNN methods outperform the other two, with OpenCV-DNN slightly better than Dlib-MMOD. This is mainly because the CNN features are much more robust than HoG or Haar features.</p><h2 id="8-总结"><a class="header-anchor" href="#8-总结">¶</a>8. 总结</h2><p>我们讨论了每个方法的优缺点。个人建议使用 OpenCV-DNN 和 Dlib-HoG 在应用和设备成本权衡中。以下我们的建议：</p><p>We had discussed the pros and cons of each method in the respective sections. I recommend to try both OpenCV-DNN and HoG methods for your application and decide accordingly. We share some tips to get started.</p><h3 id="8-1-大多数的情况"><a class="header-anchor" href="#8-1-大多数的情况">¶</a>8.1 大多数的情况</h3><p>General Case</p><p>在多数场景中，我们提前不知道图片大小，因此 选用 OpenCV – DNN 相当快也很精确，甚至对于小人脸也不错，各种人脸角度也可以。选用这个在大多情况下是最优的。</p><p>In most applications, we won’t know the size of the face in the image before-hand. Thus, it is better to use OpenCV – DNN method as it is pretty fast and very accurate, even for small sized faces. It also detects faces at various angles. We recommend to use OpenCV-DNN in most</p><h3 id="8-2-大小中等或大一点图片"><a class="header-anchor" href="#8-2-大小中等或大一点图片">¶</a>8.2 大小中等或大一点图片</h3><p>For medium to large image sizes</p><p>Dlib HoG 在 cpu上是最快的一个方法。但是它不能检测出 face size (&lt; 70x70) 的图片。所以你得清楚使用的场景，比如自拍的话就可以。如果能使用GPU的话 dlib-MMOD 是一个最好的选择，因为它支持GPU，跑得也比较快，也能适应人脸的角度变化。</p><p>Dlib HoG is the fastest method on CPU. But it does not detect small sized faces (&lt; 70x70). So, if you know that your application will not be dealing with very small sized faces ( for example a selfie app ), then HoG based Face detector is a better option. Also, If you can use a GPU, then MMOD face detector is the best option as it is very fast on GPU and also provides detection at various angles.</p><h3 id="8-3-高分辨率图像"><a class="header-anchor" href="#8-3-高分辨率图像">¶</a>8.3 高分辨率图像</h3><p>High resolution images</p><p>对于这些方法来说，高分辨图像都有点难度，计算时间比较长。可能采用的方法是resize图像 （ scale down the image），HoG / MMOD方法可能就识别不出了，但是可以使用 OpenCV-DNN 尝试一下。我认为也可以将图片分割开再识别呀，嘻嘻。</p><p>Since feeding high resolution images is not possible to these algorithms (for computation speed), HoG / MMOD detectors might fail when you scale down the image. On the other hand, OpenCV-DNN method can be used for these since it detects small faces.</p><p>有任何建议，欢迎在下面评论。Have any other suggestions? Please mention in the comments and we’ll update the post with them!</p><h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2><p><a href="https://github.com/opencv/opencv/blob/master/modules/dnn/misc/face_detector_accuracy.py" target="_blank" rel="noopener">FDDB Comparison code</a><a href="http://blog.dlib.net/2016/10/easily-create-high-quality-object.html" target="_blank" rel="noopener">Dlib Blog</a><a href="http://dlib.net/cnn_face_detector.py.html" target="_blank" rel="noopener">dlib mmod python example</a><a href="http://dlib.net/dnn_mmod_face_detection_ex.cpp.html" target="_blank" rel="noopener">dlib mmod cpp example</a><a href="https://github.com/opencv/opencv/tree/master/samples/dnn/face_detector" target="_blank" rel="noopener">OpenCV DNN Face detector</a><a href="https://docs.opencv.org/3.4/d7/d8b/tutorial_py_face_detection.html" target="_blank" rel="noopener">Haar Based Face Detector</a></p><h2 id="TODOS"><a class="header-anchor" href="#TODOS">¶</a>TODOS</h2><p>文章作者是 <a href="https://www.learnopencv.com/author/vikas/" target="_blank" rel="noopener">VIKAS GUPTA</a></p><p>来，看看这个是站长大佬的图片，是不是很熟悉？膜拜一哈。</p><p><img src="https://secure.gravatar.com/avatar/708995cd13fb5756f6bc418aecb23b78?s=250&amp;d=mm&amp;r=g" alt="blog_author"></p><p>我订阅后文章后，作者发的邮件内容，并没有给文章页的代码。</p><ul><li><a href="https://www.learnopencv.com/wp-content/uploads/2015/05/Computer-Vision-Resources.pdf" target="_blank" rel="noopener">给的Computer-Vision-Resources.pdf</a></li><li><a href="https://github.com/spmallick/dlib" target="_blank" rel="noopener">作者的Dlib fork</a></li></ul><p><strong>重要资源</strong></p><ul><li><p>作者博客 <a href="https://www.learnopencv.com/" target="_blank" rel="noopener">link</a></p></li><li><p>作者的所有代码拿走不谢 <a href="https://github.com/spmallick/learnopencv" target="_blank" rel="noopener">link</a></p></li><li><p>[x] 翻译</p></li><li><p>[ ] 代码运行</p></li><li><p>[ ] 根据该作者的博客继续翻译，学习，向大佬致敬。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;
本文为翻译文章。原文地址 &lt;a href=&quot;https://www.learnopencv.com/face-detection-opencv-dlib-and-deep-learning-c-python/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.learnopencv.com/face-detection-opencv-dlib-and-deep-learning-c-python/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章中，作者讨论使用了OpenCV或Dlib的多种人脸检测的代码，并给出性能分析。作者使用的 Face Detector 包括以下四个，后面分别给出 c++ 和 python 实现。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OpenCV 的 Haar Cascade Face Detector&lt;/li&gt;
&lt;li&gt;OpenCV 的 Deep Learning based Face Detector&lt;/li&gt;
&lt;li&gt;Dlib 的 HoG Face Detector&lt;/li&gt;
&lt;li&gt;Dlib 的 Deep Learning based Face Detector&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;作者限于篇幅没有对对理论进行深入解读，只讨论框架的使用，同时分享一些应用上的选择权衡的经验。&lt;/p&gt;
&lt;p&gt;结论：在多数场景中，我们提前不知道图片大小，因此 选用 OpenCV – DNN 相当快也很精确，甚至对于小人脸也不错，各种人脸角度也可以。选用这个在大多情况下是最优的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/spmallick/learnopencv/tree/master/FaceDetectionComparison&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;code FaceDetectionComparison&lt;/a&gt; 说明：为了使文章显得简洁一些，在文中只提供关键的代码片段。在github项目中详细代码，包括每个方法独立的代码和整合在一起的cpp和py文件（&lt;a href=&quot;http://run-all.py&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;run-all.py&lt;/a&gt; 和 run-all.cpp），同时里面也有运行代码所使用的人脸检测模型。&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="cv" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/cv/"/>
    
    
      <category term="OpenCV" scheme="https://talengu.github.io/public/tags/OpenCV/"/>
    
      <category term="Face Detection" scheme="https://talengu.github.io/public/tags/Face-Detection/"/>
    
      <category term="Dlib" scheme="https://talengu.github.io/public/tags/Dlib/"/>
    
  </entry>
  
  <entry>
    <title>希腊罗马神话</title>
    <link href="https://talengu.github.io/public/2018/11/05/readings/Gods_stories/"/>
    <id>https://talengu.github.io/public/2018/11/05/readings/Gods_stories/</id>
    <published>2018-11-05T16:00:04.000Z</published>
    <updated>2018-11-05T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>在我电的图书馆的还书柜子里面偶然所得，一本叫《希腊罗马神话对英语语言文化的影响》吕海平 著 江苏大学初版社，然后莫名的想研究一下，发现挺不错的。</p><a id="more"></a><p>古希腊罗马的神的关系还是比较乱的，尤其是jupiter 或者zeus的奥林匹斯神系。从上古的神系，总共有三代。</p><p>网上有个人（<a href="http://www.veritablehokum.com/" target="_blank" rel="noopener">Korwin Briggs</a>）做的关系图很不错。</p><p>TODO:后面我也会对其进行整理，以后给大家分享。</p><p><img src="http://www.veritablehokum.com/wp-content/uploads/2018/08/Roman-God-Family-Tree.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在我电的图书馆的还书柜子里面偶然所得，一本叫《希腊罗马神话对英语语言文化的影响》吕海平 著 江苏大学初版社，然后莫名的想研究一下，发现挺不错的。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="https://talengu.github.io/public/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="希腊罗马神话" scheme="https://talengu.github.io/public/tags/%E5%B8%8C%E8%85%8A%E7%BD%97%E9%A9%AC%E7%A5%9E%E8%AF%9D/"/>
    
      <category term="语言文化" scheme="https://talengu.github.io/public/tags/%E8%AF%AD%E8%A8%80%E6%96%87%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>怎样成为一名优秀的算法工程师</title>
    <link href="https://talengu.github.io/public/2018/10/01/AI/how_algorithm_engineer/"/>
    <id>https://talengu.github.io/public/2018/10/01/AI/how_algorithm_engineer/</id>
    <published>2018-10-01T12:00:00.000Z</published>
    <updated>2018-10-01T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载 原创： AI学习与实践平台TODO: 看完里面的文章，对每篇文章做个总结，实验+文章。</p></blockquote><h2 id="1-导言"><a class="header-anchor" href="#1-导言">¶</a>1. 导言</h2><p>怎样成为一名优秀的算法工程师？这是很多从事人工智能学术研究和产品研发的同学都关心的一个问题。面对市场对人才的大量需求与供给的严重不足，以及高薪水的诱惑，越来越多的人开始学习这个方向的技术，或者打算向人工智能转型。市面上各种鱼龙混杂的培训班以及误导人的文章会把很多初学者带入歧途，浮躁的跟风将会让你最后收获甚微，根本达不到企业的用人要求。为了更好的帮助大家学习和成长，少走弯路，在今天的文章里，<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485551&amp;idx=2&amp;sn=a6689528f10aedab3fce91857eec877b&amp;chksm=fdb695f8cac11cee025ad6d8d77ed90f7169142d6b20b2f5a6945b58edd97c27225f4a2eba91&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SIGAI</a> 的作者以自己的亲身经历和思考，为大家写下对这一问题的理解与答案。</p><p>首先来看一个高度相关的问题：一个优秀的算法工程师必须具备哪些素质？我们给出的答案是这样的：</p><ul><li>数学知识</li><li>编程能力</li><li>机器学习与深度学习的知识</li><li>应用方向的知识</li><li>对自己所做的问题的思考和经验</li></ul><p>除去教育背景，逻辑思维，学习能力，沟通能力等其他方面的因素，大多数公司在考察算法工程师的技术水平时都会考虑上面这几个因素。接下来我们将按照这几个方面进行展开，详细的说明如何学习这些方面的知识以及积累经验。</p><a id="more"></a><h2 id="2-数学知识"><a class="header-anchor" href="#2-数学知识">¶</a>2. 数学知识</h2><p>与其他工作方向如app、服务器开发相比，以及与计算机科学的其他方向如网络，数据库，分布式计算等相比，人工智能尤其是机器学习属于数学知识密集的方向。在各种书籍，论文，算法中都充斥着大量的数学公式，这让很多打算入门的人或者开始学习的人感到明显的压力。首先我们考虑一个最核心的问题：机器学习和深度学习究竟需要哪些数学知识？在<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485551&amp;idx=2&amp;sn=a6689528f10aedab3fce91857eec877b&amp;chksm=fdb695f8cac11cee025ad6d8d77ed90f7169142d6b20b2f5a6945b58edd97c27225f4a2eba91&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SIGAI</a>之前的公众号文章“<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483713&amp;idx=1&amp;sn=1e7c81381d16806ac73e15691fe17aec&amp;chksm=fdb69cd6cac115c05f1f90b0407e3f8ae9be8719e454f908074ac0d079885b5c134e2d60fd64&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">学好机器学习需要哪些数学知识</a>”里，我们已经给出了答案。先看下面这张表：</p><p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image003.gif" alt="EB5E93E91C3643F991C93D61F363373E.jpeg"></p><p>更多算法工程师的必读文章，请关注SIGAICN公众号</p><p>上面的表给出了各种典型的机器学习算法所用到的数学知识点。我们之前已经总结过，理解绝大多数算法和理论，有微积分/高等数学，线性代数，概率论，最优化方法的知识就够了。除流形学习需要简单的微分几何概念之外，深层次的数学知识如实变函数，泛函分析等主要用在一些基础理论结果的证明上，即使不能看懂证明过程，也不影响我们使用具体的机器学习算法。概率图模型、流形学习中基于图的模型会用到图论的一些基本知识，如果学习过离散数学或者数据结构，这些概念很容易理解。除此之外，某些算法会用到离散数学中的树的概念，但很容易理解。</p><h3 id="2-1-高等数学"><a class="header-anchor" href="#2-1-高等数学">¶</a>2.1 高等数学</h3><p>如果你已经学过这些大学数学课，只要把所需的知识点复习一遍就够了。对于微积分，通俗易懂而又被广为采用的是同济版的高等数学：</p><p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image005.gif" alt="88F2EB8BDFE1448EBD2DF61848E355FD.jpeg"></p><p>在机器学习中主要用到了微分部分，积分用的非常少。具体的，用到了下面的概念：</p><ul><li>导数和偏导数的定义与计算方法，与函数性质的关系</li><li>梯度向量的定义</li><li>极值定理，可导函数在极值点处导数或梯度必须为0</li><li>雅克比矩阵，这是向量到向量映射函数的偏导数构成的矩阵，在求导推导中会用到</li><li>Hessian矩阵，这是2阶导数对多元函数的推广，与函数的极值有密切的联系</li><li>凸函数的定义与判断方法</li><li>泰勒展开公式</li><li>拉格朗日乘数法，用于求解带等式约束的极值问题</li></ul><p>其中最核心的是多元函数的泰勒展开公式，根据它我们可以推导出梯度下降法，牛顿法，拟牛顿法等一系列最优化方法。</p><p>如果你想要深入的学习微积分，可以阅读数学系的教程，称为数学分析：</p><p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image007.gif" alt="DEB5F0D2FC584E0B96B263FE1D559AFF.jpeg"></p><p>与工科的高等数学偏重计算不同，它里面有大量的理论证明，对于锻炼数学思维非常有帮助。北大张筑生先生所著的数学分析可谓是国内这方面教材的精品。</p><h3 id="2-2-线性代数"><a class="header-anchor" href="#2-2-线性代数">¶</a>2.2 线性代数</h3><p>下面来看线性代数，同样是同济版的教材：</p><p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image009.gif" alt="48D5E515A7144CE6A9CB78162F6ECAAF.jpeg"></p><p>如果想更全面系统的学习线性代数，可以看这本书：</p><p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image011.gif" alt="BF71AB68DB2B4D71AC8D2B3263C197E5.jpeg"></p><p>相比之下，线性代数用的更多。具体用到的知识点有：</p><ul><li>向量和它的各种运算，包括加法，减法，数乘，转置，内积</li><li>向量和矩阵的范数，L1范数和L2范数</li><li>矩阵和它的各种运算，包括加法，减法，乘法，数乘</li><li>逆矩阵的定义与性质</li><li>行列式的定义与计算方法</li><li>二次型的定义</li><li>矩阵的正定性</li><li>特征值与特征向量</li><li>奇异值分解</li><li>线性方程组的数值解</li></ul><p>机器学习算法处理的数据一般都是向量、矩阵或者张量。经典的机器学习算法输入的数据都是特征向量，深度学习算法在处理图像时输入的2维的矩阵或者3维的张量。掌握这些概念是你理解机器学习和深度学习算法的基础。</p><h3 id="2-3-概率论"><a class="header-anchor" href="#2-3-概率论">¶</a>2.3 概率论</h3><p>概率论国内理工科专业使用最多的是浙大版的教材：</p><p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image013.gif" alt="91E918CF7ED84C7488BDDFFC7594E0D4.jpeg"></p><p>如果把机器学习所处理的样本数据看作随机变量/向量，就可以用概率论的方法对问题进行建模，这代表了机器学习中很大一类方法。在机器学习里用到的概率论知识点有:</p><ul><li>随机事件的概念，概率的定义与计算方法</li><li>随机变量与概率分布，尤其是连续型随机变量的概率密度函数和分布函数</li><li>条件概率与贝叶斯公式</li><li>常用的概率分布，包括正态分布，伯努利二项分布，均匀分布</li><li>随机变量的均值与方差，协方差</li><li>随机变量的独立性</li><li>最大似然估计</li></ul><p>这些知识不超出普通理工科概率论教材的范围。</p><h3 id="最优化"><a class="header-anchor" href="#最优化">¶</a>最优化</h3><p>最后来说最优化，几乎所有机器学习算法归根到底都是在求解最优化问题。求解最优化问题的指导思想是在极值点出函数的导数/梯度必须为0。因此你必须理解梯度下降法，牛顿法这两种常用的算法，它们的迭代公式都可以从泰勒展开公式而得到。</p><p>凸优化是机器学习中经常会提及的一个概念，这是一类特殊的优化问题，它的优化变量的可行域是凸集，目标函数是凸函数。凸优化最好的性质是它的所有局部最优解就是全局最优解，因此求解时不会陷入局部最优解。如果一个问题被证明为是凸优化问题，基本上已经宣告此问题得到了解决。在机器学习中，线性回归、岭回归、支持向量机、logistic回归等很多算法求解的都是凸优化问题。</p><p>拉格朗日对偶为带等式和不等式约束条件的优化问题构造拉格朗日函数，将其变为原问题，这两个问题是等价的。通过这一步变换，将带约束条件的问题转换成不带约束条件的问题。通过变换原始优化变量和拉格朗日乘子的优化次序，进一步将原问题转换为对偶问题，如果满足某种条件，原问题和对偶问题是等价的。这种方法的意义在于可以将一个不易于求解的问题转换成更容易求解的问题。在支持向量机中有拉格朗日对偶的应用。</p><p>KKT条件是拉格朗日乘数法对带不等式约束问题的推广，它给出了带等式和不等式约束的优化问题在极值点处所必须满足的条件。在支持向量机中也有它的应用。</p><p>如果你没有学过最优化方法这门课也不用担心，这些方法根据微积分和线性代数的基础知识可以很容易推导出来。如果需要系统的学习这方面的知识，可以阅读《凸优化》，《非线性规划》两本经典教材。</p><p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image015.gif" alt="B00246CBCFB446789B2F7F63F3292099.jpeg"></p><h2 id="3-编程能力"><a class="header-anchor" href="#3-编程能力">¶</a>3. 编程能力</h2><p>编程能力是学好机器学习和深度学习的又一大基础。对于计算机类专业的学生，由于本科已经学了c语言，c++，数据结构与算法，因此这方面一般不存在问题。对于非计算机专业的人来说，要真正学好机器学习和深度学习，这些知识是绕不开的。</p><h3 id="3-1-C"><a class="header-anchor" href="#3-1-C">¶</a>3.1 C++</h3><p>虽然现在大家热衷于学习python，但要作为一名真正的算法工程师，还是应该好好学习一下c++，至少，机器学习和深度学习的很多底层开源库都是用它写的；很多公司线上的产品，无论是运行在服务器端，还是嵌入式端，都是用c++写的。此外，如果你是应届生，在校园招聘时不少公司都会面试你c++的知识。</p><p>C++最经典的教材无疑是c++ primer：</p><p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image017.gif" alt="3E0DE0E336474B81A2F89F2190628186.jpeg"></p><p>对做算法的人来说，这本书其实不用全部看，把常用的点学完就够了。对于进阶，Effective c++是很好的选择，不少公司的面试题就直接出自这本书的知识点：</p><p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image019.gif" alt="DDCC32DD5E6D405588CB4B6F4A94BFE5.jpeg"></p><p>接下来说python，相比c++来说，学习的门槛要低很多，找一本通俗易懂的入门教程学习一遍即可。</p><h3 id="3-2-数据结构和算法"><a class="header-anchor" href="#3-2-数据结构和算法">¶</a>3.2 数据结构和算法</h3><p>数据结构和算法是编写很多程序的基础，对于机器学习和深度学习程序也不例外。很多算法的实现都依赖于数组，链表，数，排序，查找之类的数据结构和基础算法。如果有时间和精力，把算法导论啃一遍，你会有不一样的感受：</p><p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image021.gif" alt="E077608423D7473ABF1DBF75C482E060.jpeg"></p><p>对于应届生来说，学完它对于你通过大互联网和人工智能公司校园招聘的技术面试也非常有用。</p><p>上面说的只是编程语言的程序设计的理论知识，我们还要考虑实际动手能力。对于开发环境如gcc/g++，visual studio之类的工具，以及gdb之类的调试工具需要做到熟练使用。如果是在linux上开发，对linux的常用命令也要熟记于心。这方面的知识看各种具体的知识点和教程即可。另外，对于编程的一些常识，如进程，线程，虚拟内存，文件系统等，你最好也要进行了解。</p><h2 id="4-机器学习与深度学习的知识"><a class="header-anchor" href="#4-机器学习与深度学习的知识">¶</a>4. 机器学习与深度学习的知识</h2><p>在说完了数学和编程基础之后，下面我来看核心的内容，机器学习和深度学习知识。机器学习是现阶段解决很多人工智能问题的核心方法，尤其是深度学习，因此它们是算法工程师的核心知识。在这里有一个问题：是否需要先学机器学习，还是直接学深度学习？如果是一个专业的算法工程师，我的建议是先学机器学习。至少，你要知道机器学习中的基本概念， 过拟合，生成模型，ROC曲线等，上来就看深度学习，如没有背景知识你将不知所云。另外，神经网络只是机器学习中的一类方法，对于很多问题，其他机器学习算法如logistic回归，随机森林，GBDT，决策树等还在被大规模使用，因此你不要把自己局限在神经网络的小圈子里。</p><h3 id="4-1-ML和DP的教材"><a class="header-anchor" href="#4-1-ML和DP的教材">¶</a>4.1 ML和DP的教材</h3><p>首先来看机器学习，这方面的教材很多，周志华老师的机器学习，李航老师的统计学习方法是国内的经典。这里我们介绍国外的经典教材，首先是PRML：</p><p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image023.gif" alt="BE2D3D5817344DE0831B718D3F891899.jpeg"></p><p>PRML 下载地址 <a href="https://www.microsoft.com/en-us/research/publication/pattern-recognition-machine-learning/" target="_blank" rel="noopener">link</a></p><p>此书深厚，内容全面，涵盖了有监督学习，无监督学习的主要方法，理论推导和证明详细深入，是机器学习的经典。此外还有模式分类这本书，在这里不详细介绍。</p><p>本书主要内容包括：<strong>第一章：简介</strong>概率论、模型选择、决策理论、信息理论</p><p><strong>第二章：概率分布</strong>二元变量、多项变量、高斯分布、指数分布族、非参数方法</p><p><strong>第三章：线性模型回归问题</strong>线性基函数模型、偏置方差分解、贝叶斯线性回归、贝叶斯模型比较、The Evidence Approximation、固定基函数的局限性</p><p><strong>第四章：线性模型分类问题</strong>判别函数、概率生成模型、概率判别模型、拉普拉斯逼近、贝叶斯逻辑回归</p><p><strong>第五章：神经网络</strong>前馈神经网络、网络训练、误差反向传播、Hessian矩阵、神经网络的正则化、混合密度网络、贝叶斯神经网络</p><p><strong>第六章：Kernel方法</strong>对偶表示、构造核、径向基函数网络、高斯过程</p><p><strong>第七章：Sparse Kernel Machines</strong>最大边缘分类器、相关向量机</p><p><strong>第八章：图模型</strong>贝叶斯网络、条件独立性、马尔科夫随机场、图模型的推理</p><p><strong>第九章：混合模型和EM</strong>K-means聚类、高斯混合、EM算法</p><p><strong>第十章：近似推断</strong>变分推断、高斯的变分混合、变分线性回归、指数族分布、局部变分方法、变分logistic回归、Expectation Propagation</p><p><strong>第十一章：采样方法</strong>基本采样算法、马尔科夫链蒙特卡洛、吉布斯采样、切片采样、混合蒙特卡洛算法、估计划分函数</p><p><strong>第十二章：连续潜在变数</strong>主成分分析，Probabilistic PCA，Kernel PCA，非线性潜变量模型</p><p><strong>第十三章：序列数据</strong>马尔可夫模型，隐马尔可夫模型，Linear Dynamical Systems</p><p><strong>第十四章：混合模型</strong>贝叶斯模型平均法，Committees，Boosting，基于树的模型，条件混合模型</p><p>深度学习目前最权威的教程是下面这本书：</p><p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image025.gif" alt="A39AD50565E141F89B08C93CCD7DEDFC.jpeg"></p><p>它涵盖了深度学习的方方面面，从理论到工程，但美中不足的是对应于介绍的相对较少。</p><p>强化学习是机器学习很独特的一个分支，大多数人对它不太了解，这方面的教程非常少，我们推荐下面这本书：</p><p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image027.gif" alt="115B0E32F06F4538A76CB9B610F63B8C.jpeg"></p><p>美中不足的是这本书对深度强化学习没有介绍，因为出版的较早。不知最新的版本有没有加上这方面的内容。</p><p>在这里需要强调的是，你的知识要系统化，有整体感。很多同学都感觉到自己学的机器学习太零散，缺乏整体感。这需要你多思考算法之间的关系，演化历史之类的问题，这样你就做到胸中有图-机器学习算法地图。其实，<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485551&amp;idx=2&amp;sn=a6689528f10aedab3fce91857eec877b&amp;chksm=fdb695f8cac11cee025ad6d8d77ed90f7169142d6b20b2f5a6945b58edd97c27225f4a2eba91&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SIGAI</a>在之前的公众号文章“<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485306&amp;idx=1&amp;sn=fc8cc8de313bdb61dcd39c1dedb240a4&amp;chksm=fdb69aedcac113fb4b18c74248a313536ded50bade0e66b26f332ab247b148519da71ff2a3c0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">机器学习算法地图</a>”里已经给你总结出来了。</p><h3 id="4-2-开源库"><a class="header-anchor" href="#4-2-开源库">¶</a>4.2 开源库</h3><p>上面介绍了机器学习和深度学习的理论教材，下面来说实践问题。我们无需重复造车轮子，熟练的使用主流的开源库是需要掌握的一项技能。对于经典的机器学习，常用的库的有:</p><ul><li>libsvm</li><li>liblinear</li><li>XGBoost</li><li>OpenCV</li><li>HTK</li><li>Weka</li></ul><p>在这里我们不一一列举。借助于这些库，我们可以方便的完成自己的实验，或是研发自己的产品。对于深度学习，目前常用的有：</p><ul><li>Caffe</li><li>TensorFlow</li><li>MXNet</li></ul><p>除此之外，还有其他的。对于你要用到的开源库，一定要理解它的原理，以及使用中的一些细节问题。例如很多算法要求输入的数据先做归一化，否则效果会非常差，而且面临浮点数溢出的问题，这些实际经验需要你在使用中摸索。如果有精力把这些库的核心代码分析一遍，你对实现机器学习算法将会更有底气。以深度学习为例，最核心的代码无非是实现：</p><ul><li>各种层，包括它们的正向传播和反向传播</li><li>激活函数的实现</li><li>损失函数的实现</li><li>输入数据的处理</li><li>求解器，实现各种梯度下降法</li></ul><p>这些代码的量并不大，沉下心来，我相信一周之内肯定能分析完。看完之后你会有一种豁然开朗的感觉。</p><h2 id="5-应用方向的知识"><a class="header-anchor" href="#5-应用方向的知识">¶</a>5. 应用方向的知识</h2><p>接下来是各个方向的知识，与机器学习有关的应用方向当前主要有：</p><ul><li>机器视觉</li><li>语音识别</li><li>自然语言处理</li><li>数据挖掘</li><li>知识图谱</li><li>推荐系统</li></ul><p>除此之外，还有其他一些特定小方向，在这里不一一列举。这些具体的应用方向一般都有自己的教材，如果你以后要从事此方向的研究，系统的学习一遍是必须的。</p><h2 id="6-实践经验与思考"><a class="header-anchor" href="#6-实践经验与思考">¶</a>6. 实践经验与思考</h2><p>在说完理论与实践知识之后，最后我们来说经验与思考。在你确定要做某一个方向之后，对这个方向的方法要有一个全面系统的认识，很多方法是一脉相承的，如果只追求时髦看最新的算法，你很难做出学术上的创新，以及工程上的优化。对于本问题所有的经典论文，都应该化时间细度，清楚的理解它们解决了什么问题，是怎么解决的，还有哪些问题没有解决。例如：</p><ul><li>机器视觉目标检测中的遮挡问题</li><li>推荐系统中的冷启动问题</li><li>自然语言处理中文分词中的歧义切分问题</li></ul><p>只有经过大量的编程和实验训练，以及持续的思考，你才能算得上对这个方向深刻理解，以至于有自己的理解。很多同学对自己实现轮上的算法没有底气，解决这个问题最快的途径就是看论文算法的开源代码，在github上有丰富的资源，选择一些合适的，研究一下别人是怎么实现的，你就能明白怎么实现自己的网络结构和损失函数，照葫芦画瓢即可。</p><p>计算机以及人工智能是一个偏实践的学科，它的方法和理论既需要我们有扎实的理论功底，又需要有丰富的实践能力与经验。这两个方面构成了算法工程师最主要的素质。科学的学习路径能够让你取得好的学习效果，同时也缩短学习时间。错误和浮躁的做法则会让你最后事倍功半。这是  <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485551&amp;idx=2&amp;sn=a6689528f10aedab3fce91857eec877b&amp;chksm=fdb695f8cac11cee025ad6d8d77ed90f7169142d6b20b2f5a6945b58edd97c27225f4a2eba91&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SIGAI</a> 对想进入这个领域，或者刚进入这个领域的每个人要说的！</p><p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image029.gif" alt="07382DFD55044B48927C8B054DE6F745.png"></p><h2 id="7-其他材料"><a class="header-anchor" href="#7-其他材料">¶</a>7. 其他材料</h2><h3 id="7-1-科普类"><a class="header-anchor" href="#7-1-科普类">¶</a>7.1 科普类</h3><p>【‍获取码】SIGAI0413​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483705&amp;idx=1&amp;sn=c6e7c4a2e14a2469308b41eb60f155ac&amp;chksm=fdb69caecac115b8712653600e526e99a3f6976fdaa2f6b6a09388fa6f9677ccb57b40c40ae3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">机器学习——波澜壮阔四十年 </a></p><p>【获取码】SIGAI0620​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484981&amp;idx=1&amp;sn=d3003468b9853851923844812993e060&amp;chksm=fdb69ba2cac112b4dac620d52100ebd033eb679f29340726a67297c4d6980b16c7cc91122028&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解计算：从√2到AlphaGo ——第1季 从√2谈起</a></p><p>【获取码】SIGAI0704<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485155&amp;idx=1&amp;sn=990cc7400751c36e9fef0a261e6add2a&amp;chksm=fdb69b74cac112628bdae14c6435120f6fece20dae9bf7b1ffc8b8b25e5496a24160feca0a72&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解计算：从√2到AlphaGo ——第2季 神经计算的历史背景</a></p><h3 id="7-2-数学类"><a class="header-anchor" href="#7-2-数学类">¶</a>7.2 数学类</h3><p>【获取码】SIGAI0417<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483713&amp;idx=1&amp;sn=1e7c81381d16806ac73e15691fe17aec&amp;chksm=fdb69cd6cac115c05f1f90b0407e3f8ae9be8719e454f908074ac0d079885b5c134e2d60fd64&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">学好机器学习需要哪些数学知识</a></p><p>【获取码】SIGAI0511<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484111&amp;idx=1&amp;sn=4ed4480e849298a0aff828611e18f1a8&amp;chksm=fdb69f58cac1164e844726bd429862eb7b38d22509eb4d1826eb851036460cb7ca5a8de7b9bb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解梯度下降法</a></p><p>【获取码】SIGAI0518<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484439&amp;idx=1&amp;sn=4fa8c71ae9cb777d6e97ebd0dd8672e7&amp;chksm=fdb69980cac110960e08c63061e0719a8dc7945606eeef460404dc2eb21b4f5bdb434fb56f92&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解凸优化</a></p><p>【获取码】SIGAI0531<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484651&amp;idx=1&amp;sn=a0e4ca5edb868fe3eae9101b71dd7103&amp;chksm=fdb6997ccac1106a61f51fe9f8fd532045cc5d13f6c75c2cbbf1a7c94c58bcdf5f2a6661facd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解牛顿法 </a></p><h3 id="7-3-机器学习类"><a class="header-anchor" href="#7-3-机器学习类">¶</a>7.3 机器学习类</h3><p>【获取码】SIGAI0428​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483937&amp;idx=1&amp;sn=84a5acf12e96727b13fd7d456c414c12&amp;chksm=fdb69fb6cac116a02dc68d948958ee731a4ae2b6c3d81196822b665224d9dab21d0f2fccb329&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">用一张图理解SVM的脉络</a></p><p>【获取码】SIGAI0505​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483977&amp;idx=1&amp;sn=401b211bf72bc70f733d6ac90f7352cc&amp;chksm=fdb69fdecac116c81aad9e5adae42142d67f50258106f501af07dc651d2c1473c52fad8678c3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解神经网络的激活函数</a></p><p>【获取码】SIGAI0522<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484495&amp;idx=1&amp;sn=4f3a6ce21cdd1a048e402ed05c9ead91&amp;chksm=fdb699d8cac110ce53f4fc5e417e107f839059cb76d3cbf640c6f56620f90f8fb4e7f6ee02f9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【实验】理解SVM核函数和参数的作用</a></p><p>【获取码】SIGAI0601<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484658&amp;idx=1&amp;sn=f5c9f92c272c75883bf8e6f532559f11&amp;chksm=fdb69965cac11073f49048caef5d7b9129614090a363d9ef7f3d1b9bc59948d2217d2bca7b7b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【群话题精华】五月集锦—机器学习和深度学习中一些值得思考的问题   </a></p><p>【获取码】SIGAI0602​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484692&amp;idx=1&amp;sn=9b389aa65208c778dddf17c601afbee1&amp;chksm=fdb69883cac1119593934734e94c3b71aa68de67bda8a946c1f9f9e1209c3b6f0bf18fed99b8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">大话AdaBoost算法    </a></p><p>【获取码】SIGAI0606​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484754&amp;idx=1&amp;sn=b2c0d6798f44e13956bb42373e51d18c&amp;chksm=fdb698c5cac111d3e3dca24c50aafbfb61e5b05c5df5b603067bb7edec8db049370b73046b24&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解主成分分析（PCA）    </a></p><p>【获取码】SIGAI0611​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484827&amp;idx=1&amp;sn=043d7d0159baaddfbf92ed78ee5b1124&amp;chksm=fdb6980ccac1111a9faeae7f517fee46a1dfab19612f76ccfe5417487b3f090ab8fc702d18b8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解决策树  </a></p><p>【获取码】SIGAI0613​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484859&amp;idx=1&amp;sn=2c4db22fb538953a62a90983e3e1f99d&amp;chksm=fdb6982ccac1113a82e92be325bb07a947d54090274654375f3b50e11e1abd809fb7358bde16&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">用一句话总结常用的机器学习算法</a></p><p>【获取码】SIGAI0618​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484954&amp;idx=1&amp;sn=c28b7f07c22466e91b1ef90e9dbe3ad1&amp;chksm=fdb69b8dcac1129bc6e78fca1d550e2b18238ad1c240c73b280d4e529f9f93c4626b3ac45ea2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解过拟合</a></p><p>【获取码】SIGAI0627​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485074&amp;idx=1&amp;sn=0ebf1bf8f49e9c46075fe3803d04c95d&amp;chksm=fdb69b05cac112132d280c70af3923ca4c3cccfa5fcd8628b79d4b246b3b2decbc80a180abb3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">k近邻算法</a></p><p>【获取码】SIGAI0704​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485306&amp;idx=1&amp;sn=fc8cc8de313bdb61dcd39c1dedb240a4&amp;chksm=fdb69aedcac113fb4b18c74248a313536ded50bade0e66b26f332ab247b148519da71ff2a3c0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">机器学习算法地图</a></p><p>【获取码】SIGAI0706​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485446&amp;idx=1&amp;sn=57d7d866443810c20c4ea2c6ee8018cc&amp;chksm=fdb69591cac11c8773638b396abe43c0161e4d339f0fa845e54326be3e8c4933a3b6a2713dae&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">反向传播算法推导—全连接神经网络</a></p><h3 id="7-4-深度学习类"><a class="header-anchor" href="#7-4-深度学习类">¶</a>7.4 深度学习类</h3><p>【获取码】SIGAI0426<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483816&amp;idx=1&amp;sn=fc52765b012771d4736c9be4109f910e&amp;chksm=fdb69c3fcac115290020c3dd0d677d987086a031c1bde3429339bb3b5bbc0aa154e76325c225&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">卷积神经网络为什么能够称霸计算机视觉领域？</a></p><p>【获取码】SIGAI0508<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484037&amp;idx=1&amp;sn=13ad0d521b6a3578ff031e14950b41f4&amp;chksm=fdb69f12cac11604a42ccb37913c56001a11c65a8d1125c4a9aeba1aed570a751cb400d276b6&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">深度卷积神经网络演化历史及结构改进脉络-40页长文全面解读 </a></p><p>【获取码】SIGAI0515<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484310&amp;idx=1&amp;sn=0fc55a2784a894100a1ae64d7dbfa23d&amp;chksm=fdb69e01cac1171758cb021fc8779952e55de41032a66ee5417bd3e826bf703247e243654bd0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">循环神经网络综述—语音识别与自然语言处理的利器</a></p><p>【获取码】SIGAI0625<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485042&amp;idx=1&amp;sn=cdcf8d4b07acf64c7a6f5f7c1a731a12&amp;chksm=fdb69be5cac112f377766984afb87313c1e1c58d94c80005f0f6f6af61ee5a4bd1bf6c6157b6&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">卷积神经网络的压缩与加速</a></p><p>【获取码】SIGAI0709<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485551&amp;idx=1&amp;sn=213f48c4e55bee688cf0731097bb832c&amp;chksm=fdb695f8cac11ceef3ef246c54d811dd64d8cc45fc75488c374c7aa95f72c1abfb55555ef0b7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener"> 生成式对抗网络模型综述</a></p><h3 id="7-5-机器视觉类"><a class="header-anchor" href="#7-5-机器视觉类">¶</a>7.5 机器视觉类</h3><p>【获取码】SIGAI0420​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483726&amp;idx=1&amp;sn=9fef4cc1766ea4258749f8d40cc71a6e&amp;chksm=fdb69cd9cac115cf4eba16081780c3b64c75e1e55a40bf2782783d5c28f00c6f143426e6f0aa&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">人脸识别算法演化史</a></p><p>【获取码】SIGAI0424​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483731&amp;idx=1&amp;sn=237c52bc9ddfe65779b73ef8b5507f3c&amp;chksm=fdb69cc4cac115d2ca505e0deb975960a792a0106a5314ffe3052f8e02a75c9fef458fd3aca2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">基于深度学习的目标检测算法综述</a></p><p>【获取码】SIGAI0503​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483950&amp;idx=1&amp;sn=a3a5b7907b2552c233f654a529931776&amp;chksm=fdb69fb9cac116af5dd237cf987e56d12b0d2e54c5c565aab752f3e366c0c45bfefa76f5ed16&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">人脸检测算法综述</a></p><p>【获取码】SIGAI0525<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483950&amp;idx=1&amp;sn=a3a5b7907b2552c233f654a529931776&amp;chksm=fdb69fb9cac116af5dd237cf987e56d12b0d2e54c5c565aab752f3e366c0c45bfefa76f5ed16&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【SIGAI综述】行人检测算法   </a></p><p>【获取码】SIGAI0604​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484711&amp;idx=1&amp;sn=bb7644e101b5924f54d6800b952dc3aa&amp;chksm=fdb698b0cac111a6605f5b9b6f0478bf21a8527cfad2342dbaaf624b4e9dcc43c0d85ae06deb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">FlowNet到FlowNet2.0：基于卷积神经网络的光流预测算法 </a></p><p>【获取码】SIGAI0608​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484784&amp;idx=1&amp;sn=ceafb54203f4e930ae457ad392b9f89c&amp;chksm=fdb698e7cac111f13d8229d7dcc00b4a7305d66de3da1bd41e7ecc1d29bfa7be520d205c53e9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">人体骨骼关键点检测综述 </a></p><p>【获取码】SIGAI0615​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484909&amp;idx=1&amp;sn=c02ee17e5175230ed39ad63e73249f5c&amp;chksm=fdb6987acac1116c0108ec28424baf4ea16ca11d2b13f20d4a825d7b2b82fb8765720ebd1063&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">目标检测算法之YOLO</a></p><p>【获取码】SIGAI0622​    <a href="https://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485005&amp;idx=1&amp;sn=0d4fb43b8db2a8046c64a9cfcbf3f478&amp;chksm=fdb69bdacac112cce05c8b735b4f8b1ccf2348bea55a30af2055fc328958bb8f1ffd0f819bd2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">场景文本检测——CTPN算法介绍</a></p><p>【获取码】SIGAI0629​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485142&amp;idx=1&amp;sn=c0e01da30eb5e750be453eabe4be2bf4&amp;chksm=fdb69b41cac11257ae22c7dac395e9651dab628fc35dd6d3c02d9566a8c7f5f2b56353d58a64&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">自然场景文本检测识别技术综述</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载 原创： AI学习与实践平台
TODO: 看完里面的文章，对每篇文章做个总结，实验+文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1-导言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#1-导言&quot;&gt;¶&lt;/a&gt;1. 导言&lt;/h2&gt;
&lt;p&gt;怎样成为一名优秀的算法工程师？这是很多从事人工智能学术研究和产品研发的同学都关心的一个问题。面对市场对人才的大量需求与供给的严重不足，以及高薪水的诱惑，越来越多的人开始学习这个方向的技术，或者打算向人工智能转型。市面上各种鱼龙混杂的培训班以及误导人的文章会把很多初学者带入歧途，浮躁的跟风将会让你最后收获甚微，根本达不到企业的用人要求。为了更好的帮助大家学习和成长，少走弯路，在今天的文章里，&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;amp;mid=2247485551&amp;amp;idx=2&amp;amp;sn=a6689528f10aedab3fce91857eec877b&amp;amp;chksm=fdb695f8cac11cee025ad6d8d77ed90f7169142d6b20b2f5a6945b58edd97c27225f4a2eba91&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SIGAI&lt;/a&gt; 的作者以自己的亲身经历和思考，为大家写下对这一问题的理解与答案。&lt;/p&gt;
&lt;p&gt;首先来看一个高度相关的问题：一个优秀的算法工程师必须具备哪些素质？我们给出的答案是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数学知识&lt;/li&gt;
&lt;li&gt;编程能力&lt;/li&gt;
&lt;li&gt;机器学习与深度学习的知识&lt;/li&gt;
&lt;li&gt;应用方向的知识&lt;/li&gt;
&lt;li&gt;对自己所做的问题的思考和经验&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除去教育背景，逻辑思维，学习能力，沟通能力等其他方面的因素，大多数公司在考察算法工程师的技术水平时都会考虑上面这几个因素。接下来我们将按照这几个方面进行展开，详细的说明如何学习这些方面的知识以及积累经验。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://talengu.github.io/public/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="人工智能" scheme="https://talengu.github.io/public/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://talengu.github.io/public/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="深度学习" scheme="https://talengu.github.io/public/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>linux代理的使用</title>
    <link href="https://talengu.github.io/public/2018/07/24/linux/linux_proxy/"/>
    <id>https://talengu.github.io/public/2018/07/24/linux/linux_proxy/</id>
    <published>2018-07-24T22:00:00.000Z</published>
    <updated>2018-07-24T22:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>最近要下载一个在youtube上的数据库，用来训练神经网络。走国内通道下载比较慢。于是，我使用了vps代理方式下载，速度取决于你的机器连接vps的网速。本文的主要内容有，实现shadowsocks 代理 ，tsocks 代理工具使用，可组合使用的一些下载工具如wget 和axel等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 举个栗子</span></span><br><span class="line">$ tsocks wget -c https://www.dropbox.com/s/minpyv59crdifk9/datasets.zip</span><br></pre></td></tr></table></figure><p>嗯嗯，这个速度还不错！</p><p><img src="/public/2018/07/24/linux/linux_proxy/1565246896718.png" alt="1565246896718"></p><p><strong>声明</strong>：本文以科学研究为目的，请勿滥用。</p><a id="more"></a><h2 id="1-Shadowsocks"><a class="header-anchor" href="#1-Shadowsocks">¶</a>1 Shadowsocks</h2><p><strong>Shadowsocks</strong>是一个轻量级socks5代理工具。在linux平台，我们可使用 python 提供的包管理工具 pip <strong>安装 Shadowsocks</strong> ，如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip 安装 Shadowsocks</span></span><br><span class="line">$ pip install shadowsocks</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br></pre></td></tr></table></figure><p>pip安装完之后，可能要重启终端，我们就有ssserver和sslocal小工具了。下面配置server或者client。一般，server配置在国外的vps上，client配置在本地国内机器上。</p><p>PS：其他平台安装 参考 shadowsocks官方 <a href="https://github.com/shadowsocks/shadowsocks/tree/master#install" target="_blank" rel="noopener">install</a></p><h3 id="1-1-配置-Shadowsocks-server"><a class="header-anchor" href="#1-1-配置-Shadowsocks-server">¶</a>1.1 配置 Shadowsocks server</h3><p>按下面的三步走，即可。</p><ul><li><p>通过ssh连接到（Virtual Private Server）vps上，或者本地打开终端。</p></li><li><p>新建一个<strong>server_shadowsocks.json</strong>文件，内容如下：</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">443</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"密码"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行<code>ssserver -c server_shadowsocks.json</code></li></ul><p>说一点: 由于我们的下载任务是临时的，开个screen（终端复用工具）放在后台。当然你也可以设置为开机自启动，这里不再赘述。</p><h3 id="1-2-配置-Shadowsocks-client"><a class="header-anchor" href="#1-2-配置-Shadowsocks-client">¶</a>1.2 配置 Shadowsocks client</h3><ul><li><p>通过ssh连接到机器上，或者本地打开终端。</p></li><li><p>新建文件 <strong>client_shadowsocks.json</strong></p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">"server"</span>:<span class="string">"服务器ip或域名"</span>,</span><br><span class="line">        <span class="attr">"server_port"</span>:<span class="number">443</span>,</span><br><span class="line">        <span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">        <span class="attr">"local_port"</span>:<span class="number">1280</span>,</span><br><span class="line">        <span class="attr">"password"</span>:<span class="string">"密码"</span>,</span><br><span class="line">        <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">        <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">        <span class="attr">"fast_open"</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"workers"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>执行<code>sslocal -c client_shadowsocks.json</code>。</li></ul><p>说一点：推荐使用screen方式放在后台。当然也可以使用-d 参数放在后台运行。<code>sslocal -c client_shadowsocks.json -d start</code></p><h2 id="2-tsocks"><a class="header-anchor" href="#2-tsocks">¶</a>2 tsocks</h2><p>有些linux工具可能没有proxy的代理功能，或者不支持sock5代理，而用tsocks可以很好的解决这些问题。<strong>tsocks</strong> 是个终端代理工具，可以直接连接shadowsocks提供socks 5代理端口，有点类似于proxychains。</p><p>下面简单介绍下安装与使用：</p><ul><li>安装<strong>tsocks</strong><ul><li>linux安装tsocks 命令：<code>apt install tsocks</code></li><li>mac 安装参考 <a href="https://github.com/Anakros/homebrew-tsocks" target="_blank" rel="noopener">homebrew-tsocks</a></li></ul></li><li><strong>开启上面Shadowsocks的client</strong>放在后台。</li><li>修改tsocks 配置文件，在<code>/etc/tsocks.conf</code>  文件的最后添加：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">local = 192.168.1.0/255.255.255.0</span><br><span class="line">server = 127.0.0.1</span><br><span class="line">server_type = 5</span><br><span class="line">server_port = 1080</span><br></pre></td></tr></table></figure><h2 id="3-Demo：代理使用"><a class="header-anchor" href="#3-Demo：代理使用">¶</a>3 Demo：代理使用</h2><h3 id="3-1-使用-tsocks"><a class="header-anchor" href="#3-1-使用-tsocks">¶</a>3.1 使用 tsocks</h3><p>在所需代理的命令前加个tsocks就行，如：<code>tsocks wget -c xxxx</code>,<code>tsocks axel -n 10 -av xxxx</code>,<code>tsocks curl xxx</code></p><h3 id="3-2-使用-youtube-dl"><a class="header-anchor" href="#3-2-使用-youtube-dl">¶</a>3.2 使用 youtube-dl</h3><p>youtube-dl是批量下载youtube视频的好工具。youtube-dl 可以指定 proxy，<strong>可以不使用tsocks</strong>。</p><ul><li>安装youtube-dl</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade youtube-dl</span><br></pre></td></tr></table></figure><ul><li><p>使用举个例子</p><ul><li>下载youtube视频</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">URL=https://www.youtube.com/playlist?list=PLLbeS1kM6teJqdFzw1ICHfa4a1y0hg8Ax</span><br><span class="line">./youtube-dl --proxy socks5://127.0.0.1:1280 $&#123;URL&#125;</span><br><span class="line"># 在 client_shadowsocks.json 的 local_port 设置为1280，这儿也为1280</span><br></pre></td></tr></table></figure><ul><li>下载里面的mp3</li></ul>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">youtube-dl -x --audio-format mp3 https://www.youtube.com/watch?v=xpVfcZ0ZcFM</span><br></pre></td></tr></table></figure></li></ul><p><strong>youtube-dl 中待解决的问题？</strong>想只下载一个视频中的一部分，不用下载整个视频，太费vps流量了。暂未找到解决办法，我找到的一个跟问题很相似的issue，有朋友会整的，望告诉一下。<a href="https://github.com/rg3/youtube-dl/issues/4821" target="_blank" rel="noopener">is it possible to download only desired time interval?</a></p><h3 id="3-3-使用-axel"><a class="header-anchor" href="#3-3-使用-axel">¶</a>3.3 使用 axel</h3><p>axel多线程下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsocks axel -n 3 -a https://www.dropbox.com/s/minpyv59crdifk9/datasets.zip</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n 3 : 3个线程下载</span><br><span class="line">-a   : 有个进度条</span><br></pre></td></tr></table></figure><p>其他方式：下载脚本 <a href="http://axel-bash.sh" target="_blank" rel="noopener">axel-bash.sh</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh -e  </span></span><br><span class="line"><span class="comment"># usage:  ./axel-batch.sh the-download-url.list  </span></span><br><span class="line">cat <span class="variable">$1</span> | <span class="keyword">while</span> <span class="built_in">read</span> LINE  </span><br><span class="line"><span class="keyword">do</span>  </span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$LINE</span>"</span> ]; <span class="keyword">then</span>  </span><br><span class="line">axel -n 3 -a `<span class="built_in">echo</span> <span class="variable">$LINE</span>`  </span><br><span class="line"><span class="keyword">fi</span>  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;
最近要下载一个在youtube上的数据库，用来训练神经网络。走国内通道下载比较慢。于是，我使用了vps代理方式下载，速度取决于你的机器连接vps的网速。本文的主要内容有，实现shadowsocks 代理 ，tsocks 代理工具使用，可组合使用的一些下载工具如wget 和axel等。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 举个栗子&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ tsocks wget -c https://www.dropbox.com/s/minpyv59crdifk9/datasets.zip&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;嗯嗯，这个速度还不错！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/public/2018/07/24/linux/linux_proxy/1565246896718.png&quot; alt=&quot;1565246896718&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;声明&lt;/strong&gt;：本文以科学研究为目的，请勿滥用。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://talengu.github.io/public/categories/Linux/"/>
    
    
      <category term="工具" scheme="https://talengu.github.io/public/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="linux" scheme="https://talengu.github.io/public/tags/linux/"/>
    
      <category term="proxy代理" scheme="https://talengu.github.io/public/tags/proxy%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>终端中bash、vim、tmux等的配置</title>
    <link href="https://talengu.github.io/public/2018/07/12/linux/bash_bashrc/"/>
    <id>https://talengu.github.io/public/2018/07/12/linux/bash_bashrc/</id>
    <published>2018-07-12T16:00:04.000Z</published>
    <updated>2018-07-12T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>使用终端有一段时间了，现在主力的平台是Ubuntu16.04，本文对bash、vim、tmux配置的一些记录。</p><a id="more"></a><p>在<code>cd ~</code>下建立talen_bashrc文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> HOME_BASHRC=xxxx/talen_bashrc</span><br><span class="line"> alias vimbashrc='vim $HOME_BASHRC &amp;&amp; source $HOME_BASHRC'</span><br><span class="line"><span class="meta">#</span><span class="bash"> files</span></span><br><span class="line"> alias countfiles='echo "total num: " &amp;&amp; ls | wc -l &amp;&amp; du -sh'</span><br><span class="line"> alias ll='ls -htrlF --time-style="+%H:%M %Y/%m/%d"'</span><br><span class="line"> alias dum='du -a -d 1 -m |sort -nr'</span><br><span class="line"> alias dug='df -h /dev/sdbxxx &amp;&amp; du -BG -d 1 --time |sort -nr'</span><br><span class="line"></span><br><span class="line"> alias pi='pip install -i https://pypi.tuna.tsinghua.edu.cn/simple'</span><br><span class="line"> alias gpuwatch='watch -n 1 nvidia-smi'</span><br><span class="line"></span><br><span class="line"> alias gitm='git commit -m'</span><br><span class="line"> alias gits='git status -s'</span><br><span class="line"></span><br><span class="line"> export PYTHONPATH=$PYTHONPATH:xxxxxxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> vimrc</span></span><br><span class="line"> export MYVIMRC=xxxx/.vim/.vimrc</span><br><span class="line"> export VIMINIT="let &amp;rtp='xxxx/.vim,' . &amp;rtp</span><br><span class="line"> so $MYVIMRC"</span><br></pre></td></tr></table></figure><p>python环境使用的是anaconda（或者minicoonda）添加激活环境。在<code>~/.bashrc</code>中加入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias talen='source xxx/talen_bashrc &amp;&amp; source activate xxx/envs'</span><br><span class="line">alias utalen='source deactivate'</span><br></pre></td></tr></table></figure><p>github <a href="https://github.com/talengu/vim/blob/master/bashrc" target="_blank" rel="noopener">bashrc</a></p><p>其他的vimrc配置见我的github项目<a href="https://github.com/talengu/vim" target="_blank" rel="noopener">vimrc</a></p><h2 id="跳转命令-z"><a class="header-anchor" href="#跳转命令-z">¶</a>跳转命令 z</h2><p><a href="https://github.com/rupa/z/blob/master/z.sh" target="_blank" rel="noopener">z.sh</a>终端效率提升：自动路径切换<a href="https://zhuanlan.zhihu.com/p/50548459" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50548459</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用终端有一段时间了，现在主力的平台是Ubuntu16.04，本文对bash、vim、tmux配置的一些记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://talengu.github.io/public/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://talengu.github.io/public/tags/Ubuntu/"/>
    
      <category term="Bashrc" scheme="https://talengu.github.io/public/tags/Bashrc/"/>
    
      <category term="Vimrc" scheme="https://talengu.github.io/public/tags/Vimrc/"/>
    
      <category term="Tmux" scheme="https://talengu.github.io/public/tags/Tmux/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter notebook的配置</title>
    <link href="https://talengu.github.io/public/2017/07/03/linux/jupyter_notebook/"/>
    <id>https://talengu.github.io/public/2017/07/03/linux/jupyter_notebook/</id>
    <published>2017-07-03T16:00:04.000Z</published>
    <updated>2017-07-03T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>本文介绍jupyter notebook的安装配置过程和实用技巧。<a href="https://jupyter.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">jupyter.readthedocs教程</a></p><a id="more"></a><h2 id="1-安装与配置"><a class="header-anchor" href="#1-安装与配置">¶</a>1 安装与配置</h2><h3 id="1-1-安装-jupyter"><a class="header-anchor" href="#1-1-安装-jupyter">¶</a>1.1 安装 jupyter</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda install jupyter</span><br><span class="line"><span class="comment"># pip install jupyter -y</span></span><br></pre></td></tr></table></figure><h3 id="1-2-修改配置文件"><a class="header-anchor" href="#1-2-修改配置文件">¶</a>1.2 修改配置文件</h3><ul><li>生成配置文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br><span class="line">vim ~/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure><ul><li>修改配置文件内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c.NotebookApp.ip = <span class="string">'0.0.0.0'</span></span><br><span class="line">c.NotebookApp.port = <span class="number">8018</span></span><br><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">c.NotebookApp.password = <span class="string">u'sha1:bcd259ccf...your hashed password here'</span></span><br></pre></td></tr></table></figure><blockquote><p>Tip: 利用ipython 生成密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; In [1]: from IPython.lib import passwd</span><br><span class="line">&gt; In [2]: passwd()</span><br><span class="line">&gt;   Enter password:</span><br><span class="line">&gt;   Verify password:</span><br><span class="line">&gt;   Out[2]: &apos;sha1:67xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&apos;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>我选用的是password密码登陆jupyter的方案，其他的密码登陆方案见 <a href="https://zhuanlan.zhihu.com/p/23110830" target="_blank" rel="noopener">link</a></p><h3 id="1-3-安装插件管理"><a class="header-anchor" href="#1-3-安装插件管理">¶</a>1.3 安装插件管理</h3><p>jupyter_contrib_nbextensions 为 jupyter notebook 扩展插件管理器，下面简称nbextensions。</p><p>nbextensions的github <a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" target="_blank" rel="noopener">repo</a>nbextensions的教程<a href="https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/" target="_blank" rel="noopener">nbextensions_manual_readthedocs</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用conda安装</span></span><br><span class="line">conda install jupyter</span><br><span class="line">conda install -c conda-forge jupyter_contrib_nbextensions</span><br><span class="line"></span><br><span class="line"><span class="comment"># pip安装</span></span><br><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使能</span></span><br><span class="line">jupyter contrib nbextension install</span><br></pre></td></tr></table></figure><p>我启用的一些插件</p><table><thead><tr><th>plugins</th><th></th><th></th></tr></thead><tbody><tr><td>Table of Contents (2)</td><td></td><td></td></tr><tr><td>Freeze</td><td>比较好的一个插件，可以用来冻住cell</td><td></td></tr><tr><td>nbTranslate</td><td>这个插件利用Google翻译cell很好用</td><td><a href="https://github.com/jfbercher/jupyter_nbTranslate/blob/master/languages.js" target="_blank" rel="noopener">support languages</a></td></tr><tr><td>ExecuteTime</td><td>显示执行时间</td><td></td></tr><tr><td>Ruler</td><td>代码标尺</td><td></td></tr><tr><td>Autopep8</td><td>代码美化</td><td></td></tr><tr><td>Scratchpad</td><td>代码测试</td><td></td></tr></tbody></table><p>其他花样的配置</p><p><a href="https://zhuanlan.zhihu.com/p/74950682" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/74950682</a></p><h3 id="1-4-conda环境的设置"><a class="header-anchor" href="#1-4-conda环境的设置">¶</a>1.4 conda环境的设置</h3><p>jupyter使用Anaconda miniconda环境需要安装的组件。[conda repo][<a href="https://repo.anaconda.com" target="_blank" rel="noopener">https://repo.anaconda.com</a>]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建虚拟环境</span></span><br><span class="line">conda create -n env_name python=3.6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> conda虚拟核组件 切换kernel</span></span><br><span class="line">conda install nb_conda_kernels</span><br></pre></td></tr></table></figure><h3 id="1-5-解决界面中英文混杂"><a class="header-anchor" href="#1-5-解决界面中英文混杂">¶</a>1.5 解决界面中英文混杂</h3><img src="/public/2017/07/03/linux/jupyter_notebook/image-20200413125705473.png" alt="image-20200413125705473" style="zoom:50%;"><p>如图，jupyter 界面中中英文混杂，解决方法为将界面文字中文切换成英文。</p><p>原理：让jupyter就找不到他的中文配置文件夹。</p><p>找到notebook的汉化文件夹的路径，比如<code>~/miniconda3/lib/python3.6/site-packages/notebook/i18n/zh_CN</code>。将其重命名如加个下划线作为后缀<code>zh_CN_old</code>，重启jupyter就行了。</p><p>为了方便，我作了个脚本自动找<code>notebook/i18n/zh_CN</code>位置并改名此文件夹，如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> distutils.sysconfig <span class="keyword">import</span> get_python_lib</span><br><span class="line"><span class="comment"># 获取site-package包的位置</span></span><br><span class="line">path_zh=get_python_lib()+<span class="string">'/notebook/i18n/zh_CN'</span></span><br><span class="line">path_zh_old=get_python_lib()+<span class="string">'/notebook/i18n/zh_CN_old'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 notebook/i18n/zh_CN 改为 notebook/i18n/zh_CN_old</span></span><br><span class="line">shutil.move(path_zh,path_zh_old)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回中文</span></span><br><span class="line"><span class="comment"># shutil.move(path_zh_old,path_zh)</span></span><br></pre></td></tr></table></figure><p>重启jupyter就行了, 这样jupyter就找不到这个中文配置，返回中文改回去就行了<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><h2 id="2-使用的技巧"><a class="header-anchor" href="#2-使用的技巧">¶</a>2 使用的技巧</h2><h3 id="2-1-快捷键"><a class="header-anchor" href="#2-1-快捷键">¶</a>2.1 快捷键</h3><hr><table><thead><tr><th>在非激活状态即是蓝颜色的边框</th><th>内容</th></tr></thead><tbody><tr><td>A</td><td>insert cell above</td></tr><tr><td>B</td><td>insert cell below</td></tr><tr><td>H</td><td>查看帮助</td></tr><tr><td>⌃↩(ctrl + enter)</td><td>run selected cells</td></tr></tbody></table><h3 id="2-2-显示图片-视频-音频"><a class="header-anchor" href="#2-2-显示图片-视频-音频">¶</a>2.2 显示图片 视频 音频</h3><p>主要是画图、显示视频和音频的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图片</span></span><br><span class="line">%%HTML</span><br><span class="line">&lt;img src=<span class="string">"xxx.jpg"</span>  alt=<span class="string">"title"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频</span></span><br><span class="line">%%HTML</span><br><span class="line">&lt;video width=<span class="string">"330"</span> height=<span class="string">"150"</span> controls&gt;</span><br><span class="line">&lt;source src=<span class="string">"out_all.mp4"</span> type=<span class="string">"video/mp4"</span>&gt;</span><br><span class="line">&lt;/video&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语音</span></span><br><span class="line">%%HTML</span><br><span class="line">&lt;audio src=<span class="string">"out.wav"</span> controls=<span class="string">"controls"</span>&gt;</span><br><span class="line">Your browser does <span class="keyword">not</span> support the audio element.</span><br><span class="line">&lt;/audio&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># html t是html的字符串</span></span><br><span class="line"><span class="keyword">from</span> IPython.core.display <span class="keyword">import</span> HTML</span><br><span class="line">HTML(str(t))</span><br></pre></td></tr></table></figure><h3 id="2-3-其他技巧"><a class="header-anchor" href="#2-3-其他技巧">¶</a>2.3 其他技巧</h3><h4 id="修复视频文件"><a class="header-anchor" href="#修复视频文件">¶</a>修复视频文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix_use_ffmpeg</span><span class="params">(in_name, out_name,message=<span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(out_name):</span><br><span class="line">    os.remove(out_name)</span><br><span class="line">    cmd = <span class="string">'ffmpeg -i %s %s'</span> % (in_name, out_name)</span><br><span class="line">    log_lines = os.popen(cmd).readlines()</span><br><span class="line">    print(message,<span class="string">"ok"</span>)</span><br></pre></td></tr></table></figure><h4 id="加载自己的模块文件"><a class="header-anchor" href="#加载自己的模块文件">¶</a>加载自己的模块文件</h4><p>出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果你修改了你的模块，需要重启解释器；或者，如果你就是想交互式的测试这么一个模块，可以用 imp.reload() 重新加载，例如 <code>import imp; imp.reload(modulename)</code></p><h4 id="导出pdf支持中文"><a class="header-anchor" href="#导出pdf支持中文">¶</a>导出pdf支持中文</h4><p>Jupyter Notebook 输出PDF中文支持 <a href="https://www.jianshu.com/p/c3f660188766" target="_blank" rel="noopener">link</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/lib/python3.6/site-packages/nbconvert/templates/latex</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在里面的模版中添加，前提是安装好了texlive</span></span><br><span class="line">% add</span><br><span class="line">\usepackage&#123;ctex&#125;</span><br></pre></td></tr></table></figure><h4 id="ipynb2pdf"><a class="header-anchor" href="#ipynb2pdf">¶</a>ipynb2pdf</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Current version of Jupyter doesn't support pdf exporting when it comes to</span></span><br><span class="line"><span class="string">russian language in the document. To fix this, current script has born.</span></span><br><span class="line"><span class="string">It requires nbconvert as long as jupyter to be installed.</span></span><br><span class="line"><span class="string">Author:     Sergey Ivanychev</span></span><br><span class="line"><span class="string">Email:      sergeyivanychev@gmail.com</span></span><br><span class="line"><span class="string">Revision:   1</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">FORMAT = <span class="string">".ipynb"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">TODO:   What if user has ___o.tex in current folder?</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">TEMP_TEX = <span class="string">"___o.tex"</span></span><br><span class="line">TEMP_FOLDER = <span class="string">"/tmp"</span></span><br><span class="line">TRASH_EXTENSIONS = [<span class="string">".aux"</span>, <span class="string">".out"</span>, <span class="string">".log"</span>]</span><br><span class="line">OLD1 = <span class="string">r"\usepackage[utf8x]&#123;inputenc&#125;"</span></span><br><span class="line">NEW1 = <span class="string">r"""</span></span><br><span class="line"><span class="string">    \usepackage[utf8x]&#123;inputenc&#125;</span></span><br><span class="line"><span class="string">    \usepackage&#123;ctex&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">REPLACE = [(OLD1, NEW1)]</span><br><span class="line">HELP = <span class="string">"""</span></span><br><span class="line"><span class="string">This script is aimed at correctly converting .ipynb to .pdf files.</span></span><br><span class="line"><span class="string">You may use it via</span></span><br><span class="line"><span class="string"># ipynb2pdf Solution.ipynb</span></span><br><span class="line"><span class="string">To get .pdf in the same directory</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_args</span><span class="params">(argv)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> (len(argv) &gt; <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">"Please, type .ipynb filename as argument"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> (len(argv) == <span class="number">1</span>):</span><br><span class="line">        print(HELP)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    script, filename = argv</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_ipynb(filename):</span><br><span class="line">        print(<span class="string">"Please, type .ipynb filename as argument"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_extention</span><span class="params">(string, extention)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Removes argumented extention from the end of the string</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> extention[<span class="number">0</span>] != <span class="string">'.'</span>:</span><br><span class="line">        extention = <span class="string">"."</span> + extention</span><br><span class="line">    <span class="keyword">if</span> string.endswith(extention):</span><br><span class="line">        string = string[<span class="number">0</span>:-len(extention)]</span><br><span class="line">    <span class="keyword">return</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_ipynb</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> filename.endswith(<span class="string">".ipynb"</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tex2pdf</span><span class="params">(filename, desired_name)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Converts filename (which is tex document) to desired_name (which is pdf)</span></span><br><span class="line"><span class="string">    leaving no trash in current folder</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    base = remove_extention(filename, <span class="string">"tex"</span>)</span><br><span class="line">    output = base + <span class="string">".pdf"</span></span><br><span class="line">    ret = subprocess.call(<span class="string">"xelatex %s"</span> % filename , </span><br><span class="line">                                        shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">for</span> ext <span class="keyword">in</span> TRASH_EXTENSIONS:</span><br><span class="line">        os.unlink(base + ext)</span><br><span class="line">    os.rename(output, desired_name)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> check_args(argv) == <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    script, filename = argv</span><br><span class="line">    ret = subprocess.call(<span class="string">"jupyter nbconvert %s --to latex --output %s"</span> %</span><br><span class="line">                                            (filename, TEMP_TEX), shell=<span class="literal">True</span>,</span><br><span class="line">                                            stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>):</span><br><span class="line">        print(<span class="string">"ret = %d"</span> % ret)</span><br><span class="line">        os.unlink(TEMP_TEX)</span><br><span class="line">        print(<span class="string">"Converting to LaTeX failed. Return code: %d"</span> % ret)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    tex_file = open(TEMP_TEX, <span class="string">"r"</span>)</span><br><span class="line">    tex = tex_file.read()</span><br><span class="line">    <span class="keyword">for</span> old, new <span class="keyword">in</span> REPLACE:</span><br><span class="line">        tex = tex.replace(old, new)</span><br><span class="line">    tex_file.close()</span><br><span class="line">    os.unlink(TEMP_TEX)</span><br><span class="line">    tex_file = open(TEMP_TEX, <span class="string">"w+"</span>)</span><br><span class="line">    tex_file.write(tex)</span><br><span class="line">    tex_file.close()</span><br><span class="line">    ret = tex2pdf(TEMP_TEX, remove_extention(filename, <span class="string">".ipynb"</span>) + <span class="string">".pdf"</span>)</span><br><span class="line">    tex_file.close()</span><br><span class="line">    os.unlink(TEMP_TEX)</span><br><span class="line">    print(remove_extention(filename, <span class="string">".ipynb"</span>) + <span class="string">".pdf - DONE"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    exit(main(sys.argv))</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.zhihu.com/question/302814218/answer/1029684239" target="_blank" rel="noopener">https://www.zhihu.com/question/302814218/answer/1029684239</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;
本文介绍jupyter notebook的安装配置过程和实用技巧。
&lt;a href=&quot;https://jupyter.readthedocs.io/en/latest/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;jupyter.readthedocs教程&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="jupyter" scheme="https://talengu.github.io/public/categories/jupyter/"/>
    
    
      <category term="工具" scheme="https://talengu.github.io/public/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Python" scheme="https://talengu.github.io/public/tags/Python/"/>
    
      <category term="笔记应用" scheme="https://talengu.github.io/public/tags/%E7%AC%94%E8%AE%B0%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
</feed>
