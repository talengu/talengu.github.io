<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一塘</title>
  
  
  <link href="/public/atom.xml" rel="self"/>
  
  <link href="https://talengu.github.io/public/"/>
  <updated>2023-01-26T16:00:04.000Z</updated>
  <id>https://talengu.github.io/public/</id>
  
  <author>
    <name>一塘</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「202301月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2023/01/26/test/202301_obsidian/"/>
    <id>https://talengu.github.io/public/2023/01/26/test/202301_obsidian/</id>
    <published>2023-01-26T16:00:04.000Z</published>
    <updated>2023-01-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 0 📅 : 0 🔖 : 0</p><a id="more"></a><h2 id="✅-0"><a class="header-anchor" href="#✅-0">¶</a>✅ : 0</h2><h2 id="📅-0"><a class="header-anchor" href="#📅-0">¶</a>📅 : 0</h2><h2 id="🔖-0"><a class="header-anchor" href="#🔖-0">¶</a>🔖 : 0</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 0 📅 : 0 🔖 : 0&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>「202301月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2023/01/15/test/202301/"/>
    <id>https://talengu.github.io/public/2023/01/15/test/202301/</id>
    <published>2023-01-15T16:00:04.000Z</published>
    <updated>2023-01-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 3</p><a id="more"></a><h2 id="🔖跳进框框，你的-Markdown-链接可以更整洁"><a class="header-anchor" href="#🔖跳进框框，你的-Markdown-链接可以更整洁">¶</a>🔖<a href="https://sspai.com/post/77513" target="_blank" rel="noopener">跳进框框，你的 Markdown 链接可以更整洁</a></h2><p>pubdata:2022-12-29 03:30:14markdate:2023-01-03 01:17:10.436779</p><p><img src="/public/2023/01/15/test/202301/2023-01-03-011710436779.jpg" alt="img"></p><h2 id="🔖关于流感和疫苗，你需要知道哪些信息？"><a class="header-anchor" href="#🔖关于流感和疫苗，你需要知道哪些信息？">¶</a>🔖<a href="https://sspai.com/post/76945" target="_blank" rel="noopener">关于流感和疫苗，你需要知道哪些信息？</a></h2><p>pubdata:2022-11-23 06:38:28markdate:2023-01-03 13:52:56.586627</p><p><img src="/public/2023/01/15/test/202301/2023-01-03-135256586627.jpg" alt="img"></p><h2 id="🔖一日一技-两种方法让-Windows-10-也能运行-Android-应用"><a class="header-anchor" href="#🔖一日一技-两种方法让-Windows-10-也能运行-Android-应用">¶</a>🔖<a href="https://sspai.com/post/77582" target="_blank" rel="noopener">一日一技 | 两种方法让 Windows 10 也能运行 Android 应用</a></h2><p>pubdata:2023-01-03 06:30:00markdate:2023-01-04 10:20:53.166720</p><p><img src="/public/2023/01/15/test/202301/2023-01-04-102053166720.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 3&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>「202212月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/12/26/test/202212_obsidian/"/>
    <id>https://talengu.github.io/public/2022/12/26/test/202212_obsidian/</id>
    <published>2022-12-26T16:00:04.000Z</published>
    <updated>2022-12-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 1 📅 : 6 🔖 : 21</p><a id="more"></a><h2 id="✅-1"><a class="header-anchor" href="#✅-1">¶</a>✅ : 1</h2><p>✅ 🔖 <a href="https://www.zhihu.com/question/23564190/answer/2795830055?utm_id=0" target="_blank" rel="noopener">如何更深入地学习 Linux？ - michaelli 的回答 - 知乎</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W49.md">C日常/2022-W49.md</a></p><h2 id="📅-6"><a class="header-anchor" href="#📅-6">¶</a>📅 : 6</h2><p>📅 使用draw io和 cflow 生成函数调用图 单文件-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W50.md">C日常/2022-W50.md</a><br>📅 ios图像转存到本地-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W47.md">C日常/2022-W47.md</a><br>📅 学习智能家庭软件-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W47.md">C日常/2022-W47.md</a><br>📅 🔖 <a href="https://zhuanlan.zhihu.com/p/36279445?utm_id=0" target="_blank" rel="noopener">Vim 8 中 C/C++ 符号索引：GTags 篇</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W49.md">C日常/2022-W49.md</a><br>📅Vim中使用gtags-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W49.md">C日常/2022-W49.md</a><br>📅  <a href="https://blog.csdn.net/tian154731/article/details/113842348" target="_blank" rel="noopener">安卓手机抢茅台程序_JAVA学无止境的博客-CSDN博客</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W42.md">C日常/2022-W42.md</a></p><h2 id="🔖-21"><a class="header-anchor" href="#🔖-21">¶</a>🔖 : 21</h2><p>🔖 <a href="https://www.appinn.com/opensearcher/" target="_blank" rel="noopener">OpenSearcher - 开源的全文搜索工具：支持 Word、PPT、PDF，以及电子书 ePub、Mobi 等格式[Windows] - 小众软件</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W48.md">C日常/2022-W48.md</a><br>🔖 <a href="https://m.bilibili.com/video/av848443011" target="_blank" rel="noopener">【英雄联盟手游】装备属性及效果介绍-哔哩哔哩</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W43.md">C日常/2022-W43.md</a><br>🔖 电影 《走着瞧》马-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W43.md">C日常/2022-W43.md</a><br>🔖冰雪暴  -&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W43.md">C日常/2022-W43.md</a><br>🔖 <a href="https://blog.csdn.net/lyndon_li/article/details/122163468" target="_blank" rel="noopener">cflow——C语言函数调用关系生成器_Li-Yongjun的博客-CSDN博客_cflow</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W50.md">C日常/2022-W50.md</a><br>🔖 卡尔曼滤波https://www.zhihu.com/question/41823401/answer/2799679942-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W50.md">C日常/2022-W50.md</a><br>🔖 tmux vim剪切板-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W50.md">C日常/2022-W50.md</a><br>🔖 linux gdb Qemu调试-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W50.md">C日常/2022-W50.md</a><br>🔖 <a href="https://blog.csdn.net/jiangjun00000000/article/details/118277732" target="_blank" rel="noopener">如何在Debian10的Gnome桌面系统中安装并使能托盘图标_萌虎下山了的博客-CSDN博客_gnome 托盘</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W50.md">C日常/2022-W50.md</a><br>🔖 <a href="https://blog.csdn.net/allway2/article/details/122160151" target="_blank" rel="noopener">如何在 Debian 11 Bullseye Linux 上安装和配置 KVM_allway2的博客-CSDN博客_debian kvm</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W50.md">C日常/2022-W50.md</a><br>🔖 <a href="https://blog.csdn.net/u010330109/article/details/121855809" target="_blank" rel="noopener">Debian 11 gnome 桌面设置显示图标_远远看看山的博客-CSDN博客_debian显示桌面图表</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W50.md">C日常/2022-W50.md</a><br>🔖 <a href="https://github.com/mli/autocut" target="_blank" rel="noopener">AutoCut</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W47.md">C日常/2022-W47.md</a><br>🔖 <a href="https://sspai.com/post/76899" target="_blank" rel="noopener">找不到现成的字幕？Whisper 让不懂外语的你也能看懂日剧 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W47.md">C日常/2022-W47.md</a><br>🔖 canva平面设计-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W47.md">C日常/2022-W47.md</a><br>🔖 <a href="https://sspai.com/post/76922" target="_blank" rel="noopener">我们为什么需要 Matter：飞利浦 Hue 的跨平台联动探索记录 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W47.md">C日常/2022-W47.md</a><br>🔖 <a href="https://sspai.com/post/75567" target="_blank" rel="noopener">选对插件，让简悦也可以重器轻用 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W47.md">C日常/2022-W47.md</a><br>🔖 算法可视化-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W49.md">C日常/2022-W49.md</a><br>✅ 🔖 <a href="https://www.zhihu.com/question/23564190/answer/2795830055?utm_id=0" target="_blank" rel="noopener">如何更深入地学习 Linux？ - michaelli 的回答 - 知乎</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W49.md">C日常/2022-W49.md</a><br>📅 🔖 <a href="https://zhuanlan.zhihu.com/p/36279445?utm_id=0" target="_blank" rel="noopener">Vim 8 中 C/C++ 符号索引：GTags 篇</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W49.md">C日常/2022-W49.md</a><br>🔖<a href="https://www.1point3acres.com/bbs/thread-918311-1-1.html" target="_blank" rel="noopener">50岁码农面试记</a>（中文）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W42.md">C日常/2022-W42.md</a><br>🔖 <a href="https://github.com/FavioVazquez/ds-cheatsheets" target="_blank" rel="noopener">https://github.com/FavioVazquez/ds-cheatsheets</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W42.md">C日常/2022-W42.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 1 📅 : 6 🔖 : 21&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>rss翻译github脚本</title>
    <link href="https://talengu.github.io/public/2022/12/21/rss_translate/"/>
    <id>https://talengu.github.io/public/2022/12/21/rss_translate/</id>
    <published>2022-12-21T12:39:04.000Z</published>
    <updated>2022-12-21T12:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>自动翻译 rss，我利用github action开发了一下， 供大家玩乐。</p><p>比如将： <a href="http://www.mckinsey.com/insights/rss" target="_blank" rel="noopener">http://www.mckinsey.com/insights/rss</a> -&gt; <a href="https://talengu.github.io/rss-translate/rss/mckinsey_rss.xml">mckinsey_rss.xml</a> <img src="/public/2022/12/21/rss_translate/image-20230202020105514.png" alt></p><a id="more"></a><p>将需要翻译的rss 连接放到 <a href="https://github.com/talengu/rss-translate/edit/main/test.ini" target="_blank" rel="noopener">test.ini</a> 配置 ，并提交。</p><p><img src="/public/2022/12/21/rss_translate/image-20230202020439917.png" alt></p><ul><li>name：输出的xml名字</li><li>url：需要转换的url</li><li>max：输出xml 最大item数</li><li>action：设置语言转换，默认auto转中文。多语言支持 action = “auto”，这里可以换成多种语言，支持语言列表见 <a href="https://pygtrans.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">pygtrans</a> 如：action = &quot;en-&gt;zh-CN&quot;</li></ul><p>在 <a href="https://talengu.github.io/rss-translate/">https://talengu.github.io/rss-translate/</a> 等待生成连接即可。</p><p><img src="/public/2022/12/21/rss_translate/image-20230202020620284.png" alt></p><p>注：</p><ul><li>需要github账号，修改配置文件。</li><li>更新周期为1天，且为随机时间点。通过github action实现，见 <a href="https://github.com/talengu/rss-translate/blob/main/.github/cron_random.py" target="_blank" rel="noopener">random.py</a></li><li>多语言支持 action = “auto”，这里可以换成多种语言，支持语言列表见 <a href="https://pygtrans.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">pygtrans</a> 如：action = &quot;en-&gt;zh-CN&quot;</li></ul><p>欢迎大家使用！！！🐱</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;自动翻译 rss，我利用github action开发了一下， 供大家玩乐。&lt;/p&gt;
&lt;p&gt;比如将：
 &lt;a href=&quot;http://www.mckinsey.com/insights/rss&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.mckinsey.com/insights/rss&lt;/a&gt; -&amp;gt; &lt;a href=&quot;https://talengu.github.io/rss-translate/rss/mckinsey_rss.xml&quot;&gt;mckinsey_rss.xml&lt;/a&gt;
 
&lt;img src=&quot;/public/2022/12/21/rss_translate/image-20230202020105514.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="信息收集" scheme="https://talengu.github.io/public/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="工具" scheme="https://talengu.github.io/public/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="rss" scheme="https://talengu.github.io/public/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>「202212月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/12/15/test/202212/"/>
    <id>https://talengu.github.io/public/2022/12/15/test/202212/</id>
    <published>2022-12-15T16:00:04.000Z</published>
    <updated>2022-12-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 7</p><a id="more"></a><h2 id="🔖TextLocator-–-卖萌的小老头：低-CPU-占用的本地文档全文搜索工具-Win"><a class="header-anchor" href="#🔖TextLocator-–-卖萌的小老头：低-CPU-占用的本地文档全文搜索工具-Win">¶</a>🔖<a href="https://www.appinn.com/textlocator/" target="_blank" rel="noopener">TextLocator – 卖萌的小老头：低 CPU 占用的本地文档全文搜索工具[Win]</a></h2><p>pubdata:2022-11-30 08:25:46markdate:2022-12-04 02:42:46.065650</p><p><img src="/public/2022/12/15/test/202212/2022-12-04-024246065650.jpg" alt="img"></p><h2 id="🔖OpenSearcher-–-开源的全文搜索工具：支持-Word、PPT、PDF，以及电子书-ePub、Mobi-等格式-Windows"><a class="header-anchor" href="#🔖OpenSearcher-–-开源的全文搜索工具：支持-Word、PPT、PDF，以及电子书-ePub、Mobi-等格式-Windows">¶</a>🔖<a href="https://www.appinn.com/opensearcher/" target="_blank" rel="noopener">OpenSearcher – 开源的全文搜索工具：支持 Word、PPT、PDF，以及电子书 ePub、Mobi 等格式[Windows]</a></h2><p>pubdata:2022-12-01 07:31:17markdate:2022-12-04 02:42:48.883434</p><p><img src="/public/2022/12/15/test/202212/2022-12-04-024248883434.jpg" alt="img"></p><h2 id="🔖App-1-入门-Android-自动化，它比-Tasker-更好上手：MacroDroid"><a class="header-anchor" href="#🔖App-1-入门-Android-自动化，它比-Tasker-更好上手：MacroDroid">¶</a>🔖<a href="https://sspai.com/post/77077" target="_blank" rel="noopener">App+1 | 入门 Android 自动化，它比 Tasker 更好上手：MacroDroid</a></h2><p>pubdata:2022-12-02 06:30:00markdate:2022-12-04 04:03:56.824102</p><p><img src="/public/2022/12/15/test/202212/2022-12-04-040356824102.jpg" alt="img"></p><h2 id="🔖为纸质书籍进行数字备份：如何制作一本功能完备的-PDF-电子书"><a class="header-anchor" href="#🔖为纸质书籍进行数字备份：如何制作一本功能完备的-PDF-电子书">¶</a>🔖<a href="https://sspai.com/post/77118" target="_blank" rel="noopener">为纸质书籍进行数字备份：如何制作一本功能完备的 PDF 电子书</a></h2><p>pubdata:2022-12-06 06:34:06markdate:2022-12-08 13:52:36.058996</p><p><img src="/public/2022/12/15/test/202212/2022-12-08-135236058996.jpg" alt="img"></p><h2 id="🔖找笔记方便、写作又给力的知识库，我是这么搭建出来的"><a class="header-anchor" href="#🔖找笔记方便、写作又给力的知识库，我是这么搭建出来的">¶</a>🔖<a href="https://sspai.com/post/77144" target="_blank" rel="noopener">找笔记方便、写作又给力的知识库，我是这么搭建出来的</a></h2><p>pubdata:2022-12-09 06:32:24markdate:2022-12-12 05:12:48.101671</p><p><img src="/public/2022/12/15/test/202212/2022-12-12-051248101671.jpg" alt="img"></p><h2 id="🔖如何满足小众的录屏需求？自己配置-FFmpeg-解决问题"><a class="header-anchor" href="#🔖如何满足小众的录屏需求？自己配置-FFmpeg-解决问题">¶</a>🔖<a href="https://sspai.com/post/76637" target="_blank" rel="noopener">如何满足小众的录屏需求？自己配置 FFmpeg 解决问题</a></h2><p>pubdata:2022-11-05 03:00:00markdate:2022-12-24 03:02:42.639305</p><p><img src="/public/2022/12/15/test/202212/2022-12-24-030242639305.jpg" alt="img"></p><h2 id="🔖家用NAS推荐买什么价位的？"><a class="header-anchor" href="#🔖家用NAS推荐买什么价位的？">¶</a>🔖<a href="http://www.zhihu.com/question/566650643/answer/2809190517?utm_campaign=rss&amp;utm_medium=rss&amp;utm_source=rss&amp;utm_content=title" target="_blank" rel="noopener">家用NAS推荐买什么价位的？</a></h2><p>pubdata:2022-12-21 09:26:21markdate:2022-12-25 03:49:49.009390</p><p><img src="/public/2022/12/15/test/202212/2022-12-25-034949009390.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 7&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>c结构体对齐</title>
    <link href="https://talengu.github.io/public/2022/12/15/c_struct/"/>
    <id>https://talengu.github.io/public/2022/12/15/c_struct/</id>
    <published>2022-12-15T12:00:00.000Z</published>
    <updated>2022-12-15T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>c语言的字节对齐，机器的大小段模式的理解。</p><p>计算机存储的基础知识。</p><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;TM;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hp</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b;</span><br><span class="line">TM *t;</span><br><span class="line"><span class="keyword">unsigned</span> short c;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> d;</span><br><span class="line">&#125;HP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HP hp=&#123;</span><br><span class="line">.a=<span class="number">0xa1</span>,</span><br><span class="line">.b=<span class="number">0xb1</span>,</span><br><span class="line">.c=<span class="number">0xc1c2</span>,</span><br><span class="line">.d=<span class="number">0x1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *p=&amp;hp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sizeof(HP) = %lu\n"</span>,<span class="keyword">sizeof</span>(HP) );</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(HP); ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02x "</span>,p[i] );</span><br><span class="line"><span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">8</span>==<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> d=hp.d;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,d);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//OUT</span><br><span class="line">|| sizeof(HP) = 32</span><br><span class="line">|| a1 b1 00 00 00 00 00 00 </span><br><span class="line">|| 00 00 00 00 00 00 00 00 </span><br><span class="line">|| c2 c1 00 00 00 00 00 00 </span><br><span class="line">|| 01 00 00 00 00 00 00 00 </span><br><span class="line">|| 1</span><br></pre></td></tr></table></figure><h2 id="存储方式"><a class="header-anchor" href="#存储方式">¶</a>存储方式</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HP hp=&#123;</span><br><span class="line">.a=<span class="number">0xa1</span>,</span><br><span class="line">.b=<span class="number">0xb1</span>,</span><br><span class="line">.c=<span class="number">0xc1c2</span>,</span><br><span class="line">.d=<span class="number">0xd1d2d3d4</span>,<span class="comment">//&lt;-0x1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//OUT</span><br><span class="line">|| sizeof(HP) = 32</span><br><span class="line">|| a1 b1 00 00 00 00 00 00 </span><br><span class="line">|| 00 00 00 00 00 00 00 00 </span><br><span class="line">|| c2 c1 00 00 00 00 00 00 </span><br><span class="line">|| d4 d3 d2 d1 00 00 00 00 </span><br><span class="line">|| 3520254932</span><br></pre></td></tr></table></figure><h2 id="字节对齐"><a class="header-anchor" href="#字节对齐">¶</a>字节对齐</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 d 改为 d:1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hp</span>&#123;</span></span><br><span class="line"><span class="keyword">char</span> a;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> b;</span><br><span class="line">TM *t;</span><br><span class="line"><span class="keyword">unsigned</span> short c;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> d:<span class="number">1</span>; <span class="comment">//&lt;--- unsigned long d;</span></span><br><span class="line">&#125;HP;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//OUT</span><br><span class="line">|| 1 warning generated.</span><br><span class="line">|| sizeof(HP) = 24</span><br><span class="line">|| a1 b1 00 00 00 00 00 00 </span><br><span class="line">|| 00 00 00 00 00 00 00 00 </span><br><span class="line">|| c2 c1 01 00 00 00 00 00 </span><br><span class="line">|| 1</span><br></pre></td></tr></table></figure><p>少占用了一个8字节。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;c语言的字节对齐，机器的大小段模式的理解。&lt;/p&gt;
&lt;p&gt;计算机存储的基础知识。&lt;/p&gt;
    
    </summary>
    
      <category term="c语言" scheme="https://talengu.github.io/public/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://talengu.github.io/public/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>「转」Linux 内核精通</title>
    <link href="https://talengu.github.io/public/2022/12/15/%E7%AE%80%E6%82%A6%E5%90%8C%E6%AD%A5md/%E8%82%9D%E4%B8%8B%2050%20%E4%B8%87%E5%AD%97%E7%9A%84%E3%80%8ALinux%20%E5%86%85%E6%A0%B8%E7%B2%BE%E9%80%9A%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%8C%E4%BD%A0%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%B0%B4%E5%B9%B3%E5%B0%86%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%AD%94%E3%80%90%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F%E3%80%91/"/>
    <id>https://talengu.github.io/public/2022/12/15/简悦同步md/肝下 50 万字的《Linux 内核精通》笔记，你的底层原理水平将从入门到入魔【建议收藏】/</id>
    <published>2022-12-15T12:00:00.000Z</published>
    <updated>2022-12-15T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://zhuanlan.zhihu.com/p/572266986" target="_blank" rel="noopener">zhuanlan.zhihu.com</a></p></blockquote><h2 id="一、为什么要学习-Linux-内核"><a class="header-anchor" href="#一、为什么要学习-Linux-内核">¶</a>一、为什么要学习 Linux 内核</h2><a id="more"></a><p>大部分程序员可能永远没有机会开发 Linux 内核或者驱动 Linux，那么我们为什么还需要学习 Linux 内核呢？Linux 的源代码和架构都是开放的，我们可以学到很多操作系统的概念和实现原理。Linux 的设计哲学体系继承了 UNIX，现在整个设计体系相当稳定和简化，这是大部分服务器使用 Linux 的重要原因。</p><p><strong>那学习 Linux 内核的原因就在于此。</strong></p><p>进一步了解内核的原理，有助于你更好地使用命令和程序设计，让你的面试和开发更上一层楼。但是不建议直接看源代码，因为 Linux 代码太大，容易丢失。</p><p>而最好的办法是，先了解一下 Linux 内核机制，知道基本的原理与流程。</p><p>不过，Linux 内核机制也非常复杂，而且其中互相关联。</p><p><img src="https://pic1.zhimg.com/v2-f34e4013f744ab349c160d1b3564f68c_r.jpg" alt></p><p>比如说，进程运行要分配内存，内存映射涉及文件的关联，文件的读写需要经过块设备，从文件中加载代码才能运行起来进程。这些知识点要反复对照，才能理清。</p><p><strong>但是一旦攻克！你会发现 Linux 这个复杂的系统开始透明起来。</strong></p><h2 id="二、如何学习-Linux-内核？"><a class="header-anchor" href="#二、如何学习-Linux-内核？">¶</a>二、如何学习 Linux 内核？</h2><p>内核的知识就像下面的绳结一样，一环扣一环，我们要解开它们，就必须要先找到线头也就是内核中的函数接口。初学阶段，我们一般不深入的研究内核代码，会使用内核的接口函数就不错了。</p><p>下面提供了如何学习这些内核函数的方法，就像解绳子一样</p><p><strong>在我们学习 Linux 内核之前，我们首先需要掌握以下几点：</strong></p><p><a href="https://zhuanlan.zhihu.com/p/440423464" target="_blank" rel="noopener">(1) 如何学习内核，先了解 Linux 内核由哪些组成？</a></p><p><a href="https://zhuanlan.zhihu.com/p/440423464" target="_blank" rel="noopener">(2) 须知 Linux 内核源码（下载的链接 ）组织结构？</a></p><p>(3) <a href="https://zhuanlan.zhihu.com/p/440423464" target="_blank" rel="noopener">重点需要学习地知识点有哪些？</a></p><p>(4) <a href="https://link.zhihu.com/?target=https%3A//docs.qq.com/doc/DTXFKZlZ4YmFYQWZS" target="_blank" rel="noopener">最后依据我为大家提供的的学习资料，开启我们的 Linux 内核学习之旅。</a></p><p><a href="https://zhuanlan.zhihu.com/p/437667448" target="_blank" rel="noopener">(5) 全网最牛 Linux 内核 Makefile 系统文件详解 (纯文字代码)</a></p><p><a href="https://zhuanlan.zhihu.com/p/436340295" target="_blank" rel="noopener">(6) 全网最详细的 Intel CPU 体系结构分析 (内核源码)</a></p><p><a href="https://zhuanlan.zhihu.com/p/438248184" target="_blank" rel="noopener">(7) 深入理解 Linux Kernel 内核整体架构 (图文详解)</a></p><p><a href="https://zhuanlan.zhihu.com/p/499637419" target="_blank" rel="noopener">(8)QEMU 调试 Linux 内核环境搭建</a></p><p><a href="https://zhuanlan.zhihu.com/p/469270699" target="_blank" rel="noopener">(9) 网友说 Linux 驱动讲不彻底，原来这才是 Linux 驱动</a></p><p><a href="https://zhuanlan.zhihu.com/p/419643250" target="_blank" rel="noopener">(10) 一文让你深度了解 Linux 内核架构和工作原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/477292559" target="_blank" rel="noopener">(11) 从 Linux 内核看 socket 底层的本质 (IO)</a></p><p><a href="https://zhuanlan.zhihu.com/p/458996875" target="_blank" rel="noopener">(12)Linux 用户空间与内核空间通信 (Netlink 通信机制)</a></p><h2 id="二，学习资料"><a class="header-anchor" href="#二，学习资料">¶</a>二，学习资料</h2><h3 id="2-1-操作系统原理"><a class="header-anchor" href="#2-1-操作系统原理">¶</a><strong>2.1 操作系统原理</strong></h3><p>【 强烈推荐阅读】<a href="https://zhuanlan.zhihu.com/p/442771856" target="_blank" rel="noopener">一文带你彻底了解，零拷贝 Zero-Copy 技术 (图解)</a></p><p><a href="https://zhuanlan.zhihu.com/p/440820446" target="_blank" rel="noopener">Linux 操作系统学习——启动</a></p><p><a href="https://zhuanlan.zhihu.com/p/440825051" target="_blank" rel="noopener">Linux 操作系统学习——内核运行</a></p><p><a href="https://zhuanlan.zhihu.com/p/440829030" target="_blank" rel="noopener">Linux 操作系统学习——内核初始化</a></p><p><a href="https://zhuanlan.zhihu.com/p/446635858" target="_blank" rel="noopener">操作系统原理 (一)：操作系统原理与概述 (流程图)</a></p><p><a href="https://zhuanlan.zhihu.com/p/434528439" target="_blank" rel="noopener">操作系统原理 (二)：Linux 操作系统基础的常用命令</a></p><p><a href="https://zhuanlan.zhihu.com/p/434511399" target="_blank" rel="noopener">操作系统原理 (三)：Linux 操作系统 I/O 机制原理 (流程图详解)</a></p><p><a href="https://zhuanlan.zhihu.com/p/448266123" target="_blank" rel="noopener">操作系统原理 (四)：内存管理 RAID 磁盘阵列与配置</a></p><p><a href="https://zhuanlan.zhihu.com/p/448258669" target="_blank" rel="noopener">操作系统原理 (五)：内存管理之磁盘高速缓存机制原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/448147542" target="_blank" rel="noopener">操作系统原理 (六)：存储管理之页式、段式、段页式存储</a></p><p><a href="https://zhuanlan.zhihu.com/p/447668827" target="_blank" rel="noopener">系统操作原理 (七)：进程的状态和转换 (五态模型)</a></p><p><a href="https://zhuanlan.zhihu.com/p/447720544" target="_blank" rel="noopener">操作系统原理 (八)：进程同步的几种方式及基本原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/447737355" target="_blank" rel="noopener">操作系统原理 (九)：处理器调度基本准则和实现原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/448105261" target="_blank" rel="noopener">系统操作原理 (十)：多进程，多线程，并发执行中的死锁问题</a></p><p><a href="https://zhuanlan.zhihu.com/p/447720544" target="_blank" rel="noopener">系统操作原理 (十一)：操作系统原理：进程同步的几种方式及基本原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/448147542" target="_blank" rel="noopener">系统操作原理 (十二)：趣谈操作系统原理，存储管理之页式、段式、段页式存储</a></p><p><a href="https://zhuanlan.zhihu.com/p/452839400" target="_blank" rel="noopener">系统操作原理 (十三)：操作系统：通过实战理解 CPU 上下文切换</a></p><p><a href="https://zhuanlan.zhihu.com/p/449157752" target="_blank" rel="noopener">汇编语言基础 (十一)：汇编语言基础知识 (图文代码)</a></p><p><a href="https://zhuanlan.zhihu.com/p/449787476" target="_blank" rel="noopener">汇编语言入门 (十二)：汇编指令入门级整理，这些你必须要知道</a></p><p><a href="https://zhuanlan.zhihu.com/p/449565154" target="_blank" rel="noopener">汇编语言指令 (十三)：汇编语言的所有指令总结，一篇就够了</a></p><p><a href="https://zhuanlan.zhihu.com/p/449582466" target="_blank" rel="noopener">汇编语言进阶 (十四)：ARM 体系结构处理器机制原理与实现</a></p><p><a href="https://zhuanlan.zhihu.com/p/449816076" target="_blank" rel="noopener">汇编语言进阶 (十五)： ARM 指令集与汇编语言程序设计</a></p><h3 id="2-2-内存管理专题"><a class="header-anchor" href="#2-2-内存管理专题">¶</a><strong>2.2 内存管理专题</strong></h3><p>【 强烈推荐阅读】<a href="https://zhuanlan.zhihu.com/p/442268413" target="_blank" rel="noopener">尽情阅读，技术进阶，详解 mmap 原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/429118261" target="_blank" rel="noopener">内存是什么？一文让你了解内存是怎么实现的</a></p><p><a href="https://zhuanlan.zhihu.com/p/449071725" target="_blank" rel="noopener">嵌入式开发必备技能，Linux 内核源码组织结构</a></p><p><a href="https://zhuanlan.zhihu.com/p/442258814" target="_blank" rel="noopener">一文了解 Linux 内存管理，malloc、free 实现原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/456064945" target="_blank" rel="noopener">内存管理系列 (一)：Linux 操作系统内存管理 (思维导图详解)</a></p><p><a href="https://zhuanlan.zhihu.com/p/454577271" target="_blank" rel="noopener">内存管理系列 (二)：Linux 内存管理原理知识大总结</a></p><p><a href="https://zhuanlan.zhihu.com/p/454779105" target="_blank" rel="noopener">内存管理系列 (三)：学完操作系统内存管理，能回答这 8 个问题吗？</a></p><p><a href="https://zhuanlan.zhihu.com/p/454564295" target="_blank" rel="noopener">内存管理系列 (四)：理解 Memory barrier（内存屏障）</a></p><p><a href="https://zhuanlan.zhihu.com/p/453390459" target="_blank" rel="noopener">内存管理系列 (五)：内存回收之 LRU 链表机制原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/453385879" target="_blank" rel="noopener">内存管理系列 (六)：虚拟内存和物理内存机制原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/452713026" target="_blank" rel="noopener">内存管理系列 (七)：Malloc 缺页中断不同情况处理总结及反向映射 RMAP</a></p><p><a href="https://zhuanlan.zhihu.com/p/452686042" target="_blank" rel="noopener">内存管理系列 (八)：C/C++ 开发中的 Malloc 函数的实现原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/452423278" target="_blank" rel="noopener">内存管理系列 (九)：深入理解 glibc malloc：内存分配器实现原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/452415871" target="_blank" rel="noopener">内存管理系列 (十)：操作系统是如何对内存进行管理的，内存与 CPU 之间的关系</a></p><p><a href="https://zhuanlan.zhihu.com/p/451886800" target="_blank" rel="noopener">内存管理系列 (十一)：为什么 Linux 需要虚拟内存，虚拟内存对操作系统有哪些作用</a></p><p><a href="https://zhuanlan.zhihu.com/p/451881734" target="_blank" rel="noopener">内存管理系列 (十二)：用户态内存内存映射函数 Mmap 的好处</a></p><p><a href="https://zhuanlan.zhihu.com/p/451469447" target="_blank" rel="noopener">内存管理系列 (十三)：内存管理：详解虚拟地址空间 - MMU</a></p><p><a href="https://zhuanlan.zhihu.com/p/451468637" target="_blank" rel="noopener">内存管理系列 (十四)：C 语言中的 Malloc/free 是如何分配内存的</a></p><p><a href="https://zhuanlan.zhihu.com/p/451467641" target="_blank" rel="noopener">内存管理系列 (十五)：从虚拟寻址到开源项目，Linux 下的内存管理详解</a></p><p><a href="https://zhuanlan.zhihu.com/p/451405962" target="_blank" rel="noopener">内存管理系列 (十六)：一文带你了解，虚拟内存、内存分页、分段、段页式内存管理</a></p><p><a href="https://zhuanlan.zhihu.com/p/441938447" target="_blank" rel="noopener">内存管理系列 (十七)：Linux 应用程序究竟消耗了多少内存</a></p><p><a href="https://zhuanlan.zhihu.com/p/441918912" target="_blank" rel="noopener">内存管理系列 (十八)：虚拟地址到物理地址，是什么时候开始映射</a></p><p><a href="https://zhuanlan.zhihu.com/p/431277793" target="_blank" rel="noopener">内存管理系列 (十九)：浅析 Linux 内存管理中 SLAB 分配器 (源码分析)</a></p><p><a href="https://zhuanlan.zhihu.com/p/430233534" target="_blank" rel="noopener">内存管理系列 (二十)：基于 Linux 内存管理的内存分配 (伙伴算法和 slab 算法)</a></p><p><a href="https://zhuanlan.zhihu.com/p/429987335" target="_blank" rel="noopener">内存管理系列 (二十一)：探索内存原理的内存映射文件 (图文详解)</a></p><p><a href="https://zhuanlan.zhihu.com/p/483332995" target="_blank" rel="noopener">内存管理系列 (二十二)：吊打字节面试官，CPU 缓存一致性协议 MESI</a></p><p><a href="https://zhuanlan.zhihu.com/p/458935522" target="_blank" rel="noopener">内存管理系列 (二十三)：深入理解 Linux 内核页表映射分页机制原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/474795662" target="_blank" rel="noopener">内存管理系列 (二十四)：谈谈物理内存与虚拟内存之间的映射 (超详细~)</a></p><p><a href="https://zhuanlan.zhihu.com/p/452686042" target="_blank" rel="noopener">内存管理系列 (二十五)：内存管理：C/C++ 开发中的 malloc 函数的实现原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/482776355" target="_blank" rel="noopener">内存管理系列 (二十六)：熬夜肝翻 Linux 内存管理所有知识点 (图解)</a></p><h3 id="2-3-进程管理专题"><a class="header-anchor" href="#2-3-进程管理专题">¶</a>2.3 进程管理专题</h3><p><a href="https://zhuanlan.zhihu.com/p/425886322" target="_blank" rel="noopener">进程管理系列 (一)：Linux 进程管理原理详解 (代码演示)</a></p><p><a href="https://zhuanlan.zhihu.com/p/425931602" target="_blank" rel="noopener">进程管理系列 (二)：十分钟让你像大佬一样快速了解进程状态 (二种模型)</a></p><p><a href="https://zhuanlan.zhihu.com/p/425939661" target="_blank" rel="noopener">进程管理系列 (三)：作为互联网程序员，应该了解 Linux 进程六种状态吗？</a></p><p><a href="https://zhuanlan.zhihu.com/p/426836494" target="_blank" rel="noopener">进程管理系列 (四)：五分钟让你快速了解 Linux 进程管理实时调度与 SMP</a></p><p><a href="https://zhuanlan.zhihu.com/p/426399519" target="_blank" rel="noopener">进程管理系列 (六)：浅析 Linux 的进程优先级 (代码演示)</a></p><p><a href="https://zhuanlan.zhihu.com/p/441558619" target="_blank" rel="noopener">进程管理系列 (七)：进程管理 | 浅析 C 语言中并发同步与原子操作，锁三者是什么关系</a></p><p><a href="https://zhuanlan.zhihu.com/p/441346358" target="_blank" rel="noopener">进程管理系列 (八)：进程管理 | 深入理解 Linux 进程述符和进程状态</a></p><p><a href="https://zhuanlan.zhihu.com/p/442921692" target="_blank" rel="noopener">进程管理系列 (九)：一文读懂 Linux 内核中的任务间调度策略</a></p><p><a href="https://zhuanlan.zhihu.com/p/442916346" target="_blank" rel="noopener">进程管理系列 (十)：Linux 内核之进程和线程的创建和派生</a></p><p><a href="https://zhuanlan.zhihu.com/p/442905446" target="_blank" rel="noopener">进程管理系列 (十一)：基于 Linux 有几种进程状态</a></p><p><a href="https://zhuanlan.zhihu.com/p/455680633" target="_blank" rel="noopener">进程管理系列 (十二)：操作系统的几种 CPU 调度策略</a></p><p><a href="https://zhuanlan.zhihu.com/p/462066025" target="_blank" rel="noopener">进程管理系列 (十二)：Linux 进程管理之调度和进程切换</a></p><p><a href="https://zhuanlan.zhihu.com/p/465574868" target="_blank" rel="noopener">进程管理系列 (十三)：一文搞懂六大进程通信机制原理 (全网最详细)</a></p><p><a href="https://zhuanlan.zhihu.com/p/456631465" target="_blank" rel="noopener">进程管理系列 (十四)：超详细的 Socket 通信原理和实例讲解 (白嫖走起~)</a></p><p><a href="https://zhuanlan.zhihu.com/p/473639031" target="_blank" rel="noopener">进程管理系列 (十五)：这是一份很全很全的 IO 基础知识与概念</a></p><p><a href="https://zhuanlan.zhihu.com/p/472955572" target="_blank" rel="noopener">进程管理系列 (十六)：深入理解 Linux 内核进程的管理与调度 (全知乎最详细)</a></p><h3 id="2-4-网络协议栈专题"><a class="header-anchor" href="#2-4-网络协议栈专题">¶</a><strong>2.4 网络协议栈专题</strong></h3><p>【 强烈推荐阅读】<a href="https://zhuanlan.zhihu.com/p/449869444" target="_blank" rel="noopener">嵌入式必备：如何学习 Linux 内核网络协议栈</a></p><p><a href="https://zhuanlan.zhihu.com/p/460693504" target="_blank" rel="noopener">趣谈网络协议栈 (一)：套接字缓冲区原理</a></p><p><a href="https://zhuanlan.zhihu.com/p/458188649" target="_blank" rel="noopener">趣谈网络协议栈 (二)：数据包是如何处理的过程</a></p><p><a href="https://zhuanlan.zhihu.com/p/453813447" target="_blank" rel="noopener">趣谈网络协议栈 (三)：七层模型下三层数据通信</a></p><p><a href="https://zhuanlan.zhihu.com/p/453814298" target="_blank" rel="noopener">趣谈网络协议栈 (四)：传输的 Arp 报文结构</a></p><p><a href="https://zhuanlan.zhihu.com/p/453814919" target="_blank" rel="noopener">趣谈网络协议栈 (五)：Socket 编程常用函数的原理及代码实现</a></p><p><a href="https://zhuanlan.zhihu.com/p/453815877" target="_blank" rel="noopener">趣谈网络协议栈 (六)：学习 select 和 poll 函数的内核实现</a></p><p><a href="https://zhuanlan.zhihu.com/p/453816689" target="_blank" rel="noopener">趣谈网络协议栈 (七)：Epoll 从用户态到内核态过程分析</a></p><p><a href="https://zhuanlan.zhihu.com/p/444071187" target="_blank" rel="noopener">趣谈网络协议栈 (八)：套接字发送网络数据的过程</a></p><h3 id="2-5-设备驱动专题"><a class="header-anchor" href="#2-5-设备驱动专题">¶</a>2.5 设备驱动专题</h3><p><a href="https://zhuanlan.zhihu.com/p/448718574" target="_blank" rel="noopener">浅谈设备驱动 (一)：操作系统 I/O 流程详解</a></p><p><a href="https://zhuanlan.zhihu.com/p/445188798" target="_blank" rel="noopener">浅谈设备驱动 (二)：Linux 操作系统学习之字符设备</a></p><p><a href="https://zhuanlan.zhihu.com/p/445185233" target="_blank" rel="noopener">浅谈设备驱动 (三)：结合设备信息集合，探究设备和驱动是如何绑定的</a></p><h3 id="2-6-文件系统"><a class="header-anchor" href="#2-6-文件系统">¶</a>2.6 文件系统</h3><p><a href="https://zhuanlan.zhihu.com/p/460393575" target="_blank" rel="noopener">详谈文件系统 (一)：一文让你彻底了解 Linux 内核文件系统 (大总结)</a></p><h3 id="2-7-面试题-经验"><a class="header-anchor" href="#2-7-面试题-经验">¶</a>2.7 面试题 / 经验</h3><p>【 强烈推荐阅读】<a href="https://zhuanlan.zhihu.com/p/458546929" target="_blank" rel="noopener">从事十年嵌入式转内核开发 (23K 到 45K), 给兄弟们的一些建议</a></p><p><a href="https://zhuanlan.zhihu.com/p/456073398" target="_blank" rel="noopener">谈谈 Linux 内核的学习路线，具体要怎么学？</a></p><p><a href="https://zhuanlan.zhihu.com/p/453576978" target="_blank" rel="noopener">2022 年嵌入式开发想进互联网大厂，你技术过硬吗？</a></p><p><a href="https://zhuanlan.zhihu.com/p/452972023" target="_blank" rel="noopener">嵌入式 Linux 内核学习经验总结，一篇让你掌握方法</a></p><p><a href="https://zhuanlan.zhihu.com/p/445363696" target="_blank" rel="noopener">盘点 Linux 内核 (驱动开发，嵌入式，内核人群) 必问的面试题</a></p><p><a href="https://zhuanlan.zhihu.com/p/470952847" target="_blank" rel="noopener">2022 春招大厂 - 嵌入式开发经典笔试面试题目大整理</a></p><h3 id="2-8-内核书籍"><a class="header-anchor" href="#2-8-内核书籍">¶</a>2.8 内核书籍</h3><ul><li>《深入了解 Linux 内核》</li><li>《Linux 就该这么学》</li><li>《Linux 内核完全注释 V3.0 书签版》</li><li>《Linux 命令行大全 - 绍茨 (william E.shotts)》</li><li>《Linux 命令速查手册》</li><li>《Linux 性能优化大师》</li><li>《Linux 环境编程：从应用到内核》</li><li>《Linux 集群和自动化运维 余洪春》</li><li>《Linux 驱动程序开发实例 (第 2 版)》</li><li>《Linux 高级程序设计 (第 3 版)》</li><li>《构建高可用 Linux 服务器 (第 4 版)》</li></ul><p><strong>书籍免费领取地址：</strong><a href="https://link.zhihu.com/?target=https%3A//docs.qq.com/doc/DTkZRWXRFcWx1bWVx" target="_blank" rel="noopener">https://docs.qq.com/doc/DTkZRWXRFcWx1bWVx</a></p><h2 id="三，内核学习路线"><a class="header-anchor" href="#三，内核学习路线">¶</a>三，内核学习路线</h2><p>很多同学对 Linux 接触很少，对 Linux 平台的开发一无所知。现在，趋势越来越表明，作为一个优秀的软件开发者或者计算机 IT 从业者，掌握 Linux 是一个非常重要的谋生资源和手段。接下来我将结合我个人几年的开发经验，谈谈 Linux 的学习方法和学习中应该注意的一些事情，特别是关于 Linux，类 UNIX 系统和开源软件文化。</p><p>就像我刚才说的，很多同学之前可能连 Linux 是什么都不知道，更别说 UNIX 了。所以我们从最基础的一点开始，Linux 和 UNIX 的历史我们就不多说了，直接进入入门学习。</p><p>Linux 入门非常简单。问题是你有没有耐心，有没有爱折腾，有没有不排除重装之类的大修。可以说不折腾是学不好 Linux 的。鸟哥说你要真正了解 Linux 的分区机制，并且对 LVM 的使用相当熟练。不超过 20 次是无法积累 Linux 安装经验的，所以不要怕折腾。</p><p>既然之前大家都用 Windows，我也尽量照顾这些 “菜鸟”。我的推荐，如果你是第一次接触 Linux，那就先在虚拟机里试试。我推荐虚拟机用的 Virtual Box。我不提倡使用 VM，因为 VM 是开源的，是收费的。我不想推广盗版。当然，如果你有足够的钱，你可以试试 VM，但我想说的是，即使是 VM 也不一定好。付费软件不一定好。首先，虚拟盒子很小。Windows 平台下安装包 80MB 左右，而 VM 每转 600MB。虽然很强大，但是消耗了很多资源。更何况虚拟盒子完全可以满足你的需求。所以，还是自己选比较好。如何使用虚拟机是你的事。这个就不教你了，因为很简单。如果不能，可以用谷歌或者百度。如果你英语好，可以直接看官方文件。</p><p>现在介绍 Linux 发行版的知识。正如你所见，Linux 发行版并非 Linux，Linux 仅是指操作系统的内核，作为科班出生的你不要让我解释，我也没时间。</p><p><strong>我推荐的发行版如下：</strong></p><ol><li>UBUNTU 适合纯新手，追求稳定的官方支持，对系统稳定性要求弱，喜欢最新的应用，相对不喜欢折腾开发者。</li><li>比 UBUNTU 难很多的发行版 Debian，特点是稳定易用的包管理系统，缺点是缺乏企业支持，以社区开发为驱动。</li><li>Arch，追逐时尚的开发者首选，优点是包更新相当快，升级无缝。基本上一次安装就可以一直工作，没有 UBUNTU 那样的版本概念。专业点叫滚动升级，让你的系统保持最新。缺点很明显，不稳定。同时安装配置也比 Debian 麻烦。</li><li>比 Arch 更难的 Gentoo，考验用户的综合水平。从系统安装到微调，内核编译都是手把手。是高手和黑客展示自己技术手段，按需配置符合自己要求的系统的首选。</li></ol><p><strong>Slackware 与 Gentoo 类似：</strong></p><p>社区维护的 RedHat 的副本 CentOS，完全是用 RedHat 的源代码重新编译的，理论上和 RedHat 的兼容性是最好的。如果你专注于 Linux 服务器，比如网络管理和网站建设，那么 CentOS 就是你的选择。</p><p>LFS，终极黑客炫耀工具，完全从源代码安装编译系统。在安装之前，您只能获得一个文档。您所要做的就是按照文档中的说明，一步一步，一个订单一个订单地，一个一个地构建您的 Linux 包。完全在你的掌控之中，你想要什么就有什么。如果你制作了 LFS，那就证明你的 Linux 技术相当不错。如果你能借鉴 LFS 文档，把 Linux 从源代码移植到嵌入式系统，我敢说你能在中国企业做得很好。</p><p>你得挑一个适合自己的系统，然后装在虚拟机里开始用。如果你想快速学习 Linux，我有一个建议，你应该忘记图形界面。不要去想图形界面能不能为你的问题提供答案，而是去世界各地寻找，询问如何用命令行解决你的问题。在这个过程中，你最好掌握好 Linux 的命令，至少要知道常用的命令，同时要建立自己的知识库，里面包含了你积累的知识。</p><p>下一阶段需要学习 Linux 平台的 C++/C++ 开发，以及 Bash 脚本编程，如果对 Java 有很深的兴趣，还需要学习 Java。同样，我建议你抛弃图形界面的 IDE，从 VIM 开始。为什么是 VIM 而不是 Emacs？我无意挑起编辑器大战，但我认为 VIM 适合新手和手笨脑慢的开发者。Emacs 的按键太多，太复杂，我很害怕。然后是 GCC，Make，Eclipse(Java，C++ 或者)。虽然 Eclipse 中列出了 C++，但是我不建议用 IDE 开发 C++，因为这不是 Linux 的文化，你很容易忽略一些应该注意的问题。IDE 让你懒的跟猪一样懒。如果你对程序调试和测试感兴趣，你必须学好 GDB。如果不是 GDB，这也是一门必修课。这是发展的第一步。注意，我没有提到任何关于 Linux API 的东西，现阶段也不关心这个。你要做的就是积累经验，Linux 平台开发的经验。我推荐的书如下:《C 语言编程》，或者谭浩强的。c，白皮书当然更好。++C++ Primer Plus 是 C 推荐的，我不喜欢 Java，所以不推荐。工具推荐 VIM 的官方手册，GCC 中文文档，GDB 中文文档，GNU 开源软件开发指南 (电子书)，汇编语言编程 (让你对库，链接，嵌入式汇编，编译器优化选项有个初步的了解，不深入)。</p><p>如果过不了这个阶段，就不用做了。这是底线，也是最基本的基础。否则，离开，不要开发 Linux。不专业的 Linux 开发者做出来的程序与 Linux 文化或者 UNIX 文化相悖，程序走不了多远，也不可能像 Bash、VIM 这样神奇的产品。所以做不好就走人。</p><p>接下来进入 Linux 系统编程，唯一的选择，APUE，UNIX 环境下的高级编程。反复读，10 遍太少。如果你在大学能把这本书砸了，里面的内容都练过了，有作品，口语表达能力足够强，面试的时候就能说服所有考官。(可能有点夸张，但 APUE 绝对是圣经读物，连 Windows 程序员都从中汲取养分。谷歌创始人的案头书，扎伯克的床头读物。)</p><p>看完这本书，你会对 Linux 系统编程有很好的了解。Linux 和 Windows 平台有什么区别？它们的优缺点是什么？我的总结如下: Windows 平台开发难。微软的系统 API 一直在扩展。如果你想使用最新最高效的功能，你必须时刻学习最适合当前流行系统的功能。不，Linux 有大约 100 个核心 API，所以你可以用很好的记忆力记住它们。而且会长期不变。为什么不呢？因为它兼容 UNIX，符合 POSIX 标准。因此，Linux 平台的开发大多集中在底层或服务器编程上。这是它的优势。当然图形是 Linux 的软肋，但从一个开发者的角度来说，我不在乎，因为我也能适应命令行。如果有更好的图形界面，我会把它作为礼物。另外，Windows 是关闭的，你甚至不知道系统做了什么。你将永远被微软牵着鼻子走。想想吧。如果微软说 Win8 不支持 QQ，腾讯也不会哭死。而且 Linux 是完全开源的。如果不喜欢，可以自己改，只要足够熟练。另外，虽然 Windows 使用的人很多，但是使用的场合比较单一，以桌面为主。Linux 各方面都有发展，尤其是云计算、服务器软件、嵌入式领域、企业应用，兼容性一流。由于 POSIX 可以在 UNIX 系统上无缝运行，因此 Apple Mac 和 IBM AS400 系列都完全支持它。另外，Linux 的开发环境支持绝对一流，无论是 C/C++，Java，Bash，Python，PHP，Javascript，。。。。。。连 C# 都支持。而且微软除了 Visual Stdio 套件都不太友好吧？</p><p>如果你看了 APUE 后有很多感触，想验证你的一些想法或经验，推荐 UNIX 编程艺术，世界顶尖黑客将与你分享他们的观点。现在是时候转移注意力了。总的来说，我分为四个方向: 网络、图形、嵌入式、设备驱动。</p><p>如果选择网络，细分的话，其他的不太熟悉，只说服务器软件编写和高性能并发程序编写。相对来说，这是网络编程中技术含量最高的，也是最底层的。需要很多经验，看很多书，做很多项目。</p><p><strong>我的看法是以下面的顺序来看书：</strong></p><ol><li>APUE 的深度阅读——尤其是进程、线程、IPC、套接字</li><li>多核编程——Pthread 一定要吃透，你是 NB</li><li>UNIX 网络编程–第 1 卷，第 2 卷</li><li>TCP/IP 网络详解——是时候再看一遍以上两本书了。</li><li>TCP/IP 网络的详细说明–第 2 卷。我觉得看第二卷就差不多了。当然，最好还是看第三卷。尽力去看吧。</li><li>Lighttpd 源代码——这个服务器也很有名。</li><li>NGX 源代码——与 Apache 相比，Nginx 的源代码更少。如果能大致看一下，就是 NB 了。看源码主要是学习里面的 socket 编程和并发控制，想想就激动。如果你有这些技能，你可以试试给暴雪发简历，给他们写服务器后台，以为全世界的魔兽都运行在你的服务器软件上。</li><li>Linux 内核 TCP/IP 协议栈——深入了解 TCP/IP 实现</li><li>如果还是喜欢驱动设计，可以看看底层协议，比如链路层。给路由器，网卡，网络设备，嵌入式系统软件写驱动应该不是问题。当然，一般的网络公司，哪怕是百度级别的，都应该毫不犹豫的录用你。看后面的书只需要时间和经验，所以 35 岁之前就做吧！跳槽到给你未来的地方！</li></ol><p><strong>图形方向，我觉得图形方向也是很有前途的，以下几个方面：</strong></p><p>Opengl 的工业和游戏开发在国外已经比较成熟。</p><p>动画特效，比如皮克斯，在国外也比较成熟。</p><p>GPU 计算技术可以应用于浏览器网页渲染和 GPU 计算资源利用。因为开源，所以有很多文档程序可以参考。如果能进入火狐开发，或者谷歌做浏览器开发，应该很不错。</p><p><strong>嵌入式方向：嵌入式方向没说的，Linux 很重要</strong></p><p>掌握多种架构，不仅仅是 X86，ARM，MCU 等。必须理解。如果你不懂硬件，我预见你会死在路上，我也想往嵌入式方向走，但是我觉得就算是学电子的学生也比不过学校教嵌入式的方式。我劝你，做之前一定要了解硬件。如果你去做嵌入式应用开发，只能祝你好运了。不要碰上诺基亚、惠普这样的公司，否则你会很惨。</p><p>驱动设计: 软件开发周期很长，硬件不一样，很快。每个月都有这么多新硬件诞生，如何让它们在 Linux 上工作是你的工作。因为 Linux 兼容性好，如果不是太低级的驱动，基本的 C 语言就可以了，系统架构影响不大。由于系统支持，您可能可以在 ARM 上使用 PC 硬件，但需要做一些更改。所以硬件驱动开发不像嵌入式，对硬件知识要求很高。可能的方向很多，比如家电，特别是像索尼、日立、希捷、富士康这样的工厂，比较稀缺。</p><h2 id="四，学习-Linux-内核"><a class="header-anchor" href="#四，学习-Linux-内核">¶</a><strong>四，学习 Linux 内核</strong></h2><p>学习 linux 内核不像学习语言。一个月或者三月就能掌握 C 或者 java。学习 linux 内核需要循序渐进，掌握正确的 linux 内核学习路线非常重要。本文将分享一些学习 linux 内核的建议。</p><ol><li><p>了解操作系统的基本概念。如果没有，可以学习《操作系统: 设计与实现》，Andrew S.Tanenbaum 写的那本，以 MINIX 为例解释操作系统的概念。非常推荐。</p></li><li><p>有了操作系统的基本概念，你就可以理解 Linux 的机制了。推荐罗伯特 · 拉芙写的 Linux 内核设计与实现。这本书从概念上解释了 Linux 有什么以及它是如何工作的。这本书应该反复仔细阅读。</p></li><li><p>有了 Linux 内核的知识，我们还需要具体学习 Linux 内核源代码。经典的是丹尼尔 ·p· 博韦特写的《深入理解 Linux 内核》。学习这本书的时候，要看看内核代码。这本书学起来挺费劲的，所以有很多代码要研究。但是，如果这本书很好理解，那么恭喜你，你已经对 Linux 内核很熟悉了。</p></li><li><p>如果你想开发设备驱动，可以向 O 'Reilly Press 学习 Linux 设备驱动。这本书是驾驶入门的好材料。还有一本很好的教材，精通 Linux 驱动开发，可以参考一下。开车，难免要学习一些硬件协议和资料。如果你研究的是哪一种，可以找相应的硬件文档，了解硬件的工作原理。这些我就不细说了。</p></li><li><p>网络部分，学习一些 Linux 网络部分学习《深入了解 LINUX 网络技术内幕》。这本书把 Linux 的网络部分讲得非常清楚透彻。不过我们一般不做这方面的研究，也不需要做那么多研究。毕竟现在相关岗位很少。</p></li><li><p>现在 Linux 相关的工作大多集中在一些嵌入式开发领域，如 arm、mips 等。你要学习以下关于架构的信息，了解 CPU 的设计和工作模式。看看 ARM 对应的芯片手册就知道了，很详细的。mips 随便看看 MIPS 运行，有一两个版本。两个版本有些区别，建议全看。</p></li><li><p>补充一点经验。不要以为 Linux 庞大复杂，就很难学。认真学习，什么都可以学。就看你的毅力和恒心了。另外，不要走弯路，不要看市面上那些讲 Linux0.11 的书，学你想学的就好。就像学 C 语言看谭浩强一样，走弯路，费力气，严重影响学习效果。</p></li></ol><p><strong>关于 linux 内核学习路线，再多说几句应用编程，有时候经常会需要的：</strong></p><ol><li><p>学习 Linux 应用编程，建议看《unix 环境高级编程》，把里面的例子都做一遍，会对整个 Linux 编程有系统都认识。</p></li><li><p>针对 Linux，有本 《Linux 系统编程》，学完上一本，这本很快看一遍就懂了。主要是针对 Linux 具体懂一些内容，讲的挺全了，很实用。</p></li><li><p>Linux 网络编程，系统的学习一下《unix 网络编程。卷 1，套接字联网 api》，基本上网络应用相关的程序就都没问题了。</p></li></ol><p>这些内容，分几年时间，分步计划学习，就会成为 Linux 高手了。个人建议参加零声教育的培训，学习效率会高很多，有目的性的参加培训，缩短周期，快速成型才是时代所需。</p><p><strong>官方地址：</strong><a href="https://link.zhihu.com/?target=https%3A//ke.qq.com/course/4032547%3FflowToken%3D1040236" target="_blank" rel="noopener">Linux 内核源码 / 内存调优 / 文件系统 / 进程管理 / 设备驱动 / 网络协议栈 - 学习视频教程 - 腾讯课堂</a></p><p><strong>以上就是 Linux 内核学习路线，关于学习 Linux 内核的建议，希望对小伙伴们有帮助。</strong></p><p><img src="https://pic3.zhimg.com/v2-937a1ab104f7526be077ec69d7c41c42_b.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&quot;http://ksria.com/simpread/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/572266986&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;zhuanlan.zhihu.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、为什么要学习-Linux-内核&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#一、为什么要学习-Linux-内核&quot;&gt;¶&lt;/a&gt;一、为什么要学习 Linux 内核&lt;/h2&gt;
    
    </summary>
    
      <category term="linux" scheme="https://talengu.github.io/public/categories/linux/"/>
    
    
      <category term="linux" scheme="https://talengu.github.io/public/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>「转」九张图一览 Linux 性能工具 全景图</title>
    <link href="https://talengu.github.io/public/2022/12/11/linux/linux_tools/"/>
    <id>https://talengu.github.io/public/2022/12/11/linux/linux_tools/</id>
    <published>2022-12-11T12:00:00.000Z</published>
    <updated>2022-12-11T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>当今时代，绝大多数企业的应用都是运行在 Linux 操作系统上，所以对应用进行性能诊断和性能优化时，离不开 Linux 的各种性能观测工具和性能优化工具。</p><p>笔者使用过的常见的 Linux 性能观测和性能优化工具有：</p><ul><li>top/uptime</li><li>ps/pstree</li><li>df/du/free/lsblk</li><li>ip/ifconfig/ping/telnet</li><li>route/dig/nslookup</li><li>lsof/netstat/ss</li><li>tcpdump/tshark/wireshark</li><li>netstat/vmstat/iostat/pidstat/dstat/mpstat</li><li>sar/sysctl/ethtool</li></ul><p>最近在拜读国际著名的 LINUX 性能专家 Brendan Gregg 的个人博客和技术书籍，摘抄了如下九张图，一览 Linux 性能工具全景图，大家共勉！</p><a id="more"></a><h2 id="2-Linux-性能工具全景图"><a class="header-anchor" href="#2-Linux-性能工具全景图">¶</a><strong>2. Linux 性能工具全景图</strong></h2><ul><li>linux performance observability tools</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-2eadd97c53a3f20f255394c3d90ea914_r.jpg" alt></p><ul><li>linux static performance tools</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-20032bac53c856c5733259eece5c2f76_r.jpg" alt></p><ul><li>linux performance benchmark tools</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-de23423f2eb9deb5410b7128c933f9a9_r.jpg" alt></p><ul><li>linux performance tuning tools</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-cdf37de145763b762ba5af1a620f9686_r.jpg" alt></p><ul><li>linux performance observability: sar</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-eee71a6bf3865367741137da03031411_r.jpg" alt></p><ul><li>linux performance observability: perf-tools</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-1c0134fefbb04597db98ae455a40fad5_r.jpg" alt></p><ul><li><a href="https://www.zhihu.com/search?q=linux%20bcc&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2795830055%7D" target="_blank" rel="noopener">linux bcc</a>/BPF Tracing tools</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-ffe70303f4d64828ca931d987b12a6d8_r.jpg" alt></p><ul><li>bpftrace/eBPF Tools</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-5985d44e43738933c0b54c89cc20ec09_r.jpg" alt></p><ul><li>BPF Performance Tools: Linux System and Application Observability</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-0f53016fa1d993ffbbf6fc520e318784_r.jpg" alt></p><h2 id="后记"><a class="header-anchor" href="#后记">¶</a>后记</h2><p>更多 LINUX 性能资料，大家可以访问大师的个人网站和和技术书籍</p><ul><li><a href="https://www.brendangregg.com/" target="_blank" rel="noopener">https://www.brendangregg.com/</a></li><li>《性能之巅：洞悉系统、企业与云计算》（《Systems Performance: Enterprise and the Cloud, 2nd Edition (2020)》）</li><li>《洞悉 Linux 系统和应用性能》（《BPF Performance Tools》）</li><li>ps: 要说 LINUX 内核近几年 (和今后几年）最引人注目的发展模块，那就是 <a href="https://www.zhihu.com/search?q=bpf&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2795830055%7D" target="_blank" rel="noopener">bpf</a> 了，完全值得花点精力学习跟进下。</li><li>如何更深入地学习 Linux？ - michaelli的回答 - 知乎<a href="https://www.zhihu.com/question/23564190/answer/2795830055" target="_blank" rel="noopener">https://www.zhihu.com/question/23564190/answer/2795830055</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;当今时代，绝大多数企业的应用都是运行在 Linux 操作系统上，所以对应用进行性能诊断和性能优化时，离不开 Linux 的各种性能观测工具和性能优化工具。&lt;/p&gt;
&lt;p&gt;笔者使用过的常见的 Linux 性能观测和性能优化工具有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;top/uptime&lt;/li&gt;
&lt;li&gt;ps/pstree&lt;/li&gt;
&lt;li&gt;df/du/free/lsblk&lt;/li&gt;
&lt;li&gt;ip/ifconfig/ping/telnet&lt;/li&gt;
&lt;li&gt;route/dig/nslookup&lt;/li&gt;
&lt;li&gt;lsof/netstat/ss&lt;/li&gt;
&lt;li&gt;tcpdump/tshark/wireshark&lt;/li&gt;
&lt;li&gt;netstat/vmstat/iostat/pidstat/dstat/mpstat&lt;/li&gt;
&lt;li&gt;sar/sysctl/ethtool&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最近在拜读国际著名的 LINUX 性能专家 Brendan Gregg 的个人博客和技术书籍，摘抄了如下九张图，一览 Linux 性能工具全景图，大家共勉！&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://talengu.github.io/public/categories/linux/"/>
    
    
      <category term="linux" scheme="https://talengu.github.io/public/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>tcp ip 协议族</title>
    <link href="https://talengu.github.io/public/2022/12/08/linux_network/tcp_ip/"/>
    <id>https://talengu.github.io/public/2022/12/08/linux_network/tcp_ip/</id>
    <published>2022-12-08T12:00:00.000Z</published>
    <updated>2022-12-08T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>tcp ip 协议族</p><a id="more"></a><p><img src="/public/2022/12/08/linux_network/tcp_ip/tcp_ip.jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;tcp ip 协议族&lt;/p&gt;
    
    </summary>
    
      <category term="linux 网络" scheme="https://talengu.github.io/public/categories/linux-%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://talengu.github.io/public/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>「转」连接跟踪（conntrack）：原理、应用及 Linux 内核实现</title>
    <link href="https://talengu.github.io/public/2022/12/04/linux_network/conntrack_linux/"/>
    <id>https://talengu.github.io/public/2022/12/04/linux_network/conntrack_linux/</id>
    <published>2022-12-04T12:00:00.000Z</published>
    <updated>2022-12-04T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a class="header-anchor" href="#摘要">¶</a>摘要</h2><p>本文介绍连接跟踪（connection tracking，conntrack，CT）的原理，应用，及其在 Linux 内核中的实现。</p><p>代码分析基于内核 <code>4.19</code>。为使行文简洁，所贴代码只保留了核心逻辑，但都给出了代码 所在的源文件，如有需要请查阅。</p><p>水平有限，文中不免有错误之处，欢迎指正交流。</p><p>连接跟踪是许多网络应用的基础。例如，Kubernetes Service、ServiceMesh sidecar、 软件四层负载均衡器 LVS/IPVS、Docker network、OVS、iptables 主机防火墙等等，都依赖 连接跟踪功能。</p><a id="more"></a><h2 id="1-1-概念"><a class="header-anchor" href="#1-1-概念">¶</a>1.1 概念</h2><p>连接跟踪，顾名思义，就是<strong>跟踪（并记录）连接的状态</strong>。</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/node-conntrack.png" alt></p><p>Fig 1.1. 连接跟踪及其内核位置示意图</p><p>例如，上图是一台 IP 地址为 <code>10.1.1.2</code> 的 Linux 机器，我们能看到这台机器上有三条 连接：</p><ol><li>机器访问外部 HTTP 服务的连接（目的端口 80）</li><li>外部访问机器内 FTP 服务的连接（目的端口 21）</li><li>机器访问外部 DNS 服务的连接（目的端口 53）</li></ol><p>连接跟踪所做的事情就是发现并跟踪这些连接的状态，具体包括：</p><ul><li>从数据包中提取<strong>元组</strong>（tuple）信息，辨别<strong>数据流</strong>（flow）和对应的<strong>连接</strong>（connection）</li><li>为所有连接维护一个<strong>状态数据库</strong>（conntrack table），例如连接的创建时间、发送 包数、发送字节数等等</li><li>回收过期的连接（GC）</li><li>为更上层的功能（例如 NAT）提供服务</li></ul><p>需要注意的是，<strong>连接跟踪中所说的“连接”，概念和 TCP/IP 协议中“面向连接”（ connection oriented）的 “连接” 并不完全相同</strong>，简单来说：</p><ul><li>TCP/IP 协议中，连接是一个四层（Layer 4）的概念。<ul><li>TCP 是有连接的，或称面向连接的（connection oriented），发送出去的包都要求对端应答（ACK），并且有重传机制</li><li>UDP 是无连接的，发送的包无需对端应答，也没有重传机制</li></ul></li><li>CT 中，一个元组（tuple）定义的一条数据流（flow ）就表示一条连接（connection）。<ul><li>后面会看到 UDP 甚至是 <strong>ICMP 这种三层协议在 CT 中也都是有连接记录的</strong></li><li>但<strong>不是所有协议都会被连接跟踪</strong></li></ul></li></ul><p>本文中用到 “连接” 一词时，大部分情况下指的都是后者，即 “连接跟踪” 中的“连接”。</p><h2 id="1-2-原理"><a class="header-anchor" href="#1-2-原理">¶</a>1.2 原理</h2><p>了解以上概念之后，我们来思考下连接跟踪的技术原理。</p><p>要跟踪一台机器的所有连接状态，就需要</p><ol><li><strong>拦截（或称过滤）流经这台机器的每一个数据包，并进行分析</strong>。</li><li>根据这些信息<strong>建立</strong>起这台机器上的<strong>连接信息数据库</strong>（conntrack table）。</li><li>根据拦截到的包信息，不断更新数据库</li></ol><p>例如，</p><ol><li>拦截到一个 TCP <code>SYNC</code> 包时，说明正在尝试建立 TCP 连接，需要创建一条新 conntrack entry 来记录这条连接</li><li>拦截到一个属于已有 conntrack entry 的包时，需要更新这条 conntrack entry 的收发包数等统计信息</li></ol><p>除了以上两点功能需求，还要考虑<strong>性能问题</strong>，因为连接跟踪要对每个包进行过滤和分析 。性能问题非常重要，但不是本文重点，后面介绍实现时会进一步提及。</p><p>之外，这些功能最好还有配套的管理工具来更方便地使用。</p><h2 id="1-3-设计：Netfilter"><a class="header-anchor" href="#1-3-设计：Netfilter">¶</a>1.3 设计：Netfilter</h2><p><strong>Linux 的连接跟踪是在 <a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Netfilter</a> 中实现的。</strong></p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/netfilter-design.png" alt></p><p>Fig 1.2. Netfilter architecture inside Linux kernel</p><p><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Netfilter</a> 是 Linux 内核中一个对数据 包进行<strong>控制、修改和过滤</strong>（manipulation and filtering）的框架。它在内核协议 栈中设置了若干 hook 点，以此对数据包进行拦截、过滤或其他处理。</p><blockquote><p>说地更直白一些，hook 机制就是在数据包的必经之路上设置若干检测点，所有到达这 些检测点的包都必须接受检测，根据检测的结果决定：</p><ol><li>放行：不对包进行任何修改，退出检测逻辑，继续后面正常的包处理</li><li>修改：例如修改 IP 地址进行 NAT，然后将包放回正常的包处理逻辑</li><li>丢弃：安全策略或防火墙功能</li></ol><p>连接跟踪模块只是完成连接信息的采集和录入功能，并不会修改或丢弃数据包，后者是其 他模块（例如 NAT）基于 Netfilter hook 完成的。</p></blockquote><p>Netfilter 是最古老的内核框架之一，1998 年开始开发，2000 年合并到 <code>2.4.x</code> 内 核主线版本 [5]。</p><h2 id="1-4-设计：进一步思考"><a class="header-anchor" href="#1-4-设计：进一步思考">¶</a>1.4 设计：进一步思考</h2><p>现在提到连接跟踪（conntrack），可能首先都会想到 Netfilter。但由上节讨论可知， 连接跟踪概念是独立于 Netfilter 的，<strong>Netfilter 只是 Linux 内核中的一种连接跟踪实现</strong>。</p><p>换句话说，<strong>只要具备了 hook 能力，能拦截到进出主机的每个包，完全可以在此基础上自 己实现一套连接跟踪</strong>。</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/cilium-conntrack.png" alt></p><p>Fig 1.3. Cilium's conntrack and NAT architectrue</p><p>云原生网络方案 Cilium 在 <code>1.7.4+</code> 版本就实现了这样一套独立的连接跟踪和 NAT 机制 （完备功能需要 Kernel <code>4.19+</code>）。其基本原理是：</p><ol><li>基于 BPF hook 实现数据包的拦截功能（等价于 netfilter 里面的 hook 机制）</li><li>在 BPF hook 的基础上，实现一套全新的 conntrack 和 NAT</li></ol><p>因此，即便<a href="https://github.com/cilium/cilium/issues/12879" target="_blank" rel="noopener">卸载 Netfilter</a> ，也不会影响 Cilium 对 Kubernetes ClusterIP、NodePort、ExternalIPs 和 LoadBalancer 等功能的支持 [2]。</p><p>由于这套连接跟踪机制是独立于 Netfilter 的，因此它的 conntrack 和 NAT 信息也没有 存储在内核的（也就是 Netfilter 的）conntrack table 和 NAT table。所以常规的 <code>conntrack/netstats/ss/lsof</code> 等工具是看不到的，要使用 Cilium 的命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cilium bpf nat list</span><br><span class="line">$ cilium bpf ct list global</span><br></pre></td></tr></table></figure><p>配置也是独立的，需要在 Cilium 里面配置，例如命令行选项 <code>--bpf-ct-tcp-max</code>。</p><p>另外，本文会多次提到连接跟踪模块和 NAT 模块独立，但<strong>出于性能考虑，具体实现中 二者代码可能是有耦合的</strong>。例如 Cilium 做 conntrack 的垃圾回收（GC）时就会顺便把 NAT 里相应的 entry 回收掉，而非为 NAT 做单独的 GC。</p><h2 id="1-5-应用"><a class="header-anchor" href="#1-5-应用">¶</a>1.5 应用</h2><p>来看几个 conntrack 的具体应用。</p><h3 id="1-5-1-网络地址转换（NAT）"><a class="header-anchor" href="#1-5-1-网络地址转换（NAT）">¶</a>1.5.1 网络地址转换（NAT）</h3><p>网络地址转换（NAT），名字表达的意思也比较清楚：对（数据包的）网络地址（<code>IP + Port</code>）进行转换。</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/node-nat.png" alt></p><p>Fig 1.4. NAT 及其内核位置示意图</p><p>例如上图中，机器自己的 IP <code>10.1.1.2</code> 是能与外部正常通信的，但 <code>192.168</code> 网段是私有 IP 段，外界无法访问，也就是说源 IP 地址是 <code>192.168</code> 的包，其<strong>应答包是无 法回来的</strong>。因此，</p><ul><li>当源地址为 <code>192.168</code> 网段的包要出去时，机器会先将源 IP 换成机器自己的 <code>10.1.1.2</code> 再发送出去；</li><li>收到应答包时，再进行相反的转换。</li></ul><p>这就是 NAT 的基本过程。</p><p>Docker 默认的 <code>bridge</code> 网络模式就是这个原理 [4]。每个容器会分一个私有网段的 IP 地址，这个 IP 地址可以在宿主机内的不同容器之间通信，但容器流量出宿主机时要进行 NAT。</p><p>NAT 又可以细分为几类：</p><ul><li>SNAT：对源地址（source）进行转换</li><li>DNAT：对目的地址（destination）进行转换</li><li>Full NAT：同时对源地址和目的地址进行转换</li></ul><p>以上场景属于 SNAT，将不同私有 IP 都映射成同一个 “公有 IP”，以使其能访问外部网络服 务。这种场景也属于正向代理。</p><p>NAT 依赖连接跟踪的结果。连接跟踪<strong>最重要的使用场景</strong>就是 NAT。</p><h4 id="四层负载均衡（L4LB）"><a class="header-anchor" href="#四层负载均衡（L4LB）">¶</a>四层负载均衡（L4LB）</h4><p>再将范围稍微延伸一点，讨论一下 NAT 模式的四层负载均衡。</p><p>四层负载均衡是根据包的四层信息（例如 <code>src/dst ip, src/dst port, proto</code>）做流量分发。</p><p>VIP（Virtual IP）是四层负载均衡的一种实现方式：</p><ul><li>多个后端真实 IP（Real IP）挂到同一个虚拟 IP（VIP）上</li><li>客户端过来的流量先到达 VIP，再经负载均衡算法转发给某个特定的后端 IP</li></ul><p>如果在 VIP 和 Real IP 节点之间使用的 NAT 技术（也可以使用其他技术），那客户端访 问服务端时，L4LB 节点将做双向 NAT（Full NAT），数据流如下图所示：</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/nat.png" alt></p><p>Fig 1.5. L4LB: Traffic path in NAT mode [3]</p><h3 id="1-5-2-有状态防火墙"><a class="header-anchor" href="#1-5-2-有状态防火墙">¶</a>1.5.2 有状态防火墙</h3><p>有状态防火墙（stateful firewall）是相对于早期的<strong>无状态防火墙</strong>（stateless firewall）而言的：早期防火墙只能写 <code>drop syn to port 443</code> 或者 <code>allow syn to port 80</code> 这种非常简单直接 的规则，<strong>没有 flow 的概念</strong>，因此无法实现诸如 <strong>“如果这个 ack 之前已经有 syn， 就 allow，否则 drop”</strong> 这样的规则，使用非常受限 [6]。</p><p>显然，要实现有状态防火墙，就必须记录 flow 和状态，这正是 conntrack 做的事情。</p><p>来看个更具体的防火墙应用：OpenStack 主机防火墙解决方案 —— 安全组（security group）。</p><h4 id="OpenStack-安全组"><a class="header-anchor" href="#OpenStack-安全组">¶</a>OpenStack 安全组</h4><p>简单来说，安全组实现了<strong>虚拟机级别</strong>的安全隔离，具体实现是：在 node 上连接 VM 的 网络设备上做有状态防火墙。在当时，最能实现这一功能的可能就是 Netfilter/iptables。</p><p>回到宿主机内网络拓扑问题： OpenStack 使用 OVS bridge 来连接一台宿主机内的所有 VM。 如果只从网络连通性考虑，那每个 VM 应该直接连到 OVS bridge <code>br-int</code>。但这里问题 就来了 [7]：</p><ul><li>（较早版本的）OVS 没有 conntrack 模块，</li><li>Linux 中有 conntrack 模块，但基于 conntrack 的防火墙<strong>工作在 IP 层</strong>（L3），通过 iptables 控制，</li><li>而 <strong>OVS 是 L2 模块</strong>，无法使用 L3 模块的功能，</li></ul><p>最终结果是：无法在 OVS （连接虚拟机）的设备上做防火墙。</p><p>所以，2016 之前 OpenStack 的解决方案是，在每个 OVS 和 VM 之间再加一个 Linux bridge ，如下图所示，</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/ovs-compute.png" alt></p><p>Fig 1.6. Network topology within an OpenStack compute node, picture from <a href="https://thesaitech.wordpress.com/2017/09/24/how-to-trace-the-tap-interfaces-and-linux-bridges-on-the-hypervisor-your-openstack-vm-is-on/" target="_blank" rel="noopener">Sai's Blog</a></p><p>Linux bridge 也是 L2 模块，按道理也无法使用 iptables。但是，<strong>它有一个 L2 工具 ebtables，能够跳转到 iptables</strong>，因此间接支持了 iptables，也就能用到 Netfilter/iptables 防火墙的功能。</p><p>这种暴力堆砌的方式不仅丑陋、增加网络复杂性，而且会导致性能问题。因此， RedHat 在 2016 年提出了一个 OVS conntrack 方案 [7]，从那以后，才有可能干掉 Linux bridge 而仍然具备安全组的功能。</p><h2 id="1-6-小结"><a class="header-anchor" href="#1-6-小结">¶</a>1.6 小结</h2><p>以上是理论篇，接下来看一下内核实现。</p><p>Netfilter 由几个模块构成，其中最主要的是<strong>连接跟踪</strong>（CT）模块和<strong>网络地址转换</strong>（NAT）模块。</p><p>CT 模块的主要职责是识别出可进行连接跟踪的包。 CT 模块独立于 NAT 模块，但主要目的是服务于后者。</p><h2 id="2-1-Netfilter-框架"><a class="header-anchor" href="#2-1-Netfilter-框架">¶</a>2.1 Netfilter 框架</h2><h3 id="5-个-hook-点"><a class="header-anchor" href="#5-个-hook-点">¶</a>5 个 hook 点</h3><p><img src="/public/2022/12/04/linux_network/conntrack_linux/hooks.png" alt></p><p>图 2.1. The 5 hook points in netfilter framework</p><p>如上图所示，Netfilter 在内核协议栈的包处理路径上提供了 5 个 hook 点，分别是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/netfilter_ipv4.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_PRE_ROUTING    0 <span class="comment">/* After promisc drops, checksum checks. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_LOCAL_IN       1 <span class="comment">/* If the packet is destined for this box. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_FORWARD        2 <span class="comment">/* If the packet is destined for another interface. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_LOCAL_OUT      3 <span class="comment">/* Packets coming from a local process. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_POST_ROUTING   4 <span class="comment">/* Packets about to hit the wire. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_NUMHOOKS       5</span></span><br></pre></td></tr></table></figure><p>用户可以在这些 hook 点注册自己的处理函数（handlers）。当有数据包经过 hook 点时， 就会调用相应的 handlers。</p><blockquote><p>另外还有一套 <code>NF_INET_</code> 开头的定义，<code>include/uapi/linux/netfilter.h</code>。 这两套是等价的，从注释看，<code>NF_IP_</code> 开头的定义可能是为了保持兼容性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">enum</span> nf_inet_hooks &#123;</span><br><span class="line">&gt;  NF_INET_PRE_ROUTING,</span><br><span class="line">&gt;  NF_INET_LOCAL_IN,</span><br><span class="line">&gt;  NF_INET_FORWARD,</span><br><span class="line">&gt;  NF_INET_LOCAL_OUT,</span><br><span class="line">&gt;  NF_INET_POST_ROUTING,</span><br><span class="line">&gt;  NF_INET_NUMHOOKS</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="hook-返回值类型"><a class="header-anchor" href="#hook-返回值类型">¶</a>hook 返回值类型</h3><p>hook 函数对包进行判断或处理之后，需要返回一个判断结果，指导接下来要对这个包做什 么。可能的结果有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/netfilter.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_DROP   0  <span class="comment">// 已丢弃这个包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_ACCEPT 1  <span class="comment">// 接受这个包，结束判断，继续下一步处理</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_STOLEN 2  <span class="comment">// 临时 hold 这个包，不用再继续穿越协议栈了。常见的情形是缓存分片之后的包（等待重组）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_QUEUE  3  <span class="comment">// 应当将包放到队列</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_REPEAT 4  <span class="comment">// 当前处理函数应当被再次调用</span></span></span><br></pre></td></tr></table></figure><h3 id="hook-优先级"><a class="header-anchor" href="#hook-优先级">¶</a>hook 优先级</h3><p>每个 hook 点可以注册多个处理函数（handler）。在注册时必须指定这些 handlers 的<strong>优先级</strong>，这样触发 hook 时能够根据优先级依次调用处理函数。</p><h2 id="2-2-过滤规则的组织"><a class="header-anchor" href="#2-2-过滤规则的组织">¶</a>2.2 过滤规则的组织</h2><p><code>iptables</code> 是配置 Netfilter 过滤功能的用户空间工具。为便于管理， 过滤规则按功能分为若干 table：</p><ul><li>raw</li><li>filter</li><li>nat</li><li>mangle</li></ul><p>这不是本文重点。更多信息可参考 <a href="chrome-extension://ijllcpnolfcooahcekpamkbidhejabll/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener">(译) 深入理解 iptables 和 netfilter 架构</a></p><p>连接跟踪模块用于维护<strong>可跟踪协议</strong>（trackable protocols）的连接状态。 也就是说，连接跟踪<strong>针对的是特定协议的包，而不是所有协议的包</strong>。 稍后会看到它支持哪些协议。</p><h2 id="3-1-重要结构体和函数"><a class="header-anchor" href="#3-1-重要结构体和函数">¶</a>3.1 重要结构体和函数</h2><p>重要结构体：</p><ul><li><code>struct nf_conntrack_tuple {}</code>: 定义一个 tuple。<ul><li><code>struct nf_conntrack_man {}</code>：tuple 的 manipulable part。<ul><li><code>struct nf_conntrack_man_proto {}</code>：manipulable part 中协议相关的部分。</li></ul></li></ul></li><li><code>struct nf_conntrack_l4proto {}</code>: 支持连接跟踪的<strong>协议需要实现的方法集</strong>（以及其他协议相关字段）。</li><li><code>struct nf_conntrack_tuple_hash {}</code>：哈希表（conntrack table）中的表项（entry）。</li><li><code>struct nf_conn {}</code>：<strong>定义一个 flow</strong>。</li></ul><p>重要函数：</p><ul><li><p><code>hash_conntrack_raw()</code>：根据 tuple 计算出一个 32 位的哈希值（hash key）。</p></li><li><p><code>nf_conntrack_in()</code>：<strong>连接跟踪模块的核心，包进入连接跟踪的地方</strong>。</p></li><li><p><code>resolve_normal_ct() -&gt; init_conntrack() -&gt; ct = __nf_conntrack_alloc(); l4proto-&gt;new(ct)</code></p><p>创建一个新的连接记录（conntrack entry），然后初始化。</p></li><li><p><code>nf_conntrack_confirm()</code>：确认前面通过 <code>nf_conntrack_in()</code> 创建的新连接（是否被丢弃）。</p></li></ul><h2 id="3-2-struct-nf-conntrack-tuple-：元组（Tuple）"><a class="header-anchor" href="#3-2-struct-nf-conntrack-tuple-：元组（Tuple）">¶</a>3.2 <code>struct nf_conntrack_tuple {}</code>：元组（Tuple）</h2><p>Tuple 是连接跟踪中最重要的概念之一。</p><p><strong>一个 tuple 定义一个单向（unidirectional）flow</strong>。内核代码中有如下注释：</p><blockquote><p>//include/net/netfilter/nf_conntrack_tuple.h</p><p>A <code>tuple</code> is a structure containing the information to uniquely identify a connection. ie. if two packets have the same tuple, they are in the same connection; if not, they are not.</p></blockquote><h3 id="结构体定义"><a class="header-anchor" href="#结构体定义">¶</a>结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/net/netfilter/nf_conntrack_tuple.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为方便 NAT 的实现，内核将 tuple 结构体拆分为 "manipulatable" 和 "non-manipulatable" 两部分</span></span><br><span class="line"><span class="comment">// 下面结构体中的 _man 是 manipulatable 的缩写</span></span><br><span class="line">                                               <span class="comment">// ude/uapi/linux/netfilter.h</span></span><br><span class="line">                                               <span class="keyword">union</span> nf_inet_addr &#123;</span><br><span class="line">                                                   __u32            all[<span class="number">4</span>];</span><br><span class="line">                                                   __be32           ip;</span><br><span class="line">                                                   __be32           ip6[<span class="number">4</span>];</span><br><span class="line">                                                   <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>   <span class="title">in</span>;</span></span><br><span class="line">                                                   <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span>  <span class="title">in6</span>;</span></span><br><span class="line"><span class="comment">/* manipulable part of the tuple */</span>         /  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_man</span> &#123;</span>                  /</span><br><span class="line">    <span class="keyword">union</span> nf_inet_addr           u3; --&gt;--/</span><br><span class="line">    <span class="keyword">union</span> nf_conntrack_man_proto u;  --&gt;--\</span><br><span class="line">                                           \   <span class="comment">// include/uapi/linux/netfilter/nf_conntrack_tuple_common.h</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> l3num; <span class="comment">// L3 proto            \  // 协议相关的部分</span></span><br><span class="line">&#125;;                                            <span class="keyword">union</span> nf_conntrack_man_proto &#123;</span><br><span class="line">                                                  __be16 all;<span class="comment">/* Add other protocols here. */</span></span><br><span class="line"></span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; tcp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; udp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 id;   &#125; icmp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; dccp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; sctp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 key;  &#125; gre;</span><br><span class="line">                                              &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> &#123;</span> <span class="comment">/* This contains the information to distinguish a connection. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_man</span> <span class="title">src</span>;</span>  <span class="comment">// 源地址信息，manipulable part</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">union</span> nf_inet_addr u3;</span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">            __be16 all; <span class="comment">/* Add other protocols here. */</span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; tcp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; udp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">u_int8_t</span> type, code; &#125; icmp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; dccp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; sctp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 key;          &#125; gre;</span><br><span class="line">        &#125; u;</span><br><span class="line">        <span class="keyword">u_int8_t</span> protonum; <span class="comment">/* The protocol. */</span></span><br><span class="line">        <span class="keyword">u_int8_t</span> dir;      <span class="comment">/* The direction (for tuplehash) */</span></span><br><span class="line">    &#125; dst;                       <span class="comment">// 目的地址信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Tuple 结构体中只有两个字段 src 和 dst</strong>，分别保存源和目的信息。<code>src</code> 和 <code>dst</code> 自身也是结构体，能保存不同类型协议的数据。以 IPv4 UDP 为例，五元组分别保存在如下字段：</p><ul><li><code>dst.protonum</code>：协议类型</li><li><code>src.u3.ip</code>：源 IP 地址</li><li><code>dst.u3.ip</code>：目的 IP 地址</li><li><code>src.u.udp.port</code>：源端口号</li><li><code>dst.u.udp.port</code>：目的端口号</li></ul><h3 id="CT-支持的协议"><a class="header-anchor" href="#CT-支持的协议">¶</a>CT 支持的协议</h3><p>从以上定义可以看到，连接跟踪模块<strong>目前只支持以下六种协议</strong>：TCP、UDP、ICMP、DCCP、SCTP、GRE。</p><p><strong>注意其中的 ICMP 协议</strong>。大家可能会认为，连接跟踪模块依据包的三层和四层信息做 哈希，而 ICMP 是三层协议，没有四层信息，因此 ICMP 肯定不会被 CT 记录。但<strong>实际上 是会的</strong>，上面代码可以看到，ICMP 使用了其头信息中的 ICMP <code>type</code>和 <code>code</code> 字段来 定义 tuple。</p><h2 id="3-3-struct-nf-conntrack-l4proto-：协议需要实现的方法集合"><a class="header-anchor" href="#3-3-struct-nf-conntrack-l4proto-：协议需要实现的方法集合">¶</a>3.3 <code>struct nf_conntrack_l4proto {}</code>：协议需要实现的方法集合</h2><p>支持连接跟踪的协议都需要实现 <code>struct nf_conntrack_l4proto {}</code> 结构体 中定义的方法，例如 <code>pkt_to_tuple()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_l4proto.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_l4proto</span> &#123;</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> l3proto; <span class="comment">/* L3 Protocol number. */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span>  l4proto; <span class="comment">/* L4 Protocol number. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从包（skb）中提取 tuple</span></span><br><span class="line">    <span class="keyword">bool</span> (*pkt_to_tuple)(struct sk_buff *skb, ... struct nf_conntrack_tuple *tuple);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对包进行判决，返回判决结果（returns verdict for packet）</span></span><br><span class="line">    <span class="keyword">int</span> (*packet)(struct nf_conn *ct, <span class="keyword">const</span> struct sk_buff *skb ...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新连接。如果成功返回 TRUE；如果返回的是 TRUE，接下来会调用 packet() 方法</span></span><br><span class="line">    <span class="keyword">bool</span> (*<span class="keyword">new</span>)(struct nf_conn *ct, <span class="keyword">const</span> struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> dataoff);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前数据包能否被连接跟踪。如果返回成功，接下来会调用 packet() 方法</span></span><br><span class="line">    <span class="keyword">int</span> (*error)(struct net *net, struct nf_conn *tmpl, struct sk_buff *skb, ...);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-4-struct-nf-conntrack-tuple-hash-：哈希表项"><a class="header-anchor" href="#3-4-struct-nf-conntrack-tuple-hash-：哈希表项">¶</a>3.4 <code>struct nf_conntrack_tuple_hash {}</code>：哈希表项</h2><p>conntrack 将活动连接的状态存储在一张哈希表中（<code>key: value</code>）。</p><p><code>hash_conntrack_raw()</code> 根据 tuple 计算出一个 32 位的哈希值（key）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">hash_conntrack_raw</span><span class="params">(struct nf_conntrack_tuple *tuple, struct net *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    get_random_once(&amp;nf_conntrack_hash_rnd, <span class="keyword">sizeof</span>(nf_conntrack_hash_rnd));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The direction must be ignored, so we hash everything up to the</span></span><br><span class="line"><span class="comment">     * destination ports (which is a multiple of 4) and treat the last three bytes manually.  */</span></span><br><span class="line">    u32 seed = nf_conntrack_hash_rnd ^ net_hash_mix(net);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = (<span class="keyword">sizeof</span>(tuple-&gt;src) + <span class="keyword">sizeof</span>(tuple-&gt;dst.u3)) / <span class="keyword">sizeof</span>(u32);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jhash2((u32 *)tuple, n, seed ^ ((tuple-&gt;dst.u.all &lt;&lt; <span class="number">16</span>) | tuple-&gt;dst.protonum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意其中是如何利用 tuple 的不同字段来计算哈希的。</p><p><code>nf_conntrack_tuple_hash</code> 是哈希表中的表项（value）:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_tuple.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每条连接在哈希表中都对应两项，分别对应两个方向（egress/ingress）</span></span><br><span class="line"><span class="comment">// Connections have two entries in the hash table: one for each way</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_node</span>   <span class="title">hnnode</span>;</span>   <span class="comment">// 指向该哈希对应的连接 struct nf_conn，采用 list 形式是为了解决哈希冲突</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> <span class="title">tuple</span>;</span>    <span class="comment">// N 元组，前面详细介绍过了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-5-struct-nf-conn-：连接（connection）"><a class="header-anchor" href="#3-5-struct-nf-conn-：连接（connection）">¶</a>3.5 <code>struct nf_conn {}</code>：连接（connection）</h2><p><strong>Netfilter 中每个 flow 都称为一个 connection</strong>，即使是对那些非面向连接的协议（例 如 UDP）。每个 connection 用 <code>struct nf_conn {}</code> 表示，主要字段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack.h</span></span><br><span class="line"></span><br><span class="line">                                                  <span class="comment">// include/linux/skbuff.h</span></span><br><span class="line">                                        ------&gt;   <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack</span> &#123;</span></span><br><span class="line">                                        |             <span class="keyword">atomic_t</span> use;  <span class="comment">// 连接引用计数？</span></span><br><span class="line">                                        |         &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> &#123;</span>                        |</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack</span>            <span class="title">ct_general</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> <span class="title">tuplehash</span>[<span class="title">IP_CT_DIR_MAX</span>];</span> <span class="comment">// 哈希表项，数组是因为要记录两个方向的 flow</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> status; <span class="comment">// 连接状态，见下文</span></span><br><span class="line">    u32 timeout;          <span class="comment">// 连接状态的定时器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">possible_net_t</span> ct_net;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>    <span class="title">nat_bysource</span>;</span></span><br><span class="line">                                                        <span class="comment">// per conntrack: protocol private data</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">master</span>;</span>                             <span class="keyword">union</span> nf_conntrack_proto &#123;</span><br><span class="line">                                                       /    <span class="comment">/* insert conntrack proto private data here */</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> mark;    <span class="comment">/* 对 skb 进行特殊标记 */</span>      /     <span class="class"><span class="keyword">struct</span> <span class="title">nf_ct_dccp</span> <span class="title">dccp</span>;</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> secmark;                               /      <span class="class"><span class="keyword">struct</span> <span class="title">ip_ct_sctp</span> <span class="title">sctp</span>;</span></span><br><span class="line">                                                    /       <span class="class"><span class="keyword">struct</span> <span class="title">ip_ct_tcp</span> <span class="title">tcp</span>;</span></span><br><span class="line">    <span class="keyword">union</span> nf_conntrack_proto proto; ----------&gt;----/        <span class="class"><span class="keyword">struct</span> <span class="title">nf_ct_gre</span> <span class="title">gre</span>;</span></span><br><span class="line">&#125;;                                                          <span class="keyword">unsigned</span> <span class="keyword">int</span> tmpl_padto;</span><br><span class="line">                                                        &#125;;</span><br></pre></td></tr></table></figure><p><strong>连接的状态集合 enum ip_conntrack_status</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// include/uapi/linux/netfilter/nf_conntrack_common.h</span><br><span class="line"></span><br><span class="line">enum ip_conntrack_status &#123;</span><br><span class="line">    IPS_EXPECTED      = (1 &lt;&lt; IPS_EXPECTED_BIT),</span><br><span class="line">    IPS_SEEN_REPLY    = (1 &lt;&lt; IPS_SEEN_REPLY_BIT),</span><br><span class="line">    IPS_ASSURED       = (1 &lt;&lt; IPS_ASSURED_BIT),</span><br><span class="line">    IPS_CONFIRMED     = (1 &lt;&lt; IPS_CONFIRMED_BIT),</span><br><span class="line">    IPS_SRC_NAT       = (1 &lt;&lt; IPS_SRC_NAT_BIT),</span><br><span class="line">    IPS_DST_NAT       = (1 &lt;&lt; IPS_DST_NAT_BIT),</span><br><span class="line">    IPS_NAT_MASK      = (IPS_DST_NAT | IPS_SRC_NAT),</span><br><span class="line">    IPS_SEQ_ADJUST    = (1 &lt;&lt; IPS_SEQ_ADJUST_BIT),</span><br><span class="line">    IPS_SRC_NAT_DONE  = (1 &lt;&lt; IPS_SRC_NAT_DONE_BIT),</span><br><span class="line">    IPS_DST_NAT_DONE  = (1 &lt;&lt; IPS_DST_NAT_DONE_BIT),</span><br><span class="line">    IPS_NAT_DONE_MASK = (IPS_DST_NAT_DONE | IPS_SRC_NAT_DONE),</span><br><span class="line">    IPS_DYING         = (1 &lt;&lt; IPS_DYING_BIT),</span><br><span class="line">    IPS_FIXED_TIMEOUT = (1 &lt;&lt; IPS_FIXED_TIMEOUT_BIT),</span><br><span class="line">    IPS_TEMPLATE      = (1 &lt;&lt; IPS_TEMPLATE_BIT),</span><br><span class="line">    IPS_UNTRACKED     = (1 &lt;&lt; IPS_UNTRACKED_BIT),</span><br><span class="line">    IPS_HELPER        = (1 &lt;&lt; IPS_HELPER_BIT),</span><br><span class="line">    IPS_OFFLOAD       = (1 &lt;&lt; IPS_OFFLOAD_BIT),</span><br><span class="line"></span><br><span class="line">    IPS_UNCHANGEABLE_MASK = (IPS_NAT_DONE_MASK | IPS_NAT_MASK |</span><br><span class="line">                 IPS_EXPECTED | IPS_CONFIRMED | IPS_DYING |</span><br><span class="line">                 IPS_SEQ_ADJUST | IPS_TEMPLATE | IPS_OFFLOAD),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-6-nf-conntrack-in-：进入连接跟踪"><a class="header-anchor" href="#3-6-nf-conntrack-in-：进入连接跟踪">¶</a>3.6 <code>nf_conntrack_in()</code>：进入连接跟踪</h2><p><img src="/public/2022/12/04/linux_network/conntrack_linux/netfilter-conntrack.png" alt></p><p>Fig. Netfilter 中的连接跟踪点</p><p>如上图所示，Netfilter 在四个 Hook 点对包进行跟踪：</p><ol><li><p><code>PRE_ROUTING</code> 和 <code>LOCAL_OUT</code>：<strong>调用 nf_conntrack_in() 开始连接跟踪</strong>， 正常情况下会创建一条新连接记录，然后将 conntrack entry 放到 <strong>unconfirmed list</strong>。</p><p>为什么是这两个 hook 点呢？因为它们都是<strong>新连接的第一个包最先达到的地方</strong>，</p><ul><li><code>PRE_ROUTING</code> 是<strong>外部主动和本机建连</strong>时包最先到达的地方</li><li><code>LOCAL_OUT</code> 是<strong>本机主动和外部建连</strong>时包最先到达的地方</li></ul></li><li><p><code>POST_ROUTING</code> 和 <code>LOCAL_IN</code>：<strong>调用 nf_conntrack_confirm() 将 nf_conntrack_in() 创建的连接移到 confirmed list</strong>。</p><p>同样要问，为什么在这两个 hook 点呢？因为如果新连接的第一个包没有被丢弃，那这 是它们<strong>离开 netfilter 之前的最后 hook 点</strong>：</p><ul><li><strong>外部主动和本机建连</strong>的包，如果在中间处理中没有被丢弃，<code>LOCAL_IN</code> 是其被送到应用（例如 nginx 服务）之前的最后 hook 点</li><li><strong>本机主动和外部建连</strong>的包，如果在中间处理中没有被丢弃，<code>POST_ROUTING</code> 是其离开主机时的最后 hook 点</li></ul></li></ol><p>下面的代码可以看到<strong>这些 handler 是如何注册到 Netfilter hook 点的</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_proto.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Connection tracking may drop packets, but never alters them, so make it the first hook.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> <span class="title">ipv4_conntrack_ops</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_conntrack_in,       <span class="comment">// 调用 nf_conntrack_in() 进入连接跟踪</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_PRE_ROUTING,     <span class="comment">// PRE_ROUTING hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_conntrack_local,    <span class="comment">// 调用 nf_conntrack_in() 进入连接跟踪</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_LOCAL_OUT,       <span class="comment">// LOCAL_OUT hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_confirm,            <span class="comment">// 调用 nf_conntrack_confirm()</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_POST_ROUTING,    <span class="comment">// POST_ROUTING hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK_CONFIRM,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_confirm,            <span class="comment">// 调用 nf_conntrack_confirm()</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_LOCAL_IN,        <span class="comment">// LOCAL_IN hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK_CONFIRM,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>nf_conntrack_in()</code> 是<strong>连接跟踪模块的核心</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">nf_conntrack_in(struct net *net, <span class="keyword">u_int8_t</span> pf, <span class="keyword">unsigned</span> <span class="keyword">int</span> hooknum, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">tmpl</span> = <span class="title">nf_ct_get</span>(<span class="title">skb</span>, &amp;<span class="title">ctinfo</span>);</span> <span class="comment">// 获取 skb 对应的 conntrack_info 和连接记录</span></span><br><span class="line">  <span class="keyword">if</span> (tmpl || ctinfo == IP_CT_UNTRACKED) &#123;        <span class="comment">// 如果记录存在，或者是不需要跟踪的类型</span></span><br><span class="line">      <span class="keyword">if</span> ((tmpl &amp;&amp; !nf_ct_is_template(tmpl)) || ctinfo == IP_CT_UNTRACKED) &#123;</span><br><span class="line">          NF_CT_STAT_INC_ATOMIC(net, ignore);     <span class="comment">// 无需跟踪的类型，增加 ignore 计数</span></span><br><span class="line">          <span class="keyword">return</span> NF_ACCEPT;                       <span class="comment">// 返回 NF_ACCEPT，继续后面的处理</span></span><br><span class="line">      &#125;</span><br><span class="line">      skb-&gt;_nfct = <span class="number">0</span>;                             <span class="comment">// 不属于 ignore 类型，计数器置零，准备后续处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_l4proto</span> *<span class="title">l4proto</span> = __<span class="title">nf_ct_l4proto_find</span>(...);</span>    <span class="comment">// 提取协议相关的 L4 头信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l4proto-&gt;error != <span class="literal">NULL</span>) &#123;                   <span class="comment">// skb 的完整性和合法性验证</span></span><br><span class="line">      <span class="keyword">if</span> (l4proto-&gt;error(net, tmpl, skb, dataoff, pf, hooknum) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          NF_CT_STAT_INC_ATOMIC(net, error);</span><br><span class="line">          NF_CT_STAT_INC_ATOMIC(net, invalid);</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">  <span class="comment">// 开始连接跟踪：提取 tuple；创建新连接记录，或者更新已有连接的状态</span></span><br><span class="line">  resolve_normal_ct(net, tmpl, skb, ... l4proto);</span><br><span class="line"></span><br><span class="line">  l4proto-&gt;packet(ct, skb, dataoff, ctinfo); <span class="comment">// 进行一些协议相关的处理，例如 UDP 会更新 timeout</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctinfo == IP_CT_ESTABLISHED_REPLY &amp;&amp; !test_and_set_bit(IPS_SEEN_REPLY_BIT, &amp;ct-&gt;status))</span><br><span class="line">      nf_conntrack_event_cache(IPCT_REPLY, ct);</span><br><span class="line">out:</span><br><span class="line">  <span class="keyword">if</span> (tmpl)</span><br><span class="line">      nf_ct_put(tmpl); <span class="comment">// 解除对连接记录 tmpl 的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致流程：</p><ol><li>尝试获取这个 skb 对应的连接跟踪记录</li><li>判断是否需要对这个包做连接跟踪，如果不需要，更新 ignore 计数（<code>conntrack -S</code> 能看到这个计数）， 返回 <code>NF_ACCEPT</code>；如果需要，就<strong>初始化这个 skb 的引用计数</strong>。</li><li>从包的 L4 header 中提取信息，初始化协议相关的 <code>struct nf_conntrack_l4proto {}</code> 变量，其中包含了该协议的<strong>连接跟踪相关的回调方法</strong>。</li><li>调用该协议的 <code>error()</code> 方法检查包的完整性、校验和等信息。</li><li>调用 <code>resolve_normal_ct()</code> <strong>开始连接跟踪</strong>，它会创建新 tuple，新 conntrack entry，或者更新已有连接的状态。</li><li>调用该协议的 <code>packet()</code> 方法进行一些协议相关的处理，例如对于 UDP，如果 status bit 里面设置了 <code>IPS_SEEN_REPLY</code> 位，就会更新 timeout。timeout 大小和协 议相关，越小越越可以防止 DoS 攻击（DoS 的基本原理就是将机器的可用连接耗尽）</li></ol><h2 id="3-7-init-conntrack-：创建新连接记录"><a class="header-anchor" href="#3-7-init-conntrack-：创建新连接记录">¶</a>3.7 <code>init_conntrack()</code>：创建新连接记录</h2><p>如果连接不存在（flow 的第一个包），<code>resolve_normal_ct()</code> 会调用 <code>init_conntrack</code> ，后者进而会调用 <code>new()</code> 方法创建一个新的 conntrack entry。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a new conntrack</span></span><br><span class="line"><span class="keyword">static</span> noinline <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> *</span></span><br><span class="line"><span class="class"><span class="title">init_conntrack</span>(<span class="title">struct</span> <span class="title">net</span> *<span class="title">net</span>, <span class="title">struct</span> <span class="title">nf_conn</span> *<span class="title">tmpl</span>,</span></span><br><span class="line"><span class="class">           <span class="title">const</span> <span class="title">struct</span> <span class="title">nf_conntrack_tuple</span> *<span class="title">tuple</span>,</span></span><br><span class="line"><span class="class">           <span class="title">const</span> <span class="title">struct</span> <span class="title">nf_conntrack_l4proto</span> *<span class="title">l4proto</span>,</span></span><br><span class="line"><span class="class">           <span class="title">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">dataoff</span>, <span class="title">u32</span> <span class="title">hash</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">ct</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 conntrack table 中分配一个 entry，如果哈希表满了，会在内核日志中打印</span></span><br><span class="line">    <span class="comment">// "nf_conntrack: table full, dropping packet" 信息，通过 `dmesg -T` 能看到</span></span><br><span class="line">    ct = __nf_conntrack_alloc(net, zone, tuple, &amp;repl_tuple, GFP_ATOMIC, hash);</span><br><span class="line"></span><br><span class="line">    l4proto-&gt;<span class="keyword">new</span>(ct, skb, dataoff); <span class="comment">// 协议相关的方法</span></span><br><span class="line"></span><br><span class="line">    local_bh_disable();             <span class="comment">// 关闭软中断</span></span><br><span class="line">    <span class="keyword">if</span> (net-&gt;ct.expect_count) &#123;</span><br><span class="line">        <span class="built_in">exp</span> = nf_ct_find_expectation(net, zone, tuple);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>) &#123;</span><br><span class="line">            <span class="comment">/* Welcome, Mr. Bond.  We've been expecting you... */</span></span><br><span class="line">            __set_bit(IPS_EXPECTED_BIT, &amp;ct-&gt;status);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* exp-&gt;master safe, refcnt bumped in nf_ct_find_expectation */</span></span><br><span class="line">            ct-&gt;master = <span class="built_in">exp</span>-&gt;master;</span><br><span class="line">            ct-&gt;mark = <span class="built_in">exp</span>-&gt;master-&gt;mark;</span><br><span class="line">            ct-&gt;secmark = <span class="built_in">exp</span>-&gt;master-&gt;secmark;</span><br><span class="line">            NF_CT_STAT_INC(net, expect_new);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now it is inserted into the unconfirmed list, bump refcount */</span></span><br><span class="line">    <span class="comment">// 至此这个新的 conntrack entry 已经被插入 unconfirmed list</span></span><br><span class="line">    nf_conntrack_get(&amp;ct-&gt;ct_general);</span><br><span class="line">    nf_ct_add_to_unconfirmed_list(ct);</span><br><span class="line"></span><br><span class="line">    local_bh_enable();              <span class="comment">// 重新打开软中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>-&gt;expectfn)</span><br><span class="line">            <span class="built_in">exp</span>-&gt;expectfn(ct, <span class="built_in">exp</span>);</span><br><span class="line">        nf_ct_expect_put(<span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每种协议需要实现自己的 <code>l4proto-&gt;new()</code> 方法，代码见：<code>net/netfilter/nf_conntrack_proto_*.c</code>。 例如 TCP 协议对应的 <code>new()</code> 方法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_proto_tcp.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called when a new connection for this protocol found. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">tcp_new</span><span class="params">(struct nf_conn *ct, <span class="keyword">const</span> struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> dataoff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (new_state == TCP_CONNTRACK_SYN_SENT) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;ct-&gt;proto.tcp, <span class="number">0</span>, <span class="keyword">sizeof</span>(ct-&gt;proto.tcp));</span><br><span class="line">        <span class="comment">/* SYN packet */</span></span><br><span class="line">        ct-&gt;proto.tcp.seen[<span class="number">0</span>].td_end = segment_seq_plus_len(ntohl(th-&gt;seq), skb-&gt;len, dataoff, th);</span><br><span class="line">        ct-&gt;proto.tcp.seen[<span class="number">0</span>].td_maxwin = ntohs(th-&gt;window);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前包会影响后面包的状态判断，<code>init_conntrack()</code> 会设置 <code>struct nf_conn</code> 的 <code>master</code> 字段。面向连接的协议会用到这个特性，例如 TCP。</p><h2 id="3-8-nf-conntrack-confirm-：确认包没有被丢弃"><a class="header-anchor" href="#3-8-nf-conntrack-confirm-：确认包没有被丢弃">¶</a>3.8 <code>nf_conntrack_confirm()</code>：确认包没有被丢弃</h2><p><code>nf_conntrack_in()</code> 创建的新 conntrack entry 会插入到一个 <strong>未确认连接</strong>（ unconfirmed connection）列表。</p><p>如果这个包之后没有被丢弃，那它在经过 <code>POST_ROUTING</code> 时会被 <code>nf_conntrack_confirm()</code> 方法处理，原理我们在分析过了 3.6 节的开头分析过了。 <code>nf_conntrack_confirm()</code> 完成之后，状态就变为了 <code>IPS_CONFIRMED</code>，并且连接记录从 <strong>未确认列表</strong>移到<strong>正常</strong>的列表。</p><p>之所以把创建一个新 entry 的过程分为创建（new）和确认（confirm）两个阶段 ，是因为<strong>包在经过 nf_conntrack_in() 之后，到达 nf_conntrack_confirm() 之前 ，可能会被内核丢弃</strong>。这样会导致系统残留大量的半连接状态记录，在性能和安全性上都 是很大问题。分为两步之后，可以加快半连接状态 conntrack entry 的 GC。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_core.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Confirm a connection: returns NF_DROP if packet must be dropped. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nf_conntrack_confirm</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">ct</span> = (<span class="title">struct</span> <span class="title">nf_conn</span> *)<span class="title">skb_nfct</span>(<span class="title">skb</span>);</span></span><br><span class="line">    <span class="keyword">int</span> ret = NF_ACCEPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ct) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nf_ct_is_confirmed(ct))</span><br><span class="line">            ret = __nf_conntrack_confirm(skb);</span><br><span class="line">        <span class="keyword">if</span> (likely(ret == NF_ACCEPT))</span><br><span class="line">            nf_ct_deliver_cached_events(ct);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>confirm 逻辑，省略了各种错误处理逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Confirm a connection given skb; places it in hash table */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__nf_conntrack_confirm(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">ct</span>;</span></span><br><span class="line">    ct = nf_ct_get(skb, &amp;ctinfo);</span><br><span class="line"></span><br><span class="line">    local_bh_disable();               <span class="comment">// 关闭软中断</span></span><br><span class="line"></span><br><span class="line">    hash = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;ct-&gt;tuplehash[IP_CT_DIR_REPLY].hnnode.pprev;</span><br><span class="line">    reply_hash = hash_conntrack(net, &amp;ct-&gt;tuplehash[IP_CT_DIR_REPLY].tuple);</span><br><span class="line"></span><br><span class="line">    ct-&gt;timeout += nfct_time_stamp;   <span class="comment">// 更新连接超时时间，超时后会被 GC</span></span><br><span class="line">    atomic_inc(&amp;ct-&gt;ct_general.use);  <span class="comment">// 设置连接引用计数？</span></span><br><span class="line">    ct-&gt;status |= IPS_CONFIRMED;      <span class="comment">// 设置连接状态为 confirmed</span></span><br><span class="line"></span><br><span class="line">    __nf_conntrack_hash_insert(ct, hash, reply_hash);  <span class="comment">// 插入到连接跟踪哈希表</span></span><br><span class="line"></span><br><span class="line">    local_bh_enable();                <span class="comment">// 重新打开软中断</span></span><br><span class="line"></span><br><span class="line">    nf_conntrack_event_cache(master_ct(ct) ? IPCT_RELATED : IPCT_NEW, ct);</span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>连接跟踪的处理逻辑中需要频繁关闭和打开软中断</strong>，此外还有各种锁， 这是短连高并发场景下连接跟踪性能损耗的主要原因？。</p><p>NAT 是与连接跟踪独立的模块。</p><h2 id="4-1-重要数据结构和函数"><a class="header-anchor" href="#4-1-重要数据结构和函数">¶</a>4.1 重要数据结构和函数</h2><p><strong>重要数据结构：</strong></p><p>支持 NAT 的协议需要实现其中的方法：</p><ul><li><code>struct nf_nat_l3proto {}</code></li><li><code>struct nf_nat_l4proto {}</code></li></ul><p><strong>重要函数：</strong></p><ul><li><code>nf_nat_inet_fn()</code>：NAT 的核心函数，在<strong>除 NF_INET_FORWARD 之外的其他 hook 点都会被调用</strong>。</li></ul><h2 id="4-2-NAT-模块初始化"><a class="header-anchor" href="#4-2-NAT-模块初始化">¶</a>4.2 NAT 模块初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_nat_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_hook</span> <span class="title">nat_hook</span> = &#123;</span></span><br><span class="line">    .parse_nat_setup    = nfnetlink_parse_nat_setup,</span><br><span class="line">    .decode_session        = __nf_nat_decode_session,</span><br><span class="line">    .manip_pkt        = nf_nat_manip_pkt,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">nf_nat_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nf_nat_bysource = nf_ct_alloc_hashtable(&amp;nf_nat_htable_size, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    nf_ct_helper_expectfn_register(&amp;follow_master_nat);</span><br><span class="line"></span><br><span class="line">    RCU_INIT_POINTER(nf_nat_hook, &amp;nat_hook);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">module_init(nf_nat_init);</span><br></pre></td></tr></table></figure><h2 id="4-3-struct-nf-nat-l3proto-：协议相关的-NAT-方法集"><a class="header-anchor" href="#4-3-struct-nf-nat-l3proto-：协议相关的-NAT-方法集">¶</a>4.3 <code>struct nf_nat_l3proto {}</code>：协议相关的 NAT 方法集</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_nat_l3proto.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_l3proto</span> &#123;</span></span><br><span class="line">    u8    l3proto; <span class="comment">// 例如，AF_INET</span></span><br><span class="line"></span><br><span class="line">    u32     (*secure_port    )(<span class="keyword">const</span> struct nf_conntrack_tuple *t, __be16);</span><br><span class="line">    <span class="keyword">bool</span>    (*manip_pkt      )(struct sk_buff *skb, ...);</span><br><span class="line">    <span class="keyword">void</span>    (*csum_update    )(struct sk_buff *skb, ...);</span><br><span class="line">    <span class="keyword">void</span>    (*csum_recalc    )(struct sk_buff *skb, u8 proto, ...);</span><br><span class="line">    <span class="keyword">void</span>    (*decode_session )(struct sk_buff *skb, ...);</span><br><span class="line">    <span class="keyword">int</span>     (*nlattr_to_range)(struct nlattr *tb[], struct nf_nat_range2 *range);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-4-struct-nf-nat-l4proto-：协议相关的-NAT-方法集"><a class="header-anchor" href="#4-4-struct-nf-nat-l4proto-：协议相关的-NAT-方法集">¶</a>4.4 <code>struct nf_nat_l4proto {}</code>：协议相关的 NAT 方法集</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_nat_l4proto.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_l4proto</span> &#123;</span></span><br><span class="line">    u8 l4proto; <span class="comment">// Protocol number，例如 IPPROTO_UDP, IPPROTO_TCP</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传入的 tuple 和 NAT 类型（SNAT/DNAT）修改包的 L3/L4 头</span></span><br><span class="line">    <span class="keyword">bool</span> (*manip_pkt)(struct sk_buff *skb, *l3proto, *tuple, maniptype);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个唯一的 tuple</span></span><br><span class="line">    <span class="comment">// 例如对于 UDP，会根据 src_ip, dst_ip, src_port 加一个随机数生成一个 16bit 的 dst_port</span></span><br><span class="line">    <span class="keyword">void</span> (*unique_tuple)(*l3proto, tuple, struct nf_nat_range2 *range, maniptype, struct nf_conn *ct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the address range is exhausted the NAT modules will begin to drop packets.</span></span><br><span class="line">    <span class="keyword">int</span> (*nlattr_to_range)(struct nlattr *tb[], struct nf_nat_range2 *range);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>各协议实现的方法，见：<code>net/netfilter/nf_nat_proto_*.c</code>。例如 TCP 的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_nat_proto_tcp.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_l4proto</span> <span class="title">nf_nat_l4proto_tcp</span> = &#123;</span></span><br><span class="line">    .l4proto        = IPPROTO_TCP,</span><br><span class="line">    .manip_pkt        = tcp_manip_pkt,</span><br><span class="line">    .in_range        = nf_nat_l4proto_in_range,</span><br><span class="line">    .unique_tuple        = tcp_unique_tuple,</span><br><span class="line">    .nlattr_to_range    = nf_nat_l4proto_nlattr_to_range,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-5-nf-nat-inet-fn-：进入-NAT"><a class="header-anchor" href="#4-5-nf-nat-inet-fn-：进入-NAT">¶</a>4.5 <code>nf_nat_inet_fn()</code>：进入 NAT</h2><p>NAT 的核心函数是 <code>nf_nat_inet_fn()</code>，它会在以下 hook 点被调用：</p><ul><li><code>NF_INET_PRE_ROUTING</code></li><li><code>NF_INET_POST_ROUTING</code></li><li><code>NF_INET_LOCAL_OUT</code></li><li><code>NF_INET_LOCAL_IN</code></li></ul><p>也就是除了 <code>NF_INET_FORWARD</code> 之外其他 hook 点都会被调用。</p><p><strong>在这些 hook 点的优先级</strong>：<strong>Conntrack &gt; NAT &gt; Packet Filtering</strong>。 <strong>连接跟踪的优先级高于 NAT</strong> 是因为 NAT 依赖连接跟踪的结果。</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/hook-to-nat.png" alt></p><p>Fig. NAT</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">nf_nat_inet_fn(<span class="keyword">void</span> *priv, struct sk_buff *skb, <span class="keyword">const</span> struct nf_hook_state *state)</span><br><span class="line">&#123;</span><br><span class="line">    ct = nf_ct_get(skb, &amp;ctinfo);</span><br><span class="line">    <span class="keyword">if</span> (!ct)    <span class="comment">// conntrack 不存在就做不了 NAT，直接返回，这也是我们为什么说 NAT 依赖 conntrack 的结果</span></span><br><span class="line">        <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line"></span><br><span class="line">    nat = nfct_nat(ct);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ctinfo) &#123;</span><br><span class="line">    <span class="keyword">case</span> IP_CT_RELATED:</span><br><span class="line">    <span class="keyword">case</span> IP_CT_RELATED_REPLY: <span class="comment">/* Only ICMPs can be IP_CT_IS_REPLY.  Fallthrough */</span></span><br><span class="line">    <span class="keyword">case</span> IP_CT_NEW: <span class="comment">/* Seen it before? This can happen for loopback, retrans, or local packets. */</span></span><br><span class="line">        <span class="keyword">if</span> (!nf_nat_initialized(ct, maniptype)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_entries</span> *<span class="title">e</span> = <span class="title">rcu_dereference</span>(<span class="title">lpriv</span>-&gt;<span class="title">entries</span>);</span> <span class="comment">// 获取所有 NAT 规则</span></span><br><span class="line">            <span class="keyword">if</span> (!e)</span><br><span class="line">                <span class="keyword">goto</span> null_bind;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e-&gt;num_hook_entries; i++) &#123; <span class="comment">// 依次执行 NAT 规则</span></span><br><span class="line">                <span class="keyword">if</span> (e-&gt;hooks[i].hook(e-&gt;hooks[i].priv, skb, state) != NF_ACCEPT )</span><br><span class="line">                    <span class="keyword">return</span> ret;                         <span class="comment">// 任何规则返回非 NF_ACCEPT，就停止当前处理</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nf_nat_initialized(ct, maniptype))</span><br><span class="line">                    <span class="keyword">goto</span> do_nat;</span><br><span class="line">            &#125;</span><br><span class="line">null_bind:</span><br><span class="line">            nf_nat_alloc_null_binding(ct, state-&gt;hook);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Already setup manip</span></span><br><span class="line">            <span class="keyword">if</span> (nf_nat_oif_changed(state-&gt;hook, ctinfo, nat, state-&gt;out))</span><br><span class="line">                <span class="keyword">goto</span> oif_changed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* ESTABLISHED */</span></span><br><span class="line">        <span class="keyword">if</span> (nf_nat_oif_changed(state-&gt;hook, ctinfo, nat, state-&gt;out))</span><br><span class="line">            <span class="keyword">goto</span> oif_changed;</span><br><span class="line">    &#125;</span><br><span class="line">do_nat:</span><br><span class="line">    <span class="keyword">return</span> nf_nat_packet(ct, ctinfo, state-&gt;hook, skb);</span><br><span class="line">oif_changed:</span><br><span class="line">    nf_ct_kill_acct(ct, ctinfo, skb);</span><br><span class="line">    <span class="keyword">return</span> NF_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查询 conntrack 记录，如果不存在，就意味着无法跟踪这个连接，那就更不可能做 NAT 了，因此直接返回。</p><p>如果找到了 conntrack 记录，并且是 <code>IP_CT_RELATED</code>、<code>IP_CT_RELATED_REPLY</code> 或 <code>IP_CT_NEW</code> 状态，就去获取 NAT 规则。如果没有规则，直接返回 <code>NF_ACCEPT</code>，对包不 做任何改动；如果有规则，最后执行 <code>nf_nat_packet</code>，这个函数会进一步调用 <code>manip_pkt</code> 完成对包的修改，如果失败，包将被丢弃。</p><h3 id="Masquerade"><a class="header-anchor" href="#Masquerade">¶</a>Masquerade</h3><p>NAT 模块</p><ul><li>一般配置方式：<code>Change IP1 to IP2 if matching XXX</code>。</li><li>高级配置方式：<code>Change IP1 to dev1's IP if matching XXX</code>，这种方式称为 Masquerade。</li></ul><p>Masquerade 优缺点：</p><ul><li>优点：<strong>当设备（网卡）的 IP 地址发生变化时，NAT 规则无需做任何修改</strong>。</li><li>缺点：<strong>性能比第一种方式要差</strong>。</li></ul><h2 id="4-6-nf-nat-packet-：执行-NAT"><a class="header-anchor" href="#4-6-nf-nat-packet-：执行-NAT">¶</a>4.6 <code>nf_nat_packet()</code>：执行 NAT</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_nat_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do packet manipulations according to nf_nat_setup_info. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">nf_nat_packet</span><span class="params">(struct nf_conn *ct, <span class="keyword">enum</span> ip_conntrack_info ctinfo,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">unsigned</span> <span class="keyword">int</span> hooknum, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> nf_nat_manip_type mtype = HOOK2MANIP(hooknum);</span><br><span class="line">    <span class="keyword">enum</span> ip_conntrack_dir dir = CTINFO2DIR(ctinfo);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> verdict = NF_ACCEPT;</span><br><span class="line"></span><br><span class="line">    statusbit = (mtype == NF_NAT_MANIP_SRC? IPS_SRC_NAT : IPS_DST_NAT)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dir == IP_CT_DIR_REPLY)     <span class="comment">// Invert if this is reply dir</span></span><br><span class="line">        statusbit ^= IPS_NAT_MASK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ct-&gt;status &amp; statusbit)     <span class="comment">// Non-atomic: these bits don't change. */</span></span><br><span class="line">        verdict = nf_nat_manip_pkt(skb, ct, mtype, dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> verdict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">nf_nat_manip_pkt</span><span class="params">(struct sk_buff *skb, struct nf_conn *ct,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">enum</span> nf_nat_manip_type mtype, <span class="keyword">enum</span> ip_conntrack_dir dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> <span class="title">target</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We are aiming to look like inverse of other direction. */</span></span><br><span class="line">    nf_ct_invert_tuplepr(&amp;target, &amp;ct-&gt;tuplehash[!dir].tuple);</span><br><span class="line"></span><br><span class="line">    l3proto = __nf_nat_l3proto_find(target.src.l3num);</span><br><span class="line">    l4proto = __nf_nat_l4proto_find(target.src.l3num, target.dst.protonum);</span><br><span class="line">    <span class="keyword">if</span> (!l3proto-&gt;manip_pkt(skb, <span class="number">0</span>, l4proto, &amp;target, mtype)) <span class="comment">// 协议相关处理</span></span><br><span class="line">        <span class="keyword">return</span> NF_DROP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-1-查看-加载-卸载-nf-conntrack-模块"><a class="header-anchor" href="#5-1-查看-加载-卸载-nf-conntrack-模块">¶</a>5.1 查看 / 加载 / 卸载 nf_conntrack 模块</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ modinfo nf_conntrack</span><br><span class="line">filename:       /lib/modules/5.15.0-46-generic/kernel/net/netfilter/nf_conntrack.ko</span><br><span class="line">license:        GPL</span><br><span class="line"><span class="built_in">alias</span>:          nf_conntrack-10</span><br><span class="line"><span class="built_in">alias</span>:          nf_conntrack-2</span><br><span class="line"><span class="built_in">alias</span>:          ip_conntrack</span><br><span class="line">srcversion:     30B45E5822722ACEDE23A4B</span><br><span class="line">depends:        nf_defrag_ipv6,libcrc32c,nf_defrag_ipv4</span><br><span class="line">retpoline:      Y</span><br><span class="line">intree:         Y</span><br><span class="line">name:           nf_conntrack</span><br><span class="line">vermagic:       5.15.0-46-generic SMP mod_unload modversions</span><br><span class="line">sig_id:         PKCS<span class="comment">#7</span></span><br><span class="line">signer:         Build time autogenerated kernel key</span><br><span class="line">sig_key:        17:6F:92:2F:58:6B:B2:28:13:DC:71:DC:5A:97:EE:BA:D8:4B:C7:DE</span><br><span class="line">sig_hashalgo:   sha512</span><br><span class="line">signature:      0B:32:AA:93:F4:31:52:9C:FE:0D:80:B4:F6:7C:30:63:4C:F6:03:AA:</span><br><span class="line">                ...</span><br><span class="line">                E9:1F:45:C6:77:C2:29:99:B4:3D:1A:D2</span><br><span class="line">parm:           tstamp:Enable connection tracking flow timestamping. (bool)</span><br><span class="line">parm:           acct:Enable connection tracking flow accounting. (bool)</span><br><span class="line">parm:           nf_conntrack_helper:Enable automatic conntrack helper assignment (default 0) (bool)</span><br><span class="line">parm:           expect_hashsize:uint</span><br><span class="line">parm:           enable_hooks:Always <span class="built_in">enable</span> conntrack hooks (bool)</span><br></pre></td></tr></table></figure><p>卸载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rmmod nf_conntrack_netlink nf_conntrack</span><br></pre></td></tr></table></figure><p>重新加载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ modprobe nf_conntrack</span><br><span class="line"></span><br><span class="line"># 加载时还可以指定额外的配置参数，例如：</span><br><span class="line">$ modprobe nf_conntrack nf_conntrack_helper=1 expect_hashsize=131072</span><br></pre></td></tr></table></figure><h2 id="5-2-sysctl-配置项"><a class="header-anchor" href="#5-2-sysctl-配置项">¶</a>5.2 sysctl 配置项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -a | grep nf_conntrack</span><br><span class="line">net.netfilter.nf_conntrack_acct = 0</span><br><span class="line">net.netfilter.nf_conntrack_buckets = 262144                 # hashsize = nf_conntrack_max/nf_conntrack_buckets</span><br><span class="line">net.netfilter.nf_conntrack_checksum = 1</span><br><span class="line">net.netfilter.nf_conntrack_count = 2148</span><br><span class="line">... # DCCP options</span><br><span class="line">net.netfilter.nf_conntrack_events = 1</span><br><span class="line">net.netfilter.nf_conntrack_expect_max = 1024</span><br><span class="line">... # IPv6 options</span><br><span class="line">net.netfilter.nf_conntrack_generic_timeout = 600</span><br><span class="line">net.netfilter.nf_conntrack_helper = 0</span><br><span class="line">net.netfilter.nf_conntrack_icmp_timeout = 30</span><br><span class="line">net.netfilter.nf_conntrack_log_invalid = 0</span><br><span class="line">net.netfilter.nf_conntrack_max = 1048576                    # conntrack table size</span><br><span class="line">... # SCTP options</span><br><span class="line">net.netfilter.nf_conntrack_tcp_be_liberal = 0</span><br><span class="line">net.netfilter.nf_conntrack_tcp_loose = 1</span><br><span class="line">net.netfilter.nf_conntrack_tcp_max_retrans = 3</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_close = 10</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_established = 21600</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_last_ack = 30</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_max_retrans = 300</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_syn_recv = 60</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_syn_sent = 120</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_unacknowledged = 300</span><br><span class="line">net.netfilter.nf_conntrack_timestamp = 0</span><br><span class="line">net.netfilter.nf_conntrack_udp_timeout = 30</span><br><span class="line">net.netfilter.nf_conntrack_udp_timeout_stream = 180</span><br></pre></td></tr></table></figure><h2 id="5-3-监控"><a class="header-anchor" href="#5-3-监控">¶</a>5.3 监控</h2><h3 id="丢包监控"><a class="header-anchor" href="#丢包监控">¶</a>丢包监控</h3><p><code>/proc/net/stat</code> 下面有一些关于 conntrack 的详细统计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/net/stat/nf_conntrack</span><br><span class="line">entries   searched found    new      invalid  ignore   delete   delete_list insert   insert_failed drop     early_drop icmp_error  expect_new expect_create expect_delete search_restart</span><br><span class="line">000008e3  00000000 00000000 00000000 0000309d 001e72d4 00000000 00000000    00000000 00000000      00000000 00000000   000000ee    00000000   00000000      00000000       000368d7</span><br><span class="line">000008e3  00000000 00000000 00000000 00007301 002b8e8c 00000000 00000000    00000000 00000000      00000000 00000000   00000170    00000000   00000000      00000000       00035794</span><br><span class="line">000008e3  00000000 00000000 00000000 00001eea 001e6382 00000000 00000000    00000000 00000000      00000000 00000000   00000059    00000000   00000000      00000000       0003f166</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此外，还可以用 <code>conntrack</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ conntrack -S</span><br><span class="line">cpu=0   found=0 invalid=743150 ignore=238069 insert=0 insert_failed=0 drop=195603 early_drop=118583 error=16 search_restart=22391652</span><br><span class="line">cpu=1   found=0 invalid=2004   ignore=402790 insert=0 insert_failed=0 drop=44371  early_drop=34890  error=0  search_restart=1225447</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>ignore：不需要做连接跟踪的包（回忆前面，只有特定协议的包才会做连接跟踪）</li></ul><h3 id="conntrack-table-使用量监控"><a class="header-anchor" href="#conntrack-table-使用量监控">¶</a>conntrack table 使用量监控</h3><p>可以定期采集系统的 conntrack 使用量，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_count</span><br><span class="line">257273</span><br></pre></td></tr></table></figure><p>并与最大值比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_max</span><br><span class="line">262144</span><br></pre></td></tr></table></figure><h2 id="6-1-连接太多导致-conntrack-table-被打爆"><a class="header-anchor" href="#6-1-连接太多导致-conntrack-table-被打爆">¶</a>6.1 连接太多导致 conntrack table 被打爆</h2><h3 id="现象"><a class="header-anchor" href="#现象">¶</a>现象</h3><h4 id="业务层（应用层）现象"><a class="header-anchor" href="#业务层（应用层）现象">¶</a>业务层（应用层）现象</h4><ol><li><p>存在随机、偶发的<strong>新建连接</strong>超时（connect timeout）。</p><p>例如，如果业务用的是 Java，那对应的是 <code>jdbc4.CommunicationsException</code> communications link failure 之类的错误。</p></li><li><p><strong>已有连接</strong>正常。</p><p>也就是没有 read timeout 或 write timeout 之类的报错，报错都集中为 connect timeout。</p></li></ol><h4 id="网络层现象"><a class="header-anchor" href="#网络层现象">¶</a>网络层现象</h4><ol><li><p>抓包会看到三次握手的<strong>第一个 SYN 包被宿主机静默丢弃了</strong>。</p><p>需要注意的是，常规的网卡统计（<code>ifconfig</code>）和内核统计（<code>/proc/net/softnet_stat</code>） <strong>无法反映出这些丢包</strong>。</p></li><li><p><code>1s+</code> 之后出发 SYN 重传，或者还没重传连接就关闭了。</p><p><strong>第一个 SYN 的重传是 1s，这个是内核代码里写死的，不可配置</strong>（具体实现见 <a href="#ch_8.1">附录</a>）。</p><p>再考虑到其他一些耗时，第一次重传的实际间隔要大于 1s。 如果客户端设置的超时时间很小，例如 <code>1.05s</code>，那可能来不及重传连接就被关闭了，然后向上层报 connect timeout 错误。</p></li></ol><h4 id="操作系统层现象"><a class="header-anchor" href="#操作系统层现象">¶</a>操作系统层现象</h4><p>内核日志中有如下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ demsg -T</span><br><span class="line">[Tue Apr  6 18:12:30 2021] nf_conntrack: nf_conntrack: table full, dropping packet</span><br><span class="line">[Tue Apr  6 18:12:30 2021] nf_conntrack: nf_conntrack: table full, dropping packet</span><br><span class="line">[Tue Apr  6 18:12:30 2021] nf_conntrack: nf_conntrack: table full, dropping packet</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>另外，<code>cat /proc/net/stat/nf_conntrack</code> 或 <code>conntrack -S</code> 能看到有 drop 统计。</p><h3 id="确认-conntrack-table-被打爆"><a class="header-anchor" href="#确认-conntrack-table-被打爆">¶</a>确认 conntrack table 被打爆</h3><p>遇到以上现象，基本就是 conntrack 表被打爆了。确认：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_count</span><br><span class="line">257273</span><br><span class="line"></span><br><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_max</span><br><span class="line">net.netfilter.nf_conntrack_max = 262144</span><br></pre></td></tr></table></figure><p>如果有 conntrack count 监控会看的更清楚，因为我们命令行查看时，高峰可能过了。</p><h3 id="解决方式"><a class="header-anchor" href="#解决方式">¶</a>解决方式</h3><p>优先级从高到低：</p><ol><li><p>调大 conntrack 表</p><p>运行时配置（经实际测试，<strong>不会对现有连接造成影响</strong>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.netfilter.nf_conntrack_max=524288</span><br><span class="line">$ sysctl -w net.netfilter.nf_conntrack_buckets=131072 # 推荐配置 hashsize=nf_conntrack_count/4</span><br></pre></td></tr></table></figure><p>持久化配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;net.netfilter.nf_conntrack_max = 524288&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">$ echo &apos;net.netfilter.nf_conntrack_buckets = 131072&apos; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>影响：连接跟踪模块<strong>会多用一些内存</strong>。具体多用多少内存，可参考 <a href="#ch_8.2">附录</a>。</p></li><li><p>减小 GC 时间</p><p>还可以调小 conntrack 的 GC（也叫 timeout）时间，加快过期 entry 的回收。</p><p><code>nf_conntrack</code> 针对不同 TCP 状态（established、fin_wait、time_wait 等）的 entry 有不同的 GC 时间。</p><p>例如，<strong>默认的 established 状态的 GC 时间是 423000s（5 天）</strong>。设置成这么长的 <strong>可能原因</strong>是：TCP/IP 协议中允许 established 状态的连接无限期不发送任何东西（但仍然活着） [8]，协议的具体实现（Linux、BSD、Windows 等）会设置各自允许的最大 idle timeout。为防止 GC 掉这样长时间没流量但实际还活着的连接，就设置一个足够保守的 timeout 时间。[8] 中建议这个值不小于 2 小时 4 分钟（作为对比和参考， <strong>Cilium 自己实现的 CT 中，默认 established GC 是 6 小时</strong>）。 但也能看到一些厂商推荐比这个小得多的配置，例如 20 分钟。</p><p>如果对自己的网络环境和需求非常清楚，那可以将这个时间调到一个合理的、足够小的值； 如果不是非常确定的话，还是<strong>建议保守一些，例如设置 6 个小时</strong> —— 这已经比默认值 5 天小多了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.netfilter.nf_conntrack_tcp_timeout_established = 21600</span><br></pre></td></tr></table></figure><p>持久化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;net.netfilter.nf_conntrack_tcp_timeout_established = 21600&apos; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>其他几个 timeout 值（尤其是 <code>nf_conntrack_tcp_timeout_time_wait</code>，默认 <code>120s</code>）也可以适当调小， 但还是那句话：<strong>如果不确定潜在后果，千万不要激进地调小</strong>。</p></li></ol><p>连接跟踪是一个非常基础且重要的网络模块，但只有在少数场景下才会引起普通开发者的注意。</p><p>例如，L4LB 短时高并发场景下，LB 节点每秒接受大量并发短连接，可能导致 conntrack table 被打爆。此时的现象是：</p><ul><li>客户端和 L4LB 建连失败，失败可能是随机的，也可能是集中在某些时间点。</li><li>客户端重试可能会成功，也可能会失败。</li><li>在 L4LB 节点抓包看，客户端过来的 TCP SYNC 包 L4LB 收到了，但没有回 ACK。即，包 被静默丢弃了（silently dropped）。</li></ul><p>此时的原因可能是 conntrack table 太小，也可能是 GC 不够及 时，甚至是 <a href="https://github.com/cilium/cilium/pull/12729" target="_blank" rel="noopener">GC 有 bug</a>。</p><h2 id="8-1-第一个-SYN-包的重传间隔计算（Linux-4-19-118-实现）"><a class="header-anchor" href="#8-1-第一个-SYN-包的重传间隔计算（Linux-4-19-118-实现）">¶</a>8.1 第一个 SYN 包的重传间隔计算（Linux 4.19.118 实现）</h2><p>调用路径：<code>tcp_connect() -&gt; tcp_connect_init() -&gt; tcp_timeout_init()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp_output.c</span></span><br><span class="line"><span class="comment">/* Do all connect socket setups that can be done AF independent. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcp_connect_init</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inet_csk(sk)-&gt;icsk_rto = tcp_timeout_init(sk);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/net/tcp.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u32 <span class="title">tcp_timeout_init</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取 SYN-RTO：如果这个 socket 上没有 BPF 程序，或者有 BPF 程序但执行失败，都返回 -1</span></span><br><span class="line">    <span class="comment">// 除非用户自己编写 BPF 程序并 attach 到 cgroup/socket，否则这里都是没有 BPF 的，因此这里返回 -1</span></span><br><span class="line">    timeout = tcp_call_bpf(sk, BPF_SOCK_OPS_TIMEOUT_INIT, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>)                <span class="comment">// timeout == -1，接下来使用默认值</span></span><br><span class="line">        timeout = TCP_TIMEOUT_INIT;  <span class="comment">// 宏定义，等于系统的 HZ 数，也就是 1 秒，见下面</span></span><br><span class="line">    <span class="keyword">return</span> timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/net/tcp.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_RTO_MAX    ((unsigned)(120*HZ))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_RTO_MIN    ((unsigned)(HZ/5))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_TIMEOUT_MIN    (2U) <span class="comment">/* Min timeout for TCP timers in jiffies */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_TIMEOUT_INIT ((unsigned)(1*HZ))    <span class="comment">/* RFC6298 2.1 initial RTO value    */</span></span></span><br></pre></td></tr></table></figure><h2 id="8-2-根据-nf-conntrack-max-计算-conntrack-模块所需的内存"><a class="header-anchor" href="#8-2-根据-nf-conntrack-max-计算-conntrack-模块所需的内存">¶</a>8.2 根据 nf_conntrack_max 计算 conntrack 模块所需的内存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/slabinfo | head -n2; cat /proc/slabinfo | grep conntrack</span><br><span class="line">slabinfo - version: 2.1</span><br><span class="line"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span><br><span class="line">nf_conntrack      512824 599505    320   51    4 : tunables    0    0    0 : slabdata  11755  11755      0</span><br></pre></td></tr></table></figure><p>其中的 <strong>objsize 表示这个内核对象</strong>（这里对应的是 <code>struct nf_conn</code>）的大小， 单位是<strong>字节</strong>，所以以上输出表明<strong>每个 conntrack entry 占用 320 字节的内存空间</strong>。</p><p>如果忽略内存碎片（内存分配单位为 slab），那<strong>不同 size 的 conntrack table 占用的内存</strong>如下：</p><ul><li><code>nf_conntrack_max=512K</code>: <code>512K * 320Byte = 160MB</code></li><li><code>nf_conntrack_max=1M</code>: <code>1M * 320Byte = 320MB</code></li></ul><p>更精确的计算，可以参考 [9]。</p><ol><li><a href="https://wiki.aalto.fi/download/attachments/69901948/netfilter-paper.pdf" target="_blank" rel="noopener">Netfilter connection tracking and NAT implementation</a>. Proc. Seminar on Network Protocols in Operating Systems, Dept. Commun. and Networking, Aalto Univ. 2013.</li><li><a href="https://docs.cilium.io/en/v1.7/gettingstarted/kubeproxy-free/" target="_blank" rel="noopener">Cilium: Kubernetes without kube-proxy</a></li><li><a href="chrome-extension://ijllcpnolfcooahcekpamkbidhejabll/blog/k8s-l4lb/" target="_blank" rel="noopener">L4LB for Kubernetes: Theory and Practice with Cilium+BGP+ECMP</a></li><li><a href="https://docs.docker.com/network/bridge/" target="_blank" rel="noopener">Docker bridge network mode</a></li><li><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Wikipedia: Netfilter</a></li><li><a href="https://blog.cloudflare.com/conntrack-tales-one-thousand-and-one-flows/" target="_blank" rel="noopener">Conntrack tales - one thousand and one flows</a></li><li><a href="https://www.redhat.com/en/blog/how-connection-tracking-open-vswitch-helps-openstack-performance" target="_blank" rel="noopener">How connection tracking in Open vSwitch helps OpenStack performance</a></li><li><a href="https://tools.ietf.org/html/rfc5382#section-5" target="_blank" rel="noopener">NAT Behavioral Requirements for TCP</a>, RFC5382</li><li><a href="https://johnleach.co.uk/posts/2009/06/17/netfilter-conntrack-memory-usage/" target="_blank" rel="noopener">Netfilter Conntrack Memory Usage</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#摘要&quot;&gt;¶&lt;/a&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文介绍连接跟踪（connection tracking，conntrack，CT）的原理，应用，及其在 Linux 内核中的实现。&lt;/p&gt;
&lt;p&gt;代码分析基于内核 &lt;code&gt;4.19&lt;/code&gt;。为使行文简洁，所贴代码只保留了核心逻辑，但都给出了代码 所在的源文件，如有需要请查阅。&lt;/p&gt;
&lt;p&gt;水平有限，文中不免有错误之处，欢迎指正交流。&lt;/p&gt;
&lt;p&gt;连接跟踪是许多网络应用的基础。例如，Kubernetes Service、ServiceMesh sidecar、 软件四层负载均衡器 LVS/IPVS、Docker network、OVS、iptables 主机防火墙等等，都依赖 连接跟踪功能。&lt;/p&gt;
    
    </summary>
    
      <category term="连接跟踪" scheme="https://talengu.github.io/public/categories/%E8%BF%9E%E6%8E%A5%E8%B7%9F%E8%B8%AA/"/>
    
    
      <category term="conntrack" scheme="https://talengu.github.io/public/tags/conntrack/"/>
    
  </entry>
  
  <entry>
    <title>「202211月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/11/26/test/202211_obsidian/"/>
    <id>https://talengu.github.io/public/2022/11/26/test/202211_obsidian/</id>
    <published>2022-11-26T16:00:04.000Z</published>
    <updated>2022-11-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 0 📅 : 0 🔖 : 0</p><a id="more"></a><h2 id="✅-0"><a class="header-anchor" href="#✅-0">¶</a>✅ : 0</h2><h2 id="📅-0"><a class="header-anchor" href="#📅-0">¶</a>📅 : 0</h2><h2 id="🔖-0"><a class="header-anchor" href="#🔖-0">¶</a>🔖 : 0</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 0 📅 : 0 🔖 : 0&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>「202211月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/11/15/test/202211/"/>
    <id>https://talengu.github.io/public/2022/11/15/test/202211/</id>
    <published>2022-11-15T16:00:04.000Z</published>
    <updated>2022-11-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 1</p><a id="more"></a><h2 id="🔖微软官方小工具更新，这些新特性你或许也能用得上"><a class="header-anchor" href="#🔖微软官方小工具更新，这些新特性你或许也能用得上">¶</a>🔖<a href="https://sspai.com/post/76649" target="_blank" rel="noopener">微软官方小工具更新，这些新特性你或许也能用得上</a></h2><p>pubdata:2022-11-06 03:40:00markdate:2022-11-17 17:18:09.571032</p><p><img src="/public/2022/11/15/test/202211/2022-11-17-171809571032.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 1&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>「202210月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/10/26/test/202210_obsidian/"/>
    <id>https://talengu.github.io/public/2022/10/26/test/202210_obsidian/</id>
    <published>2022-10-26T16:00:04.000Z</published>
    <updated>2022-10-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 0 📅 : 2 🔖 : 8</p><a id="more"></a><h2 id="✅-0"><a class="header-anchor" href="#✅-0">¶</a>✅ : 0</h2><h2 id="📅-2"><a class="header-anchor" href="#📅-2">¶</a>📅 : 2</h2><p>📅 转载一下-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>📅 tracker更新-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a></p><h2 id="🔖-8"><a class="header-anchor" href="#🔖-8">¶</a>🔖 : 8</h2><p>🔖肝下50万字的《Linux内核精通》笔记，你的底层原理水平将从入门到入魔【建议收藏】-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖计算机组成原理(万字爆肝整理)-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖 <a href="https://xiaolincoding.com/network/" target="_blank" rel="noopener">图解网络介绍</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>🔖 <a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener">常用设计模式有哪些？</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>🔖 智能家庭网关-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>🔖 <a href="https://sadh.life/post/builtins/" target="_blank" rel="noopener">Understanding all of Python, through its builtins</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>🔖 操作系统自学-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>🔖 机器人计划-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 0 📅 : 2 🔖 : 8&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>「202210月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/10/15/test/202210/"/>
    <id>https://talengu.github.io/public/2022/10/15/test/202210/</id>
    <published>2022-10-15T16:00:04.000Z</published>
    <updated>2022-10-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 2</p><a id="more"></a><h2 id="🔖一日一技｜Obsidian-Command-进阶用法三则"><a class="header-anchor" href="#🔖一日一技｜Obsidian-Command-进阶用法三则">¶</a>🔖<a href="https://sspai.com/post/75847" target="_blank" rel="noopener">一日一技｜Obsidian Command 进阶用法三则</a></h2><p>pubdata:2022-10-01 07:00:00markdate:2022-10-08 11:41:38.979766</p><p><img src="/public/2022/10/15/test/202210/2022-10-08-114138979766.jpg" alt="img"></p><h2 id="🔖用代码编辑器进行知识管理：我用-VSCode-构建自己的笔记系统"><a class="header-anchor" href="#🔖用代码编辑器进行知识管理：我用-VSCode-构建自己的笔记系统">¶</a>🔖<a href="https://sspai.com/post/75940" target="_blank" rel="noopener">用代码编辑器进行知识管理：我用 VSCode 构建自己的笔记系统</a></h2><p>pubdata:2022-09-28 03:29:57markdate:2022-10-09 04:14:05.692239</p><p><img src="/public/2022/10/15/test/202210/2022-10-09-041405692239.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 2&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>「202209月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/09/26/test/202209_obsidian/"/>
    <id>https://talengu.github.io/public/2022/09/26/test/202209_obsidian/</id>
    <published>2022-09-26T16:00:04.000Z</published>
    <updated>2022-09-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 0 📅 : 2 🔖 : 10</p><a id="more"></a><h2 id="✅-0"><a class="header-anchor" href="#✅-0">¶</a>✅ : 0</h2><h2 id="📅-2"><a class="header-anchor" href="#📅-2">¶</a>📅 : 2</h2><p>📅升级电脑-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W35.md">C日常/2022-W35.md</a><br>📅 添加rss-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a></p><h2 id="🔖-10"><a class="header-anchor" href="#🔖-10">¶</a>🔖 : 10</h2><p>🔖 <a href="https://www.appinn.com/umi-ocr/" target="_blank" rel="noopener">Umi-OCR - 免费的离线 OCR 文字识别软件[Windows] - 小众软件</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖 设计模式-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖 苏炳添向母校捐赠100万元！-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖 <a href="https://github.com/dlvhdr/gh-dash" target="_blank" rel="noopener">gh-dash</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖 <a href="https://nginxproxymanager.com/" target="_blank" rel="noopener">Nginx Proxy Manager</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖1、<a href="https://knots3d.com/knots/en_us/ALL" target="_blank" rel="noopener">Knots 3D</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>🔖 <a href="https://m.runoob.com/typescript/" target="_blank" rel="noopener">TypeScript 教程 | 菜鸟教程</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>🔖 <a href="https://m.runoob.com/js/" target="_blank" rel="noopener">Javascript 教程 | 菜鸟教程</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>🔖 Makefile-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>🔖 <a href="https://www.zhihu.com/question/450738311/answer/2635126508?utm_medium=social&amp;utm_oi=619610399826382848&amp;utm_psn=1545021439438381056&amp;utm_source=ZHShareTargetIDMore" target="_blank" rel="noopener">windows 有什么好用的截图软件？ - 知乎</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 0 📅 : 2 🔖 : 10&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「202209月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/09/15/test/202209/"/>
    <id>https://talengu.github.io/public/2022/09/15/test/202209/</id>
    <published>2022-09-15T16:00:04.000Z</published>
    <updated>2022-09-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 3</p><a id="more"></a><h2 id="🔖WireGuard-基础教程：wg-quick-路由策略解读"><a class="header-anchor" href="#🔖WireGuard-基础教程：wg-quick-路由策略解读">¶</a>🔖<a href="https://icloudnative.io/posts/linux-routing-of-wireguard/" target="_blank" rel="noopener">WireGuard 基础教程：wg-quick 路由策略解读</a></h2><p>pubdata:2022-08-31 01:06:37markdate:2022-09-03 06:23:25.656749</p><p><img src="/public/2022/09/15/test/202209/2022-09-03-062325656749.jpg" alt="img"></p><h2 id="🔖微软官方超实用-15-小工具集-PowerToys-v0-62-0-发布，新增文本提取器-OCR-功能"><a class="header-anchor" href="#🔖微软官方超实用-15-小工具集-PowerToys-v0-62-0-发布，新增文本提取器-OCR-功能">¶</a>🔖<a href="https://www.appinn.com/powertoys-v0-62-0/" target="_blank" rel="noopener">微软官方超实用 15+ 小工具集 PowerToys v0.62.0 发布，新增文本提取器 OCR 功能</a></h2><p>pubdata:2022-09-07 04:11:14markdate:2022-09-08 04:19:59.942860</p><p><img src="/public/2022/09/15/test/202209/2022-09-08-041959942860.jpg" alt="img"></p><h2 id="🔖Stream-Deck-太贵了？触屏音箱也能成为你的直播助手"><a class="header-anchor" href="#🔖Stream-Deck-太贵了？触屏音箱也能成为你的直播助手">¶</a>🔖<a href="https://sspai.com/post/75789" target="_blank" rel="noopener">Stream Deck 太贵了？触屏音箱也能成为你的直播助手</a></h2><p>pubdata:2022-09-19 06:31:44markdate:2022-09-21 03:28:05.514939</p><p><img src="/public/2022/09/15/test/202209/2022-09-21-032805514939.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 3&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「202208月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/08/26/test/202208_obsidian/"/>
    <id>https://talengu.github.io/public/2022/08/26/test/202208_obsidian/</id>
    <published>2022-08-26T16:00:04.000Z</published>
    <updated>2022-08-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 1 📅 : 1 🔖 : 26</p><a id="more"></a><h2 id="✅-1"><a class="header-anchor" href="#✅-1">¶</a>✅ : 1</h2><p>✅自动生成rss月报-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a></p><h2 id="📅-1"><a class="header-anchor" href="#📅-1">¶</a>📅 : 1</h2><p>📅 加上地区统计-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a></p><h2 id="🔖-26"><a class="header-anchor" href="#🔖-26">¶</a>🔖 : 26</h2><p>🔖 <a href="https://github.com/serhack/pdf-diff" target="_blank" rel="noopener">GitHub - serhack/pdf-diff: A tool for visualizing differences between two pdf files.</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="http://arthurchiao.art/blog/conntrack-design-and-implementation-zh/" target="_blank" rel="noopener">连接跟踪（conntrack）：原理、应用及 Linux 内核实现</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="https://codemirror.net/docs/guide/" target="_blank" rel="noopener">CodeMirror System Guide</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/357334969?utm_id=0" target="_blank" rel="noopener">mac使用VNC远程访问Ubuntu图形界面</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="https://mp.weixin.qq.com/s/FBJ_GIvdwNbvGKVKeroZjA" target="_blank" rel="noopener">冠军私教课</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="https://cloud.tencent.com/developer/article/1585686" target="_blank" rel="noopener">如何统计 Hexo 网站的访问地区和IP - 腾讯云开发者社区-腾讯云</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="https://www.appinn.com/navidrome/" target="_blank" rel="noopener">Navidrome - 开源音乐服务器，自建云端音乐播放器 - 小众软件</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W30.md">C日常/2022-W30.md</a><br>🔖 <a href="https://sspai.com/post/73443" target="_blank" rel="noopener">力量训练：办卡之前需要了解的训练基础与细节制定 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W30.md">C日常/2022-W30.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/495262462" target="_blank" rel="noopener">网站低代码开发</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖长大后，如果是时间修剪了我们的好奇心，我们应该责怪时间吗？-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖半导体行业的组成-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖Weylus – 共享屏幕，将平板作为电脑触摸屏使用[Win/macOS/Linux]-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖跨平台开发 <a href="https://beeware.org/" target="_blank" rel="noopener">BeeWare</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖资本论复旦大学-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 Linux三剑客-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖pdf补丁丁-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://www.wdbyte.com/java/char-image.html_1-%E5%AD%97%E7%AC%A6%E5%9B%BE%E6%A1%88%E6%80%9D%E8%B7%AF" target="_blank" rel="noopener">字符作画，我用字符画个冰墩墩 | 未读代码</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/474337723?utm_source=ZHShareTargetIDMore&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">一文让你读懂Linux五大模块内核源码，内核整体架构设计（超详细）</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/483731291?utm_source=ZHShareTargetIDMore&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">学习数学思维推荐阅读的五本数学书籍</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖Snapdrop for Android – 在电脑与 Android 手机间互传文件-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖Photoview – 支持人脸识别的开源、自托管本地相册-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖GitHub - LibrePhotos/librephotos: A self-hosted open source photo management service. This is the repository of the backend.-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://www.cnblogs.com/imxiaobei/p/13619630.html" target="_blank" rel="noopener">一文搞懂后台高性能服务器设计的常见套路, BAT 高频面试系列 - 编程指北 - 博客园</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://www.appinn.com/dual-subtitles/" target="_blank" rel="noopener">YouTube™ 双字幕 - 显示双语字幕（包括自动翻译）、字幕下载，以及自定义字幕样式[Chrome/Edge] - 小众软件</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://mp.weixin.qq.com/s/cd-uS5NDIreT02GaHpdxlw" target="_blank" rel="noopener">一文搞懂WiFi的所有知识点</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/122523174" target="_blank" rel="noopener">Doxygen 中文文档</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 1 📅 : 1 🔖 : 26&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「202208月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/08/15/test/202208/"/>
    <id>https://talengu.github.io/public/2022/08/15/test/202208/</id>
    <published>2022-08-15T16:00:04.000Z</published>
    <updated>2022-08-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 5</p><a id="more"></a><h2 id="🔖AVNC-–-Android-上的开源-VNC-客户端"><a class="header-anchor" href="#🔖AVNC-–-Android-上的开源-VNC-客户端">¶</a>🔖<a href="https://www.appinn.com/avnc-for-android/" target="_blank" rel="noopener">AVNC – Android 上的开源 VNC 客户端</a></h2><p>pubdata:2022-08-07 04:59:52markdate:2022-08-07 17:42:37.878979</p><p><img src="/public/2022/08/15/test/202208/2022-08-07-174237878979.jpg" alt="img"></p><h2 id="🔖TigerVNC-–-高性能、跨平台开源-VNC-服务器与客户端"><a class="header-anchor" href="#🔖TigerVNC-–-高性能、跨平台开源-VNC-服务器与客户端">¶</a>🔖<a href="https://www.appinn.com/tigervnc/" target="_blank" rel="noopener">TigerVNC – 高性能、跨平台开源 VNC 服务器与客户端</a></h2><p>pubdata:2022-08-08 04:30:32markdate:2022-08-09 00:48:54.680756</p><p><img src="/public/2022/08/15/test/202208/2022-08-09-004854680756.jpg" alt="img"></p><h2 id="🔖Notion-又一开源替代品，诞生了！"><a class="header-anchor" href="#🔖Notion-又一开源替代品，诞生了！">¶</a>🔖<a href="https://zhuanlan.zhihu.com/p/552965032" target="_blank" rel="noopener">Notion 又一开源替代品，诞生了！</a></h2><p>pubdata:2022-08-12 04:42:26markdate:2022-08-13 16:16:00.234349</p><p><img src="/public/2022/08/15/test/202208/2022-08-13-161600234349.jpg" alt="img"></p><h2 id="🔖如何写一份高可读性的软件工程设计文档"><a class="header-anchor" href="#🔖如何写一份高可读性的软件工程设计文档">¶</a>🔖<a href="https://zhuanlan.zhihu.com/p/552095835" target="_blank" rel="noopener">如何写一份高可读性的软件工程设计文档</a></h2><p>pubdata:2022-08-10 09:00:14markdate:2022-08-20 02:27:47.773301</p><p><img src="/public/2022/08/15/test/202208/2022-08-20-022747773301.jpg" alt="img"></p><h2 id="🔖StrokesPlus-net-–-一款很厉害的鼠标手势软件，还有大佬汉化、以及持续更新脚本"><a class="header-anchor" href="#🔖StrokesPlus-net-–-一款很厉害的鼠标手势软件，还有大佬汉化、以及持续更新脚本">¶</a>🔖<a href="https://www.appinn.com/strokesplus-net/" target="_blank" rel="noopener">StrokesPlus.net – 一款很厉害的鼠标手势软件，还有大佬汉化、以及持续更新脚本</a></h2><p>pubdata:2022-08-24 04:29:23markdate:2022-08-25 03:51:08.820884</p><p><img src="/public/2022/08/15/test/202208/2022-08-25-035108820884.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 5&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「202207月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/07/26/test/202207_obsidian/"/>
    <id>https://talengu.github.io/public/2022/07/26/test/202207_obsidian/</id>
    <published>2022-07-26T16:00:04.000Z</published>
    <updated>2022-07-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 6 📅 : 3 🔖 : 47</p><a id="more"></a><h2 id="✅-6"><a class="header-anchor" href="#✅-6">¶</a>✅ : 6</h2><p>✅目标图标系统-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>✅ <a href="https://blog.csdn.net/hhhhhyyyyy8/article/details/102133863" target="_blank" rel="noopener">Linux内核数据包bridge上转发流程_hhhhhyyyyy8的博客-CSDN博客_br_multicast_flood</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>✅ 邮箱转rss-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a><br>✅  hacker news rss添加-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a><br>✅ 经济学人转载leader文章-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a><br>✅ github博客评论系统是否换成【不换】-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a></p><h2 id="📅-3"><a class="header-anchor" href="#📅-3">¶</a>📅 : 3</h2><p>📅 端口触发 端口转发-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>📅 全屋智能-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>📅 改进-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a></p><h2 id="🔖-47"><a class="header-anchor" href="#🔖-47">¶</a>🔖 : 47</h2><p>🔖 ish保持后台运行-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>🔖 <a href="https://www.jianshu.com/p/f29ca723db4f" target="_blank" rel="noopener">Git 运行配置（git config、gitk、git gui） - michael_jia - 简书</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>🔖<a href="https://www.cnblogs.com/xuanbjut/p/12624702.html" target="_blank" rel="noopener">wmctrl像xmonad那样方便地用快捷键来控制任务窗口的显示 - pycod - 博客园</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>🔖 <a href="https://blog.csdn.net/anlian523/article/details/113627568" target="_blank" rel="noopener">VSCode复制代码时去掉样式/语法高亮/代码高亮/黑色背景_anlian523的博客-CSDN博客_idea复制代码不带黑色背景</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>🔖 <a href="https://blog.csdn.net/dog250/article/details/121400218" target="_blank" rel="noopener">为什么除法，开方，求对数比乘法，乘方，求指数更难_dog250的博客-CSDN博客</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖学习小林博客的写法-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖一万字统计学梳理-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖腾讯 彻底搞清楚tcp-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖0x5f3759df这个快速开方中的常数的数学依据是什么？-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖https流程-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖使用 Clion + QEMU/GDB 远程调试Linux内核（分享自知乎网）<a href="https://zhuanlan.zhihu.com/p/412604505?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/412604505?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖TCP/IP协议到底在讲什么？ <a href="http://www.zhihu.com/question/51074319?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">http://www.zhihu.com/question/51074319?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【什么是动态规划（Dynamic Programming）？动态规划的意义是什么？】阮行止：… <a href="https://www.zhihu.com/question/23995189/answer/613096905?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/23995189/answer/613096905?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【为什么有人说弄懂了《算法导论》的 90%，就超越了 90%的程序员？】启舰：… <a href="https://www.zhihu.com/question/315201616/answer/1960517601?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/315201616/answer/1960517601?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【vs code】【keil】优雅地使用vs code代替keil。by 童话与云 👉 <a href="https://www.zhihu.com/zvideo/1422934459457253376?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/zvideo/1422934459457253376?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖图解网络 - 75张图带你了解网络设备、网络地址规划、静态路由、实战演练（分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖vscode-journal：vscode中写日记/便签/提醒，配合nutstore与安卓、ios同步_TeQuL的博客-CSDN博客-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖结构体（结构体嵌套、结构体指针、结构体参数传递） - 蓝海人 - 博客园-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖Feedme - 8大 RSS 阅读器第三方客户端[Android] - 小众软件-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖聪明人必学的停车小技巧！。by Felicidades 👉 <a href="https://www.zhihu.com/zvideo/1414008107094093824?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/zvideo/1414008107094093824?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖在线 DOS 游戏 - 近 2000 款怀旧游戏，仙剑、红警、三国志、大富翁、明星志愿、大航海、主题医院等 - 小众软件-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖Feeddd · 重新掌控你的订阅源-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【如何长时间高效学习？】硬核学长2077：… <a href="https://www.zhihu.com/question/28358499/answer/1762418904?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/28358499/answer/1762418904?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【你身边的学霸都有怎样的学习方法或习惯？】硬核学长2077：… <a href="https://www.zhihu.com/question/54265751/answer/1995587976?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/54265751/answer/1995587976?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【如何不痛苦地早起？】铁木君：… <a href="https://www.zhihu.com/question/22120300/answer/1887544838?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/22120300/answer/1887544838?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖[[obsidian_tips]]-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖<a href="https://sspai.com/post/72757" target="_blank" rel="noopener">随时可用的 PC 体验是这样「炼」成的，Windows 新版睡眠机制详解 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖<a href="https://blog.csdn.net/who538592/article/details/79483323" target="_blank" rel="noopener">TC流量控制_who538592的博客-CSDN博客_tc流量控制</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖 <a href="https://sspai.com/post/74090" target="_blank" rel="noopener">大家都说好的蛋白粉，我们应该如何取舍 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/508345279" target="_blank" rel="noopener">我的obsidian插件开发的学习过程</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>🔖 <a href="https://blog.csdn.net/Haywardwang/article/details/108626491" target="_blank" rel="noopener">python 词云构建_Haywardwang的博客-CSDN博客</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>🔖 <a href="https://blog.csdn.net/weixin_56842628/article/details/117921526?utm_medium=distribute.wap_relevant.none-task-blog-2~default~baidujs_title~default-9-117921526-blog-108626491.wap_blog_relevant_default&amp;spm=1001.2101.3001.4242.6&amp;utm_relevant_index=10" target="_blank" rel="noopener">如何用Python制作简单又好看的词云？来瞅瞅吧~_小熊爱Python的博客-CSDN博客_python词云代码简单</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>🔖 <a href="https://sspai.com/post/73779" target="_blank" rel="noopener">跨时空圆桌：伟大创作者们如何安排日常生活 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://www.appinn.com/typing-learner/" target="_blank" rel="noopener">Typing Learner - 硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」[Windows/macOS] - 小众软件</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://www.zhihu.com/question/391756708/answer/2556173863" target="_blank" rel="noopener">SpaceX的可回收火箭有什么神奇之处，为何其他航天大国还不能仿造？ - YY硕 的回答 - 知乎</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://mp.weixin.qq.com/s/KBKO4C1d4CkyHAPEkh8D4Q" target="_blank" rel="noopener">这几个通信协议的动图不错</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://oorkan.medium.com/emojifying-your-linux-terminal-9a5c1e8f6b3c" target="_blank" rel="noopener">Emojifying your Linux terminal  🚀</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://sspai.com/post/74167" target="_blank" rel="noopener">为 WSL 配置这些新功能，不用虚拟机也能体验完整 Linux - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖<a href="https://sspai.com/post/72274" target="_blank" rel="noopener">意识先行，工具辅助：谈谈我们该怎样分辨虚假信息</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖<a href="https://zhuanlan.zhihu.com/p/495262462" target="_blank" rel="noopener">网站低代码开发</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 学习体系化，效率提升-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://sspai.com/post/73958" target="_blank" rel="noopener">玩转 Obsidian 08：利用 Dataview 打造自动化 HomePage - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>🔖 <a href="https://post.m.smzdm.com/p/adwgg2rd/" target="_blank" rel="noopener">小爱同学，打开我的三菱空调——米家空调伴侣2使用分享_智能家居_什么值得买</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>🔖 <a href="https://sspai.com/post/73829" target="_blank" rel="noopener">用 59 分钟，找到工具的效率之源 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>🔖 <a href="https://cloud.tencent.com/developer/article/1879646" target="_blank" rel="noopener">tcpdump是在哪儿抓到的包？ - 腾讯云开发者社区-腾讯云</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>🔖 <a href="https://www.jianshu.com/p/79bcf09aed25" target="_blank" rel="noopener">IPTables五----ebtables - marshalzxy - 简书</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>🔖 <a href="https://david-waiting.medium.com/a-beginners-guide-to-generic-routing-encapsulation-fb2b4fb63abb" target="_blank" rel="noopener">A Beginner’s Guide to Generic Routing Encapsulation</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 6 📅 : 3 🔖 : 47&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「202207月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/07/15/test/202207/"/>
    <id>https://talengu.github.io/public/2022/07/15/test/202207/</id>
    <published>2022-07-15T16:00:04.000Z</published>
    <updated>2022-07-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 13</p><a id="more"></a><h2 id="🔖BGmi-–-自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人"><a class="header-anchor" href="#🔖BGmi-–-自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人">¶</a>🔖<a href="https://www.appinn.com/bgmi/" target="_blank" rel="noopener">BGmi – 自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人</a></h2><p>pubdata:2022-06-30 02:48:00markdate:2022-07-01 06:32:58.020141</p><p><img src="/public/2022/07/15/test/202207/2022-07-01-063258020141.jpg" alt="img"></p><h2 id="🔖老牌截图工具-PicPick-更新，新增录屏功能，支持-MP4-GIF-格式"><a class="header-anchor" href="#🔖老牌截图工具-PicPick-更新，新增录屏功能，支持-MP4-GIF-格式">¶</a>🔖<a href="https://www.appinn.com/picpick-6-2/" target="_blank" rel="noopener">老牌截图工具 PicPick 更新，新增录屏功能，支持 MP4/GIF 格式</a></h2><p>pubdata:2022-06-29 07:19:19markdate:2022-07-02 04:11:20.453414</p><p><img src="/public/2022/07/15/test/202207/2022-07-02-041120453414.jpg" alt="img"></p><h2 id="🔖白板与笔记融合：我的四个氢图使用场景"><a class="header-anchor" href="#🔖白板与笔记融合：我的四个氢图使用场景">¶</a>🔖<a href="https://sspai.com/post/73246" target="_blank" rel="noopener">白板与笔记融合：我的四个氢图使用场景</a></h2><p>pubdata:2022-06-30 03:30:02markdate:2022-07-03 01:08:35.583781</p><p><img src="/public/2022/07/15/test/202207/2022-07-03-010835583781.jpg" alt="img"></p><h2 id="🔖跨时空圆桌：伟大创作者们如何安排日常生活"><a class="header-anchor" href="#🔖跨时空圆桌：伟大创作者们如何安排日常生活">¶</a>🔖<a href="https://sspai.com/post/73779" target="_blank" rel="noopener">跨时空圆桌：伟大创作者们如何安排日常生活</a></h2><p>pubdata:2022-06-15 09:30:00markdate:2022-07-03 01:50:35.971655</p><p><img src="/public/2022/07/15/test/202207/2022-07-03-015035971655.jpg" alt="img"></p><h2 id="🔖Typing-Learner-–-硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」-Windows-macOS"><a class="header-anchor" href="#🔖Typing-Learner-–-硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」-Windows-macOS">¶</a>🔖<a href="https://www.appinn.com/typing-learner/" target="_blank" rel="noopener">Typing Learner – 硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」[Windows/macOS]</a></h2><p>pubdata:2022-07-03 04:07:39markdate:2022-07-04 05:06:58.902152</p><p><img src="/public/2022/07/15/test/202207/2022-07-04-050658902152.jpg" alt="img"></p><h2 id="🔖创建自己的第一个-Power-Automate-工作流，从此繁琐操作是路人"><a class="header-anchor" href="#🔖创建自己的第一个-Power-Automate-工作流，从此繁琐操作是路人">¶</a>🔖<a href="https://sspai.com/post/73710" target="_blank" rel="noopener">创建自己的第一个 Power Automate 工作流，从此繁琐操作是路人</a></h2><p>pubdata:2022-07-05 10:44:47markdate:2022-07-06 11:29:55.648077</p><p><img src="/public/2022/07/15/test/202207/2022-07-06-112955648077.jpg" alt="img"></p><h2 id="🔖为-WSL-配置这些新功能，不用虚拟机也能体验完整-Linux"><a class="header-anchor" href="#🔖为-WSL-配置这些新功能，不用虚拟机也能体验完整-Linux">¶</a>🔖<a href="https://sspai.com/post/74167" target="_blank" rel="noopener">为 WSL 配置这些新功能，不用虚拟机也能体验完整 Linux</a></h2><p>pubdata:2022-07-08 03:30:00markdate:2022-07-09 03:08:43.747852</p><p><img src="/public/2022/07/15/test/202207/2022-07-09-030843747852.jpg" alt="img"></p><h2 id="🔖当飞盘成为人类的玩具，我们该如何参与这场游戏"><a class="header-anchor" href="#🔖当飞盘成为人类的玩具，我们该如何参与这场游戏">¶</a>🔖<a href="https://sspai.com/post/73505" target="_blank" rel="noopener">当飞盘成为人类的玩具，我们该如何参与这场游戏</a></h2><p>pubdata:2022-06-06 08:00:00markdate:2022-07-10 01:36:40.114938</p><p><img src="/public/2022/07/15/test/202207/2022-07-10-013640114938.jpg" alt="img"></p><h2 id="🔖走进小众但不冷门的房车世界"><a class="header-anchor" href="#🔖走进小众但不冷门的房车世界">¶</a>🔖<a href="https://sspai.com/post/74043" target="_blank" rel="noopener">走进小众但不冷门的房车世界</a></h2><p>pubdata:2022-07-01 08:04:43markdate:2022-07-10 02:09:34.733003</p><p><img src="/public/2022/07/15/test/202207/2022-07-10-020934733003.jpg" alt="img"></p><h2 id="🔖从盲目崇拜到理性使用，谈谈我眼中的「双向链接」"><a class="header-anchor" href="#🔖从盲目崇拜到理性使用，谈谈我眼中的「双向链接」">¶</a>🔖<a href="https://sspai.com/post/73407" target="_blank" rel="noopener">从盲目崇拜到理性使用，谈谈我眼中的「双向链接」</a></h2><p>pubdata:2022-05-27 06:31:27markdate:2022-07-11 14:31:37.724795</p><p><img src="/public/2022/07/15/test/202207/2022-07-11-143137724795.jpg" alt="img"></p><h2 id="🔖打开终端总有好心情：我的美化方案及配置分享"><a class="header-anchor" href="#🔖打开终端总有好心情：我的美化方案及配置分享">¶</a>🔖<a href="https://sspai.com/post/74216" target="_blank" rel="noopener">打开终端总有好心情：我的美化方案及配置分享</a></h2><p>pubdata:2022-07-11 08:00:51markdate:2022-07-12 04:52:00.122103</p><p><img src="/public/2022/07/15/test/202207/2022-07-12-045200122103.jpg" alt="img"></p><h2 id="🔖咖啡美酒冷泡茶，这些消暑饮品在家就能动手做"><a class="header-anchor" href="#🔖咖啡美酒冷泡茶，这些消暑饮品在家就能动手做">¶</a>🔖<a href="https://sspai.com/post/74196" target="_blank" rel="noopener">咖啡美酒冷泡茶，这些消暑饮品在家就能动手做</a></h2><p>pubdata:2022-07-10 07:17:11markdate:2022-07-12 05:03:55.504330</p><p><img src="/public/2022/07/15/test/202207/2022-07-12-050355504330.jpg" alt="img"></p><h2 id="🔖语雀，即将开源！"><a class="header-anchor" href="#🔖语雀，即将开源！">¶</a>🔖<a href="https://zhuanlan.zhihu.com/p/540713275" target="_blank" rel="noopener">语雀，即将开源！</a></h2><p>pubdata:2022-07-12 08:19:47markdate:2022-07-14 10:28:28.713392</p><p><img src="/public/2022/07/15/test/202207/2022-07-14-102828713392.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 13&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
</feed>
