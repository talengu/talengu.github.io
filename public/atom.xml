<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一塘</title>
  
  
  <link href="/public/atom.xml" rel="self"/>
  
  <link href="https://talengu.github.io/public/"/>
  <updated>2022-07-06T16:00:04.000Z</updated>
  <id>https://talengu.github.io/public/</id>
  
  <author>
    <name>一塘</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「转」Linux内核数据包bridge上转发流程</title>
    <link href="https://talengu.github.io/public/2022/07/06/linux/linux_bridge_forward/"/>
    <id>https://talengu.github.io/public/2022/07/06/linux/linux_bridge_forward/</id>
    <published>2022-07-06T16:00:04.000Z</published>
    <updated>2022-07-06T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://blog.csdn.net/hhhhhyyyyy8/article/details/102133863" target="_blank" rel="noopener">blog.csdn.net</a>@hhhhhyyyyy8 @4.15.1</p></blockquote><h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>linux 内核源代码变动怎么这么大，handle_bridge 函数居然没有了，本来接着准备以 3.9.1 分析的，但发现和后面的又变了，还是以 4.15.1 现在电脑上用的版本分析吧。</p><p><strong>linux kernel：4.15.1</strong></p><p>先看三张图片</p><p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76153027" target="_blank" rel="noopener">IMG skb桥转发蓝图</a><img src="/public/2022/07/06/linux/linux_bridge_forward/20191005153149853.jpg" alt></p><p><a href="https://blog.csdn.net/u012247418/article/details/90137663" target="_blank" rel="noopener">IMG linux TCP/IP L2层数据包接收流程</a><img src="/public/2022/07/06/linux/linux_bridge_forward/t_70.png" alt></p><p><a href="https://www.cnblogs.com/xuanxuanBOSS/p/11424290.html" target="_blank" rel="noopener">IMG 浅析ebtables的概念和一些基本应用</a><img src="/public/2022/07/06/linux/linux_bridge_forward/netfilter.png" alt></p><blockquote><p>tips: linux 内核版本不一样，流程函数会发生细微改变。</p></blockquote><h2 id="1-br-handle-frame"><a class="header-anchor" href="#1-br-handle-frame">¶</a>1. br_handle_frame()</h2><p>作用：</p><ol><li><p>对于需要转发的报文，调用 <code>NF_BR_PRE_ROUTING</code> 处钩子函数，结束后，进入 <code>br_handle_frame_finish()</code> 函数；</p></li><li><p>对于 STP 报文，调用 <code>NF_BR_LOCAL_IN</code> 处钩子函数，结束后，进入 <code>br_handle_local_finish()</code> 函数，在 <code>br_handle_local_finish()</code> 函数中会调用 <code>br_pass_frame_up()</code> 函数。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return NULL if skb is handled</span></span><br><span class="line"><span class="comment"> * note: already called with rcu_read_lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">rx_handler_result_t</span> <span class="title">br_handle_frame</span><span class="params">(struct sk_buff **pskb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> = *<span class="title">pskb</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line"><span class="keyword">br_should_route_hook_t</span> *rhook;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*如果是环回地址，直接返回RX_HANDLER_PASS*/</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(skb-&gt;pkt_type == PACKET_LOOPBACK))</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断源MAC地址是否是有效的地址，不是直接丢弃，源MAC地址不能是多播地址和全0地址*/</span></span><br><span class="line"><span class="keyword">if</span> (!is_valid_ether_addr(eth_hdr(skb)-&gt;h_source))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"><span class="comment">/*判断是否是共享数据包，若是则clone该数据包；若clone时分配内存出错，返回NULL*/</span></span><br><span class="line">skb = skb_share_check(skb, GFP_ATOMIC);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*获取dev对应的网桥端口*/</span></span><br><span class="line">p = br_port_get_rcu(skb-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; BR_VLAN_TUNNEL) &#123;</span><br><span class="line"><span class="keyword">if</span> (br_handle_ingress_vlan_tunnel(skb, p,</span><br><span class="line">  nbp_vlan_group_rcu(p)))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*特殊MAC地址处理*/</span></span><br><span class="line"><span class="comment">//如果目的mac地址是本地链路地址link local reserved addr (01:80:c2:00:00:0X) STP报文</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(is_link_local_ether_addr(dest))) &#123;</span><br><span class="line">u16 fwd_mask = p-&gt;br-&gt;group_fwd_mask_required;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * See IEEE 802.1D Table 7-10 Reserved addresses</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Assignment Value</span></span><br><span class="line"><span class="comment"> * Bridge Group Address01-80-C2-00-00-00</span></span><br><span class="line"><span class="comment"> * (MAC Control) 802.301-80-C2-00-00-01</span></span><br><span class="line"><span class="comment"> * (Link Aggregation) 802.301-80-C2-00-00-02</span></span><br><span class="line"><span class="comment"> * 802.1X PAE address01-80-C2-00-00-03</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 802.1AB LLDP 01-80-C2-00-00-0E</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Others reserved for future standardization</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fwd_mask |= p-&gt;group_fwd_mask;</span><br><span class="line"><span class="keyword">switch</span> (dest[<span class="number">5</span>]) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x00</span>:<span class="comment">/* Bridge Group Address */</span></span><br><span class="line"><span class="comment">/* If STP is turned off,</span></span><br><span class="line"><span class="comment">   then must forward to keep loop detection */</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;br-&gt;stp_enabled == BR_NO_STP ||</span><br><span class="line">    fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line"><span class="keyword">goto</span> forward;</span><br><span class="line">*pskb = skb;</span><br><span class="line">__br_handle_local_finish(skb);</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> <span class="number">0x01</span>:<span class="comment">/* IEEE MAC (Pause) */</span></span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0E</span>:<span class="comment">/* 802.1AB LLDP */</span></span><br><span class="line">fwd_mask |= p-&gt;br-&gt;group_fwd_mask;</span><br><span class="line"><span class="keyword">if</span> (fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line"><span class="keyword">goto</span> forward;</span><br><span class="line">*pskb = skb;</span><br><span class="line">__br_handle_local_finish(skb);</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* Allow selective forwarding for most other protocols */</span></span><br><span class="line">fwd_mask |= p-&gt;br-&gt;group_fwd_mask;</span><br><span class="line"><span class="keyword">if</span> (fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line"><span class="keyword">goto</span> forward;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Deliver packet to local host only */</span></span><br><span class="line"><span class="comment">/*调用NF_BR_LOCAL_IN处钩子函数，结束后，进入br_handle_local_finish函数*/</span></span><br><span class="line">NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, dev_net(skb-&gt;dev),</span><br><span class="line"><span class="literal">NULL</span>, skb, skb-&gt;dev, <span class="literal">NULL</span>, br_handle_local_finish);</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">forward:</span><br><span class="line"><span class="keyword">switch</span> (p-&gt;state) &#123;</span><br><span class="line"><span class="comment">//网桥端口处于转发状态</span></span><br><span class="line"><span class="keyword">case</span> BR_STATE_FORWARDING:</span><br><span class="line">rhook = rcu_dereference(br_should_route_hook);</span><br><span class="line"><span class="keyword">if</span> (rhook) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*rhook)(skb)) &#123;</span><br><span class="line">*pskb = skb;</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line">&#125;</span><br><span class="line">dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* fall through */</span></span><br><span class="line"><span class="comment">/*网桥端口处于学习状态，处于转发状态也会执行下面的代码，因为上面的case没有break。*/</span></span><br><span class="line"><span class="keyword">case</span> BR_STATE_LEARNING:</span><br><span class="line"><span class="comment">/*数据包目的MAC为网桥的Mac，发往本地的数据包*/</span></span><br><span class="line"><span class="keyword">if</span> (ether_addr_equal(p-&gt;br-&gt;dev-&gt;dev_addr, dest))</span><br><span class="line">skb-&gt;pkt_type = PACKET_HOST;</span><br><span class="line"><span class="comment">/*调用NF_BR_PRE_ROUTING处钩子函数，结束后进入br_handle_frame_finish函数*/</span></span><br><span class="line">NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,</span><br><span class="line">dev_net(skb-&gt;dev), <span class="literal">NULL</span>, skb, skb-&gt;dev, <span class="literal">NULL</span>,</span><br><span class="line">br_handle_frame_finish);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">drop:</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关函数</p><h3 id="rx-handler-result-t-枚举类型"><a class="header-anchor" href="#rx-handler-result-t-枚举类型">¶</a><code>rx_handler_result_t</code> 枚举类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> rx_handler_result &#123;</span><br><span class="line">RX_HANDLER_CONSUMED,</span><br><span class="line">RX_HANDLER_ANOTHER,</span><br><span class="line">RX_HANDLER_EXACT,</span><br><span class="line">RX_HANDLER_PASS,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> rx_handler_result <span class="keyword">rx_handler_result_t</span>;</span><br></pre></td></tr></table></figure><h3 id="is-valid-ether-addr"><a class="header-anchor" href="#is-valid-ether-addr">¶</a><code>is_valid_ether_addr()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * is_valid_ether_addr - Determine if the given Ethernet address is valid</span></span><br><span class="line"><span class="comment"> * @addr: Pointer to a six-byte array containing the Ethernet address</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not</span></span><br><span class="line"><span class="comment"> * a multicast address, and is not FF:FF:FF:FF:FF:FF.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return true if the address is valid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Please note: addr must be aligned to u16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_valid_ether_addr</span><span class="params">(<span class="keyword">const</span> u8 *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to</span></span><br><span class="line"><span class="comment"> * explicitly check for it here. */</span></span><br><span class="line"><span class="keyword">return</span> !is_multicast_ether_addr(addr) &amp;&amp; !is_zero_ether_addr(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="br-handle-local-finish"><a class="header-anchor" href="#br-handle-local-finish">¶</a><code>br_handle_local_finish()</code></h3><p><code>br_handle_local_finish()</code> 函数中调用 <code>br_pass_fame_up()</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/* note: already called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">br_handle_local_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span> = <span class="title">br_port_get_rcu</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line"> </span><br><span class="line">__br_handle_local_finish(skb);</span><br><span class="line"> </span><br><span class="line">BR_INPUT_SKB_CB(skb)-&gt;brdev = p-&gt;br-&gt;dev;</span><br><span class="line">br_pass_frame_up(skb);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-br-handle-frame-finish"><a class="header-anchor" href="#2-br-handle-frame-finish">¶</a>2. br_handle_frame_finish()</h2><p>作用：</p><p>网桥设备是否处于混杂模式，如果是，则会发一份到本地进行处理</p><p>如果是广播包，则会进行广播洪泛，并会发一份到本地处理</p><p>如果是组播包，则根据组播表进行组播转发，并发一份数数包到本地处理</p><p>如果是单播包，发往本地的单播包则送到本地处理，在 fdb 表中可以找到转发表项的单播包则进行转发，未知单播包在广播域内进行洪泛</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="comment">/* note: already called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_handle_frame_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span> = <span class="title">br_port_get_rcu</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line"><span class="keyword">enum</span> br_pkt_type pkt_type = BR_PKT_UNICAST;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_fdb_entry</span> *<span class="title">dst</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_mdb_entry</span> *<span class="title">mdst</span>;</span></span><br><span class="line"><span class="keyword">bool</span> local_rcv, mcast_hit = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *dest;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span>;</span></span><br><span class="line">u16 vid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果网桥端口不存在或者网桥端口状态为BR_STATE_DISABLED，则丢弃*/</span></span><br><span class="line"><span class="keyword">if</span> (!p || p-&gt;state == BR_STATE_DISABLED)</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"><span class="comment">/*判断是否允许进入桥内，如果没有开启VLAN则所有数据包都可以进入，</span></span><br><span class="line"><span class="comment">如果开启了VLAN,则根据VLAN相应的规则，从桥上进行数据包转发。*/</span></span><br><span class="line"><span class="keyword">if</span> (!br_allowed_ingress(p-&gt;br, nbp_vlan_group_rcu(p), skb, &amp;vid))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line">nbp_switchdev_frame_mark(p, skb);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* insert into forwarding database after filtering to avoid spoofing */</span></span><br><span class="line">br = p-&gt;br;</span><br><span class="line"><span class="comment">/*如果网桥端口标志有BR_LEARNING,则更新fdb表。</span></span><br><span class="line"><span class="comment">    一般新建网桥端口p-&gt;flags=BR_LEARNING| BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD*/</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; BR_LEARNING)</span><br><span class="line">br_fdb_update(br, p, eth_hdr(skb)-&gt;h_source, vid, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发往本地数据包标记，!!的作用是转换为bool值</span></span><br><span class="line">local_rcv = !!(br-&gt;dev-&gt;flags &amp; IFF_PROMISC);</span><br><span class="line">dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line"><span class="comment">/*目的地址为多播地址*/</span></span><br><span class="line"><span class="keyword">if</span> (is_multicast_ether_addr(dest)) &#123;</span><br><span class="line"><span class="comment">/* by definition the broadcast is also a multicast address */</span></span><br><span class="line"><span class="comment">/*如果目的地址是广播地址，将数据包也发往本地一份*/</span></span><br><span class="line"><span class="keyword">if</span> (is_broadcast_ether_addr(dest)) &#123;</span><br><span class="line">pkt_type = BR_PKT_BROADCAST;</span><br><span class="line">local_rcv = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pkt_type = BR_PKT_MULTICAST;</span><br><span class="line"><span class="comment">//igmp snooping留给网桥子系统的外部接口函数，</span></span><br><span class="line"><span class="comment">//当网桥接收了igmp数据包后就会调用该函数进行后续处理</span></span><br><span class="line"><span class="keyword">if</span> (br_multicast_rcv(br, p, skb, vid))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果网桥端口状态此时还是BR_STATE_LEARNING,则丢弃。</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;state == BR_STATE_LEARNING)</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"><span class="comment">//将网桥所属的net_device放入skb的私有数据中（struct br_input_skb_cb）</span></span><br><span class="line">BR_INPUT_SKB_CB(skb)-&gt;brdev = br-&gt;dev;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_INET) &amp;&amp;</span><br><span class="line">    (skb-&gt;protocol == htons(ETH_P_ARP) ||</span><br><span class="line">     skb-&gt;protocol == htons(ETH_P_RARP))) &#123;</span><br><span class="line">br_do_proxy_suppress_arp(skb, br, vid, p);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ENABLED(CONFIG_IPV6) &amp;&amp;</span><br><span class="line">   skb-&gt;protocol == htons(ETH_P_IPV6) &amp;&amp;</span><br><span class="line">   br-&gt;neigh_suppress_enabled &amp;&amp;</span><br><span class="line">   pskb_may_pull(skb, <span class="keyword">sizeof</span>(struct ipv6hdr) +</span><br><span class="line"> <span class="keyword">sizeof</span>(struct nd_msg)) &amp;&amp;</span><br><span class="line">   ipv6_hdr(skb)-&gt;nexthdr == IPPROTO_ICMPV6) &#123;</span><br><span class="line">struct nd_msg *msg, _msg;</span><br><span class="line"> </span><br><span class="line">msg = br_is_nd_neigh_msg(skb, &amp;_msg);</span><br><span class="line"><span class="keyword">if</span> (msg)</span><br><span class="line">br_do_suppress_nd(skb, br, vid, p, msg);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">switch</span> (pkt_type) &#123;</span><br><span class="line"><span class="comment">//组播包</span></span><br><span class="line"><span class="keyword">case</span> BR_PKT_MULTICAST:</span><br><span class="line"><span class="comment">//获取组播转发项，设置local_rcv为true，组播包也要发往本地一份。</span></span><br><span class="line">mdst = br_mdb_get(br, skb, vid);</span><br><span class="line"><span class="keyword">if</span> ((mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) &amp;&amp;</span><br><span class="line">    br_multicast_querier_exists(br, eth_hdr(skb))) &#123;</span><br><span class="line"><span class="keyword">if</span> ((mdst &amp;&amp; mdst-&gt;host_joined) ||</span><br><span class="line">    br_multicast_is_router(br)) &#123;</span><br><span class="line">local_rcv = <span class="literal">true</span>;</span><br><span class="line">br-&gt;dev-&gt;stats.multicast++;</span><br><span class="line">&#125;</span><br><span class="line">mcast_hit = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">local_rcv = <span class="literal">true</span>;</span><br><span class="line">br-&gt;dev-&gt;stats.multicast++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//单播包</span></span><br><span class="line"><span class="keyword">case</span> BR_PKT_UNICAST:</span><br><span class="line"><span class="comment">//根据目的MAC地址查找fdb表，看是否有对应的表项</span></span><br><span class="line">dst = br_fdb_find_rcu(br, dest, vid);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果找到目的MAC对应的表项</span></span><br><span class="line"><span class="keyword">if</span> (dst) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> now = jiffies;</span><br><span class="line"><span class="comment">//送入上层处理</span></span><br><span class="line"><span class="keyword">if</span> (dst-&gt;is_local)</span><br><span class="line"><span class="keyword">return</span> br_pass_frame_up(skb);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (now != dst-&gt;used)</span><br><span class="line">dst-&gt;used = now;</span><br><span class="line"><span class="comment">//根据fdb转发表项进行转发，若这里local_rcv 为1,（即端口处于混杂模式IFF_PROMISC），则会克隆一份再转发</span></span><br><span class="line"><span class="comment">//传入的第一个参数dst-&gt;dst 即为要转发的目的端口</span></span><br><span class="line">br_forward(dst-&gt;dst, skb, local_rcv, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//进行广播或者组播洪泛</span></span><br><span class="line"><span class="keyword">if</span> (!mcast_hit)</span><br><span class="line">br_flood(br, skb, pkt_type, local_rcv, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">br_multicast_flood(mdst, skb, local_rcv, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//local_rcv标记为1，送入上层处理。</span></span><br><span class="line"><span class="keyword">if</span> (local_rcv)</span><br><span class="line"><span class="keyword">return</span> br_pass_frame_up(skb);</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">drop:</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-br-pass-frame-up"><a class="header-anchor" href="#3-br-pass-frame-up">¶</a>3.br_pass_frame_up</h2><p>数据包的目的 MAC 是本地的单播报文，广播，组播和网桥处于混杂模式时，报文都会通过 br_pass_frame_up 函数交由上层处理。</p><p>作用：</p><p>调用 NF_BR_LOCAL_IN 处钩子函数，最后调用 br_netif_receive_skb 函数，绕一圈后，交友上层处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">br_pass_frame_up</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">indev</span>, *<span class="title">brdev</span> = <span class="title">BR_INPUT_SKB_CB</span>(<span class="title">skb</span>)-&gt;<span class="title">brdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span> = <span class="title">netdev_priv</span>(<span class="title">brdev</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_vlan_group</span> *<span class="title">vg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcpu_sw_netstats</span> *<span class="title">brstats</span> = <span class="title">this_cpu_ptr</span>(<span class="title">br</span>-&gt;<span class="title">stats</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//统计网桥设备上的收包流量数据</span></span><br><span class="line">u64_stats_update_begin(&amp;brstats-&gt;syncp);</span><br><span class="line">brstats-&gt;rx_packets++;</span><br><span class="line">brstats-&gt;rx_bytes += skb-&gt;len;</span><br><span class="line">u64_stats_update_end(&amp;brstats-&gt;syncp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取网桥设备上的VLAN组</span></span><br><span class="line">vg = br_vlan_group_rcu(br);</span><br><span class="line"><span class="comment">/* Bridge is just like any other port.  Make sure the</span></span><br><span class="line"><span class="comment"> * packet is allowed except in promisc modue when someone</span></span><br><span class="line"><span class="comment"> * may be running packet capture.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!(brdev-&gt;flags &amp; IFF_PROMISC) &amp;&amp;</span><br><span class="line">    !br_allowed_egress(vg, skb)) &#123;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录数据包的收包网络设备</span></span><br><span class="line">indev = skb-&gt;dev;</span><br><span class="line"><span class="comment">//将数据包的收包设备改为网桥设备</span></span><br><span class="line"><span class="comment">//当再次进入__netif_receive_skb_core时就不会再次进入桥处理了，因为网桥上没有注册rx_handler 函数</span></span><br><span class="line">skb-&gt;dev = brdev;</span><br><span class="line"><span class="comment">//配置数据包vlan相关信息</span></span><br><span class="line">skb = br_handle_vlan(br, <span class="literal">NULL</span>, vg, skb);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line"><span class="comment">/* update the multicast stats if the packet is IGMP/MLD */</span></span><br><span class="line"><span class="comment">//如果数据包是组播，更新组播数据包的统计信息</span></span><br><span class="line">br_multicast_count(br, <span class="literal">NULL</span>, skb, br_multicast_igmp_type(skb),</span><br><span class="line">   BR_MCAST_DIR_TX);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用NF_BR_LOCAL_IN处钩子函数，最后调用br_netif_receive_skb函数。</span></span><br><span class="line"><span class="keyword">return</span> NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,</span><br><span class="line">       dev_net(indev), <span class="literal">NULL</span>, skb, indev, <span class="literal">NULL</span>,</span><br><span class="line">       br_netif_receive_skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次进入 netif_receive_skb，由于 skb-dev 被设置成了 bridge，而 bridge 设备的 rx_handler 函数是没有被设置的，所以就不会再次进入 bridge 逻辑，而直接进入了主机上层协议栈。</p><p>相关函数</p><h3 id="br-netif-receive-skb"><a class="header-anchor" href="#br-netif-receive-skb">¶</a><code>br_netif_receive_skb()</code></h3><p>可以看到在 br_netif_receive_skb() 函数中调用了 netif_receive_skb() 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">static int</span><br><span class="line">br_netif_receive_skb(struct net *net, struct sock *sk, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">br_drop_fake_rtable(skb);</span><br><span class="line">return netif_receive_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-br-forward"><a class="header-anchor" href="#4-br-forward">¶</a>4. br_forward()</h2><p>不是发往本地的数据包，但在 fdb 表中能找到对应的表项，则进行转发 br_forward()，若在 fdb 表中找不到对应表项就进行洪泛 br_blood().</p><p>作用：</p><p>主要是调用__br_forward() 转发报文</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * br_forward - forward a packet to a specific port</span></span><br><span class="line"><span class="comment"> * @to: destination port</span></span><br><span class="line"><span class="comment"> * @skb: packet being forwarded</span></span><br><span class="line"><span class="comment"> * @local_rcv: packet will be received locally after forwarding</span></span><br><span class="line"><span class="comment"> * @local_orig: packet is locally originated</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Should be called with rcu_read_lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_forward</span><span class="params">(<span class="keyword">const</span> struct net_bridge_port *to,</span></span></span><br><span class="line"><span class="function"><span class="params">struct sk_buff *skb, <span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//should_deliver测试是否应该将该包转发出去</span></span><br><span class="line"><span class="keyword">if</span> (to &amp;&amp; should_deliver(to, skb)) &#123;</span><br><span class="line"><span class="comment">//如果local_rcv为1，表明端口为混杂模式，先clone一份数据包再进行转发</span></span><br><span class="line"><span class="keyword">if</span> (local_rcv)</span><br><span class="line">deliver_clone(to, skb, local_orig);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__br_forward(to, skb, local_orig);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!local_rcv)</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-br-forward"><a class="header-anchor" href="#5-br-forward">¶</a>5. __br_forward()</h2><p>作用:</p><p>__br_forward() 函数根据数据包的来源（local_orig）分别进入不同的钩子点，如果数据包是从本地发出的，则进入 NF_BR_LOCAL_OUT，如果不是本地发出的，则进入 NF_BR_FORWARD 钩子，最后都进入 br_forward_finish() 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __br_forward(<span class="keyword">const</span> struct net_bridge_port *to,</span><br><span class="line"> struct sk_buff *skb, <span class="keyword">bool</span> local_orig)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_vlan_group</span> *<span class="title">vg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">indev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line"><span class="keyword">int</span> br_hook;</span><br><span class="line"><span class="comment">//获取vlan组，这个组中有许多的vlanid，br_handle_vlan函数就是要在这个组中查找自己的vid</span></span><br><span class="line">vg = nbp_vlan_group_rcu(to);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加vlan的相关配置</span></span><br><span class="line">skb = br_handle_vlan(to-&gt;br, to, vg, skb);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//记录数据包的原始收包网络设备</span></span><br><span class="line">indev = skb-&gt;dev;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将skb的dev修改为出口网络设备</span></span><br><span class="line">skb-&gt;dev = to-&gt;dev;</span><br><span class="line"><span class="comment">/*如果local_orig标志位(判断是否从本地发出的数据包)为false，就进入NF_BR_FORWARD钩子</span></span><br><span class="line"><span class="comment">若为true，就进入NF_BR_LOCAL_OUT钩子点*/</span></span><br><span class="line"><span class="keyword">if</span> (!local_orig) &#123;</span><br><span class="line"><span class="keyword">if</span> (skb_warn_if_lro(skb)) &#123;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不是本地发出的数据包，进入NF_BR_FORWARD</span></span><br><span class="line">br_hook = NF_BR_FORWARD;</span><br><span class="line">skb_forward_csum(skb);</span><br><span class="line">net = dev_net(indev);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(netpoll_tx_running(to-&gt;br-&gt;dev))) &#123;</span><br><span class="line"><span class="keyword">if</span> (!is_skb_forwardable(skb-&gt;dev, skb)) &#123;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">skb_push(skb, ETH_HLEN);</span><br><span class="line">br_netpoll_send_skb(to, skb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若是本地发出的数据包，进入NF_BR_LOCAL_OUT处理</span></span><br><span class="line">br_hook = NF_BR_LOCAL_OUT;</span><br><span class="line">net = dev_net(skb-&gt;dev);</span><br><span class="line">indev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入钩子点，最后执行br_forward_finish函数。</span></span><br><span class="line">NF_HOOK(NFPROTO_BRIDGE, br_hook,</span><br><span class="line">net, <span class="literal">NULL</span>, skb, indev, skb-&gt;dev,</span><br><span class="line">br_forward_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-br-forward-finish"><a class="header-anchor" href="#6-br-forward-finish">¶</a>6. br_forward_finish()</h2><p><code>br_forward_finish()</code> 函数比较简单，调用 <code>NF_BR_POST_ROUTING</code> 处的钩子函数，最后进入 <code>br_dev_queue_push_xmit</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_forward_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING,</span><br><span class="line">       net, sk, skb, <span class="literal">NULL</span>, skb-&gt;dev,</span><br><span class="line">       br_dev_queue_push_xmit);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-br-dev-queue-push-xmit"><a class="header-anchor" href="#7-br-dev-queue-push-xmit">¶</a>7. br_dev_queue_push_xmit</h2><p>在 <code>br_dev_queue_push_xmit()</code> 中，会先 <code>skb_push(skb,ETH,HLEN);</code> 将 data 指向二层头部，然后调用 <code>dev_queue_xmit()</code> 发送报文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_dev_queue_push_xmit</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!is_skb_forwardable(skb-&gt;dev, skb))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//注意这句操作</span></span><br><span class="line">skb_push(skb, ETH_HLEN);</span><br><span class="line">br_drop_fake_rtable(skb);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_PARTIAL &amp;&amp;</span><br><span class="line">    (skb-&gt;protocol == htons(ETH_P_8021Q) ||</span><br><span class="line">     skb-&gt;protocol == htons(ETH_P_8021AD))) &#123;</span><br><span class="line"><span class="keyword">int</span> depth;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!__vlan_get_protocol(skb, skb-&gt;protocol, &amp;depth))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">skb_set_network_header(skb, depth);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">dev_queue_xmit(skb);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">drop:</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-br-flood"><a class="header-anchor" href="#8-br-flood">¶</a>8. br_flood</h2><p><code>br_flood()</code> 也是调用 <code>__br_forward()</code> 函数转发报文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/* called under rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_flood</span><span class="params">(struct net_bridge *br, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">enum</span> br_pkt_type pkt_type, <span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 igmp_type = br_multicast_igmp_type(skb);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*遍历网桥设备的port_list，取出所有的网桥端口*/</span></span><br><span class="line">list_for_each_entry_rcu(p, &amp;br-&gt;port_list, <span class="built_in">list</span>) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">/* Do not flood unicast traffic to ports that turn it off, nor</span></span><br><span class="line"><span class="comment"> * other traffic if flood off, except for traffic we originate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (pkt_type) </span><br><span class="line">                &#123;</span><br><span class="line"><span class="keyword">case</span> BR_PKT_UNICAST:</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; BR_FLOOD))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BR_PKT_MULTICAST:</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; BR_MCAST_FLOOD) &amp;&amp; skb-&gt;dev != br-&gt;dev)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BR_PKT_BROADCAST:</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; BR_BCAST_FLOOD) &amp;&amp; skb-&gt;dev != br-&gt;dev)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Do not flood to ports that enable proxy ARP */</span></span><br><span class="line">                <span class="comment">/*代理arp*/</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; BR_PROXYARP)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((p-&gt;flags &amp; (BR_PROXYARP_WIFI | BR_NEIGH_SUPPRESS)) &amp;&amp;</span><br><span class="line">    BR_INPUT_SKB_CB(skb)-&gt;proxyarp_replied)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">prev = maybe_deliver(prev, p, skb, local_orig);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(prev))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (prev == p)</span><br><span class="line">br_multicast_count(p-&gt;br, p, skb, igmp_type,</span><br><span class="line">   BR_MCAST_DIR_TX);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!prev)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (local_rcv)</span><br><span class="line">deliver_clone(prev, skb, local_orig);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__br_forward(prev, skb, local_orig);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (!local_rcv)</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-br-mulicast-flood"><a class="header-anchor" href="#9-br-mulicast-flood">¶</a>9. br_mulicast_flood()</h2><hr><p>以后再分析，肚子饿了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/* called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_multicast_flood</span><span class="params">(struct net_bridge_mdb_entry *mdst,</span></span></span><br><span class="line"><span class="function"><span class="params">struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">BR_INPUT_SKB_CB</span>(<span class="title">skb</span>)-&gt;<span class="title">brdev</span>;</span></span><br><span class="line">u8 igmp_type = br_multicast_igmp_type(skb);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port_group</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">rp</span>;</span></span><br><span class="line"> </span><br><span class="line">rp = rcu_dereference(hlist_first_rcu(&amp;br-&gt;router_list));</span><br><span class="line">p = mdst ? rcu_dereference(mdst-&gt;ports) : <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p || rp) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">port</span>, *<span class="title">lport</span>, *<span class="title">rport</span>;</span></span><br><span class="line"> </span><br><span class="line">lport = p ? p-&gt;port : <span class="literal">NULL</span>;</span><br><span class="line">rport = rp ? hlist_entry(rp, struct net_bridge_port, rlist) :</span><br><span class="line">     <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)lport &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)rport) &#123;</span><br><span class="line">port = lport;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (port-&gt;flags &amp; BR_MULTICAST_TO_UNICAST) &#123;</span><br><span class="line">maybe_deliver_addr(lport, skb, p-&gt;eth_addr,</span><br><span class="line">   local_orig);</span><br><span class="line"><span class="keyword">goto</span> delivered;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">port = rport;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">prev = maybe_deliver(prev, port, skb, local_orig);</span><br><span class="line">delivered:</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(prev))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (prev == port)</span><br><span class="line">br_multicast_count(port-&gt;br, port, skb, igmp_type,</span><br><span class="line">   BR_MCAST_DIR_TX);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)lport &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)port)</span><br><span class="line">p = rcu_dereference(p-&gt;next);</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)rport &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)port)</span><br><span class="line">rp = rcu_dereference(hlist_next_rcu(rp));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!prev)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (local_rcv)</span><br><span class="line">deliver_clone(prev, skb, local_orig);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__br_forward(prev, skb, local_orig);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (!local_rcv)</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2><p><a href="http://ebtables.netfilter.org/br_fw_ia/br_fw_ia.html" target="_blank" rel="noopener">ebtables/iptables interaction on a Linux-based bridge</a>@ebtables @2.4.x kernel</p><p><a href="https://blog.csdn.net/sxd2001/article/details/125031113" target="_blank" rel="noopener">Iptables DNAT实现broadcast与unicast之间相互映射</a>@sxd2001 分析ebtables 的redirect 和 iptables 的redirect</p><p><a href="https://blog.csdn.net/Sophisticated_/article/details/87923362" target="_blank" rel="noopener">Linux-4.20.8内核桥收包源码解析（七）--本地（br_pass_frame_up）or 转发（br_forward）</a>@lw_yang @Linux-4.20.8</p><p><a href="http://blog.chinaunix.net/uid-28541347-id-5750406.html" target="_blank" rel="noopener">Linux 3.10 kernel bridge转发逻辑</a>@lvyilong316 @Linux 3.10 kernel</p><p><a href="https://blog.csdn.net/linyt/article/details/5191512" target="_blank" rel="noopener">kernel 网桥代码分析</a>@海枫 @ 2.6.24.4</p><p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76674232" target="_blank" rel="noopener">桥数据包处理函数——br_handle_frame_finish（七）</a>@不留你的名字</p><p><a href="https://www.cnblogs.com/super-king/p/bridge_implement.html" target="_blank" rel="noopener">Bridge实现</a>@SuperKing @linux 2.6.18</p><p><a href="https://www.cnblogs.com/ck1020/p/5894235.html" target="_blank" rel="noopener">LInux下桥接模式详解三</a>@jack.chen @linux 3.10.1</p><p><a href="https://blog.csdn.net/one_clouder/article/details/52877737" target="_blank" rel="noopener">协议栈报文接收之netif_receive_skb函数分析</a>@one_clouder @Linux4.1.12</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;原文地址 &lt;a href=&quot;https://blog.csdn.net/hhhhhyyyyy8/article/details/102133863&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;blog.csdn.net&lt;/a&gt;

      
    
    </summary>
    
      <category term="Linux" scheme="https://talengu.github.io/public/categories/Linux/"/>
    
    
      <category term="bridge" scheme="https://talengu.github.io/public/tags/bridge/"/>
    
      <category term="netfilter" scheme="https://talengu.github.io/public/tags/netfilter/"/>
    
  </entry>
  
  <entry>
    <title>「转」tcpdump是在哪儿抓到的包？</title>
    <link href="https://talengu.github.io/public/2022/07/01/linux/how_tcpdump/"/>
    <id>https://talengu.github.io/public/2022/07/01/linux/how_tcpdump/</id>
    <published>2022-07-01T16:00:04.000Z</published>
    <updated>2022-07-01T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://cloud.tencent.com/developer/article/1879646" target="_blank" rel="noopener">cloud.tencent.com</a></p></blockquote><blockquote><p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对...</p></blockquote><p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对这个问题，我进行了一番学习探究。</p><p>先说结论：通过 PF_PACKET 这个特殊的套接字协议，直接接收来自链路层的帧。数据包<strong>并非没有</strong>进入内核，而是在进入内核后直接跳过了内核中三层 / 四层的协议栈，直达套接字接口，被应用层的 tcpdump 所使用。实际上，在网卡驱动程序通知内核接受到数据帧的时候，数据包就已经进入了内核处理流程。具体的区别，可以见下图。</p><p><img src="/public/2022/07/01/linux/how_tcpdump/1620.png" alt></p><p>内核网络协议栈示意图</p><a id="more"></a><p>先来看看，普通的套接字的收包路径在内核中是怎么样。</p><p>以最常见的以太网网卡，当网卡接口接收到了一个帧，那么接受者知道它一定包含了一个 Ethernet 报头。封包在协议栈向上传递过程中，一定会在报头中包含一个字段，指出下一阶段的处理应该使用哪一个协议。 以太网卡拥有特定的 MAC 地址，在监听数据帧的时候，当看到帧的目的 MAC 地址与自己的地址或者链路层广播地址（FF:FF:FF:FF:FF:FF）相匹配，就会通过 DMA 把该帧读取到内存中的 ring buffer。</p><p>当一个数据帧被写入到内存后，将产生一个硬件中断请求，以通知 CPU 收到了数据包。操作系统为了减少硬中断产生的次数，会采用一个软中断 (softirq) 唤醒 NAPI 子系统。这样会产生一个单独的线程，调用网卡驱动注册的 poll 方法收包，同时禁止网卡产生新的硬中断，这样的效果便是一次中断可以接收多个包。一旦软终端代码判断有 softirq 处于 pending 状态，便会调用软终端处理函数 net_rx_action。</p><p>中断处理函数会在处理循环中调用 NAPI poll 来接收数据包。poll 方法会分配一个 sk_buff 数据结构（include/linux/skbuff.h），表示该数据包的内核视图。然后将数据从缓冲区提取到新建的 sk_buff 中，并对其中的 protocol 字段做初始化，该字段用以识别特定的协议。之后这个字段会被 netif_receive_skb 内核函数查询，用来确定该执行哪个函数来处理三层的封包。字段涉及协议的值都列在了 include/uapi/linux/if_ether.h 中，名字形如 ETH_P_XXX，比如 ip 协议为 ETH_P_IP。而有一种特殊情况，单一封包可以传递给多个处理函数，这就是 tcpdump 等网络嗅探应用会用到的 ETH_P_ALL。</p><p>软终端处理循环的最后是通过 netif_receive_skb 函数将将数据交给 TCP/IP 协议栈的。它会从数据包包头中取出协议信息，然后遍历注册在这个协议上的回调函数列表。这里的列表值得一提，分别是 ptype_all 和 ptype_base。他们是 hash table 数据结构，分别对应通用数据包（ETH_P_ALL 类型）和特定协议的数据包（ETH_P_XXX 类型），其中存放着指向对应协议处理函数的指针，当收到该类型的数据包时便调用对应的处理函数。</p><p>因此，以 IP 数据包为例，当 ETH_P_IP 类型数据包出队后，软中断处理程序 net_rx_action 最终会在 ptype_base 列表中找到 IP 协议的处理函数 ip_rcv() 并调用它，完成数据包向上提交到协议栈。这里略过 IP 协议栈的处理过程，简而言之，在经过 IP 数据包完整性校验、Netfilter 子系统（iptables 的底层实现）、路由子系统等等一些列流程之后，开始准备送往高层协议。这里的处理和 net_rx_action 很相似，从 IP 数据包头部提取出协议类型后，通过名为 inet_protos 的哈希来寻找高层协议的处理函数，每个高层协议都对应一个处理函数，型如 tcp_v4_rcv(), udp_rcv() 等。</p><p>四层协议以较为简单的 UDP 为例，udp_rcv 会对 udp 包进行合法性校验，然后查找是否有愿意接收此数据包的套接字，如果找到，__udp_queue_rcv_skb 会将包放到 socket 的接收队列。最后，所有在这个 socket 上等待数据的进程都会收到通过 sk_data_ready 函数处理的通知。</p><p>以上是一个数据包穿越协议栈到达 socket 的简要过程，实际的内核处理过程会复杂的多，这里只是做简要的描述。以引入本文的主角：PF_PACKET 协议数据包在内核中的处理路径。</p><p>当创建 PF_PACKET 套接字时，与协议相关的数据包类型将被同时注册进 ptype_all 和 ptype_base，接受函数为 packet_rcb()。此时，net_rx_action 函数会拦截所有进入机器的包，并同样通过 netif_receive_skb 函数遍历 ptype_all 后，传递给 PF_PACKET 接受函数。值得一提的是，tcpdump 依赖的 libpcap 库并非使用原始套接字 + recvfrom 的方式收包，而是在内核空间分配一块内核缓冲区，然后用户空间调用 mmap 系统调用映射到用户空间。</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2><p><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/" target="_blank" rel="noopener">Monitoring and Tuning the Linux Networking Stack: Receiving Data</a></p><p><a href="https://www.linuxjournal.com/article/4852" target="_blank" rel="noopener">Inside the Linux Packet Filter</a></p><p><a href="https://km.woa.com/group/17746/articles/show/%E5%9B%BE%E8%A7%A3linux%20tcpdump" target="_blank" rel="noopener">图解 linux tcpdump</a></p><p>《深入理解 Linux 网络技术内幕》</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址 &lt;a href=&quot;https://cloud.tencent.com/developer/article/1879646&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cloud.tencent.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对这个问题，我进行了一番学习探究。&lt;/p&gt;
&lt;p&gt;先说结论：通过 PF_PACKET 这个特殊的套接字协议，直接接收来自链路层的帧。数据包&lt;strong&gt;并非没有&lt;/strong&gt;进入内核，而是在进入内核后直接跳过了内核中三层 / 四层的协议栈，直达套接字接口，被应用层的 tcpdump 所使用。实际上，在网卡驱动程序通知内核接受到数据帧的时候，数据包就已经进入了内核处理流程。具体的区别，可以见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/public/2022/07/01/linux/how_tcpdump/1620.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;内核网络协议栈示意图&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://talengu.github.io/public/categories/Linux/"/>
    
    
      <category term="tcpdump" scheme="https://talengu.github.io/public/tags/tcpdump/"/>
    
  </entry>
  
  <entry>
    <title>使用脚本将英文rss转成中文rss</title>
    <link href="https://talengu.github.io/public/2022/05/08/rss_google_translate/"/>
    <id>https://talengu.github.io/public/2022/05/08/rss_google_translate/</id>
    <published>2022-05-08T22:00:04.000Z</published>
    <updated>2022-05-08T22:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>本文中我们将英文rss 自动转成中文 rss供ttrss使用。（利用谷歌翻译）</p><p>方便在手机上进行阅读或者收听。<img src="/public/2022/05/08/rss_google_translate/20220508-22-28-27.png" alt></p><a id="more"></a><h2 id="举例"><a class="header-anchor" href="#举例">¶</a>举例</h2><p>国外有很多不错的rss源，比如:</p><ul><li><p><a href="http://www.mckinsey.com/insights/rss" target="_blank" rel="noopener">McKinsey Insights &amp; Publications</a><img src="/public/2022/05/08/rss_google_translate/20220508-22-18-23.png" alt>转成中文rss<img src="/public/2022/05/08/rss_google_translate/20220508-22-20-48.png" alt></p></li><li><p><a href="http://rss.acast.com/nature" target="_blank" rel="noopener">Nature Podcast</a><img src="/public/2022/05/08/rss_google_translate/20220508-22-25-04.png" alt>转成中文rss<img src="/public/2022/05/08/rss_google_translate/20220508-22-26-36.png" alt></p></li></ul><h2 id="脚本"><a class="header-anchor" href="#脚本">¶</a>脚本</h2><p>使用 Translate 和 BeautifulSoup 项目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8 </span></span><br><span class="line"><span class="keyword">from</span> pygtrans <span class="keyword">import</span> Translate</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment"># pip 安装</span></span><br><span class="line"><span class="comment"># pip install pygtrans BeautifulSoup -i https://pypi.org/simple</span></span><br><span class="line"><span class="comment"># ref:https://zhuanlan.zhihu.com/p/390801784</span></span><br><span class="line"><span class="comment"># ref:https://beautifulsoup.readthedocs.io/zh_CN/latest/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># client = Translate()</span></span><br><span class="line"><span class="comment"># text = client.translate('Google Translate')</span></span><br><span class="line"><span class="comment"># print(text.translatedText)  # 谷歌翻译</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"></span><br><span class="line">args = sys.argv</span><br><span class="line">URL=<span class="string">"http://www.mckinsey.com/insights/rss"</span></span><br><span class="line"></span><br><span class="line">BASE=<span class="string">"/home/xxx/www/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tran</span><span class="params">(url=URL,out_dir=BASE+<span class="string">"mckinsey_rss.xml"</span>)</span>:</span></span><br><span class="line">    GT = Translate()</span><br><span class="line">    content= request.urlopen(url).read().decode(<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="comment"># 变tag，以使用谷歌翻译</span></span><br><span class="line">    content=content.replace(<span class="string">'title&gt;'</span>, <span class="string">'stitle&gt;'</span>) <span class="comment">#谷歌翻译会将很多titile去掉，所以需要换一个tag</span></span><br><span class="line">    content=content.replace( <span class="string">'&lt;pubDate&gt;'</span>,<span class="string">'&lt;pubDate&gt;&lt;span translate="no"&gt;'</span>) </span><br><span class="line">    <span class="comment"># 谷歌翻译对&lt;span translate="no"&gt; &lt;/span&gt; 不翻译。</span></span><br><span class="line">    content=content.replace( <span class="string">'&lt;/pubDate&gt;'</span>,<span class="string">'&lt;/span&gt;&lt;/pubDate&gt;'</span>)</span><br><span class="line">    <span class="comment">#print(content)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    _text = GT.translate(content)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(out_dir,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        c=_text.translatedText</span><br><span class="line">        <span class="comment"># 还原tag</span></span><br><span class="line">        c=c.replace(<span class="string">'stitle&gt;'</span>, <span class="string">'title&gt;'</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;span translate="no"&gt;'</span>, <span class="string">''</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;/span&gt;&lt;/pubDate&gt;'</span>, <span class="string">'&lt;/pubDate&gt;'</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        f.write(c)</span><br><span class="line">        <span class="comment">#f.write(content)</span></span><br><span class="line">    print(<span class="string">"GT: "</span>+ url +<span class="string">" &gt; "</span>+ out_dir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(args)==<span class="number">1</span>:</span><br><span class="line">    tran()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    tran(args[<span class="number">1</span>],args[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tran_nature</span><span class="params">(url=<span class="string">"http://rss.acast.com/nature"</span>,out_dir=BASE+<span class="string">"nature_rss.xml"</span>)</span>:</span></span><br><span class="line">    GT = Translate()</span><br><span class="line">    </span><br><span class="line">    html_doc=request.urlopen(url).read().decode(<span class="string">'utf8'</span>)</span><br><span class="line">    soup = BeautifulSoup(html_doc)</span><br><span class="line"></span><br><span class="line">    items=soup.find_all(<span class="string">'item'</span>)</span><br><span class="line">    <span class="comment"># nature post内容太多，谷歌api翻译不了，去掉一些</span></span><br><span class="line">    <span class="keyword">for</span> idx,e <span class="keyword">in</span> enumerate(items):</span><br><span class="line">        <span class="keyword">if</span> idx &gt;<span class="number">8</span>:</span><br><span class="line">                e.decompose()</span><br><span class="line">    </span><br><span class="line">    content= str(soup)</span><br><span class="line">    content=content.replace(<span class="string">'title&gt;'</span>, <span class="string">'stitle&gt;'</span>)</span><br><span class="line">    content=content.replace( <span class="string">'&lt;pubdate&gt;'</span>,<span class="string">'&lt;pubDate&gt;&lt;span translate="no"&gt;'</span>)</span><br><span class="line">    content=content.replace( <span class="string">'&lt;/pubdate&gt;'</span>,<span class="string">'&lt;/span&gt;&lt;/pubdate&gt;'</span>)</span><br><span class="line">    <span class="comment">#print(content)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    _text = GT.translate(content)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(out_dir,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        c=_text.translatedText</span><br><span class="line">        c=c.replace(<span class="string">'stitle&gt;'</span>, <span class="string">'title&gt;'</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;span translate="no"&gt;'</span>, <span class="string">''</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;/span&gt;&lt;/pubdate&gt;'</span>, <span class="string">'&lt;/pubDate&gt;'</span>) <span class="comment"># 对于ttrss需要为pubDate才会识别正确</span></span><br><span class="line">        c=c.replace(<span class="string">'&amp;gt'</span>,<span class="string">'&gt;'</span>) <span class="comment"># &amp;gt 会影响识别</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        f.write(c)</span><br><span class="line">        <span class="comment">#f.write(content)</span></span><br><span class="line">    print(<span class="string">"GT: "</span>+ url +<span class="string">" &gt; "</span>+ out_dir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tran_nature()</span><br></pre></td></tr></table></figure><h3 id="定时任务"><a class="header-anchor" href="#定时任务">¶</a>定时任务</h3><blockquote><p>注意激活一下miniconda3 这个命令<code>source /home/xxx/miniconda3/bin/activate</code></p></blockquote><p>放到 <code>/etc/cron.daily/</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">source</span> /home/xxx/miniconda3/bin/activate</span><br><span class="line">python /home/xxx/txxx.py</span><br></pre></td></tr></table></figure><h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2><ul><li><a href="https://blog.csdn.net/wokuailewozihao/article/details/82021709" target="_blank" rel="noopener">利用Google翻译实现网站国际化——js插件</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文中我们将英文rss 自动转成中文 rss供ttrss使用。（利用谷歌翻译）&lt;/p&gt;
&lt;p&gt;方便在手机上进行阅读或者收听。
&lt;img src=&quot;/public/2022/05/08/rss_google_translate/20220508-22-28-27.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://talengu.github.io/public/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="rss" scheme="https://talengu.github.io/public/tags/rss/"/>
    
      <category term="python" scheme="https://talengu.github.io/public/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>rss统计 基于ttrss的PostgresQL数据库</title>
    <link href="https://talengu.github.io/public/2022/05/08/rss_ttrss_statics/"/>
    <id>https://talengu.github.io/public/2022/05/08/rss_ttrss_statics/</id>
    <published>2022-05-08T22:00:04.000Z</published>
    <updated>2022-05-08T22:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>统计ttrss的使用数据。</p><ul><li>月度mark文件分析 OK</li></ul><p>TODO：</p><ul><li>全年阅读报告 doing</li></ul><a id="more"></a><h2 id="按月保存mark的内容"><a class="header-anchor" href="#按月保存mark的内容">¶</a>按月保存mark的内容</h2><p>账号 密码 和你docker文件里面的一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按月来保存</span></span><br><span class="line"><span class="keyword">import</span> html2text</span><br><span class="line"><span class="comment"># psycopg2 head</span></span><br><span class="line"><span class="keyword">import</span> psycopg2</span><br><span class="line"><span class="comment"># pip3 install psycopg2-binary</span></span><br><span class="line"><span class="comment"># ref:https://blog.csdn.net/Haiqiang1995/article/details/89069791</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_from_dataset</span><span class="params">(cmd_sql)</span>:</span></span><br><span class="line">    conn = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># read database configuration</span></span><br><span class="line">        params = &#123;</span><br><span class="line">        <span class="string">'host'</span>: <span class="string">"?????"</span>,</span><br><span class="line">        <span class="string">'user'</span>: <span class="string">"????"</span>,</span><br><span class="line">        <span class="string">'password'</span>: <span class="string">"????"</span>,</span><br><span class="line">        <span class="string">'dbname'</span>: <span class="string">"ttrss"</span>,</span><br><span class="line">        'port': ??00</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># connect to the PostgresQL database</span></span><br><span class="line">        conn = psycopg2.connect(**params)</span><br><span class="line">        <span class="comment"># create a new cursor object</span></span><br><span class="line">        cur = conn.cursor()</span><br><span class="line">        <span class="comment"># execute the SELECT statement</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        print(cmd_sql)</span><br><span class="line">        cur.execute(cmd_sql)</span><br><span class="line"></span><br><span class="line">        blob = cur.fetchall()</span><br><span class="line">        <span class="comment"># blob = cur.fetchone()</span></span><br><span class="line">        <span class="comment">#open(path_to_dir + str(blob[0]) + '.jpg', 'wb').write(blob[1])</span></span><br><span class="line">        <span class="comment"># close the communication with the PostgresQL database</span></span><br><span class="line">        cur.close()</span><br><span class="line">    <span class="keyword">except</span> (Exception, psycopg2.DatabaseError) <span class="keyword">as</span> error:</span><br><span class="line">        print(error)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> conn <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            conn.close()</span><br><span class="line">    print(<span class="string">"get_from_dataset success"</span>)</span><br><span class="line">    <span class="keyword">return</span> blob</span><br><span class="line"></span><br><span class="line">_s=<span class="string">"ref_id,feed_id,last_read,last_marked"</span></span><br><span class="line">cmd_sql=<span class="string">"SELECT %s  FROM public.ttrss_user_entries Where marked=TRUE AND last_marked BETWEEN '2022-04-01' And '2022-5-01'"</span> % _s</span><br><span class="line"><span class="comment"># 可以自己改日期</span></span><br><span class="line"></span><br><span class="line">g_content=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> _e <span class="keyword">in</span> sorted(get_from_dataset(cmd_sql),key=<span class="keyword">lambda</span> x:x[<span class="number">3</span>]):</span><br><span class="line">    [ref_id,feed_id,last_read,last_marked] = _e</span><br><span class="line">    _s=<span class="string">"id,title,link,updated,content"</span></span><br><span class="line">    cmd_sql=<span class="string">"SELECT %s FROM public.ttrss_entries WHERE id = %s"</span> % (_s,ref_id)</span><br><span class="line">    [id,title,link,updated,content] =get_from_dataset(cmd_sql)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    g_content += <span class="string">"# [%s](%s)\n"</span>%(title,link)</span><br><span class="line">    g_content +=<span class="string">"pubdata:%s\n"</span>%str(updated)</span><br><span class="line">    g_content +=<span class="string">"markdate:%s\n"</span>%str(last_marked)</span><br><span class="line">    g_content+=html2text.html2text(content)</span><br><span class="line">    </span><br><span class="line">    g_content+=<span class="string">"\n\n"</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">D=<span class="string">"C:\\Users\\talen\\Desktop\\"</span></span><br><span class="line"><span class="keyword">with</span> open(D+<span class="string">"cc.md"</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(g_content)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;
统计ttrss的使用数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;月度mark文件分析 OK&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TODO：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全年阅读报告 doing&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="工具" scheme="https://talengu.github.io/public/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="rss" scheme="https://talengu.github.io/public/tags/rss/"/>
    
      <category term="python" scheme="https://talengu.github.io/public/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>本地安装rss</title>
    <link href="https://talengu.github.io/public/2022/04/16/rss_local_install/"/>
    <id>https://talengu.github.io/public/2022/04/16/rss_local_install/</id>
    <published>2022-04-16T12:39:04.000Z</published>
    <updated>2022-04-27T12:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>在 “<a href="https://zhuanlan.zhihu.com/p/149452085" target="_blank" rel="noopener">二零年RSS杂谈</a>”中说到，我想建立一种信息的获取系统，免受广告和推荐算法的困扰。</p><p>我希望其的功能包括：</p><ul><li>多终端 Web、PC、 mobile的同步</li><li>全文获取能力</li><li>可自定义过滤规则</li><li>RSS源自定义</li></ul><p>方案：</p><ul><li>RSS源 rsshub</li><li>RSS服务  ttrss</li><li>RSS电脑手机软件：Android的Readably、Feedme，mac的reeder等等。windows上我暂时没有发现，我用的是ttrss的web界面。</li></ul><a id="more"></a><p>rsshub 是由 DIYgod 开发的开源RSS源生成工具，RSShub原始的网站可能不稳定，所以我选择了自己搭建。</p><p>ttrss 是一个rss源管理配置的工具，可获取全文，可自定义过滤规则。</p><p>本教程我们将完成在window电脑通过docker安装，ttrss与全文插件、rsshub的过程。</p><p>服务器的成本还是有点小贵的，我们可以在本地搭建整个服务，即利用docker安装这些服务，开机的时候记得启动这些服务。不爽点：</p><ul><li>需要后台开启docker服务，使得其自动更新信息</li><li>没有公网ip的情况下，无法全网连接服务</li></ul><h2 id="最终ttrss界面"><a class="header-anchor" href="#最终ttrss界面">¶</a>最终ttrss界面</h2><p>在这里我已经添加一些rss源了。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626135803804.png" alt="image-20200626135803804"></p><h2 id="docker-windows安装"><a class="header-anchor" href="#docker-windows安装">¶</a>docker windows安装</h2><p>从<a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">docker 官网</a> 下载windows版本安装。完成后，在图标区会有一个鲸鱼船。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626141604658.png" alt="image-20200626141604658"></p><p>我们使用docker-compose 来进行下一步 网站服务的安装。将下面的资料保存到s<code> docker-compose.yml</code> 然后利用docker-compose方法安装。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">service.rsshub:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">diygod/rsshub</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rsshub</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"1200:1200"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rsshub_data:/app/lib</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">service.rss:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangqiru/ttrss:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ttrss</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8118</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SELF_URL_PATH=http://127.0.0.1:8118/</span> <span class="comment"># please change to your own domain</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_HOST=database.postgres</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PORT=5432</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_NAME=ttrss</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_USER=postgres</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PASS=ttrss</span> <span class="comment"># please change the password</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ENABLE_PLUGINS=auth_internal,fever</span> <span class="comment"># auth_internal is required. Plugins enabled here will be enabled for all users as system plugins</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FEED_LOG_QUIET=true</span></span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">'sh /wait-for.sh $$DB_HOST:$$DB_PORT -- php /configure-db.php &amp;&amp; exec s6-svscan /etc/s6/'</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">database.postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_PASSWORD=ttrss</span> <span class="comment"># please change the password</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgres_data:/var/lib/postgresql/data</span> <span class="comment"># persist postgres data to ~/postgres/data/ on the host</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">service.mercury:</span> <span class="comment"># set Mercury Parser API endpoint to `service.mercury:3000` on TTRSS plugin setting page</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangqiru/mercury-parser-api:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mercury</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">postgres_data:</span></span><br><span class="line">  <span class="attr">rsshub_data:</span></span><br></pre></td></tr></table></figure><p><img src="/public/2022/04/16/rss_local_install/image-20200626140114783.png" alt="image-20200626140114783"></p><p>在地址栏输入<code>cmd</code>，我们就可以打开cmd界面了，然后运行<code>docker-compose up -d</code> ，就可以自动安装全部内容了。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626134626593.png" alt="image-20200626134626593"></p><p>在地址栏输入<code>cmd</code> 然后回车，我们就能进入cmd界面，然后使用docker-compose，进行安装，网速好的话，安装很快。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626140147402.png" alt="image-20200626140147402"></p><p>安装完毕我们就可以使用了，下面是其资源占用情况。</p><table><thead><tr><th></th><th>内容</th><th>占用内存空间（M）</th></tr></thead><tbody><tr><td>mercury</td><td>全文获取ttrss插件</td><td>66.8</td></tr><tr><td>postgres</td><td>ttrss数据库</td><td>6.8</td></tr><tr><td>ttrss</td><td>ttrss工具</td><td>30.2</td></tr><tr><td>rsshub</td><td>rsshub各种b站源等等</td><td>142.4</td></tr><tr><td></td><td></td><td>246.2</td></tr></tbody></table><p><img src="/public/2022/04/16/rss_local_install/image-20200626140407183.png" alt="image-20200626140407183"></p><p>打开 <a href="http://127.0.0.1:8118/" target="_blank" rel="noopener">http://127.0.0.1:8118/</a></p><p>默认账户：admin 密码：password，请第一时间更改。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626143320968.png" alt="image-20200626143320968"></p><h2 id="在chrome安装-rsshub-radar"><a class="header-anchor" href="#在chrome安装-rsshub-radar">¶</a>在chrome安装 rsshub radar</h2><p><img src="/public/2022/04/16/rss_local_install/image-20200626144233385.png" alt="image-20200626144233385"></p><p>并设置到本机的rsshub地址，ttrss地址，如上。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626144330350.png" alt="image-20200626144330350"></p><p>打开bilibili up主的主页就能订阅了，订阅到ttrss。</p><p>这里有问题。需要解决。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626145153354.png" alt="image-20200626145153354"></p><p>本次安装教程到此结束，下期我们介绍全文获取功能，手机app的联动，即ttrss的设置问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 “&lt;a href=&quot;https://zhuanlan.zhihu.com/p/149452085&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二零年RSS杂谈&lt;/a&gt;”中说到，我想建立一种信息的获取系统，免受广告和推荐算法的困扰。&lt;/p&gt;
&lt;p&gt;我希望其的功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多终端 Web、PC、 mobile的同步&lt;/li&gt;
&lt;li&gt;全文获取能力&lt;/li&gt;
&lt;li&gt;可自定义过滤规则&lt;/li&gt;
&lt;li&gt;RSS源自定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RSS源 rsshub&lt;/li&gt;
&lt;li&gt;RSS服务  ttrss&lt;/li&gt;
&lt;li&gt;RSS电脑手机软件：Android的Readably、Feedme，mac的reeder等等。windows上我暂时没有发现，我用的是ttrss的web界面。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="信息收集" scheme="https://talengu.github.io/public/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="rss" scheme="https://talengu.github.io/public/tags/rss/"/>
    
      <category term="工具" scheme="https://talengu.github.io/public/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【转】window软件运行时间</title>
    <link href="https://talengu.github.io/public/2022/04/15/soft_run_time/"/>
    <id>https://talengu.github.io/public/2022/04/15/soft_run_time/</id>
    <published>2022-04-15T12:39:04.000Z</published>
    <updated>2022-04-27T12:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2><p>对关注性能的程序开发人员而言，一个好的计时部件既是益友，也是良师。计时器既可以作为程序组件帮助程序员精确的控制程序进程，又是一件有力的调试武器，在有经验的程序员手里可以尽快的确定程序的性能瓶颈，或者对不同的算法作出有说服力的性能比较。</p><a id="more"></a><p>在Windows平台下，常用的计时器有两种，一种是<code>timeGetTime</code>多媒体计时器，它可以提供毫秒级的计时。但这个精度对很多应用场合而言还是太粗糙了。另一种是<code>QueryPerformanceCount</code>计数器，随系统的不同可以提供微秒级的计数。对于实时图形处理、多媒体数据流处理、或者实时系统构造的程序员，善用<code>QueryPerformanceCount/QueryPerformanceFrequency</code>是一项基本功。</p><p>本文要介绍的，是另一种直接利用<code>Pentium CPU</code>内部时间戳进行计时的高精度计时手段。以下讨论主要得益于<code>《Windows图形编程》</code>一书，第15页－17页，有兴趣的读者可以直接参考该书。关于RDTSC指令的详细讨论，可以参考Intel产品手册。本文仅仅作抛砖之用。</p><p>在 <code>Intel Pentium</code>以上级别的CPU中，有一个称为“时间戳（Time   Stamp）”的部件，它以64位无符号整型数的格式，记录了自CPU上电以来所经过的时钟周期数。由于目前的CPU主频都非常高，因此这个部件可以达到纳秒级的计时精度。这个精确性是上述两种方法所无法比拟的。</p><p>在Pentium以上的CPU中，提供了一条机器指令RDTSC（Read Time   Stamp Counter）来读取这个时间戳的数字，并将其保存在EDX:EAX寄存器对中。由于<code>EDX:EAX</code>寄存器对恰好是Win32平台下C++语言保存函数返回值的寄存器，所以我们可以把这条指令看成是一个普通的函数调用。像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline   unsigned   __int64   GetCycleCount()   </span><br><span class="line">&#123;   </span><br><span class="line">  __asm   RDTSC   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是不行，因为RDTSC不被C++的内嵌汇编器直接支持，所以我们要用_emit伪指令直接嵌入该指令的机器码形式<code>0X0F</code>、<code>0X31</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  inline   unsigned   __int64   GetCycleCount()   </span><br><span class="line">  &#123;   </span><br><span class="line">    __asm   _emit   0x0F   </span><br><span class="line">    __asm   _emit   0x31   </span><br><span class="line">  &#125;   </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">以后在需要计数器的场合，可以像使用普通的Win32   API一样，调用两次GetCycleCount函数，比较两个返回值的差，像这样：</span><br></pre></td></tr></table></figure><p>unsigned   long   t;<br>t   =   (unsigned   long)GetCycleCount();<br>//Do   Something   time-intensive   ...<br>t   -=   (unsigned   long)GetCycleCount();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`《Windows图形编程》`第15页编写了一个类，把这个计数器封装起来。有兴趣的读者可以去参考那个类的代码。作者为了更精确的定时，做了一点小小的改进，把执行`RDTSC`指令的时间，通过连续两次调用`GetCycleCount`函数计算出来并保存了起来，以后每次计时结束后，都从实际得到的计数中减掉这一小段时间，以得到更准确的计时数字。但我个人觉得这一点点改进意义不大。在我的机器上实测，这条指令大概花掉了几十到100多个周期，在`Celeron 800MHz`的机器上，这不过是十分之一微秒的时间。对大多数应用来说，这点时间完全可以忽略不计；而对那些确实要精确到纳秒数量级的应用来说，这个补偿也过于粗糙了。   </span><br><span class="line">    </span><br><span class="line">  这个方法的优点是：   </span><br><span class="line">    </span><br><span class="line">  1. 高精度。可以直接达到纳秒级的计时精度（在1GHz的CPU上每个时钟周期就是一纳秒），这是其他计时方法所难以企及的。   </span><br><span class="line">    </span><br><span class="line">  2. 成本低。`timeGetTime`函数需要链接多媒体库 `winmm.lib`，`QueryPerformance*`函数根据MSDN的说明，需要硬件的支持（虽然我还没有见过不支持的机器）和KERNEL库的支持，所以二者都只能在Windows平台下使用（关于DOS平台下的高精度计时问题，可以参考`《图形程序开发人员指南》`，里面有关于控制定时器8253的详细说明）。但`RDTSC`指令是一条CPU指令，凡是i386平台下Pentium以上的机器均支持，甚至没有平台的限制（我相信i386版本UNIX和Linux下这个方法同样适用，但没有条件试验），而且函数调用的开销是最小的。   </span><br><span class="line">    </span><br><span class="line">  3. 具有和CPU主频直接对应的速率关系。一个计数相当于1/(CPU主频Hz数)秒，这样只要知道了CPU的主频，可以直接计算出时间。这和   `QueryPerformanceCount`不同，后者需要通过`QueryPerformanceFrequency`获取当前计数器每秒的计数次数才能换算成时间。   </span><br><span class="line">    </span><br><span class="line">  这个方法的缺点是：   </span><br><span class="line">    </span><br><span class="line">  1. 现有的C/C++编译器多数不直接支持使用RDTSC指令，需要用直接嵌入机器码的方式编程，比较麻烦。   </span><br><span class="line">    </span><br><span class="line">  2. 数据抖动比较厉害。其实对任何计量手段而言，精度和稳定性永远是一对矛盾。如果用低精度的`timeGetTime`来计时，基本上每次计时的结果都是相同的；而`RDTSC`指令每次结果都不一样，经常有几百甚至上千的差距。这是这种方法高精度本身固有的矛盾。   </span><br><span class="line">    </span><br><span class="line">  关于这个方法计时的最大长度，我们可以简单的用下列公式计算：</span><br></pre></td></tr></table></figure><p>自CPU上电以来的秒数   =   RDTSC读出的周期数   /   CPU主频速率（Hz）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">64位无符号整数所能表达的最大数字是`1.8×10^19`，在我的`Celeron   800`上可以计时大约700年（书中说可以在200MHz的Pentium上计时117年，这个数字不知道是怎么得出来的，与我的计算有出入）。无论如何，我们大可不必关心溢出的问题。   </span><br><span class="line">    </span><br><span class="line">下面是几个小例子，简要比较了三种计时方法的用法与精度   </span><br><span class="line"> ```c</span><br><span class="line">//Timer1.cpp   使用了RDTSC指令的Timer类//KTimer类的定义可以参见《Windows图形编程》P15   </span><br><span class="line">//编译行：CL Timer1.cpp   /link   USER32.lib   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">#include   &quot;KTimer.h&quot;   </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  unsigned   t;   </span><br><span class="line">  KTimer   timer;   </span><br><span class="line">  timer.Start();   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  t   =   timer.Stop();   </span><br><span class="line">  printf(&quot;Lasting   Time:   %d\n&quot;,t);   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">//Timer2.cpp   使用了timeGetTime函数   </span><br><span class="line">//需包含&lt;mmsys.h&gt;，但由于Windows头文件错综复杂的关系   </span><br><span class="line">//简单包含&lt;windows.h&gt;比较偷懒：）   </span><br><span class="line">//编译行：CL   timer2.cpp   /link   winmm.lib     </span><br><span class="line">#include   &lt;windows.h&gt;   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">  </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  DWORD   t1,   t2;   </span><br><span class="line">  t1   =   timeGetTime();   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  t2   =   timeGetTime();   </span><br><span class="line">  printf(&quot;Begin   Time:   %u\n&quot;,   t1);   </span><br><span class="line">  printf(&quot;End   Time:   %u\n&quot;,   t2);   </span><br><span class="line">  printf(&quot;Lasting   Time:   %u\n&quot;,(t2-t1));   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">//Timer3.cpp   使用了QueryPerformanceCounter函数   </span><br><span class="line">//编译行：CL   timer3.cpp   /link   KERNEl32.lib   </span><br><span class="line">#include   &lt;windows.h&gt;   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">  </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  LARGE_INTEGER   t1,   t2,   tc;   </span><br><span class="line">  QueryPerformanceFrequency(&amp;tc);   </span><br><span class="line">  printf(&quot;Frequency:   %u\n&quot;,   tc.QuadPart);   </span><br><span class="line">  QueryPerformanceCounter(&amp;t1);   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  QueryPerformanceCounter(&amp;t2);   </span><br><span class="line">  printf(&quot;Begin   Time:   %u\n&quot;,   t1.QuadPart);   </span><br><span class="line">  printf(&quot;End   Time:   %u\n&quot;,   t2.QuadPart);   </span><br><span class="line">  printf(&quot;Lasting   Time:   %u\n&quot;,(   t2.QuadPart-   t1.QuadPart));   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">////////////////////////////////////////////////   </span><br><span class="line">//以上三个示例程序都是测试1秒钟休眠所耗费的时间   </span><br><span class="line">//测试环境：Celeron   800MHz   /   256M   SDRAM       </span><br><span class="line">//         Windows   2000   Professional   SP2   </span><br><span class="line">//         Microsoft   Visual   C++   6.0   SP5   </span><br><span class="line">////////////////////////////////////////////////</span><br></pre></td></tr></table></figure><p>以下是Timer1的运行结果，使用的是高精度的<code>RDTSC</code>指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lasting   Time:   804586872</span><br></pre></td></tr></table></figure><p>以下是Timer2的运行结果，使用的是最粗糙的<code>timeGetTime API</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Begin   Time:   20254254   </span><br><span class="line">End   Time:   20255255   </span><br><span class="line">Lasting   Time:   1001</span><br></pre></td></tr></table></figure><p>以下是Timer3的运行结果，使用的是<code>QueryPerformanceCount API</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Frequency:   3579545   </span><br><span class="line">Begin   Time:   3804729124   </span><br><span class="line">End   Time:   3808298836   </span><br><span class="line">Lasting   Time:   3569712</span><br></pre></td></tr></table></figure><p>古人说，触类旁通。从一本介绍图形编程的书上得到一个如此有用的实时处理知识，我感到非常高兴。有美不敢自专，希望大家和我一样喜欢这个轻便有效的计时器。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#背景&quot;&gt;¶&lt;/a&gt;背景&lt;/h2&gt;
&lt;p&gt;对关注性能的程序开发人员而言，一个好的计时部件既是益友，也是良师。计时器既可以作为程序组件帮助程序员精确的控制程序进程，又是一件有力的调试武器，在有经验的程序员手里可以尽快的确定程序的性能瓶颈，或者对不同的算法作出有说服力的性能比较。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://talengu.github.io/public/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="软件运行" scheme="https://talengu.github.io/public/tags/%E8%BD%AF%E4%BB%B6%E8%BF%90%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>知识记忆软件anki的使用</title>
    <link href="https://talengu.github.io/public/2022/04/14/anki_tips/"/>
    <id>https://talengu.github.io/public/2022/04/14/anki_tips/</id>
    <published>2022-04-14T12:39:04.000Z</published>
    <updated>2022-04-27T12:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="anki使用-自建-anki-server"><a class="header-anchor" href="#anki使用-自建-anki-server">¶</a>anki使用 - 自建 anki  server</h2><p>当初想设计好用的英语背诵软件，现在发现了anki人家功能全部实现，还要啥自行车。</p><p>我当时设计的单词勇士开源Android软件：<a href="https://github.com/talengu/WordWarrior" target="_blank" rel="noopener">https://github.com/talengu/WordWarrior</a>现在已弃坑。</p><p>我们当然选用docker compose 来安装，相当丝滑。</p><p>在使用Anki过程中，主要工作是制作卡组，我们可以只关心内容而不关心技术。</p><a id="more"></a><h2 id="docker-compose"><a class="header-anchor" href="#docker-compose">¶</a>docker compose</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">service.anki:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kuklinistvan/anki-sync-server</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">anki-container</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8121</span><span class="string">:27701</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/anki-sync-server:/app/data</span> <span class="comment"># anki data</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="登陆container"><a class="header-anchor" href="#登陆container">¶</a>登陆container</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it anki-container /bin/sh</span><br><span class="line"></span><br><span class="line">./ankisyncctl.py lsuser             - list users</span><br><span class="line">./ankisyncctl.py adduser &lt;username&gt; - add a new user</span><br><span class="line">./ankisyncctl.py deluser &lt;username&gt; - delete a user</span><br><span class="line">./ankisyncctl.py passwd &lt;username&gt;  - change password of a user</span><br></pre></td></tr></table></figure><h2 id="客户端"><a class="header-anchor" href="#客户端">¶</a>客户端</h2><img src="/public/2022/04/14/anki_tips/image-20200424005627732.png" alt="image-20200424005627732" style="zoom:33%;"><h3 id="mac-win-客户端"><a class="header-anchor" href="#mac-win-客户端">¶</a>mac/win 客户端</h3><p>从官网下载 【anki mac版本 2.1.21 (f1734a47)】/【Windows PC 客户端】</p><p>中文网：<a href="http://www.ankichina.net/" target="_blank" rel="noopener">http://www.ankichina.net/</a></p><p>工具-&gt;附加组件-&gt;<code>获取插件</code>，输入 代码：2124817646</p><img src="/public/2022/04/14/anki_tips/add_server.png" alt="add_server" style="zoom:30%;"><img src="/public/2022/04/14/anki_tips/add_on1.png" alt="add_on1" style="zoom:30%;"><p>插件下载完成后设置ip地址，点击<code>设置</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"msyncUrl"</span>: <span class="string">"http://127.0.0.1:27701/msync/"</span>,</span><br><span class="line">    <span class="attr">"syncUrl"</span>: <span class="string">"http://127.0.0.1:27701/sync/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/public/2022/04/14/anki_tips/addon_2.png" alt="addon_2" style="zoom:30%;"><p>重启anki，同步并输入输入自定义服务器中配置的账户</p><h3 id="Android客户端-AnkiDroid"><a class="header-anchor" href="#Android客户端-AnkiDroid">¶</a>Android客户端 - AnkiDroid</h3><p>首先配置服务器地址信息，打开<code>设置-&gt;高级设置-&gt;自定义同步服务器</code>，输入同步地址 和 媒体文件同步地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 同步地址</span><br><span class="line">http://127.0.0.1:27701/</span><br><span class="line"># 媒体文件同步地址</span><br><span class="line">http://127.0.0.1:27701/msync/</span><br></pre></td></tr></table></figure><p>然后打开 <code>设置-&gt;AnkiDroid常用设置-&gt;AnkiWeb账户</code>，输入在服务器里面设置的账户和密码。PS：可在服务器重置密码。</p><table><tr><td><center><img src="/public/2022/04/14/anki_tips/IMG_20200424_010047.jpg">图1    </center></td><td><center><img src="/public/2022/04/14/anki_tips/IMG_20200424_011338.jpg">图2      </center></td></tr></table><p>coco20000 anki 包 <a href="https://www.dazhuanlan.com/2019/11/20/5dd54a6571f01/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/11/20/5dd54a6571f01/</a></p><h2 id="其他docker-安装方法"><a class="header-anchor" href="#其他docker-安装方法">¶</a>其他docker 安装方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ANKI_SYNC_DATA_DIR=<span class="variable">$HOME</span>/anki-sync-server</span><br><span class="line"><span class="built_in">export</span> HOST_PORT=27701</span><br><span class="line"></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$ANKI_SYNC_DATA_DIR</span>"</span></span><br><span class="line"><span class="comment">#export DOCKER_USER=root</span></span><br><span class="line"><span class="comment">#chown "$DOCKER_USER" "$ANKI_SYNC_DATA_DIR"</span></span><br><span class="line">chmod 700 <span class="string">"<span class="variable">$ANKI_SYNC_DATA_DIR</span>"</span></span><br><span class="line"></span><br><span class="line">docker run -itd \</span><br><span class="line">   -v <span class="string">"<span class="variable">$ANKI_SYNC_DATA_DIR</span>"</span>:/app/data \</span><br><span class="line">   -p <span class="string">"<span class="variable">$HOST_PORT</span>"</span>:27701 \</span><br><span class="line">   --name anki-container \</span><br><span class="line">   --restart always \</span><br><span class="line">   kuklinistvan/anki-sync-server:latest</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;anki使用-自建-anki-server&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#anki使用-自建-anki-server&quot;&gt;¶&lt;/a&gt;anki使用 - 自建 anki  server&lt;/h2&gt;
&lt;p&gt;当初想设计好用的英语背诵软件，现在发现了anki人家功能全部实现，还要啥自行车。&lt;/p&gt;
&lt;p&gt;我当时设计的单词勇士开源Android软件：
&lt;a href=&quot;https://github.com/talengu/WordWarrior&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/talengu/WordWarrior&lt;/a&gt;
现在已弃坑。&lt;/p&gt;
&lt;p&gt;我们当然选用docker compose 来安装，相当丝滑。&lt;/p&gt;
&lt;p&gt;在使用Anki过程中，主要工作是制作卡组，我们可以只关心内容而不关心技术。&lt;/p&gt;
    
    </summary>
    
      <category term="知识管理" scheme="https://talengu.github.io/public/categories/%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="工具" scheme="https://talengu.github.io/public/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="anki" scheme="https://talengu.github.io/public/tags/anki/"/>
    
      <category term="技巧" scheme="https://talengu.github.io/public/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu完全教程</title>
    <link href="https://talengu.github.io/public/2022/04/01/linux/ubuntu_tour/"/>
    <id>https://talengu.github.io/public/2022/04/01/linux/ubuntu_tour/</id>
    <published>2022-04-01T18:00:04.000Z</published>
    <updated>2022-04-01T18:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ref:<a href="http://www.cnblogs.com/dutlei/archive/2012/11/20/2778327.html" target="_blank" rel="noopener">Ubuntu完全教程，让你成为Ubuntu高手！</a>todo整理</p></blockquote><h2 id="Ubuntu的发音"><a class="header-anchor" href="#Ubuntu的发音">¶</a>Ubuntu的发音</h2><p>Ubuntu，源于非洲祖鲁人和科萨人的语言，发作 oo-boon-too 的音。了解发音是有意义的，您不是第一个为此困惑的人，当然，也不会是最后一个：）</p><p>大多数的美国人读 ubuntu 时，将 u 作为元音发音，类似单词 who 或者 boo ，重音在第二个音节即 u'buntu ，oo-boon-too 。</p><p>如果您喜欢撒哈拉，喜欢它令人窒息的温柔、梦幻般的寂寥还有张扬恣肆的旷远，您大可在第一个 u，后面带些嗡嗡声： oom-boon-too。</p><p>Ubuntu的中文发音大约为： 乌班图</p><h3 id="Ubuntu的涵义"><a class="header-anchor" href="#Ubuntu的涵义">¶</a>Ubuntu的涵义</h3><p>Ubuntu这个单词源自非洲，意谓“班图精神”────谁都不是一座孤岛，自成一体。每个人都包孕于人类，因他人存在而存在，因他人幸福而幸福。</p><h3 id="Ubuntu当前版本"><a class="header-anchor" href="#Ubuntu当前版本">¶</a>Ubuntu当前版本</h3><p>Ubuntu Linux v6.06 LTS (Dapper Drake)</p><p>LTS：Long Term Support</p><p>Dapper Drake：当前版本的开发代号</p><h3 id="Ubuntu的特点"><a class="header-anchor" href="#Ubuntu的特点">¶</a>Ubuntu的特点</h3><p>Ubuntu 完全基于 Linux 操作系统， 可以免费得到社区及专业机构的支持。庞大的社区是它成长的沃土，请向这片动人的热忱敞开心扉。</p><p>Ubuntu 社区恪守 Ubuntu 理念：自由！软件应是自由的，应尊重人类的自由意志，它与人类之间不应有任何隔膜。本地语种，功能限制，自主改进的权利……都不应成为使用的障碍或负担。</p><p>自由，让 Ubuntu 与传统的私有软件从根本上不同: 免费不能用来遮羞，您有权修正它，直到满意为止。</p><p>Ubuntu 适合桌面和服务器。当前 Ubuntu 发布版支持 PC (Intel x86), 64-bit PC (AMD64) 和 PowerPC (Apple iBook 和 Powerbook, G4 和 G5) 架构。</p><p>Ubuntu 包涵了超过 16,000 种软件， 核心的桌面系统却只有一张光盘， Ubuntu 覆盖了所有的桌面应用程序,</p><p>从文字处理，电子表格到 web 服务器和开发设计环境一应俱全。 详情查看 Ubuntu 桌面 和 Ubuntu 服务器的介绍。</p><h3 id="Ubuntu相对其它Linux发行版的主要特点"><a class="header-anchor" href="#Ubuntu相对其它Linux发行版的主要特点">¶</a>Ubuntu相对其它Linux发行版的主要特点</h3><ul><li><p>基于Debian/Linux，使用 APT 包管理系统。</p></li><li><p>相对于Fedora Code： APT 包管理系统优雅地解决了依赖问题，并且可以从容的在线安装升级</p></li><li><p>相对于Debian：软件更新积极，而Debian较保守。</p></li><li><p>相对于Gentoo：基本无需编译，省力、省时、省心。</p></li></ul><a id="more"></a><h3 id="基本操作"><a class="header-anchor" href="#基本操作">¶</a>基本操作</h3><p><strong>进入系统</strong></p><p>在登录界面中输入您的用户名，然后系统将提问您的密码</p><p>输入您的密码后，回车，稍事等待，您便可以进入Ubuntu系统</p><p>点击桌面左上角的图标，您可以打开一个菜单（或者使用 Alt+F1 组合键）</p><p>如果您想退出系统，可以点击该图标</p><p>在桌面上方启动栏中，包含了一些常用程序的启动图标这些图标也可以在开始菜单中找到</p><p>现在点击FireFox图标，您便可以使用FireFox浏览器冲浪</p><p>或者按下 Alt+F2 组合键，弹出一个运行命令对话框。输入 firefox 后回车，同样可以启动FireFox</p><p>在菜单中找到 终端</p><p>点击它便开启了一个终端窗口，您可以在终端窗口中运行命令</p><p>也可以在控制台中输入命令。使用 Ctrl+Alt+[F1~F6] ，您可以切换到1~6号控制台</p><p>使用 Ctrl+Alt+F7 可以返回图形界面（您可以使用 Ctrl+Alt+BackSpace 将图形界面关闭）</p><p>命令行提示符</p><p>user@ubuntu:~$ 为命令提示符， @ 之前的部分为当前用户ID， @ 与 : 之间的部分，为您的主机名称， : 与 $ 之间的部分，为当前的路径。</p><p><strong>退出系统</strong></p><p>您可以点击这一个图标来退出系统</p><p>也可以在终端或者控制台中输入命令</p><p>sudo halt</p><p>系统会提问您密码，输入正确密码，便可以退出系统</p><p>在以后的章节中，如果我们提示您输入命令，那么您即可以在终端中输入，也可以在控制台中输入。如果只是启动应用程序，还可以使用 Alt+F2 组合键。</p><h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2><h3 id="分区概念"><a class="header-anchor" href="#分区概念">¶</a>分区概念</h3><p>首先我们需要知道，硬盘分区的存在，是由硬盘的物理特性决定的，并不会因为不同的操作系统而有所改变。</p><p>请您把一块硬盘想象为一本书……即便您不喜欢读书，您也一定非常熟悉它，所有的书都是相同的，包括我们使用的课本……您肯定非常熟悉</p><p>一本完整的书，通常包括书名、索引和正文。</p><p>如果您需要Linux，您首先需要找到一本书名为《linux》的书，书名相当于硬盘中的MBR，也就是主引导纪录。不同的是，MBR可以是几个书名合在一起，类似于《XX合订本》。这部分内容暂时还没有什么实用价值，您只需要大概的了解。</p><p>而正文，就是硬盘中纪录的数据，这也非常容易理解，且对于安装系统并没有什么影响，所以现在我们来了解索引</p><p>索引相当于硬盘中的分区表，书中的每一个章节，相当于硬盘中的一个分区，它起始和结束的页次，都可以在索引中找到。试想，如果阅读一本撕掉索引的书，您将很难找到您想阅读的部分。同样，如果没有分区表，操作系统也不能够在硬盘上定位数据的位置。</p><p>由于历史的原因，硬盘中的分区表大小受到了限制，最多只可以容纳四个分区（主分区）。如果一本书，它的索引最多只能有四个章节，那不是太可怕了么？很多书的内容远远不止四个章节啊！</p><p>于是聪明的人们想到了一个变通的办法，就是利用其中的一个章节，来存储其它部分的索引。比如第一章是前言，第二章是其它部分的索引，我们翻到第二章，呵呵，这里是第二个索引，因为只有第一个索引受四个章节的限制，所以这个索引的内容可以非常的详尽。第二个索引就是分区表中的扩展分区了，其中定义的章节，就是硬盘中的逻辑分区，不是很难理解吧？</p><p>明白了这一点，我们来看看Linux和Windows对于分区不同的表示方法：</p><p>可能您已经很熟悉Windows了，它使用盘符来表示分区，比如 C: D: E:，每一个分区使用一个盘符来标识，而且顺序可以颠倒， D:并不一定就是您系统中的第二个分区。（如果您给第二个分区分配最后一个硬盘盘符，把所有的盘符按顺序排列好，并且重装一次系统，您就会理解什么叫作“头疼”了：）</p><p>而在Linux中，分区是这样表示的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/hda        /dev/hda1      /dev/hda2       /dev/hda5/      dev/sdb1</span><br></pre></td></tr></table></figure><p>以 /dev/hda5 为例:</p><p>因为在Linux中，每一个设备都是用 /dev/ 文件夹下的一个文件来表示，所以 /dev/hda5 中， /dev/ 表示的是根目录下的dev目录，我们来看剩下的部分 hda5 。</p><p>前两位的字母 hd 表示这是一块IDE硬盘，如果是 sd ，则代表SATA硬盘，或者闪存等外设。</p><p>第三位的字母 a 表示这是该类型接口上的第一个设备。同理， b、c、d…… 分别代表该类型接口上的第二三四……个设备。例如 hdc 表示第二个IDE接口上的主硬盘（每个IDE接口上允许一个主设备和一个从设备）。</p><p>第四位的数字 5，并不表示这是该硬盘中的第5个分区，而是第一个逻辑分区。因为在Linux中，为了避免不必要的混乱，分区的顺序是不能改变的，分区标识则由它们在硬盘中的位置决定。系统又要为所有可能的主分区预留标识，所以 1-4 一定不会是逻辑分区， 5 则是第一个逻辑分区，以此类推。</p><h3 id="安装中的注意事项"><a class="header-anchor" href="#安装中的注意事项">¶</a>安装中的注意事项</h3><p>在Ubuntu系统的安装过程中，您需要选择系统目录的挂载点。</p><p>我们知道，安装Windows时，我们可以选择把系统安装在哪一个分区，把系统挂载到分区上。而在ubuntu/Linux中则相反，我们要把分区挂载到系统中。当我们使用Windows的安装方式，把系统挂载到分区上，我们就不可能把Windows目录放在C盘，而把<code>MyDocuments</code>目录放到其它分区。您或者出于习惯，或者出于数据安全方面的考虑，通常把文档放到其它分区中。但是Windows下很多软件保存文件的默认目录就是<code>MyDocument</code>目录，这就比较不方便。</p><p>在系统安装完成后，我们还是可以将<code>MyDocuments</code>目录转移到其它分区中，不过有点麻烦，可能许多朋友还不知道怎么去作……而任何一种Linux系统时，当然包括<code>Ubuntu</code>，我们可以在系统安装时就把分区挂载到目录下， <code>/home</code> 目录相当于Windows的<code>MyDocuments</code> ，我们可以把 <code>/dev/hda5</code> 挂载到此目录下，这样我们往 <code>/home</code>目录里存东西的时候，其实保存在第一个扩展分区中。如果再一次安装系统，只要把这个分区挂载到 <code>/home</code>目录下，那么进入新系统就像回家一样，真是太棒了。</p><p>理论上来讲，您可以将分区挂载到任何目录下面，您可以自定义挂载的路径。但是我们并不推荐您这么作，因为那没有任何意义。系统安装程序向您建议的挂载目录，通常也是我们向您建议的，现在我们来了解一下，这些目录通常都是用来作什么的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/    根目录，唯一必须挂载的目录。不要有任何的犹豫，选一个分区，挂载它！（在绝大多数情况下，有2G的容量应该是够用了。当然了，很多东西都是多多益善的：）</span><br><span class="line"></span><br><span class="line">Swap     交换分区，可能不是必须的，不过按照传统，并且照顾到您的安全感，还是挂载它吧。它的容量只要大于您的物理内存就可以了，如果超过了您物理内存两倍的容量，那绝对是一种浪费。</span><br><span class="line"></span><br><span class="line">/home    前面已经介绍过了，这是您的家目录，通常您自己创建的文件，都保存在这里，您最好给它分配一个分区</span><br><span class="line"></span><br><span class="line">/usr  应用程序目录。大部分的软件都安装在这里。如果您计划安装许多软件，建议您也给它分配一个分区</span><br><span class="line"></span><br><span class="line">/var      如果您要作一些服务器方面的应用，可以考虑给它分配一个较大的分区</span><br><span class="line"></span><br><span class="line">/boot     如果您的硬盘不支持LBA模式（我想那不太可能:），您最好挂载它，如果挂载硬盘的第一个分区，应该比较稳妥。一般来说，挂载的分区只要100M大小就足够了</span><br></pre></td></tr></table></figure><p>在文件系统这一环节中，我们建议您选择： <code>ReiserFS</code></p><p>也许您注意到了，Windows中，盘符既用于表示硬件（硬盘上的分区）,又用于表示系统中的路径。而Linux中，硬件就是硬件，路径就是路径，不会混淆在一起，简单直接！</p><h2 id="Linux基础"><a class="header-anchor" href="#Linux基础">¶</a>Linux基础</h2><h3 id="Shell"><a class="header-anchor" href="#Shell">¶</a>Shell</h3><p>可能您早已能够熟练的使用GUI（图形用户界面），例如您可以使用鼠标双击一个图标，来打开或者执行它。</p><p>我们来看这个过程: 您使用鼠标定位桌面上的一个程序图标，按下左键两次。系统读取鼠标指针的位置，并且判断该位置下图标的涵义，根据预设的双击动作，运行程序或者打开文件。</p><p>这一套GUI系统，便是一种Shell，它的作用是实现人机交互。如果我们不能够控制电脑，那么电脑还不如电视机好玩，不是么？电视机也可以选择频道（电视机的遥控器，也是一种人机交互的界面，不过相对于电脑，确实是相当简单了：）</p><p>易于上手、界面直观是GUI的优点，但是GUI为不意味着简单！或许您有类似经历: 桌面上有几十个程序的启动图标，也知道它们的名字，但是翻出一个来，并不是一件轻松的事情。</p><p>我的Windows系统中，桌面上摆满了各种图标，每当启动一个程序的时候，我都很是困扰。后来尝试了 音速启动 这类的程序启动管理器，效果还是差强人意。</p><p>在我的不懈努力下，这个难道最终得到了解决： 将快捷方式名称简化，放到特定目录下，使用 Win+R 组合键呼出 运行对话框，键入快捷方式的名称来运行该程序。比如 反恐精英 的快捷方式为 cs ，我把它放在 Windows 目录下; 运行 cs命令，就可以去维护世界和平了。</p><p>这么多快捷方式，统统放到 Windows 目录下，非常混乱。因此，我在D盘建立了一个名为 path的目录，并把它的路径加入到环境变量的 path 项中，快捷方式放在 <code>D:\path</code>目录中。即便重装系统，只要在环境变量中重新加入此路径，原来的程序大多可以直接以命令来运行……我的许多朋友强烈要示我帮他们设定这种启动方式，因为这确实很方便：）</p><p>其实在Linux下，所有的程序都可以通过命令运行。虽然Linux也有GUI，但是它并不比Windows的GUI更优秀！上面只是简单的介绍了CLI（命令行界面）相对GUI的优越之处，使用CLI还有更多的好处，您会慢慢体会到的。</p><p>当然了，在您的印象中，CLI一定非常的不友善，缺少亲和力，冷漠而拒人于千里之外……您和CLI之间甚至有代沟的存在：）</p><h4 id="命令"><a class="header-anchor" href="#命令">¶</a>命令</h4><p>坦白的说，冷不丁见到那么老长的一串命令，谁都会毛骨悚然。</p><p>也许您使用过DOS，留下这种印象：命令先放一边，光是正确的输入目录、文件名都够瞧的。而且DOS不区分大小写，要是像Linux一样区分大小写，那多恐怖啊！！！</p><p>其实Linux命令行具有补全功能，非常实用。假设有这样一个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> path/file</span><br></pre></td></tr></table></figure><p>如果只有一个以 c 起始的命令，键入 c ，再按一次 tab 键，系统将自动补全该命令余下的部分。 只要 c tab 两次按键，就可以完成 command 的输入。</p><p>如果不只一个 c 起始的命令，那么您可以按两次 tab 键，系统会列出所有符合条件的选项，也就是以 c 起始的所有命令。进一步输入 o ，如果只有一个以 co 起始的命令（一直输入，直到项符合条件的选项唯一），再按一次 tab ，命令就被补全完整。</p><p>路径和文件名也可以通过 tab 键来补全。还有一种 遍历补全 的方式，如果您的文件名是中文，而您不想切换输入法；甚至您的文件名中出现乱码，无法输入，这时 遍历补全 就可以大显身手了。这部分内容我们稍后再谈：）</p><p>现在我们来了解命令的语法结构，这一部分相当重要，您可得看仔细。</p><p>我们知道，任何语言都有特定的语法结构，以我们的中文为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们郑重地推荐您Ubuntu/Linux！</span><br></pre></td></tr></table></figure><p>这个句子的语法尽管简单，却是大部分的命令行采用的句型。让我们看一下，这个句子里都有些什么：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们</span><br></pre></td></tr></table></figure><p>主语，Linux命令的执行者只有一个，所以主语一概省略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">推荐</span><br></pre></td></tr></table></figure><p>一个动词，作为谓语而存在。Linux命令中，这一部分是必须的。这一部分也是不同命令之间最根本的区别方式，所以它通常作为命令名，写在最前面。键入 date 命令，您可以查看当前的时间日期。（ 应用程序-&gt;附件-&gt;终端 ）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">郑重的</span><br></pre></td></tr></table></figure><p>状语，用来修饰谓语。与之相对应，Linux命令可以使用参数来精细调节程序的行为。为了与命令的操作对象相区别，参数前通常要加 - 或者 -- 符号。原则上，在命令名之后，参数的位置可以随意，但是为了养成一个良好的习惯，我们建议您在命令名后直接跟参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">您 Ubuntu/linux</span><br></pre></td></tr></table></figure><p>这两个部分都是宾语，它们是命令的操作对象。大部分的命令只有一个操作对象，也有一些命令是双宾语结构的，具有一个直接宾语和一个间接宾语。比如 拷贝 这个命令 cp (copy)</p><h4 id="分隔符"><a class="header-anchor" href="#分隔符">¶</a>分隔符</h4><p>我们的汉语是象形文字，没有分隔符。但是所有的拼音文字中都有分隔符，来分隔单词。Linux命令中同样使用空格作分隔符。</p><p>cp a /home 表示把当前目录下的 a 文件，拷贝到 /home 目录下。（命令的不同部分使用空格分隔，连续的空格视为一个空格）</p><p>上面的那句话，翻译成Linux的命令，应该是这个样子的：</p><p>推荐 --郑重的 您 Ubuntu/Linux （按照传统，“-”后跟简写为单个字母的参数，“--”后跟完整单词的参数。不过也有例外：）</p><p>哈，Linux的命令也蛮简单吧？</p><h3 id="Linux程序、进程"><a class="header-anchor" href="#Linux程序、进程">¶</a>Linux程序、进程</h3><p>或许您会这样想，Linux命令的句型确实不难，但是那么多命令，我怎么知道它们都是作什么的呢？而且不同的系统中，可以使用的命令似乎也不太一样，这真让人困惑……</p><p>其实Linux的命令，运行的是Linux系统中的程序。只要您已安装了程序，您就可以通过命令来运行它，并且可以使用参数来精细的调整它的运行状态。也可以通过点击启动图标来运行，不过启动图标不能够方便的调整参数，并不是很方便。</p><p>举一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplayer -shuffle -loop 3 -playlist mymp3.list</span><br></pre></td></tr></table></figure><p>可能您运行上面命令，系统会提示您 无法找到命令，那是因为您没有安装mplayer这个程序。mplayer是我见过的支持格式最多的播放器，几乎任何已知格式的多媒体文件，都可以使用mplayer来播放。它包含一个图形界面的前端，您可以在菜单中找到它，鼠标点击运行;也可以通过执行命令来运行它的命令行版本。</p><p>如果您的系统中没有mplayer播放器，我们建议您安装一个。关于程序的安装，请参阅 软件安装 。</p><p>上面命令中， mplayer 调用了mplayer播放器程序。参数 -shuffle 表示随机播放， -loop 表示循环播放，后面的3 为循环的次数，如果为 0 ,则一直播放。 -playlist 表示播放列表中的曲目。我们可以把mp3的路径放到 mymp3.list文件中，让mplayer来播放它们。</p><p><strong>进程</strong> 为运行中的程序，是程序在内存中的镜像。</p><p>好了，现在您已经了解了 Shell 、 命令 、 程序 、 进程 的概念，您基本上也就了解了Linux（Linux系统真是非常简洁，而且容易理解：）。</p><p>但只知道这些，您并不能顺畅使用。接下来的章节中，我们来进一步介绍它的细节。</p><h2 id="Linux系统简介"><a class="header-anchor" href="#Linux系统简介">¶</a>Linux系统简介</h2><h3 id="路径"><a class="header-anchor" href="#路径">¶</a>路径</h3><p>路径分为绝对路径和相对路径。</p><p><strong>绝对路径</strong>的起始点为根目录 <code>/</code> ，例如 <code>/usr/local/bin</code> 就是绝对路径，它指向系统中一个绝对的位置，不受其它因素影响。</p><p><strong>相对路径</strong>的起始点为当前目录，如果您现在位于 /usr 目录，那么相对路径 local/bin 所指示的位置为 <code>/usr/local/bin</code></p><p>也就是说，相对路径所指示的位置，除了相对路径本身，还受到当前位置的影响。例如Linux系统中常见的目录 <code>/bin</code> 、 <code>/usr/bin</code>、 <code>/usr/local/bin</code>，如果只有一个相对路径 bin，那么它指示的位置可能上面三个目录中的任意一个，也可能是其它目录。</p><p>如果我告诉您到 <code>bin</code> 目录寻找一个文件，您可能搞不清楚是哪一个 <code>bin</code> 目录。只有当前位置确定，相对路径指示的位置才能够确定。</p><p>现在我说， <code>/usr/local</code> 目录下，它的相对路径 <code>bin</code> 中有某个文件，这样就比较明确了。</p><p>在相对路径中 . 表示当前目录， .. 表示当前目录的上一级目录。</p><p>假设您安装了一个程序，它的主程序没有被放置到上面三个 bin 目录中的任何一个，或者其它系统能够找到的地方，您就得告诉系统，它的可执行文件在哪里。</p><blockquote><p>可以使用绝对路径，例如： <code>/home/user/bin/</code>可执行文件</p></blockquote><p>或者定位到 <code>/home/user/bin</code> 目录，使用相对目录来定位它 ./可执行文件</p><p>如果您定位到了它的子目录，比如 <code>/home/user/bin/gui</code>，您可以使用 <code>..</code> 来表示它的上级目录 <code>../</code>可执行文件</p><p>路径相关命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> (change directory) 更改目录。</span><br><span class="line"><span class="built_in">pwd</span> (<span class="built_in">print</span> working directory)显示当前路径。</span><br><span class="line">ls (list) 显示当前目录中的文件列表。</span><br></pre></td></tr></table></figure><p>请尝试以下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc 进入“/etc”目录，这里使用的是绝对路径</span><br><span class="line"></span><br><span class="line"><span class="built_in">pwd</span> 显示当前路径，这个命令返回结果“/etc”</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> init.d 进入“/etc”目录的子目录“init.d”，这里使用的是相对路径</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> .. 进入上一级目录“/etc”</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ../home “/etc” 目录的上一级目录为“/”，它的子目录“home”为“/home”</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> - 回到上一次的目录，我们在“/etc”目录跳转到“/home”目录，所以这次是回到“/etc”目录</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~ “~”代表当前用户的“<span class="variable">$HOME</span>”目录，也就是“/home/&#123;用户名&#125;”目录。</span><br><span class="line"></span><br><span class="line">ls 在任何时候，您都可以使用“ls”命令，来了解当前目录下都有哪些文件。</span><br></pre></td></tr></table></figure><p>远程路径：</p><p>远程路径的表示方法为 <code>协议://用户名:密码@位置/路径:端口</code></p><p>大多数的远程路径可以使用默认端口匿名访问，由此用户名、密码、端口通常不需要填写。例如：</p><p><code>http://www.ubuntu.org.cn/.../index.html</code></p><p>要求身份验证的远程路径，您可以使用下面的方式访问:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp://user:passwd@ftp.ubuntu.org.cn:21</span><br></pre></td></tr></table></figure><h3 id="软件"><a class="header-anchor" href="#软件">¶</a>软件</h3><p>Linux中没有***注册表***这个概念。安装软件，理论上讲，只要拷贝所有相关文件，并运行它的主程序就可以了。</p><p>按照传统，一个软件通常分别拷贝到同级目录下的 bin、etc、lib、share等文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Bin      可执行文件，程序的可执行文件通常在这个目录下。在环境变量中设定搜索路径，就可以直接执行，而不需要定位其路径。</span><br><span class="line"></span><br><span class="line">Etc       配置文件，大部分系统程序的配置文件保存于 /etc 目录，便于集中修改。</span><br><span class="line"></span><br><span class="line">Lib      库文件，集中在一起，方便共享给不同程序。相较不同的软件单独保存库文件，能够节约一些磁盘空间。</span><br><span class="line"></span><br><span class="line">Share    程序运行所需要的其它资源，例如图标、文本。这部分文件是专有的，不需要共享；而且目录结构相对复杂，混放在一起比较混乱，所以单独存放。</span><br></pre></td></tr></table></figure><p>还有一些软件，占用一个单独的目录，所有的资源都在这个目录中。类似于Windows下的绿色软件，不推荐在Linux系统下这样作。</p><ul><li><p>执行时，系统找不到可执行文件（搜索所有路径，资源开销过大，是不现实的），需要定位其位置，像这样 /home/user/bin/可执行文件 ，不够方便。</p></li><li><p>许多系统软件需要协作运行，配置文件分别保存，定位它们非常麻烦</p></li><li><p>如果程序使用的库文件，像图形库文件，都单独存放，那么磁盘空间的浪费会非常严重。</p></li></ul><p>有一些大型软件，或者您布署的重要应用，您可以将它们单独安装在一个文件夹下。（通常源码安装支持这种方式，将在 <a href="#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85">软件安装</a> 部分介绍）</p><h4 id="配置方式"><a class="header-anchor" href="#配置方式">¶</a>配置方式</h4><p>Linux下没有类似 注册表 的系统，系统和软件都可以通过纯文本的配置文件进行设置。</p><p>事实上，图形界面的配置工具，通常就是以图形界面的方式修改配置文件，适合设置一些比较简单的程序。如果软件有几千个可以配置的选项，全部作成菜单，想象一下……开始发抖吧……</p><p>图形界面的配置工具，可以看作特定配置文件专用编辑器。您一样可以使用通用文本编辑器来编辑配置文件，比如 Nano、Gedit、Knote、Vim或者Emacs等等。不考虑阅读、修改配置文本占用的时间，直接修改配置文件甚至更迅速。</p><p>如果只是要修改某一常用选项，而且时常修改，比如主机的IP地址。使用文本编辑器，您要找到相应的配置文件，还要在配置文件中找到相应的选项，会浪费掉您的时间和耐性。</p><p>图形配置工具经常会受各种因素制约，比如网络服务器中不提供图形服务，图形界面不够稳定……这时，您可以使用命令行的配置工具来完成这些工作。</p><p>例如： 修改主机IP地址，可以使用ifconfig这个程序，执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.0.1</span><br></pre></td></tr></table></figure><p>在以后的章节中，如果我们提示您修改某一文件，例如 /etc/fstab ，您可以使用任何顺手的文本编辑器打开它。</p><h3 id="隐藏文件"><a class="header-anchor" href="#隐藏文件">¶</a>隐藏文件</h3><p>Linux下，名称中第一个字符为 . 的文件或者文件夹，系统默认情况下将它们隐藏起来，</p><p>您可以尝试以下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ 进入您的用户目录</span><br><span class="line">ls 查看当前目录下的文件列表</span><br><span class="line">ls -a 查看所有文件的文件列表（包括隐藏文件）。</span><br></pre></td></tr></table></figure><p>现在，您可以看到许多文件名以 . 起始的文件或者文件夹了吧？使用 ls 命令无法显示它们</p><ul><li><p>如果您只想查看隐藏文件，而不包括这两个特殊目录，您可以使用 ls 命令的参数 -A （ls -A）</p></li><li><p>每个目录下都包含两个特殊目录 . 和 .. 。您也许猜到了， . 代表当前目录， .. 代表上一级目录。目录是一种特殊类型的文件！</p></li></ul><p>文件类型</p><p>Linux系统主要根据文件头信息来判断文件类型，扩展名并非决定因素。</p><p>现在使用 ls -l 命令，查看详细信息格式的文件列表，您将会看到如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">total 5</span><br><span class="line">drwxr-x--- 4 user group 4096 Mar 10 00:37 filename</span><br><span class="line">drwxr-xr-x 21 user group 4096 Mar 10 20:16 文件名</span><br><span class="line">-rw------- 1 user group 524 Mar 10 00:40 a</span><br><span class="line">-rw-r--r-- 1 user group 24 Jun 11 2000 b</span><br><span class="line">drwx------ 2 user group 4096 Mar 9 11:06 c</span><br></pre></td></tr></table></figure><p>共显示了七列信息，从左至右依次为：权限、文件数、归属用户、归属群组、文件大小、创建日期、文件名称</p><p>其中要特别留意的是第一列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drwxr-xr-x</span><br></pre></td></tr></table></figure><p>一共有10个位置，可以分为4组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d    rwx  r-x  r-x</span><br></pre></td></tr></table></figure><p>第一组只有一个字符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">** d* *文件夹*     ** -* *普通文件*        ** l* *链接*       ** b* *块设备文件*     ** c* *字符设备文件。*</span><br></pre></td></tr></table></figure><p>剩下的3组分别为归属用户、归属群组、其它用户或群组对于该文件的权限。我们看它的格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rwx rwx  rwx</span><br><span class="line"></span><br><span class="line">** r* *可读*       ** w* *可写*      ** x* *可执行*</span><br></pre></td></tr></table></figure><p>它们的顺便不能颠倒，某一位置为空(-)，则表示不具有相应的权限。</p><p>说明：Linux下的可执行文件并不是由扩展名（例如 .exe ）决定的，而是由其可执行权限位决定。</p><p>权限</p><p>我们已经知道了，文件的权限分为 <code>r</code> （可读）、 <code>w</code> （可写）、 <code>x </code>（可执行）三种类型，而一个文件可以针对归属用户，归属群组，其它用户用户或群组分别设定权限。</p><p>这种权限管理的方式灵活、简单、严密、明晰。尽管如此，在最初的阶段，可能会有一点小小的不适。因为它无所不在，而您习惯了的Windows的权限管理却不是这样（非常混乱，大多数时间形同虚设，偶尔用到却让人伤透脑筋）。</p><p>使用 <code>chmod</code> 命令更改文件的权限，使用 <code>chown</code> 来更改文件的归属。例如：</p><p>chmod 755 xxx</p><p>chmod a+x xxx</p><p>chown user:group xxx 用来更改文件的归属用户，也可以同时更改其归属群组</p><p>chgrp group xxx 用来更改文件的归属群组</p><p>上面命令中的 755 和 a+x 是两种类型的表达式</p><p>我们将后面章节中详细介绍 权限管理 用户管理</p><p>执行命令的权限</p><p>有一些命令，普通用户也可以执行，但是只有root用户才能执行成功，这是为什么呢？</p><p>例如在系统中增加一个新用户 useradd</p><p>ls -l /usr/sbin/useradd</p><p>可以看到：</p><p>-rwxr-xr-x 1 root root 56156 2006-04-03 21:37 /usr/sbin/useradd</p><p>明明所有的用户都可以执行嘛？</p><p>这是因为， useradd 命令是修改 /etc/passwd 文件的一个工具，来看看这个文件：</p><p>ls -l /etc/passwd</p><p>-rw-r--r-- 1 root root 1835 2006-06-24 17:58 /etc/passwd</p><p>原来只有root用户才能写入修改结果，非root用户执行 useradd 命令当然不会有结果。</p><p>执行命令的身份</p><p>默认情况下，您的命令提示符末位为 $ ，这表示您将以普通用户的身份执行命令。</p><p>您可以使用 su （switch user）这个命令来切换其它用户。</p><p>例如 su root ，切换到root用户，如果 su 命令后面没有切换目标，那么这个命令默认切换到root用户。</p><p>现在您执行 su 这个命令，系统会提示您输入密码，请输入管理员的密码。这个时候，您会发现命令提示符末位变成了 # ，您将以root用户的身份执行命令。</p><p>Ubuntu系统默认会随机设定系统的root密码，这样会更安全一些，这个时候您可以执行“sudo”命令，输入当前用户密码后，暂时以root</p><p>用户的身份执行命令。（前提是sudoer列表中要包含您的ID。您在安装Ubuntu系统时创建的用户，默认具有“sudo”权限）</p><p>如果您能够执行“sudo”命令，那么您也就拥有了root权限。在后面的章节中，如果我们提到了“root权限”，那么您可以通过以上两种方式来实现</p><h3 id="命令行"><a class="header-anchor" href="#命令行">¶</a>命令行</h3><p>Shell、Console、Terminal</p><p>在前面的章节中，我们曾提到，电视机的遥控器，也是一种人机交互的界面，算是一种Shell。</p><p>但是这个概念并不准确，遥控器只是向Shell发送指令的工具，Shell接收到遥控器发出指令后，将指令转换为系统命令，由系统来执行。</p><p>例如我们按的遥控器上的 数字键1 ,遥控器将 切换为1频道 的指令发送到Shell，Shell将指令转换为系统可以识别的 频道1 ，系统执行它，您就可以观看1频道的电视节目了。</p><p>通常每台电视机只有一种Shell，比如有的电视机系统具有“画中画”的功能，那么Shell中便有相应的功能定义，您可以通过遥控器上的“画中画”功能键来开启它。假设您的电视机没有此功能，Shell中也就没有相应的功能定义。拥有一个带“画中画”功能控制键的遥控器，即便信号兼容，您还是不能够使用这一功能：）</p><p>不用遥控器也可以控制电视机，假设您的遥控器丢了，您还可以走到电视机前，使用机身上的控制面板来控制它（相当于使用Linux的控制台）。但是您一定不喜欢这种方式，除非您想锻炼身体：）</p><p>在Linux系统中，由于图形界面和控制台的分辨率通常不一致，所以切换时要有一个延时。对于我们中文用户来讲，控制台下中文的显示也比较麻烦。而且控制台显示内容通常不如终端显示的全面。</p><p>所以我们推荐您使用终端来执行命令，它使用起来感觉很像遥控器：）</p><p>rxvt-unicode</p><p>通常情况下，您买一台电视机，只能获得一个遥控器。虽然它为您的电视机量身定作，能够最大限度发挥电视机的能力，但您却不一定喜欢它。说不定这个遥控器体形太大，持握不方便;或者它体形太小，容易失踪;又或者它的按键要么太硬，要么太软;它的键盘要么太大，要么太小……您一般也可以容忍，毕竟遥控器使用频率并不算高：）</p><p>如果您的终端有些地方不讨您喜欢，比如说响应太慢，或者不能正常显示中文……那就难以忍受了，您应该换一个其它的试试。</p><p>在前面的章节，我们介绍您使用的终端为Gnome-Termianl，它是系统默认使用的终端，显示中文不错，不过响应比较慢，您可能已经处于水深火热之中了。。。</p><p>我们推荐您使用urxvt（mlterm也是不错的选择）</p><p>您可以使用 <code>sudo apt-get install rxvt-unicode</code> 命令来安装它。</p><p>urxvt 启动它 （urxvt不支持控制台，您得在图形界面下启动它。终端、Alt+F2，建议您在启动栏里新建一个启动图标）</p><p>rxvt-unicode还支持“服务器/客户端”的运行模式：</p><p>urxvtd 启动一个守护进程daemon（支持控制台）</p><p>urxvtc 启动客户端client。多个客户端可以同时连接到一个urxvtd，以达到节省系统资源的目的。</p><p>或许您对rxvt的默认设置不满意，您可以修改用户配置文件 ~/.Xresources 来设定它。修改全局配置文件 /etc/X11/Xresources/Xresources ，则对所有用户生效，只有root才可以修改此文件。</p><p>这里有一些简单的选项：（以 ! 起始的行是注释，您可以直接拷贝此文件的内容）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">!!=============================================================================</span><br><span class="line">!! RXVT-unicode setting</span><br><span class="line">!!=============================================================================</span><br><span class="line">!设置字体分辨率</span><br><span class="line">Xft.dpi:96</span><br><span class="line"></span><br><span class="line">!窗口大小</span><br><span class="line">Rxvt.geometry: 80x40+80+80</span><br><span class="line"></span><br><span class="line">!颜色</span><br><span class="line">Rxvt.background:#333333</span><br><span class="line">Rxvt.foreground:antiquewhite</span><br><span class="line">Rxvt.inheritPixmap:False</span><br><span class="line">Rxvt.colorBD:yellow</span><br><span class="line">Rxvt.colorUL:antiquewhite</span><br><span class="line"></span><br><span class="line">!滚动条</span><br><span class="line">Rxvt.scrollBar:True</span><br><span class="line">Rxvt.scrollBar_left:True</span><br><span class="line">Rxvt.scrollBar_floating:False</span><br><span class="line">Rxvt.scrollstyle:next</span><br><span class="line">Rxvt.scrollColor:#999999</span><br><span class="line"></span><br><span class="line">!屏幕缓冲</span><br><span class="line">Rxvt.saveLines:30000</span><br><span class="line">Rxvt.color12:DodgerBlue</span><br><span class="line">Rxvt.font:7x14,xft:AR PL New Sung</span><br><span class="line"></span><br><span class="line">!输入法一般设置为xim</span><br><span class="line">!inputMethod:xim;Scim除外</span><br><span class="line">!输入法样式可选:Root(置底) OverTheSpot(跟随) OffTheSpot OnTheSpot，后两种不是所有的都支持</span><br><span class="line">Rxvt.preeditType:Root</span><br></pre></td></tr></table></figure><blockquote><p>Tip：右键点击启动栏， 添加自启动器 ， 自定义程序 ，便可以在添加自己的启动图标。</p></blockquote><h3 id="在线帮助系统"><a class="header-anchor" href="#在线帮助系统">¶</a>在线帮助系统</h3><p>您可以使用命令 man 或者 info 来阅读Linux命令的在线文档。命令的格式非常简单：</p><p>man xxx</p><p>大部分命令手册为英文版，如果您的英文不太好，或许有些困难。在后面的 系统管理 章节中，我们会尽力向您介绍命令的使用方法。</p><p>说明：在使用“man”浏览器的时候，一些快捷键您可能会用到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+f(orward) 向下翻一页 Ctrl+d(own) 向下翻半页</span><br><span class="line">Ctrl+b(ackward) 向上翻一页 Ctrl+u(p) 向上翻半页</span><br><span class="line">/ 查找 q(uit) 退出</span><br></pre></td></tr></table></figure><p>以上为VI风格的键绑定。您也可以使用Emacs风格的键绑定</p><h3 id="bash"><a class="header-anchor" href="#bash">¶</a>bash</h3><p>好了，现在我们换了一个遥控器，感觉顺手多了。现在来操练一下，下载一首mp3：</p><p>我们使用 wget 这个程序，它非常可靠，完全值得您信赖。</p><p>首先找到一个可以下载的地址，复制链接，在终端窗口内点击鼠标中键，把它粘贴进去。</p><p>现在终端中大概是这种情形：</p><p><a href="http://www.download.net/xxx.mp3" target="_blank" rel="noopener">http://www.download.net/xxx.mp3</a></p><p>按下 Ctrl+a 组合键，我们发现光标移动到了行首。输入 wget 和 空格</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.download.net/xxx.mp3</span><br></pre></td></tr></table></figure><p>回车后，终端中出现一些信息，不一会儿工夫，mp3便下载完成。</p><p>使用 Ctrl+a 组合键，我们就不需要使用方向键来移动光标，方向键每次只能移动一个字符，没有效率</p><p>您还可以使用 Ctrl+f 向前移动光标， Ctrl+b 向后移动光标， Ctrl+e 将光标移动到行末……………… （键绑定）</p><h3 id="Note"><a class="header-anchor" href="#Note">¶</a>Note</h3><p>Linux的图形界面中，鼠标中键通常执行“粘贴”的操作，如果您的鼠标没有中键，您可以左右键同时按下。</p><p>中止正在运行的程序</p><p>如果一个命令持续时间很长，以致于不能够进行其它操作，可以使用 Ctrl+c 来强行中止它。</p><p>Ctrl+s</p><p>出于意外，有时您会按下 Ctrl+s 这个组合键，Shell便被冻结。尝试使用 Ctrl+q 组合键，看能否恢复正常。</p><h3 id="键绑定"><a class="header-anchor" href="#键绑定">¶</a>键绑定</h3><p>等等，有必要记这么多快捷键么？都这么复杂！</p><p>我们强烈建议您记住，以大幅度的提高操作效率。而且这是readline控件的键绑定，在任何使用readline控件的程序中，您都可以使用它们。例如bash、lftp、gdb等程序;同时，Linux下最著名的Emacs编辑器，也是这种风格的键绑定（其实是readline使用了Emacs风格的键绑定才对），甚至FireFox中，也可以使用类似风格的快捷键！（Linux下主要有两种风格的键绑定，一种是VI风格，另一种是Emacs风格，我们会在 简明VIM教程中介绍）</p><p>现在列举一些ReadLine的键绑定，您可以自行尝试。（运行 man readline 命令，来查看ReadLine手册）</p><p>先来了解一些约定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">\C<span class="_">-a</span> 表示 Ctrl+a</span><br><span class="line">\M<span class="_">-a</span> 表示 Meta+a Meta键在PC中通常为ALT键</span><br><span class="line"></span><br><span class="line">A 表示 Shift+a</span><br><span class="line">（下面括号中的\A代表Alt，\S代表Shift）</span><br><span class="line"></span><br><span class="line">移动命令：</span><br><span class="line"></span><br><span class="line"> \C<span class="_">-a</span>  移动到行首  Aheah        \C<span class="_">-e</span>  移动到行末  End          \C<span class="_">-f</span>  向前移动一个字符  Forward </span><br><span class="line"></span><br><span class="line">*\C-b* *向后移动一个字符* *Backward        \M<span class="_">-f</span>* *向前移动一个单词*        *\M-b* *向后移动一个单词*</span><br><span class="line"></span><br><span class="line">*\C<span class="_">-l</span>* *清空屏幕* *cLear*      *这两个命令也可以理解为移动命令*        *\C-p* *上翻，前一条命令* *Previous*</span><br><span class="line"></span><br><span class="line">*\C-n* *下翻，后一条命令* *Next*        *编辑命令：*</span><br><span class="line"></span><br><span class="line">*\C<span class="_">-d</span>* *删除光标后的一个字符* *\M<span class="_">-d</span>* *删除光标后的一个单词* *Delete*</span><br><span class="line"></span><br><span class="line">*\BackSpace* *删除光标前的一个字符* *\M-BackSpace* *删除光标前的一个单词*</span><br><span class="line"></span><br><span class="line">*\C-k* *删除光标至行末的部分* *Kill         \C-u* *删除光标至行首的部分* *Unix-line-discard*</span><br><span class="line"></span><br><span class="line">*\C-w* *删除光标前的一个单词* *Word       \C-y* *粘贴（最后删除的对象）* *Yank      \C--* *撤消*</span><br><span class="line"></span><br><span class="line">搜索历史纪录：</span><br><span class="line"></span><br><span class="line">*\C-r* *连续使用* *``C-r``* *可以查找下一个*        *\M-p      \M-n*</span><br><span class="line"></span><br><span class="line">补全：</span><br><span class="line"></span><br><span class="line">*\Tab* *使用频率最高的功能！*        *\C-o* *遍历补全* *（未定义）*</span><br><span class="line"></span><br><span class="line">*\M-? M-=* *列出所有可能选项，相当于按两次**Tab**键（**M-**？* *实际按键为**\A+\S+/**）*</span><br><span class="line"></span><br><span class="line">*\M-<span class="comment">#* *注释掉当前命令，用于将当前命令暂存于历史纪录列表（**\A+\S+3**）*</span></span><br><span class="line"></span><br><span class="line">*\M-!* *补全命令，通常用来补全子命令，例如* *``sudo``* *的子命令（**\A+\S+1**）*</span><br><span class="line"></span><br><span class="line">*\M-~* *补全用户名（**\A+\S+`**）*       *\M-@* *补全主机名（**\A+\S+2**）*</span><br><span class="line"></span><br><span class="line">*\M-$* *补全变量（**\A+\S+4**）*         *\M-_* *补全历史纪录中的纪录（**\A+\S+-**）*</span><br><span class="line"></span><br><span class="line">*\M-** *将所有可能选项放到命令行中（**\A+\S+8**）*</span><br></pre></td></tr></table></figure><h4 id="自定义键绑定"><a class="header-anchor" href="#自定义键绑定">¶</a>自定义键绑定</h4><p>通过修改 <code>/etc/inputrc</code> 文件，可以更改键绑定。建议您使用默认的键绑定，以避免不必要的烦恼。当然了，Emacs风格的键绑定是通用的，随时都有可能用到。</p><p>在文件中添加该行，可以将ReadLine的键绑定设为VI风格。（Bash、Lftp等使用ReadLine的软件同时生效）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set editing-mode vi</span><br></pre></td></tr></table></figure><p>找到这一行：</p><p>$if mode=emacs</p><p>在它的下面添加如下内容</p><p>&quot;\C-o&quot;: menu-complete</p><p>###这两行不是必须的，视情况而定###</p><p>&quot;\c-p&quot;: non-incremental-reverse-search-history</p><p>&quot;\c-n&quot;: non-incremental-forward-search-history</p><p>重新登录Shell，您就可以使用 \C-o （Ctrl+o）来遍历补全。假如您的文件名为中文，或者出现乱码时，您可以使用 \M-*</p><p>将所有文件名放入命令行，再删除多余的，这真是麻烦极了！所以您可以使用 \C-o 遍历补全，将所有可能的选项轮流放入命令行。</p><p>或者使用Vim编辑器编辑 /etc/inputrc 文件，在插入模式下使用 Ctrl+v 组合键。按下 Ctrl+o ，这时编辑区新增一个 ^O 字符，等价于 \C-o</p><h3 id="通配符"><a class="header-anchor" href="#通配符">¶</a>通配符</h3><p>使用 <code>?</code> 代表任意单个字符。例如 <code>???lo</code> ，表示 <code>lo</code> 前有三个字符，它可以匹配 <code>Hello</code></p><p>使用 <code>*</code> 代表随意几个任意字符。例如<code>*.iso</code>，代表所有 <code>iso</code> 格式的文件。</p><p>说明：您可以将遍历补全和通配符结合使用，以提高效率。</p><p>例如：</p><p>cd */ 则遍历补全只补全文件夹</p><p>chmview *.chm 则遍历补全只补全chm文件</p><h3 id="任务管理"><a class="header-anchor" href="#任务管理">¶</a>任务管理</h3><p><code>&amp;</code> 在命令的末尾加上一个 <code>&amp;</code> 符号，表示背景任务，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.download.net/xxx/mp3 &amp;</span><br></pre></td></tr></table></figure><p><code>;</code> 使用 <code>;</code> 将多个命令连结起来，则表示任务按顺序执行</p><p><code>&amp;&amp;</code> 使用 <code>&amp;&amp;</code> 将多个命令连结起来，则表示只有前面的命令执行成功，后面的命令才能得以执行</p><p>`` `&lt;命令&gt;` ，如果一个命令中包含以 `` （Esc键下方的按键）括起来的子命令，那么子命令将被优先执行，执行结果被代入上一级命令继续执行，例如创建一个以当前时间命名的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch `date +%m.%d_%H:%M:%S`</span><br></pre></td></tr></table></figure><p><code>touch</code> 命令能够创建一个文件，它的操作对象，为 <code>date +%m%d%H%M%S 命令的输出 06.06_06:06:60</code></p><p>这样，我们创建了一个名为 <code>06.06_06:06:60</code> 的文件（六月六日六时六分刚过六十秒-_-!）</p><p>Ctrl+z</p><p>将当前Shell中的任务挂起</p><p>这个时候任务的状态为</p><p>[1]+ Stopped xxx</p><p>Bg-------------------------------------------------将挂起的任务背景运行。这时它的状态为[1]+ xxx &amp;</p><p>Fg-------------------------------------------------将背景任务调到前台执行jobs</p><p>方括号中的数字为命令的任务编号，您可以使用 jobs 命令来查看所有背景任务</p><p>如果后台运行多个任务，您可以在 bg 或者 fg 后跟任务编号，作为操作对象，例如：bg 2</p><p>管道、重定向</p><p>&gt;-----------------------重定向符号，它的作用是将命令的输出重定向到一个文件中。比如我们想把命令 ls 的结果保存为 FileList 文件，作一个清单，我们可以使用重定向符号来完成它：</p><p>ls -l &gt; FileList</p><p>&gt;&gt;----------------------作用与 &gt; 基本相同，不同点在于， &gt;&gt; 以追加的方式，将命令的输出写入文件的末尾。</p><p>&lt;-----------------------是从文件到命令的重定向，将文件的内容作为命令的输入。</p><p>|------------------------为管道符号，它的作用是将前一个命令的输出，作为下一个命令的输入。假设一个目录下的文件太多，使用 ls命令不能够在屏幕中完全显示，这个时候您可以将 ls 命令的输出，通过管道符号，作为浏览器 less 的输入。就可以使用浏览器的功能翻页、查找：ls -al | less</p><p>说明： less 浏览器的键绑定几乎与 man 相同，请参阅 在线帮助系统</p><h3 id="脱字符"><a class="header-anchor" href="#脱字符">¶</a>脱字符</h3><p>Shell中的一些功能是通过特殊符号作为控制字符来实现的，上面已经介绍了很多了。这产生一个问题，如果一个文件名中，刚好包含了这些字符，比如 ; ，就很难对它进行操作。使用 less 浏览这个文件</p><p>less ;xxx</p><p>less 会很快返回一个错误信息，因为并没有一个文件名作为操作对象。接着，Shell会报告，系统中没有 xxx 这个命令。</p><p>这是因为Shell将文件名中的 ; 解析为按顺序执行命令。</p><p>或者您的文件名以空白起始，而在Shell中，无论多少个空格，都将被解析为一个分隔符。您甚至不是使用命令重命名此文件。</p><p>这个时候就要用到脱字符 \ 了，它能够将一个具有特殊涵义的字符转换普通字符。上面的两个任务，可以在文件名中每个特殊字符前加一个 \ ，像这样</p><p>less ;xxx</p><p>less \ \xxx</p><p>less ;\ &amp;\xxx</p><p>说明：也可以使用 &quot; 将文件名括起来，例如 less &quot;; &amp;xxx&quot; ，在很多情况下，这样甚至更方便。</p><p>脱字符在Shell中也可以作为换行符，在一个命令的末尾添加一个 \ ，然后回车，在下一行继续输入命令剩余的部分，将一个命令拆分为多行且不影响它的执行（如果执行一个很长的命令，请将它拆分为多行以便于阅读）</p><p>事实上换行符也符合脱字符的定义。回车键有两个涵义，一个是 执行 （Enter），另一个 换行 （折线箭头）。在Shell中它作为控制字符 执行 ，使用脱字符后，它便代表排版字符 换行 了。</p><h3 id="Fish"><a class="header-anchor" href="#Fish">¶</a>Fish</h3><p>the friendly interactive shell</p><p>正如它的名字，Fish是一款非常友好的Shell，大力推荐！使用命令 sudo apt-get install fish 安装它。完成后，运行命令 fish 切换到fish， exit 返回bash。</p><p>简单介绍一下它的优点：</p><h4 id="1-自动补全、语法高亮"><a class="header-anchor" href="#1-自动补全、语法高亮">¶</a>1.自动补全、语法高亮</h4><p>bash的自动补全默认只是补全命令、路径，如果想补全变量、参数等，通常需要使用复杂的组合键（见上面bash的介绍），即便您能够记住它们，快</p><p>速准确的按下这些组合键，也是一种严峻的考验。而FISH的自动补全可以自动识别语法，补全正确的内容。并且具有语法高亮的功能，比如用MPLAYER放</p><p>MP3：</p><p>mpl<tab>(ayer) -l<tab>(oop) <tab>(0)</tab></tab></tab></p><p>-sh<tab>(uffle) -pl<tab>(aylist) <tab>(mp3_playlist)</tab></tab></tab></p><p>一阵猛按 <tab> 键，一个蛮长的命令就完成了。</tab></p><p>补全结果不唯一时给出的提示中含有简短的说明，这样通常也不用看帮助了：）比如：</p><p>mplayer -l</p><p><tab> 后，自动将参数补全为 -lo 然后给出提示</tab></p><p>-{lo}adidx (Load index from file) -{lo}op (Loop playback) {花括号中为青色文字}</p><p>它的语法高亮功能十分有用，如果你输入的命令是正确的，则用青色显示，正确的参数用白色显示，错误的则一律用红色。</p><h4 id="2-方便的历史纪录搜索"><a class="header-anchor" href="#2-方便的历史纪录搜索">¶</a>2.方便的历史纪录搜索</h4><p>还是上面的那个命令</p><p>mplayer -loop 0 -shuffle -playlist mp3_playlist</p><p>用上翻配合下翻浏览命令历史，直到找到这个命令，当然那样太慢了。</p><p>还可以输入以上命令中的某一部分，如 uffle 只要翻一次就可以找到了</p><p>（还可以META＋上翻在已输入部分中插入某一历史单词）</p><h4 id="3-文件夹历史纪录"><a class="header-anchor" href="#3-文件夹历史纪录">¶</a>3.文件夹历史纪录</h4><p>dirh （dir history）就可以显示当前会话中进入的文件夹纪录</p><p>使用 prevd 和 nextd 跳转</p><p>假如曾进入过1 2 3 4 5 这几个文件夹， prevd 4 可以让你在 5 中直接跳到 1</p><h4 id="4-其它的功能"><a class="header-anchor" href="#4-其它的功能">¶</a>4.其它的功能</h4><p>fish基本是兼容bash的。键绑定也非常的相似，少数的键绑定不尽一致，例如：</p><p>\C-h 删除光标前的一个字符（bash为退格键，不方便）</p><p>修改 /etc/fish_inputrc 这个文件，增加以下行：</p><p>&quot;\C-n&quot;: history-search-forward</p><p>&quot;\C-p&quot;: history-search-backward</p><p>现在使用Ctrl+p上翻，使用Ctrl+n下翻。如果已经在命令行中输入字符，那么Ctrl+p就是在历史纪录向上查找您输入的字符，Ctrl+n为向下查找，非常的方便。</p><p>设定您的默认Shell</p><p>如果能够拥有root权限，可以直接修改 /etc/passwd 文件。找到您用户ID起始的行</p><p>user:x:1000:112:user,,,:/home/user:/bin/bash</p><p>最后一个字段为登录后的默认Shell， /bin/bash 是程序 bash 的主程序路径。 fish 主程序的路径通常为 /usr/bin/fish 。</p><p>/etc/shells 中列出系统中所有可用Shell（ /bin/false 代表禁用Shell）</p><p>也可以使用如下命令更改您的默认Shell</p><p>chsh -s /usr/bin/fish</p><p>（需要输入您的密码）</p><p>Tip：可以使用 whereis xxx 命令，来查找 xxx 程序的安装位置，详见搜索</p><p>设定命令的搜索路径</p><p>使用 echo $PATH ，可以显示 $PATH 变量，输出如下：</p><p>/usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin /usr/bin/X11 /usr/games /usr/X11R6/bin</p><p>它是一个环境变量，代表执行命令时，Shell的搜索路径。</p><p>执行一个命令时，Shell会到 $PATH 变量定义的路径去搜索，并运行与命令同名的可执行文件。如果程序、脚本等可执行文件并不在上面的路径中，就必须使用绝对路径或者相对路径定位可执行文件。</p><p>例如：</p><p>/usr/local/mplayer -menu xxx.rmvb</p><p>/etc/init.d/powernowd start</p><p>cd /usr/local/ &amp;&amp; ./mplayer -menu xxx.rmvb</p><p>可以修改 /etc/environment 文件来设定您的命令搜索路径，找到 PATH 起始的行</p><p>PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin&quot;</p><p>在双引号中添加您的自定义路径，并以 : 分隔。</p><h2 id="Ubuntu系统简介"><a class="header-anchor" href="#Ubuntu系统简介">¶</a>Ubuntu系统简介</h2><h3 id="Ubuntu系统目录结构"><a class="header-anchor" href="#Ubuntu系统目录结构">¶</a>Ubuntu系统目录结构</h3><p>以下为Ubuntu目录的主要目录结构，您稍微了解它们都包含了哪些文件就可以了，不需要记忆。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/ 根目录</span><br><span class="line">│</span><br><span class="line">├boot/ 启动文件。所有与系统启动有关的文件都保存在这里</span><br><span class="line">│ └grub/ Grub引导器相关的文件</span><br><span class="line">│</span><br><span class="line">├dev/ 设备文件</span><br><span class="line">├proc/ 内核与进程镜像</span><br><span class="line">│</span><br><span class="line">├mnt/ 临时挂载</span><br><span class="line">├media/ 挂载媒体设备</span><br><span class="line">│</span><br><span class="line">├root/ root用户的<span class="variable">$HOME</span>目录</span><br><span class="line">├home/</span><br><span class="line">│ ├user/ 普通用户的<span class="variable">$HOME</span>目录</span><br><span class="line">│ └.../</span><br><span class="line">│</span><br><span class="line">├bin/ 系统程序</span><br><span class="line">├sbin/ 管理员系统程序</span><br><span class="line">├lib/ 系统程序库文件</span><br><span class="line">├etc/ 系统程序和大部分应用程序的全局配置文件</span><br><span class="line">│ ├init.d/ SystemV风格的启动脚本</span><br><span class="line">│ ├rcX.d/ 启动脚本的链接，定义运行级别</span><br><span class="line">│ ├network/ 网络配置文件</span><br><span class="line">│ ├X11/ 图形界面配置文件</span><br><span class="line">├usr/</span><br><span class="line">│ ├bin/ 应用程序</span><br><span class="line">│ ├sbin/ 管理员应用程序</span><br><span class="line">│ ├lib/ 应用程序库文件</span><br><span class="line">│ ├share/ 应用程序资源文件</span><br><span class="line">│ ├src/ 应用程序源代码</span><br><span class="line">│ ├<span class="built_in">local</span>/</span><br><span class="line">│ │ ├soft/ 用户程序</span><br><span class="line">│ │ └.../ 通常使用单独文件夹</span><br><span class="line">│ ├X11R6/ 图形界面系统</span><br><span class="line">│</span><br><span class="line">├var/ 动态数据</span><br><span class="line">│</span><br><span class="line">├temp/ 临时文件</span><br><span class="line">├lost+found/ 磁盘修复文件</span><br></pre></td></tr></table></figure><h3 id="启动流程"><a class="header-anchor" href="#启动流程">¶</a>启动流程</h3><p>Linux系统主要通过以下步骤启动：</p><h4 id="1-读取MBR的信息，启动Boot-Manager"><a class="header-anchor" href="#1-读取MBR的信息，启动Boot-Manager">¶</a>1.读取MBR的信息，启动Boot Manager</h4><p>Windows使用NTLDR作为Boot</p><p>Manager，如果您的系统中安装多个版本的Windows，您就需要在NTLDR中选择您要进入的系统。</p><p>Linux通常使用功能强大，配置灵活的GRUB作为Boot Manager，我们将在启动管理章节中向您介绍它的使用方式。</p><h4 id="2-加载系统内核，启动init进程"><a class="header-anchor" href="#2-加载系统内核，启动init进程">¶</a>2.加载系统内核，启动init进程</h4><p>init进程是Linux的根进程，所有的系统进程都是它的子进程。</p><h4 id="3-init进程读取-etc-inittab文件中的信息，并进入预设的运行级别，按顺序运行该运行级别对应文件夹下的脚本。脚本通常以-start-参数启动，并指向一个系统中的程序。"><a class="header-anchor" href="#3-init进程读取-etc-inittab文件中的信息，并进入预设的运行级别，按顺序运行该运行级别对应文件夹下的脚本。脚本通常以-start-参数启动，并指向一个系统中的程序。">¶</a>3.init进程读取 /etc/inittab文件中的信息，并进入预设的运行级别，按顺序运行该运行级别对应文件夹下的脚本。脚本通常以 start 参数启动，并指向一个系统中的程序。</h4><p>通常情况下， <code>/etc/rcS.d/</code> 目录下的启动脚本首先被执行，然后是 <code>/etc/rcN.d/</code> 目录。例如您设定的运行级别为<code>3</code>,那么它对应的启动目录为 <code>/etc/rc3.d/</code> 。</p><h4 id="4-根据-etc-rcS-d-文件夹中对应的脚本启动-Xwindow服务器-xorg"><a class="header-anchor" href="#4-根据-etc-rcS-d-文件夹中对应的脚本启动-Xwindow服务器-xorg">¶</a>4.根据 /etc/rcS.d/文件夹中对应的脚本启动 Xwindow服务器 xorg</h4><p>Xwindow为Linux下的图形用户界面系统。</p><h4 id="5-启动登录管理器，等待用户登录"><a class="header-anchor" href="#5-启动登录管理器，等待用户登录">¶</a>5.启动登录管理器，等待用户登录</h4><p>Ubuntu系统默认使用GDM作为登录管理器，您在登录管理器界面中输入用户名和密码后，便可以登录系统。（您可以在 <code>/etc/rc3.d/</code> 文件夹中找到一个名为 <code>S13gdm</code> 的链接）</p><h3 id="更改运行级别"><a class="header-anchor" href="#更改运行级别">¶</a>更改运行级别</h3><p>在 /etc/inittab 文件中找到如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The default runlevel.</span></span><br><span class="line">id:2:initdefault:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一行中的数字 2 ,为系统的运行级别，默认的运行级别涵义如下：</span></span><br><span class="line"><span class="comment"># 0 关机    1 单用户维护模式   2~5 多用户模式  6 重启</span></span><br></pre></td></tr></table></figure><h3 id="服务管理"><a class="header-anchor" href="#服务管理">¶</a>服务管理</h3><p>更改启动服务</p><p>在运行级别对应的文件夹中，您可以看到许多文件名以 <code>S##</code> 和 <code>K##</code> 起始的启动脚本链接。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/rcS.d/S35mountall.sh 挂载文件系统</span><br><span class="line">/etc/rcS.d/S40networking 启用网络支持</span><br><span class="line">/etc/rc2.d/S13gdm 启动登录管理器</span><br><span class="line">/etc/rc2.d/S20makedev 创建设备文件</span><br><span class="line">/etc/rc2.d/S23xinetd 启动超级进程</span><br></pre></td></tr></table></figure><p>init进程将以 start 为参数，按文件名顺序执行所有以 S## 起始的脚本。脚本名称中的数字越小，它将被越早执行。例如在</p><p>/etc/rc2.d/ 文件夹中， S13gdm 文件名中的数字小于 S23xinetd , S13gdm 将比 S23xinetd 先执行。</p><p>如果一个脚本链接，以 K## 起始，表示它将以 stop 参数被执行。如果相应服务没有启动，则不执行该脚本。例如：</p><p>/etc/rc2.d/K20powernowd 针对某种硬件的电源管理支持</p><p>如果您想禁止某一服务在启动时自动运行，您可以将相应运行级别中的脚本由 S##xxx 重命名为 K##xxx 。</p><p>手动控制服务</p><p>您也可以手动运行带有以下参数的启动脚本，来控制系统服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- start 启动    - stop 停止    - restart 重启</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc2.d/K20powernowd start</span><br></pre></td></tr></table></figure><p>有时您并不清楚当前运行级别，该运行级别下未必有相应脚本；而且此类脚本的前三位字符并不固定，不便于记忆。这时，可以直接使用</p><p>/etc/init.d/ 文件夹中的启动脚本（ /etc/rcX.d/ 中的启动脚本链接到 /etc/init.d/</p><p>文件夹下相应脚本），这也是推荐的方式。</p><p>例如：</p><p>/etc/init.d/powernowd start</p><blockquote><p>Note：以上命令的位置并没有包含在环境变量的搜索路径中，所以要输入完整路径。</p></blockquote><h3 id="常用系统服务"><a class="header-anchor" href="#常用系统服务">¶</a>常用系统服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">acpi-support 高级电源管理支持     acpid acpi守护程序.这两个用于电源管理，非常重要</span><br><span class="line"></span><br><span class="line">alsa 声音子系统          alsa-utils</span><br><span class="line"></span><br><span class="line">anacron cron的子系统，将系统关闭期间的计划任务，在下一次系统运行时执行。</span><br><span class="line"></span><br><span class="line">apmd acpi的扩展         atd 类似于cron的任务调度系统。建议关闭</span><br><span class="line"></span><br><span class="line">binfmt-support 核心支持其他二进制的文件格式。建议开启         bluez-utiles 蓝牙设备支持</span><br><span class="line"></span><br><span class="line">bootlogd 启动日志。开启它         cron 任务调度系统，建议开启</span><br><span class="line"></span><br><span class="line">cupsys 打印机子系统。       dbus 消息总线系统(message bus system)。非常重要</span><br><span class="line"></span><br><span class="line">dns-clean 使用拨号连接时，清除dns信息。        </span><br><span class="line"></span><br><span class="line">evms 企业卷管理系统（Enterprise Volumn Management system）</span><br><span class="line"></span><br><span class="line">fetchmail 邮件用户代理守护进程，用于收取邮件         gdm gnome登录和桌面管理器。</span><br><span class="line"></span><br><span class="line">Gdomap       gpm 终端中的鼠标支持。      halt 别动它。</span><br><span class="line"></span><br><span class="line">hdparm 调整硬盘的脚本，配置文件为 /etc/hdparm.conf。       hibernate 系统休眠</span><br><span class="line"></span><br><span class="line">hotkey-setup 笔记本功能键支持。支持类型包括： HP, Acer, ASUS, Sony, Dell, 和IBM</span><br><span class="line"></span><br><span class="line">hotplug and hotplug-net 即插即用支持，比较复杂，建议不要动它</span><br><span class="line"></span><br><span class="line">hplip HP打印机和图形子系统       ifrename 网络接口重命名脚本。如果您有十块网卡，您应该开启它</span><br><span class="line"></span><br><span class="line">inetd 在文件 /etc/inetd.conf 中，注释掉所有你不需要的服务。如果该文件不包含任何服务，那关闭它是很安全的。       klogd 重要。</span><br><span class="line"></span><br><span class="line">linux-restricted-modules-common 受限模块支持。 /lib/linux-restricted-modules/ 文件夹中的模块为受限模块。例如某些驱动程序，如果您没有使用受限模块，就不需要开启它。</span><br><span class="line"></span><br><span class="line">lvm 逻辑卷管理系统支持。         makedev 创建设备文件，非常重要。      mdamd 磁盘阵列</span><br><span class="line"></span><br><span class="line">module-init-tools 从/etc/modules加载扩展模块，建议开启。</span><br><span class="line"></span><br><span class="line">networking 网络支持。按 /etc/network/interfaces 文件预设激活网络，非常重要。</span><br><span class="line"></span><br><span class="line">ntpdate 时间同步服务，建议关闭。      pcmcia pcmcia设备支持。      powernowd 移动CPU节能支持</span><br><span class="line"></span><br><span class="line">ppp and ppp-dns 拨号连接          readahead 预加载库文件。     reboot 别动它      </span><br><span class="line"></span><br><span class="line">resolvconf 自动配置DNS      rmnologin 清除nologin         rsync rsync守护程序</span><br><span class="line"></span><br><span class="line">sendsigs 在重启和关机期间发送信号      single 激活单用户模式         ssh ssh守护程序。建议开启</span><br><span class="line"></span><br><span class="line">stop-bootlogd 在2，3，4，5运行级别中停止bootlogd服务          sudo 检查sudo状态。重要</span><br><span class="line"></span><br><span class="line">sysklogd 系统日志       udev &amp; udev-mab 用户空间dev文件系统（userspace dev filesystem）。重要</span><br><span class="line"></span><br><span class="line">umountfs 卸载文件系统        urandom 随机数生成器        usplash 开机画面支持</span><br><span class="line"></span><br><span class="line">vbesave 显卡BIOS配置工具。保存显卡的状态      xorg-common 设置X服务ICE socket。</span><br><span class="line"></span><br><span class="line">adjtimex 调整核心时钟的工具       dirmngr 证书列表管理工具,和gnupg一起工作。</span><br><span class="line"></span><br><span class="line">hwtools irqs优化工具          libpam-devperm 系统崩溃之后，用于修理设备文件许可的守护程序。</span><br><span class="line"></span><br><span class="line">lm-sensors 板载传感器支持         mdadm-raid 磁盘陈列管理器        </span><br><span class="line"></span><br><span class="line">screen-cleanup 清除开机屏幕的脚本       xinetd 管理其他守护进程的一个inetd超级守护程序</span><br></pre></td></tr></table></figure><h3 id="重要配置文件"><a class="header-anchor" href="#重要配置文件">¶</a>重要配置文件</h3><blockquote><p>无论任何情况下，修改配置文件之前，先备份它！</p></blockquote><p>建议使用这个命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp xxx xxx_`date +%y%m%d_%H:%M`</span><br></pre></td></tr></table></figure><p>当然这很麻烦，您可以新建一个名为 bak 的文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">sudo cp <span class="variable">$1</span> <span class="variable">$1_</span>`date +%y%m%d_%H:%M`</span><br></pre></td></tr></table></figure><p>把它放在您能够记住的目录下，比如 <code>/home</code> ，执行命令 <code>sh /home/bak xxx</code> ，就可以将当前文件夹下的文件 <code>xxx</code> 另存为 <code>xxx_yymmdd_HH:MM</code> 的格式了</p><p>全局配置文件</p><p>系统初始化</p><p>/etc/inittab 运行级别、控制台数量        /etc/timezone 时区        /etc/inetd.conf 超级进程</p><p>文件系统</p><p>/etc/fstab 开机时挂载的文件系统         /etc/mtab 当前挂载的文件系统</p><p>用户系统</p><p>/etc/passwd 用户信息          /etc/shadow 用户密码          /etc/group 群组信息</p><p>/etc/gshadow 群组密码         /etc/sudoers Sudoer列表（请使用“visudo”命令修改此文件，而不要直接编辑）</p><p>Shell</p><p>/etc/shell 可用Shell列表       /etc/inputrc ReadLine控件设定       /etc/profile 用户首选项</p><p>/etc/bash.bashrc bash配置文件</p><p>系统环境</p><p>/etc/environment 环境变量      /etc/updatedb.conf 文件检索数据库配置信息         /etc/issue 发行信息</p><p>/etc/issue.net         /etc/screenrc 屏幕设定</p><p>网络</p><p>/etc/iftab 网卡MAC地址绑定       /etc/hosts 主机列表       /etc/hostname 主机名</p><p>/etc/resolv.conf 域名解析服务器地址       /etc/network/interfaces 网卡配置文件</p><p>用户配置文件</p><p>/etc/ 目录下的文件，只有root用户才有权修改。应用软件的全局配置文件，通常普通用户也不能够修改，如果要通过配置软件，来适应特殊需求，您可以修改用户配置文件。</p><p>用户配置文件通常为全局配置文件的同名隐藏文件，放在$HOME目录下，例如：</p><p>/etc/inputrc /home/user/.inputrc</p><p>/etc/vim/vimrc /home/user/.vim/vimrc</p><p>也有少数例外，通常是系统程序</p><h3 id="软件安装"><a class="header-anchor" href="#软件安装">¶</a>软件安装</h3><h4 id="DPKG"><a class="header-anchor" href="#DPKG">¶</a>DPKG</h4><p>Linux系统中，软件通常以源代码或者预编译包的形式提供。</p><p>软件源代码需要编译为二进制的机器代码才能够使用，安装比较耗时，不过您可以自行调节编译选项，决定需要的功能或组件，或者针对硬件平台作一些优化。</p><p>预编译的软件包，通常是由软件的发布者进行编译，您只要将软件拷贝到系统中就可以了。考虑到预编译软件包的适用性，预编译软件包通常不会针对某种硬件平台优化。它所包含的功能和组件也是通用的组合。</p><p>Ubuntu系统中，软件通常以 deb 格式的包文件发布，它是一种预编译软件包。deb包中除了包含已编译的软件，通常还包括软件的拷贝路径、对其它软件包的依赖关系纪录、比较通用的配置文件以及软件的描述、版本、作者、类别、占用空间等信息。</p><p>deb软件包命令遵行如下约定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soft_ver-rev_arch.deb</span><br><span class="line">soft 软件包名称   ver 软件版本号    revUbuntu 修订版本号   arch 目标架构名称</span><br></pre></td></tr></table></figure><p>例如： azureus_2.4.0.2-0ubuntu2_all.deb</p><p>您需要使用 <code>dpkg</code> 命令来管理deb软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i | --install xxx.deb 安装deb软件包</span><br><span class="line"></span><br><span class="line">dpkg -r | --remove xxx.deb 删除软件包</span><br><span class="line"></span><br><span class="line">dpkg -r -P | --purge xxx.deb 连同配置文件一起删除</span><br><span class="line"></span><br><span class="line">dpkg -I | -info xxx.deb 查看软件包信息</span><br><span class="line"></span><br><span class="line">dpkg -L xxx.deb 查看包内文件</span><br><span class="line"></span><br><span class="line">dpkg -l 查看系统中已安装软件包信息</span><br><span class="line"></span><br><span class="line">dpkg-reconfigure xxx 重新配置软件包</span><br></pre></td></tr></table></figure><p>有些时候，您使用 dpkg 安装一个软件包，系统会提示您该软件包依赖其它软件包。这时，您先安装其它软件包，直到满足依赖关系为止。或者同时安装多个软件包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i aaa.deb bbb.deb ccc.deb</span><br></pre></td></tr></table></figure><h4 id="APT"><a class="header-anchor" href="#APT">¶</a>APT</h4><p>如果一个软件依赖关系过于复杂，使用 <code>dpkg</code></p><p>来安装它，并不是一个明智的选择，这个时候您就需要用到APT软件包管理系统。APT可以自动的检查依赖关系，通过您预设的方式来获得相关软件包，并自动</p><p>安装配置它。事实上，在多数情况下，我们推荐您使用APT软件包管理系统。</p><p>APT系统需要一个软件信息数据库和至少一个存放着大量deb包的软件仓库，我们称之为 <code>源</code> 。 <code>源</code> 可以是网络服务器，安装CD或者本地软件仓库。您需要修改 <code>/etc/apt/sources.list</code> 文件，使APT系统能够连接到 <code>源</code>。</p><p>从以下页面中获得网络安装源的列表，并且根据您的网络环境，选择速度较快的源。</p><p><a href="http://wiki.ubuntu.org.cn/%E5%BF%AB%E9%80%9F%25E" target="_blank" rel="noopener">http://wiki.ubuntu.org.cn/快速%E</a>......%97/DapperDrake</p><p>APT系统主要包括 <code>apt-get</code> 和 <code>apt-cache</code> 等命令。通常是复合命令，包含若干个子命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apt-get install xxx 安装xxx</span><br><span class="line"> -d 仅下载       -f  强制安装 </span><br><span class="line"></span><br><span class="line">apt-get remove xxx 卸载xxx</span><br><span class="line"></span><br><span class="line">apt-get update 更新软件信息数据库</span><br><span class="line"></span><br><span class="line">apt-get upgrade 进行系统升级</span><br><span class="line"></span><br><span class="line">apt-cache search 搜索软件包</span><br></pre></td></tr></table></figure><blockquote><p>说明：建议您经常使用 sudo apt-get update 命令来更新您的软件信息数据库</p></blockquote><blockquote><p>APT系统修复由于各种意外，APT系统可能会出现问题，使用如下命令，尝试进行修复：apt-get -f install</p></blockquote><h3 id="源码包"><a class="header-anchor" href="#源码包">¶</a>源码包</h3><p>对于绝大多数软件，我们建议您使用APT系统来安装它。在少数情况下，例如某软件没有以deb包的格式发布，或者需要定制适合自己的软件，您可以通过编译源代码的方式安装它。</p><p>首先需要下载软件的源码包，并且将它解包为一些源代码文件。并了便于管理，建议将下载的源码包移动到 <code>/usr/local/src/</code> 目录下，并在这里解包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mv xxx.tar.gz /usr/<span class="built_in">local</span>/src 移动源码包</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src 进入“/usr/<span class="built_in">local</span>/src/”目录</span><br><span class="line">sudo tar -xzvf xxx.tar.gz 解包源码</span><br><span class="line"><span class="built_in">cd</span> xxx_ver/ 进行解包后的源码目录</span><br></pre></td></tr></table></figure><p>源码目录中通常有一个 <code>configure</code> 脚本，用来配置即将开始的编译过程。您可以执行它</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./configure [--prefix=/usr/loca/xxx ......]</span><br></pre></td></tr></table></figure><p>它会自动检测软件的编译环境和依赖关系，并且生成 <code>Makefile</code> 文件。</p><p>使用带参数的命令 <code>./configure --help</code> ，或者阅读 <code>INSTALL</code> 文件，查看该脚本允许的参数。例如使用</p><p><code>--prefix=/usr/local/xxx</code> 参数，将软件的安装目录设定为 <code>/usr/local/xxx/</code>。（如果一定要将软件安装在单独目录下，建议您安装在这里）</p><p>现在执行 <code>make</code> 命令，系统会根据 <code>Makefile</code> 文件中的设定，通过 make 工具调用编译器和所需资源文件，将源代码编译成目标文件。</p><p>sudo make</p><p>执行 <code>make install</code> 命令， <code>make</code> 工具会自动连接目标文件和库文件，将最终生成的文件拷贝到 <code>Makefile</code> 文件设定的路径中，并且完成更改文件的属性，删除残留文件等活动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>现在，编译安装已经完成，为了更方便的使用它，需要给程序的可执行文件作一个符号链接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -sf /usr/<span class="built_in">local</span>/xxx/可执行文件 /usr/<span class="built_in">local</span>/bin/可执行文件</span><br></pre></td></tr></table></figure><blockquote><p>Tip:为了顺利的进行编译，至少需要安装 build-essential 软件包。<code>sudo apt-get install build-essential</code></p></blockquote><h3 id="Xwindow简介"><a class="header-anchor" href="#Xwindow简介">¶</a>Xwindow简介</h3><p>Xwindow是工作站图形系统的工业标准，它有多种不同的实现，Ubuntu系统中使用的为Xorg。</p><p>（比较前卫的图形界面系统XGL，实际代替X服务器的作用，另外还有与之配套的窗口管理器）</p><h4 id="历史"><a class="header-anchor" href="#历史">¶</a>历史</h4><p>当然，Xwindow有悠久的历史和传统，不过那不在我们讨论的范围。您要注意的有两点：</p><ul><li><p>Xwindow 和 Xbox 中的“X”本意是不同的， X 只是 W 后的一个字母，差不多应该这样理解，Xwindow 是 Window 的接班人 （注意，Window不是Windows）</p></li><li><p>同样，也不要把 Xwindow 说成是 Xwindows，那是一种亵渎！一切伟大的创造，都应得到应有的理解和尊重。</p></li></ul><h4 id="架构及原理"><a class="header-anchor" href="#架构及原理">¶</a>架构及原理</h4><p>Xwindow使用服务器－客户端架构。无论本地图形界面，还是远程图形界面，都以同样的流程工作。这样便不需要分别进行设计和维护，极大的提高了网络透明性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本地X客户端 ┐ ┌ 键盘</span><br><span class="line">远程X客户端 ┼ X协议 ─ X服务器 ─ 硬件规范 ┼ 鼠标</span><br><span class="line">远程X客户端 ┘ └ 显示器</span><br></pre></td></tr></table></figure><h4 id="Xserver"><a class="header-anchor" href="#Xserver">¶</a>Xserver</h4><p>Xwindow系统服务器端，通过驱动程序（硬件规范）来管理硬件资源。</p><p>例如：当我们移动鼠标时，通过驱动程序，向 Xserver 发送信息：</p><p>“向右移动200点，向上移动100点”（向右上移动）；“按下左键”……</p><p>Xserver作出如下响应：</p><p>1、上一次鼠标停止的坐标为600,500</p><p>2、向右200，向上100。现在鼠标位于坐标800,600</p><p>3、坐标800,600处，为窗口Firefox的“关闭”按钮</p><p>4、根据预设动作，将 “点击Firefox窗口的关闭按钮” 翻译为 “关闭窗口Firefox”</p><p>5、向X客户端Firefox发送一个“退出”消息</p><p>6、Xserver通过显示子系统（显卡、显示器），全程显示鼠标的位置和移动</p><p>* 事实上，向程序发送“退出”信号，通常窗口管理器完成……为了描述方便，这里暂不区分。稍后，我们将向您介绍 窗口管理器 的其它一些细节。</p><p>大多数的鼠标不需要专门的驱动程序，因为它们符合某一硬件规范，例如：有四个移动方向和三个键</p><h4 id="Xclient"><a class="header-anchor" href="#Xclient">¶</a>Xclient</h4><p>Xwindow系统客户端，通过X协议，实现与Xserver 的交互。</p><p>例如：</p><p>1、Xclient （假设Firefox） 接收Xserver的消息： 输入焦点在地址栏的范围内，“<a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”，回车</p><p>2、Firefox根据预设动作，将这些消息识别为 “打开链接 <a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”</p><p>3、Firefox向域名服务器请求 链接 “<a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”。域名服务器将这个请求转换为 “<a href="http://ubuntu.org.cn/%E2%80%9D" target="_blank" rel="noopener">http://ubuntu.org.cn/”</a> 和 IP地址211.148.131.7，发送回 Firefox</p><p>4、Firefox将 “<a href="http://ubuntu.org.cn/%E2%80%9D%E6%98%BE%E7%A4%BA%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%EF%BC%88%E5%90%91Xserver%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%BD%8D%E7%BD%AE%E6%98%BE%E7%A4%BA%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%EF%BC%89" target="_blank" rel="noopener">http://ubuntu.org.cn/”显示在地址栏（向Xserver发送请求，在地址栏位置显示这个地址）</a></p><p>5、Firefox向地址 211.148.131.7 请示显示页面。</p><p>6、Firefox将服务器发送回的页面显示在主窗口中</p><h4 id="Xprotocol"><a class="header-anchor" href="#Xprotocol">¶</a>Xprotocol</h4><p>Xwindow系统协议，Xserver和Xclient之间进行通信的规则</p><h4 id="窗口管理器"><a class="header-anchor" href="#窗口管理器">¶</a>窗口管理器</h4><p>Window Manager，一种特殊的Xclient。</p><p>使用窗口管理器时，Xserver并不直接与其它Xclient通信，而是通过WM中转，当一些消息被定义为WM指令时，它们会被拦截。例如Alt+F4关闭窗口、拖动标题栏……</p><p>消息“打开链接 <a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”，具体内容如下：</p><p>输入焦点在地址栏的范围内，“<a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”，回车</p><p>Xserver并不能直接判断焦点，而是这样：</p><p>1、Xserver向WM发送位置和点击的信息，WM根据当前的“焦点策略”确定激活（最上层）的窗口为Firefox</p><p>2、Xserver将Firefox显示在最上层，高亮显示它的标题栏</p><p>3、在窗口Firefox内点击地址栏，或者 Ctrl+L，Xserver将位置信息发送给WM，WM再发送给Firefox</p><p>4、Firefox判断当前焦点后，显示一个闪动的文字输入光标</p><p>5、Firefox将输入光标通过WM发送给Xserver，Xserver在屏幕相应位置进行显示</p><p>那么，“窗口管理器”到底能作些什么呢？其实它所作的一切都是管理窗口。例如：</p><p>1.最上层的窗口会把其它窗口挡住</p><p>2.它通常是一个“已激活窗口”，根据不同的“焦点策略”，窗口管理器确定被激活的窗口。</p><p>激活窗口标题栏高亮显示，接收大部分的键盘消息和窗口内的鼠标点击消息。</p><p>3.为了美观和容易分辨，大多数窗口都要有标题栏和边框。</p><p>为了方便，标题栏上还要有一些按钮，比如：最小化，最大化，关闭（这些按钮是窗口管理器请求的小窗口）</p><p>4.一个窗口可以在另一个窗口旁边显示，而不一定完全被遮挡。为了实现这一点，就要控制窗口显示的位置</p><p>5.为了控制窗口的显示位置，需要将整个屏幕用座标描述，最好的办法是绘制一个填充整个屏幕的窗口，也就是根窗口。</p><p>6.因为根窗口是最大的，所以它可以严严实实的遮挡任何窗口，为了避免这一点，根窗口永远在最底层。</p><p>这很形象的说明了为什么它叫作“根窗口” ……root</p><p>7.根窗口不一定只有一个，大多数的窗口管理器可以使用 “工作区” ，来切换显示多个根窗口</p><p>8.根窗口固定位置上通常放置一些其它Xclient的窗口，例如底部面板，顶部面板，侧面板，程序启动图标</p><p>9.面板上又可以放一些其它的Xclient窗口，如任务条，启动栏，菜单……</p><p>任务条可以以图标显示正在运行的任务，还可以作其它的杂活，像自动挂载USB设备……</p><p>启动流程</p><p>我们知道 init 是linux的根进程，是所有进程的父进程。同样， xinit是所有Xwindow进程的根进程</p><p>Startx</p><p>startx 命令可以在命令行下启动图形界面。执行startx 命令时，实际执行这一命令：</p><p>xinit /etc/X11/xinit/xinitrc -- /etc/X11/xinit/xserverrc</p><p>根据脚本 /etc/X11/xinit/xserverrc 启动Xserver，同时根据脚本 /etc/X11/xinit/xinitrc 启动指定Xclient进程，例如窗口管理器</p><p>脚本 /etc/X11/xinit/xserverrc 以预设的参数运行程序 /usr/bin/X11/X</p><p>/etc/X11/xinit/xinitrc 脚本则指向 /etc/X11/Xsession ，依次启动 /etc/X11/Xsession.d 目录中的脚本</p><p>* 您可以在用户配置文件 ~/.Xsession 中定义使用的WM，它的优先级高于全局配置文件(对于GDM会话不起作用)</p><p>* startx启动时，并不会再进行身份认证。因为它启动的是 /etc/X11/Xsession.d/gnome-session ，而不是 GDM会话</p><p>GDM会话</p><p>Ubuntu系统启动时自动进入图形界面，不需要运行 startx 命令</p><p>在某些启动级别中，包含了gdm的启动脚本，例如 ： /etc/rc2.d/S13gdm</p><p>\1. 指向 /etc/gdm/gdm-cdd.conf 文件，加载预设视觉主题，启动 /usr/lib/gdm/gdmgreeter（登录屏幕）</p><p>\2. 用户身份认证完成后，启动 /etc/X11/default-display-manager 这个文件中设定的默认窗口管理器 /usr/sbin/gdm</p><p>gdm在启动时，会要求用户名和密码，也就是我们看到的登录屏幕（gdmgreeter）</p><p>* /usr/share/xsessions 目录下为所有可用登录会话的脚本</p><p>配置文件</p><p>X服务器</p><p>X服务器的主要配置文件为 /etc/X11/xorg.conf</p><p>布局</p><p>Section &quot;ServerLayout&quot;</p><p>Identifier &quot;Default Layout&quot;</p><p>Screen &quot;Default Screen&quot; 0 0</p><p>InputDevice &quot;Generic Keyboard&quot;</p><p>InputDevice &quot;Configured Mouse&quot;</p><p>EndSection</p><p>* 定义了 布局标识 、 屏幕标识 、 键盘标识 、 鼠标标识</p><p>模块</p><p>Section &quot;Module&quot;</p><p>Load &quot;i2c&quot;</p><p>Load &quot;bitmap&quot;</p><p>Load &quot;ddc&quot;</p><p>Load &quot;dri&quot;</p><p>Load &quot;extmod&quot;</p><p>Load &quot;freetype&quot;</p><p>Load &quot;glx&quot;</p><p>Load &quot;int10&quot;</p><p>Load &quot;type1&quot;</p><p>Load &quot;vbe&quot;</p><p>EndSection</p><p>X核心字体路径</p><p>Section &quot;Files&quot;</p><p>FontPath &quot;/usr/share/X11/fonts/75dpi&quot;</p><p>FontPath &quot;/usr/share/X11/fonts/100dpi&quot;</p><p>FontPath &quot;/usr/share/X11/fonts/misc&quot;</p><p>FontPath &quot;/usr/share/X11/fonts/cyrillic&quot;</p><p>FontPath &quot;/usr/share/X11/fonts/100dpi/:unscaled&quot;</p><p>FontPath &quot;/usr/share/X11/fonts/75dpi/:unscaled&quot;</p><p>FontPath &quot;/usr/share/X11/fonts/Type1&quot;</p><p>FontPath &quot;/usr/share/fonts/Chinese/wqy-bitmapfont&quot;</p><p>EndSection</p><p>屏幕</p><p>Section &quot;Screen&quot;</p><p>Identifier &quot;Default Screen&quot;</p><p>Device &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;</p><p>Monitor &quot;DELL E176FP&quot;</p><p>DefaultDepth 24</p><p>SubSection &quot;Display&quot;</p><p>Depth 1</p><p>Modes &quot;1280x1024&quot; &quot;1152x864&quot; &quot;1024x768&quot; &quot;800x600&quot; &quot;720x400&quot; &quot;640x480&quot;</p><p>………………</p><p>EndSubSection</p><p>EndSection</p><p>* DefaultDepth 24 默认色深</p><p>* SubSection 可用色深及分辨率</p><p>显卡</p><p>Section &quot;Device&quot;</p><p>Identifier &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;</p><p>Driver &quot;fglrx&quot;</p><p>Option &quot;KernelModuleParm&quot; &quot;agplock=0&quot;</p><p>VideoRam 131072</p><p>EndSection</p><p>* Identifier 显卡标识</p><p>* Driver 显卡驱动（如不同正常启用图形界面，首先尝试&quot;vesa&quot;）</p><p>* Option 显卡参数</p><p>* VideoRam 显存大小</p><p>显示器</p><p>Section &quot;Device&quot;</p><p>Identifier &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;</p><p>Driver &quot;fglrx&quot;</p><p>Option &quot;KernelModuleParm&quot; &quot;agplock=0&quot;</p><p>VideoRam 131072</p><p>EndSection</p><p>配置文件内部结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">├/ <span class="string">"ServerLayout"</span> 布局</span><br><span class="line">│├ <span class="string">"InputDevice"</span> keyboard 键盘</span><br><span class="line">│├ <span class="string">"InputDevice"</span> mouse 鼠标</span><br><span class="line">││</span><br><span class="line">│└/ <span class="string">"Screen"</span> 显示子系统</span><br><span class="line">│ ├ <span class="string">"Monitor"</span> 显示器</span><br><span class="line">│ ├ <span class="string">"Device"</span> videocard 显卡</span><br><span class="line">│</span><br><span class="line">│</span><br><span class="line">├ <span class="string">"Files"</span> 字体</span><br><span class="line">└ <span class="string">"Module"</span> 模块</span><br></pre></td></tr></table></figure><p>X客户端</p><p>在 /etc/X11/Xsession 文件中可以发现下列内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OPTIONFILE=/etc/X11/Xsession.options</span><br><span class="line">SYSRESOURCES=/etc/X11/Xresources</span><br><span class="line">USRRESOURCES=<span class="variable">$HOME</span>/.Xresources</span><br><span class="line">SYSSESSIONDIR=/etc/X11/Xsession.d</span><br><span class="line">USERXSESSION=<span class="variable">$HOME</span>/.xsession</span><br><span class="line">ALTUSERXSESSION=<span class="variable">$HOME</span>/.Xsession</span><br><span class="line">ERRFILE=<span class="variable">$HOME</span>/.xsession-errors</span><br></pre></td></tr></table></figure><ul><li><p><code>OPTIONFILE=/etc/X11/Xsession.options</code> 设定X进程的启动参数。例如允许用户进程<code>allow-user-xsession</code></p></li><li><p><code>Xresources X</code>资源文件。许多程序保留了X接口，允许X服务器管理一些视觉选项，例如窗口内的字体，配色等</p></li><li><p><code>xsession X</code>进程。可以设置一些启动时自动运行的程序，也可以用来设定自己的窗口管理器（窗口管理器和桌面环境或者登录管理器是无关的）</p></li></ul><p>字体</p><p>freetype渲染引擎</p><p>作为Xorg服务器的一个模块，freetype的功能包括读取Truetype字体信息，如大小、分辨率、编码等，并以之为依据渲染字体 -</p><p>freetype2.x相对于freetype1.x 增加了抗锯齿等功能 - ( /etc/X11/xorg/conf 的 Module</p><p>字段中，可以选择字体渲染模块，建议使用默认的 freetype )</p><p>freetype只负责渲染字体。而查找字体，则可以由X服务器、X客户端或者字体服务器来完成。找到字体后，使用freetype引擎就地渲染</p><p>X核心字体</p><p>X服务器根据X客户端的请求（字符编码），查找字体并进行渲染，然后显示，我们称之为</p><p>Xft字体</p><p>X客户端自行查找字体并进行渲染，X服务器只负责显示</p><p>由于Xft字体的渲染在客户端完成，所以它可以动态的加载，而不需要随同X服务器一同启动</p><p>字体服务器</p><p>另外还有一种字体服务器模式，例如 XFT字体：当客户端请求字体时，X服务器将请求转发到字体服务器，由字体服务器查找字体，并使用freetype引擎渲染，将结果传回X服务器，X服务器进行显示……</p><p>X核心字体</p><p>/etc/X11/xorg.conf 中可以配置X核心字体的搜索路径</p><p>Section &quot;Files&quot;</p><p>FontPath &quot;/usr/X11R6/lib/X11/fonts/misc/&quot;</p><p>FontPath &quot;/usr/X11R6/lib/X11/fonts/Type1/&quot;</p><p>FontPath &quot;/usr/X11R6/lib/X11/fonts/Speedo/&quot;</p><p>FontPath &quot;/usr/X11R6/lib/X11/fonts/100dpi/&quot;</p><p>FontPath &quot;/usr/X11R6/lib/X11/fonts/75dpi/&quot;</p><p>EndSection</p><ul><li></li></ul><p>当X客户端向X服务器请求显示文字的时候，X服务器会按上面列表的先后顺序查找字体</p><p>例如显示中文时，如果第一个路径中的字体不包含中文，则查找下面的路径，直到发现中文字体</p><ul><li></li></ul><p>请将您偏好的字体放在靠前的位置</p><p>要使安装的字体能够作为X核心字体使用，将字体的安装路径添加到上面的列表中，使用 mkfontscale 、 mkfontdir</p><p>扫瞄文件夹中的字体，并生成索引，就可以了（建议使用 ttmkfdir 生成 fonts.scale ，将其复制为 fonts.dir ）</p><p>字体的选择及显示风格，可以修改GTK1的配置文件，或者在Xresources文件中对程序单独进行定义</p><p>事实上，在我们的日常应用中，X核心字体环境并不常见，使用GTK1图形库的程序、某些类型的终端……</p><p>* Emacs也是这样一个老派的程序……不过Emacs23中刚刚加入了xft字体的支持</p><p>XFT字体</p><p>Xft字体相关选项在 /etc/fonts/fonts.conf 文件中配置</p><p>可以使用 fc-cache 命令，递归扫瞄以下目录中的字体（包括子文件夹中的字体），建立字体缓存</p><p>/usr/share/X11/fonts</p><p>/usr/share/fonts</p><p>/usr/local/share/fonts</p><p>~/.fonts</p><p>* /etc/fonts/fonts.conf 文件的 <dir> 字段</dir></p><p>多数支持GTK2或者Qt图形库的X客户端能够使用Xft字体渲染技术</p><p>* GTK2为Gnome使用的图形库，Qt为KDE使用的图形库。相对来说，GTK2图形库在程序的GUI设计中更加通用</p><p>安装字体，只要将字体拷贝到以上任意目录， fc-cache -fv 刷新字体缓存即可 （参数: -f 强制刷新; -v 显示过程）</p><p>使用命令 fc-list 列出所有可用字体</p><p>字体的选择及显示风格，可以修改GTK2或者Qt的配置文件，建议使用图形界面配置</p><p>* 一般情况下，桌面环境中附带了相关程序，例如 gnome-font-properties</p><h3 id="系统管理"><a class="header-anchor" href="#系统管理">¶</a>系统管理</h3><h4 id="一些细节"><a class="header-anchor" href="#一些细节">¶</a>一些细节</h4><ul><li><p>Linux是大小写敏感的系统，所有的命令、路径、参数、变量……都区分大小写</p></li><li><p>使用 <code>TAB</code> 键补全命令，无论任何时候，多按几次TAB总会有所帮助</p></li><li><p>Shell的功能键能够协助您更高效的编辑命令，请熟悉其键绑定，尽量使用它</p></li><li><p>命令由 <code>命令名</code> 、 <code>分隔符</code> 、 <code>参数</code> 、 <code>操作对象</code> 构成</p></li></ul><h4 id="命令名"><a class="header-anchor" href="#命令名">¶</a>命令名</h4><p>标识命令的功能，例如cp(copy)、mv(move)、rm(remove)……</p><p>有些命令包含一些子命令，您可以认为它的命令名由两个单词构成，例如<code>apt</code>软件包管理系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install <span class="comment"># 安装一个软件</span></span><br><span class="line">apt-get remove  <span class="comment"># 删除一个软件</span></span><br></pre></td></tr></table></figure><h4 id="分隔符-2"><a class="header-anchor" href="#分隔符-2">¶</a>分隔符</h4><p>通常为空格，<code>多个连续的空格视为一个空格</code>，下面两个命令相同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp a b</span><br><span class="line">cp   a   b</span><br></pre></td></tr></table></figure><p>有一些特殊符号也属于分隔符，例如 <code>管道 | 、重定向 &gt; 、 &gt;&gt; 、 &lt; 、后台运行 &amp; 、序列执行 &amp;&amp; 、 ; </code>。使用这些符号时，您不需要再使用<code>空格作为分隔符</code>，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al|less</span><br></pre></td></tr></table></figure><p>写为以下形式，是为了让您更容易的阅读它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al | less</span><br></pre></td></tr></table></figure><h4 id="参数"><a class="header-anchor" href="#参数">¶</a>参数</h4><p>精细调节命令的行为，以 <code>-</code> 引导，通常为参数名的首字母。许多软件都可以使用 <code>-h</code> 参数来阅读使用说明，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -h</span><br></pre></td></tr></table></figure><p>也可以使用参数的全名，一般以 -- 引导，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>多数命令中，使用 - 引导多个字符，将会被视为多个参数，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -<span class="built_in">help</span></span><br></pre></td></tr></table></figure><p>系统会解读为以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get -h -e -l -p</span><br></pre></td></tr></table></figure><p>少数命令的参数，不需要以 <code>-</code> 引导，或者使用 <code>-</code> 引导参数全名，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br><span class="line">/etc/init.d/gdm start</span><br><span class="line">mplayer -loop xxx</span><br></pre></td></tr></table></figure><p>需要对多个对象进行操作时，可以使用空格分隔符将它们隔开：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch 1 2 3 4 5 6</span><br></pre></td></tr></table></figure><p>使用空格分隔的多个对象，视为一个整体，作为命令的一个操作对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv 1 2 3 4 5 6 /home/</span><br></pre></td></tr></table></figure><p>这个命令把<code>1 2 3 4 5 6</code>作为一个操作对象，移动到另一个操作对象，<code>/home/</code>目录</p><p>递归 表示在子层次中重复相同操作。例如递归复制某目录，不但复制当前目录及其下的所有文件；而且对当前目录的子目录，也进行递归复制的操作。</p><h4 id="格式约定"><a class="header-anchor" href="#格式约定">¶</a>格式约定</h4><p>使用 <code>[]</code> 表示可选项，实际输入为方括号中的内容，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [-al]</span><br></pre></td></tr></table></figure><ul><li><p><code>ls</code>是必须的，参数不需要以方括号括起来。</p></li><li><p>使用 <code>&lt;&gt;</code> 表示必需项，实际输入为尖括号中的内容</p></li><li><p>使用 | 表示 或 ，以 | 分隔的项目不能同时使用，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [-z|j c|x vf] &lt;归档文件&gt; [源文件]</span><br></pre></td></tr></table></figure></li></ul><p>参数通常紧跟命令名，除非必要，在命令格式中，我们通常省略它们</p><h3 id="系统信息"><a class="header-anchor" href="#系统信息">¶</a>系统信息</h3><h4 id="uptime"><a class="header-anchor" href="#uptime">¶</a>uptime</h4><p>联机信息-时间，显示如下</p><p>11:27pm up 9 days, 7:12, 3 user, load average: 0.07, 0.12, 0.14</p><p>当前系统时间 系统运行时间 当前在线用户数 系统负荷 1分钟前 5分钟前 15分钟前</p><h4 id="w"><a class="header-anchor" href="#w">¶</a>w</h4><p>联机信息-已登录用户，显示如下</p><p>01:04:10 up 1:34, 2 users, load average: 0.25, 0.16, 0.11</p><p>uptime 信息</p><p>USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT</p><p>user tty1 192.168.0.1 23:30 1:33 0.14s 0.12s -bash</p><p>用户名 登录方式 来源地址 登录时间 发呆时间 资源占用 当前任务</p><p>Tip：w [用户名称] : 显示某一用户相关信息</p><h4 id="who"><a class="header-anchor" href="#who">¶</a>who</h4><p>联机信息，常用参数</p><p>-r 运行级别</p><h4 id="whoami"><a class="header-anchor" href="#whoami">¶</a>whoami</h4><p>显示当前用户名</p><h4 id="last"><a class="header-anchor" href="#last">¶</a>last</h4><p>最近用户登录信息-&lt;数字&gt; 使用数字作为参数，控制显示条目。例如last -10 显示10条纪录</p><h4 id="uname"><a class="header-anchor" href="#uname">¶</a>uname</h4><p>系统信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-s 内核名称（默认参数）    -a 全部        -p CPU 信息       -n 主机名     </span><br><span class="line">-r 内核发行信息（版本号）  -v 内核版本信息</span><br></pre></td></tr></table></figure><h4 id="date"><a class="header-anchor" href="#date">¶</a>date</h4><p>显示、设定系统时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-u 显示格林尼洛时间（UTC）</span><br><span class="line"></span><br><span class="line">MMDDhhmm[[CC]YY][.ss] 设定时间，需要管理员权限。例如： date 12292359</span><br><span class="line"></span><br><span class="line">MM 月份 DD 天数 hh 小时 mm 分钟 CC 年份前两位 YY 年份后两位 ss 秒钟</span><br><span class="line"></span><br><span class="line">秒钟、年份为可选，例如： date 122923592006.59</span><br><span class="line"></span><br><span class="line">+[%X]设定显示格式，以下为date默认输出格式：</span><br><span class="line"></span><br><span class="line">date +%Y年%m月%d日%A%H:%M:%S%Z</span><br><span class="line"></span><br><span class="line">格式控制      %n 换行       %t 制表符</span><br><span class="line"></span><br><span class="line">小时          %H(00~23) %I(01~12) %k(0~23) %l(1~12) %p(AM|PM)</span><br><span class="line"></span><br><span class="line">分、秒        %M分钟(00~59)         %S秒(00..61)       %T(hh:mm:ss) %r(hh:mm:ss [AM|PM])</span><br><span class="line"></span><br><span class="line">%s 从1970年1月1日00:00:00 UTC到目前为止的秒数       %X(%H:%M:%S)         %Z时区</span><br><span class="line"></span><br><span class="line">星期          %a(Sun~Sat) %A(Sunday~Saturday) %w : 一周中的第几天 (0..6)</span><br><span class="line"></span><br><span class="line">年份          %Y(0000~9999) %y(00~99)</span><br><span class="line"></span><br><span class="line">月份          %m(01~12) %b %h(Jan~Dec) %B(January~December)</span><br><span class="line"></span><br><span class="line">日期          %d(01~31) %j(001~366)</span><br><span class="line"></span><br><span class="line">%x(本地格式mm/dd/yy) %D(mm/dd/yy) %c</span><br><span class="line"></span><br><span class="line">一年中的第几周</span><br><span class="line"></span><br><span class="line">%U(00~53)以Sunday为一周的第一天 %W(00~53)以Monday为一周的第一天</span><br></pre></td></tr></table></figure><h4 id="cal"><a class="header-anchor" href="#cal">¶</a>cal</h4><p>显示日历</p><h3 id="文件管理"><a class="header-anchor" href="#文件管理">¶</a>文件管理</h3><p>一些细节</p><p><code>/</code> 目录为文件系统根目录，所有目录都是它的子目录</p><p>绝对路径以 <code>/</code> 起始，相对路径以当前所在目录起始</p><p>目录是一种特殊类型的文件，如果没有特别指明， 文件 包括文件和目录</p><p><code>..</code> 表示上一级目录， <code>.</code> 表示当前目录，它们是两个特殊目录</p><h4 id="链接"><a class="header-anchor" href="#链接">¶</a>链接</h4><p>为当前文件建立在其它路径中的访问方法。例如将系统中其它位置的可执行文件，链接到 <code>/usr/local/bin</code> 目录下，使用命令调用。</p><p>ls [路径]</p><p>显示当前目录文件列表</p><p>--color 不同属性以不同颜色显示（默认参数）</p><p><em>-a</em> <em>全部显示</em>        <em>-i</em> <em>显示<strong>inode</strong>值</em>     <em>-l</em> <em>详细信息</em></p><p><em>-F</em> <em>显示文件类型后缀</em> <em>目录</em>*/* <em>链接</em>*@* <em>可执行文件</em>*** <em>端口文件</em>*=* <em>管道文件</em>*| &gt;*</p><p><em>-A</em> <em>显示隐藏文件</em>         <em>-R</em> <em>递归显示子目录文件列表</em>        <em>-S</em> <em>按文件大小排序</em></p><p><em>-t</em> <em>按修改时间排序</em>       <em>-u</em> <em>按访问时间排序</em>       <em>-d</em> <em>只显示目录，不递归显示目录下的文件</em></p><p>cd [目录路径] | [特殊路径]</p><p>切换目录</p><p>目录路径可以使用绝对路径或者相对路径特殊路径：</p><p><em>~ $HOME**目录（默认值）</em>     <em>-</em> <em>上一次目录</em>       <em>..</em> <em>上一级目录</em>       <em>.</em> <em>当前目录</em></p><p>说明：您可以通过修改 /etc/environment 文件，来定义 $CDPATH 变量，设定“cd”命令的搜索路径。</p><p>pwd</p><p>显示当前路径</p><p>file &lt;文件名&gt;</p><p>显示文件类型</p><p>*<strong>-i*</strong> ***显示mime****<strong>类型*</strong></p><p>du [路径]</p><p>计算文件或目录空间占用</p><p><em>-h</em> <em>人性化显示。自动以<strong>G</strong>、<strong>M</strong>、<strong>K</strong>为单位显示占用空间大小</em>         <em>-l</em> <em>重复计算硬链接文件大小</em></p><p><em>-L</em> <em>计算符号链接文件大小</em>     <em>-a</em> <em>显示当前目录子目录中的文件</em>         <em>-c</em> <em>显示文件数</em></p><p>less &lt;文件名&gt;</p><p>浏览文件，使用VI和Emacs两种风格的键绑定。以下为VI风格键绑定</p><p><em>Ctrl+f(orward)</em> <em>向下翻一页</em> <em>Ctrl+d(own)</em> <em>向下翻半页</em></p><p><em>Ctrl+b(ackward)</em> <em>向上翻一页</em> <em>Ctrl+u(p)</em> <em>向上翻半页</em>       <em>/</em> <em>查找</em> <em>q(uit)</em> <em>退出</em></p><p>touch &lt;目标文件&gt;</p><p>触碰，在不修改文件的前提下，更改其时间属性。通常用来创建一个空文件</p><p>mkdir &lt;文件夹&gt;</p><p>创建文件夹</p><p><em>-p &lt;<strong>多级目录</strong>&gt;</em> <em>按路径创建多级目录</em>      <em>-m &lt;<strong>数字权限值</strong>&gt;</em> <em>设定权限</em></p><p>cp &lt;源文件&gt; &lt;目标目录|文件&gt;</p><p>将源文件复制为目录文件，或者将源文件复制到目标目录。多个源文件使用空格分隔</p><p>cp &lt;源目录&gt; &lt;目标目录&gt;</p><p>将源目录复制到目标目录中，如果复制多个源目录，需要使用 -R 参数</p><p><em>-a</em> <em>相当于</em>*-dpr**参数*       <em>-d</em> <em>保留链接</em>        <em>-f</em> <em>强制复制，覆盖目标文件</em>         <em>-i</em> <em>覆盖时询问用户</em></p><p><em>-p</em> <em>保留修改时间和访问权限</em>        <em>-r -R</em> <em>递归复制（目录</em>*=&gt;*<em>目录）</em>     <em>-l</em> <em>创建链接</em></p><p><em>-v</em> <em>显示过程</em></p><p>rm &lt;目标目录|文件&gt;</p><p>删除</p><p><em>-r -R</em> <em>递归删除</em>      <em>-f</em> <em>强制删除（无需确认，直接删除。慎用！）</em>        <em>-i</em> <em>交互式删除（询问用户）</em></p><p>rmdir &lt;目标目录&gt;</p><p>删除目录时，建议您使用“rm -r”命令</p><p>mv &lt;源文件&gt; &lt;目标目录|文件&gt;</p><p>相当于cp后删除源文件，也可以作为“重命名”使用。</p><p>mv &lt;源目录&gt; &lt;目标目录&gt;</p><p><em>-r -R</em> <em>递归</em></p><p>ln &lt;源文件&gt; &lt;链接&gt;</p><p>链接</p><p><em>-s</em> <em>符号链接</em>        <em>-f</em> <em>强制链接，覆盖目标文件</em>         <em>-i</em> <em>覆盖前询问用户</em></p><h3 id="文件操作"><a class="header-anchor" href="#文件操作">¶</a>文件操作</h3><p>nano</p><p>一个简单轻便的文本编辑器，使用Emacs风格的键绑定。</p><p>split &lt;源文件&gt; [目标文件名前缀]</p><p>将源文件按一定规则分割成若干个目标文件。默认文件名前缀为 x</p><p><em>-&lt;<strong>行数</strong>&gt;</em> <em>按行数分割文件</em>      <em>-l &lt;<strong>行数</strong>&gt;</em> <em>同上</em></p><p><em>-b &lt;<strong>字节</strong>&gt;</em> <em>按大小分割文件。可以使用<strong>b</strong>、<strong>k</strong>、<strong>m</strong>作单位，不指定单位的情况下，默认单位为**b</em></p><p><em>-C &lt;<strong>字节</strong>&gt;</em> <em>按大小分割文件，并尽量保持每行的完整</em></p><p>示例：split -C 100k file.split x</p><p>cat &lt;文件名&gt;</p><p>输出文件内容。用空格分隔多个文件名，可以将多个文件内容连接到一起输出。使用重定向合并为一个文件</p><p><em>-n</em> <em>在输出中添加行号</em>          <em>-b</em> <em>在输出中添加行号，空行不编号</em></p><p><em>-s</em> <em>将两行或以上的空行，合并为一个空行</em></p><p>示例：cat xaa xab xac &gt; file.split</p><p>sort [-o &lt;输出文件&gt;] [-t &lt;分隔字符&gt;] [+&lt;起始字段&gt; - &lt;结束字段&gt;] [文件]</p><p>对文本内容排序</p><p><em>-m</em> <em>合并文件</em>        <em>-c</em> <em>检查文件是否已按规则排序</em>      <em>-b</em> <em>忽略行首空格字符</em></p><p><em>-u</em> <em>忽略内容重复行</em>       <em>-f</em> <em>忽略大小写</em>       <em>-l</em> <em>忽略非打印字符</em>       <em>-M</em> <em>作为月份比较</em></p><p><em>-d</em> <em>按字典顺序排序，按照字母、数字、空格、制表符排序</em>      <em>-r</em> <em>逆序输出</em></p><p>more</p><p>查看文件内容，我们建议您使用 less</p><p>diff &lt;文件名&gt;</p><p>比较文件</p><p>cksum [文件名]</p><p>计算文件的CRC值。不指定文件名则从标准输入设备读入数据，例如：</p><p>echo xxx | cksum</p><p>md5sum [文件名] 计算文件的md5值。同上</p><h3 id="权限管理"><a class="header-anchor" href="#权限管理">¶</a>权限管理</h3><p>一些细节</p><p>一个文件主要包含下列属性， ls -l</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- rwx rwx rwx user group date filename</span><br><span class="line"></span><br><span class="line">111 101 101</span><br></pre></td></tr></table></figure><p>其中，第一组为归属用户的权限，第二组为归属群组的权限，第三组为其它用户群组的权限。user为文件的归属用户，group为文件的归属群组，date为日期信息，filename为文件名。</p><p>对于文件夹，必须拥有它的可执行权限，才能够使用 cd 命令进入该文件夹；拥有可读权限，才能够使用 ls 命令查看该文件夹的文件列表。</p><p>root用户拥有最高权限。</p><p>可以使用3位的二进制数字来描述一组权限，某一权限对应的数字为1,则表示具有该种权限，为0,则不具有该种权限。</p><p>使用二进制数字来描述一组权限，虽然非常直观，但是3组权限需要用9位数来表示，使用不够方便。因此我们将三组权限使用3位8进制数字来表示。它们的对应关系为：</p><p>r 100 4</p><p>w 010 2</p><p>x 001 1</p><p>将这三位8进制数字相加的结果，就可以表示该组权限的具体内容，例如：</p><p>7=4+2+1=rwx</p><p>5=4+1=rx</p><p>755=4+2+1 4+1 4+1=rwx r-x r-x</p><p>还可以使用 a 、 u 、 g 、 o 表示归属关系，使用 = 、 + 、 - 表示权限变化，使用 r 、 w 、 x 表示权限内容，</p><p>a 所有用户 u 归属用户 g 归属群组 o 其它用户</p><p>= 具有权限 + 增加权限 - 去除权限</p><p>r 可读权限 w 可写权限 x 可执行权限</p><p>例如：</p><p>a+x 给所有用户增加可执行权限</p><p>go-wx 将归属群组和其它用户的可写、可执行权限去掉</p><p>u=rwx 归属用户具有可读、可写、可执行权限</p><p>chmod &lt;权限表达式&gt; &lt;文件|目录&gt;</p><p>更改文件的权限。权限的表达式可以使用三位8进制数字表示，或者使用 augo +-= rxw-s 来表示</p><p>-R 递归</p><p>-v 显示过程</p><p>-c 类似“-v”，仅显示更改部分</p><p>--reference=&lt;参考文件或目录&gt; 以指定文件为参考更改权限</p><p>示例：</p><p>chmod -R a+x path</p><p>chmod -Rv 755 path</p><p>chown &lt;归属用户&gt;[:归属群组] &lt;文件|目录&gt;</p><p>更改文件的归属用户。可以使用用户名或者UID</p><p><em>-R</em> <em>递归</em>       <em>-v</em> <em>显示过程</em>        <em>-c</em> <em>类似</em> <em>-v</em> <em>，仅显示更改部分</em></p><p>--reference=&lt;参考文件或目录&gt; 以指定文件为参考更改权限</p><p>示例：</p><p>chown user:admin path          chown -R user.admin path       chown user path</p><p>chgrp &lt;归属群组&gt; &lt;文件|目录&gt;</p><p>更改文件的归属群组。可以使用群组名或者GID</p><p>参数同上</p><p>SUID、SGID、Sticky bit</p><p>某些情况下，需要以可执行文件归属用户的身份执行该文件，可以为该文件设置SUID。同样，设置SGID能够以该文件归属群组的身份执行它。</p><p>例如：用户自行设定密码。出于安全方面的考虑， /etc/shadow 只能由root用户直接修改。</p><p>-rw------- root root /etc/shadow</p><p>这个时候，可以为程序 /usr/bin/passwd</p><p>设置SUID，当普通用户执行“passwd”命令时，便能够以该程序归属用户root的身份修改 /etc/shadow</p><p>文件。而“passwd”程序自身带有身份验证机制，不能通过验证时拒绝执行，从而保证了安全。</p><p>ls -l /usr/bin/passwd</p><p>-r-s--x--x root root /usr/bin/passwd</p><p>我们发现，归属用户的可执行权限位使用 s ，表示SUID。同样，归属群组的可执行权限位使用 s ，表示SGID。任何用户或群组都拥有</p><p>其它用户 的权限，所以不需要以 其它用户 身份执行文件，其它用户的可执行权限位便不会出现 s 。该权限位可能出现的属性为 t</p><p>，也就是粘着位Sticky bit。</p><p>ls -ld /tmp</p><p>drwxrwxrwt root root /tmp</p><p>粘着位表示任何用户都可能具有写权限，但只有该归属用户或root用户才能够删除</p><p>SUID、SGID、Sticky bit也可以像权限一样，使用一个八进制数表示，如下：</p><p>4 SUID</p><p>2 SGID</p><p>1 Sticky bit</p><p>通过在“chmod”命令中使用4个八进制数的表达式，如 4755 ，用第一位表示SUID、SGID、或Sticky bit，便能够为文件设置这些特殊权限。示例：</p><p>chmod -R 4755 path</p><p>lsattr [路径]</p><p>查看文件的特殊属性</p><p><em>-a</em> <em>全部显示</em>        <em>-d</em> <em>只显示目录</em>      <em>-R</em> <em>递归</em></p><p>特殊属性包括：</p><p><em>a</em>*：仅供附加用途*         <em>b</em>*：不更新最后存取时间*       <em>c</em>*：压缩后存放*      <em>d</em>*：排除在倾倒操作之外*</p><p><em>i</em>*：不得任意更动文件或目录*        <em>s</em>*：保密性删除文件或目录*     <em>S</em>*：即时更新文件或目录*</p><p><em>u</em>*：预防以外删除*</p><p>chattr +|-|=&lt;属性&gt; &lt;路径&gt;</p><p>更改文件特殊属性</p><p><em>-R</em> <em>递归</em>       <em>-V</em> <em>显示过程</em></p><h3 id="压缩解压"><a class="header-anchor" href="#压缩解压">¶</a>压缩解压</h3><p>tar -c|x|u|r|t[z|j][v] -f &lt;归档文件&gt; [未打包文件]</p><p>将多个文件打包为一个归档文件，可以在打包的同时进行压缩。支持的格式为tar（归档）、gz（压缩）、bz2（压缩率更高，比较耗时）</p><p><em>-c</em> <em>创建</em>        <em>-x</em> <em>解包</em>        <em>-u</em> <em>更新</em>        <em>-r</em> <em>添加</em>        <em>-t</em> <em>查看</em></p><p><em>-d</em> <em>比较压缩包内文件和文件</em>        <em>-A</em> <em>将<strong>tar</strong>文件添加到归档文件中</em>         <em>-z</em> <em>使用<strong>gz</strong>压缩格式</em></p><p><em>-j</em> <em>使用<strong>bz2</strong>压缩格式</em>      <em>-v</em> <em>显示过程</em>        <em>-f &lt;<strong>文件名</strong>&gt;</em> <em>归档文件的文件名</em></p><p><em>-C &lt;<strong>解压路径</strong>&gt;</em> <em>将压缩包中的文件解压到指定目录</em></p><p>[未打包文件] 创建、更新时必须填写</p><p>示例：</p><p>tar -zcvf xxx.tar.gz xxx/ xxx1 xxx2 xxx3 多个待打包文件以空格分隔</p><p>tar -zcvf xxx.tar.gz /home/user/xxx/ 使用绝对路径打包，解包也使用绝对路径</p><p>tar -zxvf xxx.tar.gz 按相对路径解包到当前目录下，或按绝对路径解包</p><p>tar -zcvf xxx.tar.gz xxx | split -b 1m 打包后，使用split分割为1m大小的多个文件</p><p>其它参数</p><p><em>-P</em> <em>使用绝对路径压缩时，保留根目录</em>*“/”       -W* <em>校验</em>       <em>-p</em> <em>还原文件权限</em></p><p><em>-w</em> <em>询问用户</em>        <em>--totals</em> <em>统计</em>        <em>-T &lt;<strong>表达式</strong>&gt;</em> <em>处理符合条件的文件</em></p><p><em>-X &lt;<strong>表达式</strong>&gt;</em> <em>排除符合条件的文件</em></p><p>zip [参数] &lt;压缩包&gt; &lt;源文件&gt;</p><p>使用zip格式打包文件</p><p><em>-r</em> <em>递归，将指定目录下的所有文件和子目录一并处理</em>          <em>-S</em> <em>包含系统和隐藏文件</em></p><p><em>-y</em> <em>直接保存符号连接，而非该连接所指向的文件</em>         <em>-X</em> <em>不保存额外的文件属性</em></p><p><em>-m</em> <em>将文件压缩并加入压缩文件后，删除源文件</em></p><p>-&lt;压缩级别&gt; 1~9，数字越大，压缩率越高</p><p><em>-F</em> <em>尝试修复已损坏的压缩文件</em>      <em>-T</em> <em>检查备份文件内的每个文件是否正确无误</em></p><p><em>-q</em> <em>不显示指令执行过程</em>        <em>-g</em> <em>将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件</em></p><p><em>-u</em> <em>更新压缩包内文件</em></p><p><em>-f</em> <em>更新压缩包内文件。如果符合条件的文件没有包含在压缩包中，则压缩后添加</em></p><p><em>-$</em> <em>保存第一个被压缩文件所在磁盘的卷标</em>      <em>-j</em> <em>只保存文件名称及其内容</em></p><p><em>-D</em> <em>压缩文件内不建立目录名称</em>      <em>-i &lt;<strong>表达式</strong>&gt;</em> <em>压缩目录时，只压缩符合条件的文件</em></p><p><em>-x &lt;<strong>表达式</strong>&gt;</em> <em>排除符合条件的文件</em>        <em>-n &lt;<strong>文件名后缀</strong>&gt;</em> <em>排除指定文件名后缀的文件</em></p><p><em>-b &lt;<strong>缓存路径</strong>&gt;</em> <em>指定临时文件目录</em>        <em>-d &lt;<strong>表达式</strong>&gt;</em> <em>从压缩文件内删除指定的文件</em></p><p><em>-t &lt;<strong>日期时间</strong>&gt;</em> <em>把压缩文件的日期设成指定的日期</em></p><p><em>-o</em> <em>以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同</em></p><p><em>-A</em> <em>调整可执行的自动解压缩文件</em>         <em>-c</em> <em>替每个被压缩的文件加上注释</em></p><p><em>-z</em> <em>替压缩文件加上注释</em>        <em>-k</em> <em>使用<strong>MS-DOS</strong>兼容格式的文件名称。</em></p><p><em>-l</em> <em>压缩文件时，把<strong>LF</strong>字符置换成<strong>LF+CR</strong>字符。</em>         <em>-ll</em> <em>压缩文件时，把<strong>LF+CR</strong>字符置换成<strong>LF</strong>字符。</em></p><p>unzip [参数] &lt;压缩文件&gt; [压缩包中将被释放的文件]</p><p>解压zip压缩包文件</p><p><em>-P &lt;<strong>密码</strong>&gt; zip**压缩包的密码</em>         <em>-d &lt;<strong>路径</strong>&gt;</em> <em>指定解压路径</em>      <em>-n</em> <em>解压缩时不覆盖原有文件</em></p><p><em>-f</em> <em>覆盖原有文件</em>         <em>-o</em> <em>不经询问，直接覆盖原有文件</em></p><p><em>-u</em> <em>覆盖原有文件，并将压缩文件中的其他文件解压缩到目录中</em></p><p><em>-l</em> <em>显示压缩文件内所包含的文件</em>         <em>-t</em> <em>检查压缩文件是否正确</em>      <em>-z</em> <em>显示压缩包注释</em></p><p><em>-Z unzip -Z<strong>等于执行</strong>zipinfo**指令</em>          <em>-j</em> <em>不处理压缩文件中原有的目录路径</em></p><p><em>-C</em> <em>压缩文件中的文件名称区分大小写</em>         <em>-L</em> <em>将压缩文件中的全部文件名改为小写</em></p><p><em>-s</em> <em>将文件名中的空格转换下划线</em>         <em>-X</em> <em>解压缩时保留文件原来的**UID/GID</em></p><p><em>-q</em> <em>执行时不显示任何信息</em>               <em>-v</em> <em>执行是时显示详细的信息</em></p><p><em>-c</em> <em>将解压缩的结果显示到屏幕上，并对字符做适当的转换</em></p><p><em>-p</em> <em>与</em>*-c**参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换*</p><p><em>-a</em> <em>对文本文件进行必要的字符转换</em>            <em>-b</em> <em>不要对文本文件进行字符转换</em></p><p><em>-x &lt;<strong>表达式</strong>&gt;</em> <em>处理里排除压缩包中的指定文件</em>            <em>-M</em> <em>将输出结果送到<strong>more</strong>程序处理</em></p><p>7z|7za &lt;子命令&gt; [参数] &lt;压缩包&gt; [文件]</p><p>子命令</p><p><em>a</em> <em>添加</em>    <em>d</em> <em>删除</em>    <em>e</em> <em>解压</em>    <em>x</em> <em>带路径解压</em>  <em>l</em> <em>列表查看</em>     <em>t</em> <em>测试</em>    <em>u</em> <em>更新</em></p><p>参数</p><p><em>-m&lt;<strong>压缩方式</strong>&gt;      -m0=&lt;<strong>压缩算法</strong>&gt;</em> <em>默认使用**lzma         -mx=&lt;1~9&gt;</em> <em>压缩级别</em></p><p><em>-mfb=64 number of fast bytes for LZMA = 64      -md=&lt;<strong>字典大小</strong>&gt;</em> <em>设置字典大小，例如</em> <em>-md=32m</em></p><p><em>-ms=&lt;on|off&gt;</em> <em>是否固实压缩</em>        <em>-o&lt;<strong>输出目录</strong>&gt;</em> <em>设置输出目录</em>        <em>-p[<strong>密码</strong>]</em> <em>使用密码</em></p><p><em>-r[<strong>数字</strong>]</em> <em>递归，使用数字定义递归子目录的深度</em>          <em>-sfx[&lt;<strong>模块名称</strong>&gt;]</em> <em>使用自解压模块</em></p><p><em>-si</em> <em>从标准输入设备读入数据</em>        <em>-so</em> <em>将数据写入标准输出设备</em>       <em>-y</em> <em>所有询问均回答**Yes</em></p><p><em>-w&lt;<strong>工作目录</strong>&gt;</em></p><p>rar &lt;子命令&gt; [参数] &lt;压缩包&gt; [文件|文件列表|路径]</p><p>子命令</p><p><em>x</em> <em>带路径解压</em>       <em>e</em> <em>解压到当前目录</em>        <em>a</em> <em>将文件添加到压缩包内</em>      <em>d</em> <em>从压缩包中删除文件</em></p><p><em>u</em> <em>更新压缩包内文件</em>      <em>f</em> <em>更新压缩包内文件，并添加压缩包内不存在的文件</em>      <em>m</em> <em>添加并删除源文件</em></p><p><em>r</em> <em>修复</em>        <em>l</em> <em>列表查看压缩包内文件信息</em> <em>lt</em> <em>更详细信息</em> <em>lb</em> <em>简短信息</em>      <em>c</em> <em>添加压缩包注释</em></p><p>cf &lt;文件名&gt; 将文件内容添加为注释</p><p>cw &lt;文件名&gt; 将注释保存为文件</p><p>t 测试压缩包       rr 添加恢复纪录         rv 恢复到文件</p><p>参数</p><p>-p&lt;密码&gt; 设置密码</p><p>-m&lt;0~5&gt; 设置压缩级别，数字越大，压缩级别越高</p><h3 id="搜索"><a class="header-anchor" href="#搜索">¶</a>搜索</h3><p>whereis &lt;程序名称&gt;</p><p>查找软件的安装路径</p><p><em>-b</em> <em>只查找二进制文件</em>          <em>-m</em> <em>只查找帮助文件</em>      <em>-s</em> <em>只查找源代码</em>    <em>-u</em> <em>排除指定类型文件</em></p><p><em>-f</em> <em>只显示文件名</em>         <em>-B &lt;<strong>目录</strong>&gt;</em> <em>在指定目录下查找二进制文件</em></p><p><em>-M &lt;<strong>目录</strong>&gt;</em> <em>在指定目录下查找帮助文件</em>        <em>-S &lt;<strong>目录</strong>&gt;</em> <em>在指定目录下查找源代码</em></p><p>locate &lt;文件名称&gt;</p><p>在文件索引数据库中搜索文件</p><p>-d &lt;数据库路径&gt; 搜索指定数据库</p><p>updatedb 更新文件索引数据库</p><p>find [路径] &lt;表达式&gt;</p><p>查找文件</p><p>-name &lt;表达式&gt; 根据文件名查找文件</p><p>-iname &lt;表达式&gt; 根据文件名查找文件，忽略大小写</p><p>-path &lt;表达式&gt; 根据路径查找文件</p><p>-ipath &lt;表达式&gt; 根据路径查找文件，忽略大小写</p><p>-amin &lt;分钟&gt; 过去N分钟内访问过的文件</p><p>-atime &lt;天数&gt; 过去N天内访问过的文件</p><p>-cmin &lt;分钟&gt; 过去N分钟内修改过的文件</p><p>-ctime &lt;天数&gt; 过去N天内修改过的文件</p><p>-anewer &lt;参照文件&gt; 比参照文件更晚被读取过的文件</p><p>-cnewer &lt;参照文件&gt; 比参照文件更晚被修改过的文件</p><p>-size &lt;大小&gt; 根据文件大小查找文件，单位b c w k M G</p><p>-type &lt;文件类型&gt; 根据文件类型查找文件。b 块设备 c 字符设备 d 目录 p 管道文件 f 普通文件 l 链接 s 端口文件</p><p>-user &lt;用户名&gt; 按归属用户查找文件</p><p>-uid <uid> 按UID查找文件</uid></p><p>-group &lt;群组名&gt; 按归属群组查找文件</p><p>-gid <gid> 按GID查找文件</gid></p><p>-empty 查找空文件</p><p>grep &lt;字符串&gt;|&quot;&lt;正则表达式&gt;&quot; [文件名]</p><h3 id="其它"><a class="header-anchor" href="#其它">¶</a>其它</h3><p>echo &lt;字符串&gt;</p><p>回显。较复杂的字符串，可以使用 &quot; 括起来。</p><p><em>-n</em> <em>输出内容不换行</em>       <em>-E</em> <em>不解析脱字符</em>         <em>-e</em> <em>解析脱字符</em></p><p>控制字符</p><p>** <em>反斜线</em>       <em>a</em> <em>警告</em>        <em>b</em> <em>退格</em>        <em>n</em> <em>换行</em>        <em>r</em> <em>回车</em>        <em>t</em> <em>水平制表符</em></p><p>clear</p><p>消除屏幕</p><p>alias &lt;输入内容&gt; &lt;实际内容&gt;</p><p>别名，为命令指定一个别名，以简化输入。例如：</p><p>alias ls='ls --color=auto'</p><p>alias ls=&quot;l -CF&quot;</p><p>可以将您的定义保存在 ~/.bashrc 文件中。</p><p>export &lt;变量名称&gt;</p><p>将变量导出为环境变量，常写变量赋值一同使用，例如：</p><p>export PATH=&quot;$PATH:xxx&quot;</p><p>其中 $PATH 表示变量 PATH 原值</p><p>shutdown</p><p>关闭计算机，向根进程 init 发送信号，更改 runlevel 为 0 (halt)</p><p><em>-h</em> <em>关闭电源</em>        <em>-r</em> <em>重启</em>        <em>-n</em> <em>强行关机，不向</em> <em>init**进程</em> <em>发送信号</em></p><p><em>-k</em> <em>模拟关机，向登录者发送关机警告</em>          <em>-t &lt;<strong>秒</strong>&gt; N**秒后关机</em>       <em>time &lt;<strong>时间</strong>&gt;</em> <em>定时关机</em></p><p><em>-c [<strong>说明信息</strong>]</em> <em>取消关机</em>        <em>-f</em> <em>重启时忽略检测文件系统</em>         <em>-F</em> <em>重启时强制检测文件系统</em></p><p>halt</p><p>关闭计算机。 调用 shutdown -h ，结束系统进程，同步文件系统，停止内核。</p><p><em>-n</em> <em>不同步文件系统</em>       <em>-w</em> <em>模拟关机，写</em> <em>/var/log/wtmp</em> <em>纪录</em>     <em>-f</em> <em>不调用</em> *shutdown ,*<em>强行关机</em></p><p><em>-p</em> <em>默认选项，关机时调用</em> <em>poweroff       -i</em> <em>关机前断开网络</em></p><p>reboot</p><p>重新启动计算机。参数与 halt 相似</p><p>chroot &lt;路径&gt;</p><p>Change Root 更改根目录，重新定义会话的运行环境。</p><h3 id="用户管理"><a class="header-anchor" href="#用户管理">¶</a>用户管理</h3><p>一些细节</p><p>root 用户为根用户，也就是 系统管理员 拥有全部权限</p><p>一个用户只能拥有一个 GID ，但是还可以归属于其它附加群组</p><p>用户管理的重要配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/etc/passwd 用户名 密码位 UID 归属GID 姓名 $HOME目录 登录Shell</span><br><span class="line">/etc/shadow 用户名 已加密密码 密码改动信息 密码策略</span><br><span class="line">/etc/group 群组名 密码位 GID 组内用户</span><br><span class="line">/etc/gshadow 群组密码相关文件，不重要</span><br><span class="line">/etc/sudoers 用户名 权限定义 权限</span><br></pre></td></tr></table></figure><p>可以使用 pwconv 命令创建影子密码，将 /etc/passwd 文件中的密码转换到 /etc/shadow 文件</p><p>su [用户名]</p><p>切换到其它用户，默认切换到root用户。提示密码为将切换用户密码</p><p><em>-f</em> <em>快速切换，忽略配置文件</em>         <em>-l</em> <em>重新登录</em>         <em>-m</em> <em>，**-p</em> <em>不更改环境变量</em></p><p><em>-c &lt;<strong>命令</strong>&gt;</em> <em>切换后执行命令，并退出切换</em></p><p>sudo [命令]</p><p>以其它用户的身份执行命令，默认以root的身份执行。提示密码为当前用户密码</p><p><em>-s</em> <em>切换为**root shell       -i</em> <em>切换为<strong>root shell</strong>，并初始化</em>       <em>-u &lt;<strong>用户名</strong>|UID&gt;</em> <em>执行命令的身份</em></p><p><em>-l</em> <em>显示自己的权限</em></p><p>passwd [用户名]</p><p>设定用户密码</p><p><em>-d</em> <em>清除密码</em>        <em>-l</em> <em>锁定用户</em>         <em>-e</em> <em>使密码过期，在下次登录时更改密码</em></p><p><em>-S</em> <em>显示密码认证信息</em>          <em>-x &lt;<strong>天数</strong>&gt;</em> <em>密码过期，最大使用时间</em></p><p><em>-n &lt;<strong>天数</strong>&gt;</em> <em>冻结密码，最小使用时间</em>      <em>-s</em> <em>更改登录**Shell         -f</em> <em>更改用户信息</em></p><p>示例：</p><p>$passwd</p><p>Changing password for user</p><p>(current) UNIX password: 原密码</p><p>Enter new UNIX password: 新密码</p><p>Retype new UNIX password: 确认新密码</p><p>chsh [-s <shell>] [用户名]</shell></p><p>更改登录Shell</p><p>usermod &lt;用户名&gt;</p><p>修改用户账号</p><p><em>-d &lt;<strong>目录</strong>&gt;</em> <em>设定</em>*$HOME<em><em>目录*        <em>-m</em> <em>设定</em></em>$HOME</em>*目录时自动建立*</p><p><em>-s <shell></shell></em> <em>修改用户登录**Shell       -l &lt;<strong>新用户名</strong>&gt;</em> <em>修改为新用户名</em></p><p><em>-u <uid></uid></em> <em>修改用户**UID           -g &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属群组</em></p><p><em>-G &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属附加群组</em>     <em>-L</em> <em>锁定帐户</em>        <em>-U</em> <em>解除锁定</em></p><p><em>-e &lt;<strong>过期时间</strong>&gt;</em> <em>设定用户账号过期时间</em>         <em>-f &lt;<strong>缓冲天数</strong>&gt;</em> <em>设定密码过期后多长时间关闭账号</em></p><p><em>-c &lt;<strong>字符串</strong>&gt;</em> <em>修改用户备注</em></p><p>useradd &lt;用户名&gt;</p><p>新建用户</p><p><em>-d &lt;<strong>目录</strong>&gt;</em> <em>设定</em>*$HOME<em><em>目录*        <em>-m</em> <em>自动建立</em></em>$HOME</em><em>目录*      <em>-M</em> <em>不自动建立</em></em>$HOME**目录*</p><p><em>-s <shell></shell></em> <em>修改用户登录**Shell       -l &lt;<strong>用户名</strong>&gt;</em> <em>修改为新用户名</em>        <em>-u <uid></uid></em> <em>修改用户**UID</em></p><p><em>-g &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属群组</em>          <em>-G &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属附加群组</em></p><p><em>-n</em> <em>不建立以用户名为名称的群组</em>         <em>-e &lt;<strong>过期时间</strong>&gt;</em> <em>设定用户账号过期时间</em></p><p><em>-f &lt;<strong>缓冲天数</strong>&gt;</em> <em>设定密码过期后多长时间关闭账号</em>        <em>-c &lt;<strong>字符串</strong>&gt;</em> <em>修改用户备注</em></p><p><em>-D [<strong>表达式</strong>]</em> <em>更改预设值</em> <em>（预设值保存于</em> <em>/etc/default/useradd</em> <em>文件中）</em></p><p>新建用户规则保存于 /etc/login.defs 文件中</p><p>新建用户默认文件保存于 /etc/skel/ 目录中。新建用户时，系统自动拷贝此目录下的文件至新建用户的 $HOME 目录</p><p>userdel &lt;用户名&gt;</p><p>删除用户</p><p><em>-r</em> <em>删除用户相关文件和目录</em></p><p>id [用户名]</p><p>显示用户 UID GID 归属附加群组</p><p>finger [用户名]</p><p>显示用户信息</p><h3 id="进程管理"><a class="header-anchor" href="#进程管理">¶</a>进程管理</h3><p>一些细节</p><p>进程一般分为交互进程、批处理进程和守护进程三类。</p><p>守护进程总是活跃，在系统启动时通过脚本自动启动，或由root启动，通常在后台运行。</p><p>一个进程可以拥有子进程。当父进程终止时，它的子进程也随之终止；而子进程终止时，父进程通常可以继续运行。</p><p>init 进程为根进程，所有进程都是它的子进程</p><p>ps</p><p>显示进程信息，参数可省略 -</p><p><em>aux</em> <em>以<strong>BSD</strong>风格显示进程**(<strong>常用</strong>)          -efH</em> <em>以<strong>System V</strong>风格显示进程</em></p><p><em>-e , -A</em> <em>显示所有进程</em>      <em>a</em> <em>显示终端上所有用户的进程</em>       <em>x</em> <em>显示无终端进程</em></p><p><em>u</em> <em>显示详细信息</em>          <em>f</em> <em>树状显示</em>         <em>w</em> <em>完整显示信息</em>         <em>l</em> <em>显示长列表</em></p><p>示例：</p><p>ps alx 另一种常用输出格式</p><p>ps aux | less 将输出通过管道，使用 less 查看</p><p>ps aux | grep &lt;关键字&gt; 通过关键字查找进程</p><p>输出字段</p><p>USER 进程所有者        PID 进程ID        PPID 父进程       %CPU CPU占用率</p><p>%MEM 内存占用率      NI 进程优先级。数值越大，占用CPU时间越少         VSZ 进程虚拟大小</p><p>RSS 页面文件占用       TTY 终端ID       STAT 进程状态</p><p>D 不可中断 Uninterruptible sleep (usually IO)        R 正在运行，或在队列中的进程</p><p>S 处于休眠状态          T 停止或被追踪         Z 僵尸进程</p><p>W 进入内存交换（从内核2.6开始无效）      X 死掉的进程      &lt; 高优先级         N 低优先级</p><p>L 有些页被锁进内存     s 包含子进程       + 位于后台的进程组；</p><p>l 多线程，克隆线程 multi-threaded (using CLONE_THREAD, like NPTL pthreads do)</p><p>pstree</p><p>树状显示进程信息</p><p><em>-a</em> <em>显示完整命令及参数</em>        <em>-c</em> <em>重复进程分别显示</em>          <em>-c</em> <em>显示进程**ID PID  -n</em> <em>按</em> <em>PID</em> <em>排列进程</em></p><p>pgrep &lt;进程名&gt;</p><p>显示进程的PID</p><p><em>-l</em> <em>显示进程名和进程**PID      -o</em> <em>进程起始**ID      -n</em> <em>进程终止**ID</em></p><p>xkill</p><p>在图形界面中点杀进程。执行此命令后，鼠标指针变为骷髅图案（一定看过《加勒比海盗》吧）。在窗口中点击左键杀死进程，右键取消</p><p>pkill &lt;进程名&gt;</p><p>结束进程族。如果结束单个进程，请用 kill</p><p>kill [信号代码] &lt;进程PID&gt;</p><p>根据PID向进程发送信号，常用来结束进程，默认信号为 -9</p><p>-l [信号数字] 显示、翻译信号代码</p><p>-9 , -KILL 发送 kill 信号退出</p><p>-6 , -ABRT 发送 abort 信号退出</p><p>-15 , -TERM 发送 Termination 信号</p><p>-1 , -HUP 挂起</p><p>-2 , -INT 从键盘中断，相当于 Ctrl+c</p><p>-3 , -QUIT 从键盘退出，相当于 Ctrl+d</p><p>-4 , -ILL 非法指令</p><p>-11 , -SEGV 内存错误</p><p>-13 , -PIPE 破坏管道</p><p>-14 , -ALRM</p><p>-STOP 停止进程，但不结束</p><p>-CONT 继续运行已停止的进程</p><p>-9 -1 结束当前用户的所有进程</p><p>renice &lt;优先级表达式&gt; &lt;进程表达式&gt;</p><p>重新设定进程优先级（无此必要）</p><p>优先级表达式：</p><p>+|-|= &lt;nice值&gt;</p><p>nice取值范围： -20~19</p><p>进程表达式：</p><p>-p <pid> 通过进程ID进行设定</pid></p><p>-g <pgid> 通过进程群组ID</pgid></p><p>-u <uid> 通过进程拥有者UID设定</uid></p><p>top</p><p>动态、交互式进程管理器</p><p>-c 显示进程启动状态，包括参数、操作对象等；而不只是进程名</p><p>-d &lt;秒&gt; 刷新频率。 -d 5，表示5秒刷新一次</p><p>-n &lt;次&gt; 刷新次数，然后退出。 -n 5，表示刷新5次后退出；</p><p>-b 以批量模式运行，让输出能够使用管道或重定向。但不能进行交互，最好和 -n &lt;次&gt; 参数一同使用</p><p>-i 禁止显示空闲进程或僵尸进程；</p><p>-p PID 仅监视指定进程的ID；PID是一个数值；</p><p>-s 安全模式运行，禁用一些效互指令；</p><p>-S 累积模式，输出每个进程的总的CPU时间，包括已死的子进程；</p><p>交互命令：</p><p><space> 立即刷新</space></p><p>k 交互式杀死进程，提示输入进程 PID （默认发送信号15）</p><p>r 设定renice，提示输入PID和renice值</p><p>s 改变两次刷新时间间隔，以秒为单位</p><p>n 设定显示进程数， 0 为不作限制</p><p>i 隐藏空闲进程和僵尸进程</p><p>S 切换到累积时间模式</p><p>l 开关，在顶部显示 uptime 信息</p><p>t 开关，在顶部显示 进程和CPU状态</p><p>m 开关，在顶部显示 free 信息</p><p>c 显示方式切换： 进程名/进程启动状态</p><p>A 按进程启动顺序进行排序。由新到旧</p><p>M 按内存占用排序。由大到小</p><p>N 以进程ID排序。由大到小</p><p>P 按CPU占用排序。由大到小</p><p>T 按时间／累积时间排序</p><p>f ，F 设定显示字段。设定完成后空格退出</p><p>o,O 设定显示字段的排序。大写向前移动，小写向后移动，空格退出</p><p>h,? 显示有关安全模式和累积模式的帮助信息</p><p>W 把当前的配置写到~/.toprc中；</p><p>nohup &lt;命令&gt;</p><p>将任务提交到后台，输出附加到 ~/nohup.out 文件。即便用户退出登录，提交的命令仍继续执行。</p><p>&lt;命令&gt; &amp;</p><p>背景执行此命令，如果用户退出登录，则命令停止执行</p><p>&lt;命令1&gt; ; &lt;命令2&gt; ; ......</p><p>命令队列，从左向右，依次执行以 ; 分隔的命令</p><p>&lt;命令1&gt; &amp;&amp; &lt;命令2&gt; &amp;&amp; ......</p><p>命令队列，从左向右，依次执行以 &amp;&amp; 分隔的命令。前一个命令执行成功，后一个命令才能执行</p><p>&lt;命令&gt; &lt;Ctrl+z&gt;</p><p>&lt;Ctrl+z&gt; 挂起当前Shell中的任务</p><p>jobs</p><p>显示背景任务</p><p>bg [任务编号]</p><p>将挂起的任务背景执行</p><p>fg [任务编号]</p><p>将背景任务调到前台执行</p><p>计划任务</p><h3 id="磁盘和内存管理"><a class="header-anchor" href="#磁盘和内存管理">¶</a>磁盘和内存管理</h3><p>一些细节</p><p>Linux中，设备用/dev/目录下的文件表示。例如</p><p>/dev/hda1 第一块硬盘的第一主分区</p><p>/dev/hdb5 第二块硬盘的第一逻辑分区</p><p>/dev/sda4 第一块SATA硬盘的第四主分区，或者扩展分区</p><p>/dev/null 黑洞设备</p><p>关于磁盘设备，详见 分区概念</p><p>mount &lt;设备文件&gt; [挂载路径]</p><p>挂载文件系统</p><p>-t 指定文件系统的类型。通常不必指定，mount自动检测。下面是常用的格式</p><p>reiserfs ReiserFS 3.6版</p><p>jfs IBM技术</p><p>xfs SGI技术(适合高级服务器，桌面用户慎用)</p><p>ext3 Linux传统文件系统</p><p>vfat fat fat32</p><p>ext2 不带日志的ext3</p><p>ntfs WINNT</p><p>iso9660 光盘</p><p>smbfs Windows文件共享</p><p>-o [选项1] [选项2] ......</p><p>loop 环设备。光盘、ISO镜像等</p><p>ro | rw 只读readonly；可读写read-write</p><p>sync | async 同步模式|异步模式。决定修改是否立即写入文件系统</p><p>atime | noattime 读取时是否修改访问时间。对于写入敏感设备，例如闪存、软盘，建议使用 <em>noatime</em></p><p>auto | noauto 自动挂载模式</p><p>exec | noexec 是否允许可执行权限</p><p>defaults 使用预设的选项 rw, suid, dev, exec, auto, nouser, async</p><p>iocharset=UTF-8 指定字符集，可简写为 utf8</p><p>codepage=936 指定代码页，可简写为 cp936 西文系统代码页为 437</p><p>umask=&lt;权限掩码&gt; 设定权限掩码</p><p>uid=<uid> 设定归属用户</uid></p><p>gid=<gid> 设定归属群组</gid></p><p>remount 以不同选项重新挂载</p><p>-L &lt;卷标&gt; 将带有特殊卷标的分区</p><p>Tip</p><p>权限掩码</p><p>权限=777-权限掩码（三位） | 7777-权限掩码（四位）</p><p>假如权限掩码为 022 ，则新建对象权限为 755 rwxr-xr-x</p><p>可以使用 umask 命令设置权限掩码</p><p>mount -a</p><p>挂载 /etc/fstab 文件中定义的所有设备</p><p>示例：</p><p>sudo mount -t iso9660 -o loop /dev/cdrom0 /media/cdrom</p><p>sudo mount -t vfat -o remount iocharset=utf8,codepage=cp936 /dev/hda5 /media/hda5</p><p>umount &lt;设备文件&gt; | &lt;挂载路径&gt;</p><p>卸载已挂载文件系统</p><p>df</p><p>查看已挂载文件系统的磁盘空间占用</p><p>-a 显示所有文件系统的磁盘使用情况，包括0块（block）的文件系统，如/proc文件系统</p><p>-T 显示文件系统类型         -k 以k字节为单位显示        -i 显示i节点信息，而不是磁盘块</p><p>-t &lt;文件系统类型&gt; 显示指定类型的文件系统的磁盘空间使用情况</p><p>-x &lt;文件系统类型&gt; 列出不是某一指定类型文件系统的磁盘空间使用情况（与t选项相反）。</p><p>-l 只显示本地文件系统</p><p>free</p><p>查看内存、缓冲区、交换空间的占用</p><p>-b 以字节为单位显示数值      -k 以千字节为单位显示数值        -m 以兆字节为单位显示数值</p><p>-g 以吉字节为单位显示数值        -l 显示内存占用峰值     -o 不显示缓冲区占用          -t 统计结果</p><p>-s &lt;秒&gt; 刷新频率</p><p>sync</p><p>同步文件系统。将缓冲区中的数据写入文件系统</p><p>fdisk &lt;磁盘设备文件&gt;</p><p>分区表修改工具</p><p>交互命令：</p><p>m 使用帮助        l 查看已知文件系统类型       p 显示分区信息</p><p>n 新建分区 （p:主分区 l:扩展分区 参见 分区概念 )     d 删除分区         t 改变分区类型</p><p>w 将改动写入分区表          q 放弃改动并退出</p><p>* 磁盘设备名称为整块磁盘，而不是磁盘中的分区。例如 /dev/hda ，而不是 /dev/hda1</p><p><strong>fdisk -l</strong></p><p>查看所有磁盘分区信息</p><p>cfdisk</p><p>更加友善的分区表修改工具</p><p>mkfs.&lt;文件系统类型&gt; &lt;分区设备文件&gt;</p><p>将分区格式化为文件系统。 文件系统类型</p><p>示例：</p><p>sudo mkfs.reiserfs /dev/hda1</p><p>mkfs &lt;分区设备文件&gt;</p><p>-t &lt;文件系统类型&gt; 指定文件系统类型         -c 格式化前检查磁盘</p><p><strong>mkisofs -o &lt;<strong><strong>镜像文件</strong></strong>&gt; [<strong><strong>源文件目录</strong></strong>]</strong></p><p>用光盘或者文件制作iso镜像</p><p>-b 可启动镜像</p><p>hdparm &lt;磁盘设备文件&gt;</p><p>设置硬盘参数</p><p>-d &lt;0|1&gt; DMA模式开关       -a &lt;0|1&gt; 预计模式开关         -t 性能测试         -T 缓存性能测试</p><p>-c &lt;0|1|3&gt; 32位传输模式开关        -g 显示柱面，扇区等信息      -i -I 显示磁盘信息</p><h3 id="网络和硬件管理"><a class="header-anchor" href="#网络和硬件管理">¶</a>网络和硬件管理</h3><p>ifconfig</p><p>配置网络接口</p><p>-a 显示所有网络接口</p><p>ifconfig &lt;网卡&gt; up|down</p><p>激活|禁用网卡</p><p>示例： ::</p><p>sudo ifconfig eth0 up</p><p>ifconfig &lt;网卡&gt; add &lt;IP地址&gt; [ netmask &lt;子网掩码&gt; ]</p><p>给网卡指定IP地址或子网掩码</p><p>route</p><p>配置路由及网关</p><p>route add -net &lt;路由地址&gt; gw &lt;网关地址&gt; [ netmask &lt;子网掩码&gt; ] dev &lt;网卡&gt;</p><p>指定路由及网关</p><p>route del -net &lt;网关地址&gt; gw &lt;网关地址&gt; [ netmask &lt;子网掩码&gt; ]</p><p>删除路由及网关</p><p>ip</p><p>配置网络</p><p>子命令：</p><p>link 网卡配置       address 配置地址。相当于 ifconfig        route 配置路由。相当于 route</p><p>参数：</p><p>show 显示(默认)         set 设置       add 添加      del 删除</p><p>示例：</p><p>ip link show 显示网卡配置</p><p>ip link set eth0 name xxx 重命名网络接口</p><p>ping &lt;IP地址&gt;</p><p>向目标地址发送ICMP封包，常用来测试网络</p><p>-b &lt;广播地址&gt; ping整个网段        -c 发送封包次数         -s &lt;封包大小&gt; 默认为64字节</p><p>netstat</p><p>网络连接状态</p><p>-r 显示路由表，同 route       -a 所有连接        -t 只显示TCP协议      -U 只显示UDP协议</p><p>-l 只显示正在监听的端口      -p 显示PID和进程名         -c &lt;秒&gt; 刷新频率</p><p>* http/ftp/ssh…… 为应用层协议         * TCP/UDP为传输层协议      * IP/ICMP为网络层协议</p><p>lspci</p><p>查看PCI总线连接的设备</p><p>lsusb</p><p>查看USB接口连接的设备</p><p>lsmod</p><p>查看已加载模块</p><p>* /lib/modules/uname -r 目录下为所有可用模块</p><p>modprobe &lt;模块名称&gt;</p><h2 id="简明VIM教程"><a class="header-anchor" href="#简明VIM教程">¶</a>简明VIM教程</h2><h3 id="VIM简介"><a class="header-anchor" href="#VIM简介">¶</a>VIM简介</h3><p>我们使用的大多数编辑器，都可以直接在编辑区输入字符，并且能够通过一些快捷键来完成一些控制功能，比如使用方向键移动光标，使用</p><p>BackSpack 或者 Delete 键删除文字，使用 PgUp 和 PgDn 翻页，使用 Home 和 End 来定位行首和行末……</p><p>而Vim是一个带模式的编辑器，同样的按键，在不同模式下，具有不同的功能定义。例如 h j k l 在 编辑模式 下输入相应的字符，在 普通模式 下却相当于方向键的作用。</p><p>由于需要切换模式，Vim的使用起来略显繁琐。不过优点也显而易见：您只要把手安安稳稳的放在打字区就可以了，而不需要使用诸如方向键、排版键、小键盘等</p><p>需要挪开双手的键位，从而提高了您的效率和专注程度。事实上，Vim的前身Vi诞生的时候，键盘上还没有方向键、排版键和小键盘：）</p><h3 id="命令-2"><a class="header-anchor" href="#命令-2">¶</a>命令</h3><p>使用Vim编辑文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi [文件名]</span><br><span class="line">vim [文件名]</span><br></pre></td></tr></table></figure><p>教学模式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimtutor [语言]</span><br></pre></td></tr></table></figure><p>vim教程，相当于使用Vim编辑器以只读模式打开教程文件。您无论对这个文件作了什么，都会在退出后恢复原来的样貌。与只读模式的区别在于，它不会没有眼色的提醒您，现在的状态为只读模式。您可以使用它作一些练习</p><p>您可以指定教程文件的语言，如果使用本地语言(ZH_cn)出现乱码，您可以尝试使用英语</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimtutor en</span><br></pre></td></tr></table></figure><h3 id="使用Vim比较文件区别"><a class="header-anchor" href="#使用Vim比较文件区别">¶</a>使用Vim比较文件区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimdiff [文件1] [文件2] [其它文件]……</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a class="header-anchor" href="#配置文件">¶</a>配置文件</h3><p>Vim的全局配置文件为 /etc/vim/vimrc ，用户配置文件为 ~/.vimrc ， &quot; 起始的行为注释行。我们提供的配置项，您直接加入配置文件就可以了</p><p>您可以先对Vim进行一些简单的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&quot;设定文件编码</span><br><span class="line">set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span><br><span class="line"></span><br><span class="line">&quot;开启语法加亮</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">&quot;配色风格</span><br><span class="line">colorscheme pablo</span><br><span class="line"></span><br><span class="line">&quot;设定行距 GUI界面中生效</span><br><span class="line">set linespace=4</span><br><span class="line"></span><br><span class="line">&quot;设定GUI选项</span><br><span class="line">&quot;set guioptions=gmrLtT m:菜单 T:工具栏</span><br><span class="line">set guioptions=gmrLt</span><br><span class="line"></span><br><span class="line">&quot;设定Tab键缩进的空格数</span><br><span class="line">set tabstop=4</span><br><span class="line"></span><br><span class="line">&quot;设定编辑器将多少空格视为一个缩进</span><br><span class="line">set shiftwidth=4</span><br><span class="line"></span><br><span class="line">&quot;将缩进转换为空格</span><br><span class="line">&quot;set expandtab</span><br><span class="line"></span><br><span class="line">&quot;设定折叠方式</span><br><span class="line">&quot;set foldmethod=indent</span><br><span class="line"></span><br><span class="line">&quot;以下字符将被视为单词的一部分 (ASCII)：</span><br><span class="line">&quot;set iskeyword+=33-47,58-64,91-96,123-128</span><br></pre></td></tr></table></figure><h3 id="模式介绍"><a class="header-anchor" href="#模式介绍">¶</a>模式介绍</h3><p>Vim常见的模式有： <code>普通模式</code> 、 <code>插入模式</code> 、 <code>命令模式</code> ，另外我们也会经常用到 <code>可视模式</code> 。</p><p>Vim启动时进入 <code>普通模式</code> ；或者在其它模式下，按下 Esc 键，便可以回到<code>普通模式</code>。</p><p>使用 <code>vimtutor en</code> 命令进入教程，现在是普通模式。随便按几下 j 、 k 、 l 、 h 键，您会发现光标的位置发生改变。</p><p>按下 i 键，编辑器底部出现了 -- 插入 -- 或者 -- insert -- ，您进入了插入模式。随便按几下 j 、 k 、 l、 h，您会发现相应的字符出现在编辑区，现在还可以通过方向键来移动光标。可能您觉得使用方向键移动光标不是什么问题，但是习惯了Vim后，您会认为方向键太麻烦了，简直不能容忍！好了，现在按下 <code>Esc</code> 键回到普通模式，我们又可以使用 j 、 k 、 l 、 h 来移动光标了。</p><p>在<code>普通模式</code>下，按下 : 键（也就是 Shift+; ），在编辑器底部出现了一个 : ，您进入了命令模式。在 : 后输入一个命令 new ，回车后，编辑器被分割为上下两栏。为了方便起见，我们在命令前加一个 : 来表示命令模式下输入的命令，像这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:vnew</span><br></pre></td></tr></table></figure><p>一个命令能够以一些规则简化，上面的命令也可以写为这种形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:vne</span><br></pre></td></tr></table></figure><p>现在您的编辑区一定弄的四分五裂，您可以使用命令<code>:quit</code>来关闭当前栏，直接用简写就可以了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></table></figure><p>这个命令是退出编辑器，如果编辑区被分成多栏，则是退出当前栏。</p><p>执行完一个命令（按下回车后），编辑器会自动回到普通模式。如果您想不执行当前命令，直接回到普通模式，您可以按下Esc键。</p><p>按下 v 键，您进入了可视模式，可以使用 j 、 k 、 l 、 h 移动光标，高亮选取文本 。</p><p>事实上，可视模式相当于高亮选取文本后的普通模式。</p><p>可视模式具有子模式，以行为单位进行选取的可视行模式，使用 V 键进入（也就是 Shift+v ）；和以块为单位进行选取的可视块模式，使用 Ctrl+v 键进入。</p><h3 id="模式切换"><a class="header-anchor" href="#模式切换">¶</a>模式切换</h3><p>好了，现在我们总结一下模式间切换的方法</p><p>其它模式==&gt;普通模式</p><p>Esc</p><p>普通模式==&gt;插入模式</p><p>i 在光标前插入 I 在行首插入           a 在光标后插入 A 在行末插入</p><p>o 在当前行之下新建行 O 在当前行之上新建行          r 替换当前字符 R 从当前字符开始替换</p><p>普通模式==&gt;命令模式         普通模式==&gt;可视模式         v 可视模式         V 可视块模式</p><p>&lt;Ctrl+v&gt; 可视块模式</p><h3 id="移动"><a class="header-anchor" href="#移动">¶</a>移动</h3><p>在普通模式中，您可以使用以下方式移动光标</p><p>j 向下         k 向上        l 向右 h l      h 向左 j</p><p>您可以使用其它更有效率的方式移动光标</p><p>w 下一个单词词首 W 将特殊符号视为单词的一部分           b 上一个单词词首 B 同上</p><p>e 单词末尾 E 同上       0 行首 ^ 行首文字（行首空格之后）         $ 行末</p><p>H 页面顶部        M 页面中部        L 页面底部</p><p>在其它模式中，您可以使用方向键移动光标，不过我们不推荐您那样作，您可以在配置文件中绑定插入模式下的功能键</p><p>noremap! <m-j> <down></down></m-j></p><p>noremap! <m-k> <up></up></m-k></p><p>noremap! <m-h> <left></left></m-h></p><p>noremap! <m-l> <right></right></m-l></p><p>………………</p><p>&lt;作用范围&gt; &lt;键位&gt; &lt;功能&gt;</p><p>其中，map!绑定的键盘映射，作用于所有模式；inoremap!绑定的映射，仅作用于插入模式。</p><h3 id="数字参数"><a class="header-anchor" href="#数字参数">¶</a>数字参数</h3><p>您也可以使用数字参数，来重复执行。例如</p><p>100j 执行100次j键，向下100行</p><p>或者作为跳转的行号、百分比。见下面的浏览部分</p><p>&lt;行号&gt; Ctrl+g 按行号跳转</p><h3 id="标记"><a class="header-anchor" href="#标记">¶</a>标记</h3><p>您可以在当前光标处作一个标记，以便快速返回</p><p>m&lt;标记名称&gt; 定义标记。标记名称为一个字符</p><p>`&lt;标记名称&gt; 返回标记</p><p>mx 将当前光标处定义为标记 x</p><p>`x 返回标记 x</p><h3 id="浏览"><a class="header-anchor" href="#浏览">¶</a>浏览</h3><p>&lt;Ctrl+f&gt; 下翻一页 &lt;Ctrl+d&gt; 下翻半页        &lt;Ctrl+b&gt; 上翻一页 &lt;Ctrl+u&gt; 上翻半页</p><p>gg 文件首行        G 文件末行        &lt;行号&gt;G 按行号转到相应行</p><p>&lt;1~100&gt;% 按百分比转到相应的行数      zz 将光标所在行调整至页面中间</p><p>&lt;Ctrl+e&gt; 下卷一行       &lt;Ctrl+y&gt; 上卷一行</p><p>说明：gg 定位到文件首行， V 进入可视行模式， G 定位到文件末行，实现类似“全选”的功能。依次按下 g g V(Shift+v) G(Shift+g)</p><h3 id="编辑"><a class="header-anchor" href="#编辑">¶</a>编辑</h3><p>x 剪切当前字符              dd 剪切当前行      y 复制可视模式选取字符      yy 复制当前行</p><p>p 在光标后粘贴 P 在光标前粘贴        u 撤消        &lt;trl+r&gt; 重做</p><p>&lt;Ctrl+y&gt; 逐字克隆上一行内容           &lt;Ctrl+e&gt; 逐字克隆下一行内容</p><h3 id="寄存器操作"><a class="header-anchor" href="#寄存器操作">¶</a>寄存器操作</h3><p>Vim可以将不同字段剪切或复制到不同寄存器中，您可以从不同寄存器中取出内容后粘贴</p><p>&quot;&lt;寄存器名称&gt; 按下“&quot;”键和另一个字符键，便可以定义一个寄存器。例如：</p><p>&quot;a &quot;1</p><p>定义寄存器后直接进行操作</p><p>&quot;ayy 将当前行复制到寄存器 a 中</p><p>&quot;ap 将寄存器 a 中的内容粘贴到光标之后</p><p>* 通常情况下，寄存器 + ( &quot; + Shift+= )对应X下的剪贴板。您在其它程序中复制的内容，可以使用 &quot;+p 粘贴到Vim中；您在Vim中，可以使用 &quot;+y 将内容复制到剪贴板，再粘贴到其它程序中</p><p>* 没有指定寄存器时，Vim使用“无名寄存器”存储内容</p><h3 id="搜索和替换"><a class="header-anchor" href="#搜索和替换">¶</a>搜索和替换</h3><p>按下 / 键，编辑器底部会出现 / 符号，接着输入字符串，便可以进行搜索</p><p>/ 向下搜索 ? 向上搜索</p><p>n 搜索下一个</p><p>N 搜索上一个</p><p>:s/&lt;源字符串&gt;/&lt;目标字符串&gt; 将源字符串替换为目标字符串</p><p>:s/&lt;源字符串&gt;/&lt;目标字符串&gt;/g 替换当前行中所有符合条件的字符串</p><p>:&lt;行号1&gt;,&lt;行号2&gt;s/&lt;源字符串&gt;/&lt;目标字符串&gt;/g 在指定行中进行替换</p><p>:%s/&lt;源字符串&gt;/&lt;目标字符串&gt;/g 全文替换</p><h3 id="正则表达式"><a class="header-anchor" href="#正则表达式">¶</a>正则表达式</h3><p>在搜索和替换时，可以使用正则表达式进行匹配</p><h3 id="宏"><a class="header-anchor" href="#宏">¶</a>宏</h3><p>您可以将一系列的操作录制为一个宏，然后执行它</p><p>q&lt;宏名称&gt; 开始录制宏。宏名称为一个字符</p><p>q 录制中按下“q”键，结束录制</p><p>@&lt;宏名称&gt; 执行宏</p><p>插入模式下的快捷键</p><p>&lt;Ctrl+r&gt;&lt;寄存器名称&gt; 输入指定寄存器内容</p><p>&lt;Ctrl+k&gt;&lt;2个字符&gt; 输入二合字符</p><p>&lt;Ctrl+v&gt;&lt;数字&gt; 通过数字编码输入字符</p><p>&lt;Ctrl+v&gt;&lt;键位&gt; 输入键位的名称</p><h3 id="键绑定、缩写"><a class="header-anchor" href="#键绑定、缩写">¶</a>键绑定、缩写</h3><p>前面我们已经向您介绍了键绑定，</p><p>map! <m-j> <down></down></m-j></p><p>尖括号及其中的内容，为Vim配置文件的约定，分别描述了按键和功能，表示将功能编写到按键上。如果绑定的只是普通字符，例如：</p><p>map! xxx XXXXX</p><p>表示将 fXXXXX 绑定到 xxx 上。当您键入 xxx 时，编辑器会自动替换为 XXXXX 。</p><p>如果您只是想将字符串绑定为缩写，方便输入，我们建议您使用 iabbrev 来绑定。例如：</p><p>iabbrev ubt Ubuntu</p><p>在插入模式下键入 ubt ，编辑器会自动替换为 Ubuntu 。您可以将 iabbrev 命令缩写为 iab ，例如：</p><p>iab ubt Ubuntu</p><p>以上命令，您可以直接在命令模式下输入，临时启用。也可以写入配置文件，永久启用。</p><h3 id="单词补全"><a class="header-anchor" href="#单词补全">¶</a>单词补全</h3><p>&lt;Ctrl+n&gt; 下一个匹配项</p><p>&lt;Ctrl+p&gt; 上一个匹配项</p><p>您可以在配置文件中定义补全的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;自动补全方式：(使用逗号分隔)</span><br><span class="line">set complete=k,.</span><br><span class="line"></span><br><span class="line">&quot; . 当前文件</span><br><span class="line">&quot; b 已被装缓冲区,但是没有在窗口内的文件</span><br><span class="line">&quot; d 在当前的文件中定义和由#include包含进来的文件</span><br><span class="line">&quot; i 由#include包含进来的文件</span><br><span class="line">&quot; k 由dictionary选项定义的文件</span><br><span class="line">&quot; kfile 名为&#123;file&#125;的文件</span><br><span class="line">&quot; t 标记(tags)文件</span><br><span class="line">&quot; u 没有载入的缓冲区</span><br><span class="line">&quot; w 在其他窗口中的文件</span><br><span class="line">&quot;设定自动补全字典 ：</span><br><span class="line">set dictionary=path</span><br></pre></td></tr></table></figure><h3 id="命令模式"><a class="header-anchor" href="#命令模式">¶</a>命令模式</h3><p>前面介绍了普通模式和插入模式。我们发现，普通模式主要用来浏览和修改文本内容，而插入模式则用来向文本中添加内容。</p><p>而命令模式则多用于操作文本文件（而不是操作文本文件的内容），例如保存文件；或者用来更改编辑器本身的状态，例如设定多栏窗口、标签或者退出编辑器……</p><p>w(rote) 将更改写入文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w</span><br></pre></td></tr></table></figure><p>q(uit) 退出编辑器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></table></figure><p>某些情况下，编辑器会阻止命令的执行。例如您修改了文件，而没有保存，那么您使用 :q 命令退出时，编辑器就不会执行这条命令，而是提醒您保存文件。</p><p>这个时候，您可以在命令末尾追加 ! 来强制执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&lt;命令&gt;!</span><br></pre></td></tr></table></figure><p>例如 <code>:q!</code> ，即便您没有保存已修改的文件，使用此命令，编辑器也会放弃修改而强行退出</p><p>以 ! 引导一个Shell命令，则可以从Vim临时切换到Shell中，执行一个Shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!&lt;命令&gt;</span><br></pre></td></tr></table></figure><p>例如 :<code>!ls</code></p><h3 id="多栏窗口"><a class="header-anchor" href="#多栏窗口">¶</a>多栏窗口</h3><p>您可以使用以下命令，将当前窗口水平分为两栏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:new</span><br></pre></td></tr></table></figure><p>新建一栏空白窗口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:split</span><br></pre></td></tr></table></figure><p>将当前文件分两栏显示</p><p>同理，您可以使用下列命令，将当前窗口垂直分为两栏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:vnew</span><br><span class="line"></span><br><span class="line">:vsplit</span><br></pre></td></tr></table></figure><p>先按下 &lt;ctrl+w&gt; 键，再按下方向键 j 、 k 、 l 、 h ，您可以切换到其它栏；在当前栏中使用 :q 命令，可以退出当前栏，也可以使用其它命令，对当前栏作出修改</p><p>如果您希望当前命令在所有栏中生效，您可以在命令的末尾追加 all</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&lt;命令&gt;all</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:qall</span><br></pre></td></tr></table></figure><p>如果您希望这条命令强制执行，那么 ! 位于命令的最末</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:&lt;命令&gt;all!</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:qall! 强行退出所有栏窗口</span><br></pre></td></tr></table></figure><h3 id="标签页"><a class="header-anchor" href="#标签页">¶</a>标签页</h3><p>Vim在7以后的版本，开始支持标签页的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:tabnew 新建一个标签</span><br><span class="line">:tabnext 转到下一个标签</span><br><span class="line">:tabprevious 转到上一个标签</span><br></pre></td></tr></table></figure><p>多数情况下，您可以使用鼠标点击标签进行切换。</p><h2 id="引导管理器Grub"><a class="header-anchor" href="#引导管理器Grub">¶</a>引导管理器Grub</h2><h3 id="硬件基础"><a class="header-anchor" href="#硬件基础">¶</a>硬件基础</h3><p>一块硬盘，它起始的一部分扇区为主引导扇区，包括MBR（主引导纪录）和DPT（分区表，您可以阅读分区概念章节中相关内容）</p><p>每个分区起始的一部分扇区，为分区引导扇区。</p><p>在分区引导扇区之后的部分，为文件系统的索引，文件系统通过它定位文件在硬盘上的位置。不同的文件系统采用不同的索引，例如FAT文件系统使用文件分配表和目录区。</p><p>绝大多数操作系统，对硬盘的读写操作，通过文件系统来完成，因此引导扇区中的内容，我们不能够在文件系统中进行操作，而需要专用软件，比如引导管理器。</p><p>我们对文件进行修改后，操作系统会将文件系统索引中的内容同步。</p><h3 id="系统引导流程"><a class="header-anchor" href="#系统引导流程">¶</a>系统引导流程</h3><p>1.系统启动时，首先引导至MBR，将控制权移交安装在MBR中的引导管理器</p><p>（Windows使用NTLDR，Linux通常用Grub）</p><p>2.引导管理器读取分区表</p><p>3.引导管理器读取分区中的配置文件，并按配置文件中预设的参数运行</p><p>例如，Grub读取“/boot/grub/menu.lst”文件中内容，将可引导系统通过菜单显示</p><p>4.引导管理器根据您的选择，可能会有如下活动</p><p>加载内核，启动Linux系统检查活动分区，并引导它（单一Windows系统）读取相应分区的引导扇区，将控制权移交该扇区中的引导管理器，Ubuntu系统在安装Grub时，会提问您安装在MBR或者分区引导扇区中。如果将Grub安装在分区引导纪录中，您必须确保MBR中的引导管理器能够正确的引导至分区引导扇区。</p><p>如果您在MBR中使用的是Windows的引导管理器NTLDR，完成这件工作会非常困难，因而我们推荐您使用Grub。</p><h3 id="Grub介绍"><a class="header-anchor" href="#Grub介绍">¶</a>Grub介绍</h3><p>Grub主要有以下功能：</p><ul><li>菜单式选择</li><li>命令行模式</li><li>支持开机画面</li><li>支持大硬盘</li></ul><p>其它的功能还有很多，就不一一介绍了。</p><p>您可以运行命令 grub 启动它。会显示一些版本信息和使用提示，当然还有命令提示符，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GNU GRUB version 0.97 (640K lower / 3072K upper memory)</span><br><span class="line">[ Minimal BASH-like line editing is supported. For the first word, TAB lists possible <span class="built_in">command</span> completions. Anywhere <span class="keyword">else</span> TAB lists the possible completions of a device/filename. ]</span><br><span class="line">grub&gt;</span><br></pre></td></tr></table></figure><p>您可以使用 TAB 键补全命令和路径，这非常重要，因为Grub中路径表示方式与操作系统是不同的，您可能比较陌生，所以尽量用TAB补全它，既方便，也不容易出错。</p><p>您可以在 grub&gt; 提示符后按 TAB 键，会将所有可用的命令显示出来。</p><p>呵呵，是不是有点晕，命令可真不少啊！！！</p><p>其实我们会用到的命令只有两个，</p><p>root</p><p>setup</p><h3 id="Grub术语"><a class="header-anchor" href="#Grub术语">¶</a>Grub术语</h3><p>在分区概念章节里，我们已经介绍了Linux系统中表示分区的方法 /dev/hda5</p><p>/dev/hdMN M为a起始的小写字母，表示硬盘序号；N为1起始的数字，表示分区序号</p><p>Grub中使用的表示方法为 hd0,1</p><p>hdX,Y X为0起始的数字，表示硬盘序号；Y为0起始的数字，表示分区序号</p><p>您得留意它们之间的区别：</p><p>N从1开始计数，X和Y从0开始计数</p><p>N为1~4，它是一个主分区；N为5或大于5，它是第(N-4)个逻辑分区。Y按分区在硬盘上排列的顺序排列，无论它表示的是主分区还是逻辑分区。</p><p>举例来说：</p><p>主 主 逻 逻 主</p><p>/dev/hdMN hda1 hda2 hda5 hda6 hda3</p><p>hdX,Y hd0,0 hd0,1 hd0,2 hd0,3 hd0,4</p><p>现在我们来看 root 和 setup 命令的使用：</p><p>grub&gt;root (hd0,1)</p><p>这个命令将Grub的根分区定位为 “(hd0,1)”</p><p>grub&gt;setup (hd0)</p><p>这个命令表示将Grub安装在“(hd0)”，因为没有指定安装的分区，所以安装位置为MBR</p><p>Grub的根分区 为Grub配置文件 /boot/grub/menu.lst 所在分区。假如您单独为 /boot 目录挂载了一个分区，那么Grub的根分区通常为您系统中 /boot 目录所在的分区。</p><p>搞错了根分区，Grub就不能正确读取配置文件，自然不能正确引导。</p><p>引导分区 ，Windows等系统的引导分区为它的安装分区，Linux系统的引导分区为它的 /boot 目录所在的分区</p><p>系统根目录所在分区 ，Linux根目录 / 的挂载分区。Linux系统的分区挂载信息保存在文件系统分配表 /etc/fstab 文件中</p><p>Grub首先读取根分区中的 /boot/grub/menu.lst</p><p>文件，并转到引导分区，如果是Windows等系统，则将控制权移动分区引导扇区中的启动管理器。如果是Linux系统，则加载内核和设备，并根据</p><p>/etc/fstab 文件的内容挂载文件系统。</p><p>看这个例子：（假设Grub安装在MBR中）</p><p>title Ubuntu</p><p>root (hd0,0)</p><p>kernel (hd0,1)/boot/vmlinuz-2.6.15-25-686 root=/dev/sda3 ro splash vga=0x31b</p><p>initrd (hd0,1)/boot/initrd.img-2.6.15-25-686</p><p>boot</p><p>Grub的安装位置为 (hd0)</p><p>root (hd0,0) ，这一行表示Grub的根分区为第一块硬盘的第一个分区 (hd0,0) ，它读取该分区中的配置文件 grub/menu.lst</p><p>kernel 和 initrd 行中的 (hd0,1) ，表示当前系统的 /boot 目录挂载到第一块硬盘的第二个分区 (hd0,1)</p><p>kernel 行的 root=/dev/sda3 ，表示当前系统的 / 目录挂载到第一块硬盘的第三个分区 (hd0,2) ，内核根据该分区中的 /etc/fstab 文件来挂载文件系统</p><h3 id="Grub配置文件"><a class="header-anchor" href="#Grub配置文件">¶</a>Grub配置文件</h3><p>/boot/grub/menu.lst 文件，主要由一些下面这样的块构成的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">title Ubuntu</span><br><span class="line">root (hd0,2)</span><br><span class="line">kernel (hd0,2)/boot/vmlinuz-2.6.15-25-686 root=/dev/sda3 ro splash vga=0x31b</span><br><span class="line">initrd (hd0,2)/boot/initrd.img-2.6.15-25-686</span><br><span class="line">boot</span><br><span class="line">title Windows xp</span><br><span class="line">root (hd0,0)</span><br><span class="line">makeactive</span><br><span class="line">chainloader +1</span><br></pre></td></tr></table></figure><p>每一块代表一个操作系统，包含下面里几个部分</p><p>title xxx 标题，title和分隔符后的内容为Grub菜单中显示的条目</p><p>root (hdX,Y) 引导分区，可以留空，默认为 grub/menu.lst 所在分区（根分区），可以使用 grub&gt;root (hdX,Y) 命令设置，或者在您安装系统时自动设置</p><p>如果您计划引导至分区引导扇区，如Windows或者Unix系统（Unix和Linux系统，您需要选择将引导管理器安装到分区中），那么需要这样配置</p><p>makeactive 设置活动分区，系统默认设置，可以删除</p><p>chainloader +1 链式引导，不要动它。</p><p>如果以这种方式引导系统，上面 root (hdX,Y) 这一行通常需要配置， (hdX,Y) 为您的系统所在的分区。假如您的Windows在第一块硬盘的第一个分区，则这样写 root (hd0,0)</p><p>如果您引导的是Linux系统（没有在分区中安装引导管理器，而是安装到MBR），则需要这样配置</p><p>kernel (hd0,2)/boot/vmlinuz-2.6.15-25-686 root=/dev/sda2 ro splash vga=0x31b</p><p>initrd (hd0,2)/boot/initrd.img-2.6.15-25-686 设备镜像文件，与上一行保持一致</p><p>boot 不要动它</p><p>kernel 这一行最关键，它控制系统内核的加载。行末以 ro 起始的部分为参数（ro只读，splash显示启动画面，vga设定启动屏幕分辨率）</p><p>之前的部分可以写为这种形式：</p><p>kernel (hdX,Y)/boot/vmlinuz root=/dev/sdMN</p><p>(hdX,Y) 通常不是必须的，如果您安装了多个Linux系统，或者 /boot<code>目录与根目录 </code>/ 不在一个分区，则应把它写为 /boot 目录所在分区。而后面的 root=/dev/sdMN 为系统根目录 / 所在的分区。</p><p>initrd 这一行的 (hdX,Y) 与上一行保持一致。</p><h3 id="Grub安装"><a class="header-anchor" href="#Grub安装">¶</a>Grub安装</h3><p>上面已经向您介绍了Grub的安装，不过更多的侧重理论。现在我们来实践一下，假设您的系统不能引导，您可以尝试下面的方法：）</p><ol><li></li></ol><ul><li>找一张Ubuntu的LiveCD （Knoppix也是不错的选择）</li><li>也可以使用安装光盘，启动后在 boot 提示符后输入 linux rescue ，回车进入救援模式。</li><li>如果您拥有root权限，命令行提示符为 # ，如果是普通用户，则为 $ 。</li></ul><blockquote><p>在救援模式下，通常你已经具有了root权限</p></blockquote><blockquote><p>如果是LiveCD且没有root权限，请在终端中输入 su命令切换到root，会提问你root的密码。如果不知道root密码，可以使用这个命令 sudo su，只要你知道自己的密码，并且你在ID在sudoer列表中就可以了。</p></blockquote><ol start="2"><li>在终端中输入 grub ，会进入到Grub的提示符界面</li></ol><p>a. 输入命令 root (hd 后按 Tab 键，屏幕上就会列出所有可用选项。比如我的是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Possible disks are: hd0 hd1</span><br></pre></td></tr></table></figure><p>这表示我装了两块硬盘，如果你只有一块硬盘的话，那么一定是hd0。</p><p>在 root(hd 后输入 0 ,按 Tab ，会自动补上一个 , ，现在你输入的内容成为这样：</p><p>root(hd0,</p><p>再按 Tab 键，会列出所有可用选项，我的是这样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Possible partitions are:</span><br><span class="line">Partition num: 0, Filesystem type unknown, partition type 0x7</span><br><span class="line">Partition num: 1, Filesystem type is fat, partition type 0xc</span><br><span class="line">Partition num: 2, Filesystem type is reiserfs, partition type 0x83</span><br><span class="line">Partition num: 4, Filesystem type is reiserfs, partition type 0x83</span><br><span class="line">Partition num: 5, Filesystem type unknown, partition type 0x82</span><br><span class="line">Partition num: 6, Filesystem type unknown, partition type 0x7</span><br><span class="line">Partition num: 7, Filesystem type is fat, partition type 0xc</span><br></pre></td></tr></table></figure><p>输入你的选择，比如为 1 ， Tab 一次后，结果是这样的：</p><p>root (hd1,1)</p><p>现在回车</p><p>输入命令</p><p>setup (hd0)</p><p>将grub安装在mbr中</p><p>最后，quit 命令退出GRUB</p><h3 id="Grub使用"><a class="header-anchor" href="#Grub使用">¶</a>Grub使用</h3><p>命令行</p><p>在Grub启动菜单中，您可以选择您要的选项，按下 e 键，进入到命令行模式</p><p>修改您的启动参数，完成后回车</p><p>按 b 键，Grub将以您修改后的参数引导系统。</p><h3 id="其它-2"><a class="header-anchor" href="#其它-2">¶</a>其它</h3><p>在Grub启动菜单中，按下 c 进入命令行模式</p><p>按下 d 删除当前选中的项</p><h2 id="FAQ"><a class="header-anchor" href="#FAQ">¶</a>FAQ</h2><h3 id="我的D盘到哪里去了？"><a class="header-anchor" href="#我的D盘到哪里去了？">¶</a>我的D盘到哪里去了？</h3><p>在使用Linux最初的几天里，我感到有些不安。</p><p>Windows下，我可以把系统装在C盘，软件放在D盘，音乐放在E盘……如果系统出现问题，我只要重装系统就可以了，大部分软件都可以直接使用（养成使</p><p>用绿色软件是一种好习惯：），而我辛辛苦苦收集起来的电影和音乐，我总是把它们放在一个安全的地方，以免引发失眠的严重后果。</p><p>其实Linux下硬盘也具有分区的概念，这一点和Windows没有什么不同（分区的概念是由硬盘的物理特性产生的，而不是操作系统）。不同的是，Linux可以将分区挂载到任意的目录下，而不像Windows，您的分区只能够在“我的电脑”里面：）</p><p>那么这么作有什么好处么？</p><p>我们来看看Linux和Windows下路径的表示方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Windows C:\Documents and Settings\Users\Documents\MyDocument</span><br><span class="line"></span><br><span class="line">Linux /home/User/MyDocument</span><br></pre></td></tr></table></figure><p>您一定注意到了，在Windows下面，路径中含有盘符“C:”，它通常代表您硬盘上的第一个分区。也就是说，在使用这些文件时，您需要知道它们在硬盘上</p><p>存储的相关物理细节。而在Linux下，您不需要知道这些，或者说，只要您设定好了分区挂载的目录，您就不需要再去理会什么分区。</p><p>Windows下的路径包含有分区、目录和文件三部分内容;而Linux下的路径则只有目录和文件，不包含任何分区信息，它的硬件抽象度更高！</p><p>Linux下的目录用“/”表示，这不标准吧？？</p><p>完全相反，这才是标准的体现。您只是习惯了Windows的目录符号，但是那并不意味着它是标准的。</p><p>看看Winodws下，各种位置、路径的表示方法：</p><p><a href="http://www.ubuntu.org.cn" target="_blank" rel="noopener">http://www.ubuntu.org.cn</a></p><p><a href="ftp://192.168.0.1" target="_blank" rel="noopener">ftp://192.168.0.1</a></p><p>c:\Windows\</p><p>file:///C:/Windows/</p><p>\127.0.0.1$C</p><h3 id="操作系统是一种非常精密的高科技产品，怎么可能如此混乱！！！他们是怎么作到的？？？"><a class="header-anchor" href="#操作系统是一种非常精密的高科技产品，怎么可能如此混乱！！！他们是怎么作到的？？？">¶</a>操作系统是一种非常精密的高科技产品，怎么可能如此混乱！！！他们是怎么作到的？？？</h3><p>Linux下的病毒少，是因为Linux的使用者少，骇客显然不愿意浪费气力去攻击没有人使用的操作系统。</p><p>您可能已经知道了，互联网上用作重要用途的服务器，其中很大一部分是Linux系统，另外的一部分是Unix系统：）如果骇客能够搞掉Linux系统的话，那么整个互联网就会陷于瘫痪！效果似乎更好一些。</p><p>当然了，您一定会想：骇客也是人，他们也喜欢上网，兔子还不吃窝边草呢……兔子那么笨，连乌龟都跑不过……骇客们可比兔子要聪明的多了！</p><p>是的，我承认这一点……不过他们也不一定非得把互联网干掉。很多骇客作梦都想入侵美国军方的服务器，美军服务器中的绝密数据，只要1kb，应该就可以买一台顶级的个人电脑了：）</p><p>如果可以的话，骇客为什么不去入侵美军的服务器，而要入侵您的电脑呢？</p><p>这是一个很有意思的观点，与之相映成趣，另一种论调也使人侧目：Windows服务器占到了服务器操作系统xx%的份额。</p><p>或许这个现象可以用80：20法则来解释：）</p><p>占服务器总数80%的Windows提供了服务总量的20%！</p><p>请您务必注意，这只是举一个例子，Windows服务器可能永远也不会占到服务器总数的80%！它提供的服务，以我个人的角度，我不认为可以达到20%，而且永远不会有那一天。</p><h3 id="软件安装繁琐"><a class="header-anchor" href="#软件安装繁琐">¶</a>软件安装繁琐</h3><p>或许您已经看过一些关于Linux软件安装的文章，但是您也不要忽略，此类文章的数量，是不能够和同类Windows文章相比的。</p><p>当然，使用源码包安装软件确实有点麻烦，但却不一定比Windows下的某些软件复杂。特别要提到，Ubuntu的包管理系统，为您提供了一种高效快捷的</p><p>软件管理方式，您只要知道您需要什么软件就可以了，甚至不需要关心它存放在网络上的哪一台服务器中，而且绝大多数的软件都可以使用这种方式来安装。</p><p>详情请参阅 APT</p><p>如果您有如下需求，您也可以尝试以源码的形式安装软件：</p><p>您需要某些软件的技术预览版本</p><p>您想测试您的机器的运算能力</p><p>您找不到一种比安装软件更好的方式来消磨时间 | （试图通过编译源码安装来大幅提高系统性能，其结果很可能会让您失望）</p><h3 id="源码保密性不强，存在安全隐患"><a class="header-anchor" href="#源码保密性不强，存在安全隐患">¶</a>源码保密性不强，存在安全隐患</h3><p>既然Linux下软件都开放源代码，那么会不会造成一些安全隐患呢？比如说一名骇客会发现其中的漏洞，并利用它？</p><p>事实刚好相反，一个软件，即便它不开放源码，骇客一样可以找到其中的漏洞，雷蒙德的软件巨头就是最好的佐证。就像一把锁，无论如何坚固，它总是能被撬开！它的作用无外乎“聊备一格，以防君子”：）</p><p>而这把锁，防住的恰恰是能够改进它的工程师！工程师知道了它的漏洞，却不能够去改进它;骇客知道了它的漏洞，却可以利用它……这把锁正是封闭源码！</p><p>这岂不是不妙？</p><h3 id="软件功能不够强"><a class="header-anchor" href="#软件功能不够强">¶</a>软件功能不够强</h3><p>虽然您很愿意使用Linux系统，但是它的软件并不能使您满意，甚至使您多愁善感的心灵又蒙上了一层阴影，“长太息以掩涕……”</p><p>首先您别忘了，《泰坦尼克》的特效就是在Linux系统下完成的，连业界巨头SGI都在向Linux迁移（尽管SGI的IRIX本来就是一种Unix系统）。如果您不知道SoftImage，那么Maya您总听说过吧？它最初就是多平台的。</p><p>对于电影特效处理时需要的高吞吐量的数据（以TB计）和运算能力，Windows系统恐怕连崩溃的机会都没有=_=#(最新统计资料显示，Top500计算机中，使用Linux的占到73.4%，包括最快的前两名。其中Linux系统367部，Unix系统98部，混合操作系统24部，AppleMacOS系统5部,BSD系统4部，Windows系统，2部）类似于大气模拟、基因解码等等真正的科学运算……Windows……前几天我还在verycd.com上看到一套欧洲某天文台的天文学软件，只有Linux版！</p><p>当然了，Linux下功能强大的软件大多是命令行的，图形界面的程序只能视觉上强大，外强中干！建议您多使用man这个命令来查询各类软件的使用方法，它排版美观，格式工整，语法简明，意韵流畅，实在是学习英语难得的教材。</p><h3 id="界面不友好"><a class="header-anchor" href="#界面不友好">¶</a>界面不友好</h3><p>如果您指的是系统的美观程度。Gnome默认效果我认为与Windows处于同一水平线，而KDE的效果就要略好一点，很多高手用FVWM可以作出让人眼花瞭乱的效果来……而Novell的XGL，更是可以用“惊艳”来形容。</p><p>如果您指的是操作，这属于“易于上手难于精通”与“难于上手易于精通”两种理念的冲撞。</p><p>当然了，我指的精通主要针对效率而言。如果您经常玩Blizzard出品的游戏，您对于“易于上手难于精通”这种理念或许相当了解，甚至非常欣赏。</p><p>不过这一理念只适用于竞技游戏！竞技游戏要球能够吸引大量的玩家，所以要易于上手。但是竞技游戏是为竞技而生的，所以不可能人人是高手 ────事实上高手只是一小部分人！</p><p>而操作系统是给人们来用的，最好人人都成为高手，所以易于精通是很重要的……当然最好也能够易于上手。但是考虑到效率的问题，这很难解决……</p><h3 id="Linux怎么占用这么多内存？"><a class="header-anchor" href="#Linux怎么占用这么多内存？">¶</a>Linux怎么占用这么多内存？</h3><p>Linux会最大程度的利用物理内存，避免使用交换空间;而不是尽量的回收内存，使用页面文件。</p><p>又因为Linux系统的内存管理非常优秀，程序退出时可以高效的回收内存，所以更加没有必要在程序运行时就回收内存！</p><p>因此，Linux系统表面看来内存开销很大，实际上系统运行是很稳定的──Linux不会时而流畅，时而瘫痪。事实上，在正常情况下，它运行是非常流畅的。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ref:&lt;a href=&quot;http://www.cnblogs.com/dutlei/archive/2012/11/20/2778327.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ubuntu完全教程，让你成为Ubuntu高手！&lt;/a&gt;
todo整理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Ubuntu的发音&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Ubuntu的发音&quot;&gt;¶&lt;/a&gt;Ubuntu的发音&lt;/h2&gt;
&lt;p&gt;Ubuntu，源于非洲祖鲁人和科萨人的语言，发作 oo-boon-too 的音。了解发音是有意义的，您不是第一个为此困惑的人，当然，也不会是最后一个：）&lt;/p&gt;
&lt;p&gt;大多数的美国人读 ubuntu 时，将 u 作为元音发音，类似单词 who 或者 boo ，重音在第二个音节即 u&#39;buntu ，oo-boon-too 。&lt;/p&gt;
&lt;p&gt;如果您喜欢撒哈拉，喜欢它令人窒息的温柔、梦幻般的寂寥还有张扬恣肆的旷远，您大可在第一个 u，后面带些嗡嗡声： oom-boon-too。&lt;/p&gt;
&lt;p&gt;Ubuntu的中文发音大约为： 乌班图&lt;/p&gt;
&lt;h3 id=&quot;Ubuntu的涵义&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Ubuntu的涵义&quot;&gt;¶&lt;/a&gt;Ubuntu的涵义&lt;/h3&gt;
&lt;p&gt;Ubuntu这个单词源自非洲，意谓“班图精神”────谁都不是一座孤岛，自成一体。每个人都包孕于人类，因他人存在而存在，因他人幸福而幸福。&lt;/p&gt;
&lt;h3 id=&quot;Ubuntu当前版本&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Ubuntu当前版本&quot;&gt;¶&lt;/a&gt;Ubuntu当前版本&lt;/h3&gt;
&lt;p&gt;Ubuntu Linux v6.06 LTS (Dapper Drake)&lt;/p&gt;
&lt;p&gt;LTS：Long Term Support&lt;/p&gt;
&lt;p&gt;Dapper Drake：当前版本的开发代号&lt;/p&gt;
&lt;h3 id=&quot;Ubuntu的特点&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Ubuntu的特点&quot;&gt;¶&lt;/a&gt;Ubuntu的特点&lt;/h3&gt;
&lt;p&gt;Ubuntu 完全基于 Linux 操作系统， 可以免费得到社区及专业机构的支持。庞大的社区是它成长的沃土，请向这片动人的热忱敞开心扉。&lt;/p&gt;
&lt;p&gt;Ubuntu 社区恪守 Ubuntu 理念：自由！软件应是自由的，应尊重人类的自由意志，它与人类之间不应有任何隔膜。本地语种，功能限制，自主改进的权利……都不应成为使用的障碍或负担。&lt;/p&gt;
&lt;p&gt;自由，让 Ubuntu 与传统的私有软件从根本上不同: 免费不能用来遮羞，您有权修正它，直到满意为止。&lt;/p&gt;
&lt;p&gt;Ubuntu 适合桌面和服务器。当前 Ubuntu 发布版支持 PC (Intel x86), 64-bit PC (AMD64) 和 PowerPC (Apple iBook 和 Powerbook, G4 和 G5) 架构。&lt;/p&gt;
&lt;p&gt;Ubuntu 包涵了超过 16,000 种软件， 核心的桌面系统却只有一张光盘， Ubuntu 覆盖了所有的桌面应用程序,&lt;/p&gt;
&lt;p&gt;从文字处理，电子表格到 web 服务器和开发设计环境一应俱全。 详情查看 Ubuntu 桌面 和 Ubuntu 服务器的介绍。&lt;/p&gt;
&lt;h3 id=&quot;Ubuntu相对其它Linux发行版的主要特点&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#Ubuntu相对其它Linux发行版的主要特点&quot;&gt;¶&lt;/a&gt;Ubuntu相对其它Linux发行版的主要特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基于Debian/Linux，使用 APT 包管理系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相对于Fedora Code： APT 包管理系统优雅地解决了依赖问题，并且可以从容的在线安装升级&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相对于Debian：软件更新积极，而Debian较保守。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相对于Gentoo：基本无需编译，省力、省时、省心。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://talengu.github.io/public/categories/Linux/"/>
    
    
      <category term="技巧" scheme="https://talengu.github.io/public/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="Ubuntu" scheme="https://talengu.github.io/public/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>爱立信的百年沉浮</title>
    <link href="https://talengu.github.io/public/2022/04/01/history_ericsson/"/>
    <id>https://talengu.github.io/public/2022/04/01/history_ericsson/</id>
    <published>2022-04-01T12:39:04.000Z</published>
    <updated>2022-04-01T12:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章来源：<br>鲜枣课堂（ID：xzclasscom）<br><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTY1MjY0MQ==&amp;mid=2650814278&amp;idx=1&amp;sn=26083fed8d8dd76340e063fd42a59dea" target="_blank" rel="noopener">原文</a></p></blockquote><p>19 世纪中叶，电报业务在欧洲大陆逐渐开始普及。</p><p>1853 年，北欧小国瑞典动用 “海盗基金”（不是海盗的钱，是政府用来打海盗的钱），架设了自己的第一条电报线路，从首都斯德哥尔摩到乌普萨拉。</p><p>为了确保负责这条线路的正常运营，瑞典政府还成立了自己的第一家电报公司，名字叫 Televerket。</p><p>当时，Televerket 公司急需大量的电报硬件设备。于是，乌普萨拉电报局的局长，<strong>安东 · 亨里克 · 奥勒</strong>（Anton Henric Öller），决定创办一家公司，为 Televerket 生产、修理和改进电报机。</p><p>不久后，这家电气设备维修公司正式成立，名字叫奥勒公司（Öller &amp; Co）。</p><p><img src="/public/2022/04/01/history_ericsson/640.png" alt></p><center><div>安东 · 亨里克 · 奥勒，瑞典电信业的先驱</div></center><p>奥勒公司名义上是一家公司，但实际上就是一个手工作坊，规模很小，只能靠 Televerket 公司的资助才能维持生存。</p><p>在奥勒公司的员工中，有一个勤奋的小伙子，当时专门负责维修电报设备以及其它机械设备。他的名字，叫做<strong>拉什 · 玛格纳斯 · 爱立信</strong>（Lars Magnus Ericsson）。</p><p><img src="/public/2022/04/01/history_ericsson/640-16487839499382.png" alt></p><center><div> 拉什 · 玛格纳斯 · 爱立信</div></center><a id="more"></a><p>拉什 · 爱立信 1846 年 5 月 5 日出生于瑞典中部瓦姆兰省的一个小农场里。他的家庭条件贫困，自己在 9 个兄弟姐妹中排行第六。</p><p>11 岁时，由于父亲病逝，他不得不外出工作，养家糊口。这期间，他当过矿工，修过铁路，还在铁匠铺做了很长时间的学徒。</p><p>1867 年，拉什 · 爱立信终于攒够了路费，来到他梦寐以求的瑞典首都——斯德哥尔摩。经过一周的试用后，他成功加入了奥勒公司，成为一名修理工。</p><p>尽管这份工作的工资微薄，拉什 · 爱立信仍然感到十分满足。他后来回忆说：“（这份工作）足以满足我的需求，让我庆幸地看到生活比以往任何时候都更加光明，我心中第一次感受到了生活的快乐。”</p><p>工作之余，拉什 · 爱立信努力学习数学、材料技术、工程制图，以及德语和英语。在公司老板奥勒先生的推荐下，1873 年和 1875 年，拉什 · 爱立信先后两次获得瑞典政府的官方资助，前往德国和瑞士进行游学和实习。</p><p>这期间，拉什 · 爱立信来到了德国柏林的西门子公司（Siemens &amp; Halske），学到了很多电报工程技术知识，也接触到一些先进的机床设备。</p><p><img src="/public/2022/04/01/history_ericsson/640-16487839554904.jpeg" alt></p><center><div> 拉什 · 爱立信在西门子公司时绘制的图纸，相当精妙</div></center><p>游学结束之后，拉什 · 爱立信返回瑞典。此时的他，已经具备了非常丰富的专业知识，有能力开创属于自己的事业。</p><p>1876 年 4 月，拉什 · 爱立信拒绝了奥勒公司升职加薪的提议，在斯德哥尔摩皇后街 15 号一个普通建筑的小厨房里，创建了 <strong>L.M.Ericsson</strong> 公司。</p><p><img src="/public/2022/04/01/history_ericsson/640-16487839586856.png" alt></p><center><div> 爱立信公司最初的商标</div></center><center><div>MEK.WERKSTAD 的意思是 “机械作坊”</div></center><center><div> STOCKHOLM 就是瑞典首都 “斯德哥尔摩”</div></center><p>当时的 L.M.Ericsson 公司，其实就是一个作坊修理铺。启动资金 1000 克朗，是借来的。小厨房不到 13 平方米，是租来的。仅有的一套工作设备，是一架脚踏式机床。</p><p>公司的全部员工，除了拉什 · 爱立信本人之外，只有一名临时雇佣的 12 岁男孩。</p><p>不久后，拉什 · 爱立信在奥勒公司的前同事卡尔 · 乔汗 · 安德森（Carl Johan Andersson）加入了他的新公司，成为合伙人。</p><p>公司创立之后，主要业务是维修各种机械设备、电报机以及电器仪表。他们接到的第一单生意，是维修用于火警的一只机械指示器，收费 2 克朗。</p><p>没过多久，拉什 · 爱立信凭借自己的才华和经验，制造出了一些不错的产品，例如用于铁路系统的拨号电报仪器，以及小型社区的防火电报系统。</p><p>这些产品，逐渐赢得了铁路、消防等部门用户的认可，带来了源源不断的订单。</p><h2 id="█-涉足电话业务，规模迅速扩张"><a class="header-anchor" href="#█-涉足电话业务，规模迅速扩张">¶</a>█  涉足电话业务，规模迅速扩张</h2><p>爱立信公司成立的同一年（1876 年），美国的亚历山大 · 贝尔申请并获得了电话的发明专利，从而将人类带入了电话时代。</p><p>1877 年，电话被引入瑞典。拉什 · 爱立信第一时间去买了一对，并进行了拆解研究。</p><p>后来，很多用户将损坏的电话机送到拉什 · 爱立信这里维修，使得他对电话机内部结构有了更深入的了解。</p><p>凭借敏锐的商业嗅觉，拉什 · 爱立信意识到电话背后的巨大商机。于是，他决定研制自己的电话机型号。</p><p>1878 年底，拉什 · 爱立信在妻子<strong>希尔达 · 爱立信</strong>（Hilda Ericsson）的帮助下，成功研制出第一台电话机产品。这款产品性能出色，价格远低于对手，受到了用户的欢迎。</p><p><img src="/public/2022/04/01/history_ericsson/640-16487981603198.jpeg" alt></p><center><div>拉什 · 爱立信的妻子（左），对他帮助极大</div></center><p>后来，拉什 · 爱立信又推出了自己的墙式电话机，再次获得畅销。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879816421310.png" alt></p><center><div>爱立信的墙式电话机</div></center><p>1880 年，拉什 · 爱立信和他的公司迎来了一次重大的机遇。</p><p>当时，美国贝尔公司在斯德哥尔摩、哥德堡、马尔默、松兹瓦尔和索德港建造了一个电话网络。如果任由贝尔公司发展下去，他们将垄断整个瑞典的电话市场。</p><p>于是，拉什 · 爱立信决定与贝尔公司进行正面竞争。不久后，L.M.Ericsson 公司成功击败对手，先后中标了耶夫勒市和挪威卑尔根市的本地电话系统合同。</p><p>拉什 · 爱立信的胜利，极大地增强了瑞典人民的信心。事实证明，瑞典的工艺和技术，完全可以与世界最领先的公司相媲美。</p><p>1883 年，拉什 · 爱立信遇到了自己创业早期最重要的合作伙伴兼客户，<strong>亨里克 · 托勒 · 塞德格伦</strong>（Henrik Thore Cedergren）。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879816726712.jpeg" alt></p><center><div>亨里克 · 托勒 · 塞德格伦</div></center><p>亨里克 · 塞德格伦原本是一个珠宝商人。作为瑞典最早的电话机用户之一，他非常看好电话的发展潜力。但是，他认为贝尔公司的收费太过昂贵，阻碍了电话业务的普及。</p><p>于是，1883 年 2 月，他成立了一家名为 Stockholms Allmänna Telefonaktiebolag（斯德哥尔摩公共电话公司，以下简称 SAT 公司）的独立瑞典电话公司，旨在为公众提供廉价的电话连接服务。</p><p>起初，拉什 · 爱立信并不看好亨里克 · 塞德格伦和他的公司，因为他们完全没有电话网络方面的经验。后来，亨里克 · 塞德格伦凭借自己的热情，打动了拉什 · 爱立信，说服他支持自己的事业。</p><p>1883 年，L.M.Ericsson 公司和 SAT 公司就电话供应签订了一项供货合同，全面负责 SAT 的电话及相关设备。那一年，L.M.Ericsson 公司完成了 SAT 订购的 1000 部电话机和 22 套电话交换设备的交付。</p><p>此后，L.M.Ericsson 公司进入了发展的快车道。</p><p>1884 年，公司建造完成了自己的第一家大规模工厂。1885 年，生产了第一部手持送受话筒。1887 年，签订了当时的最大的合同，为 SAT 在斯德哥尔摩开办的电话局提供设备。这个电话局，是当时欧洲最大的电话局。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879816988314.png" alt></p><center><div>当时的 SAT 公司电话塔</div></center><p>1890 年，L.M.Ericsson 公司的员工人数上升到 153 人。1896 年，L.M.Ericsson 公司改制为有限责任公司，股份资本为 100 万克朗。这一年的 6 月 1 日，爱立信公司累计生产电话超过十万部。</p><p>此后的爱立信，开始全面开拓海外市场。</p><p>1897 年，爱立信在俄罗斯圣彼得堡开办工厂，组装电话机。1902 年，爱立信在纽约开设办事处。1903 年，爱立信与英国国家电话公司联合组建英国爱立信制造有限公司。</p><p>后来，爱立信陆续进入了挪威、丹麦、芬兰、澳大利亚、新西兰、南非、墨西哥、法国、匈牙利、奥地利等国家，成为一家全球性的电信设备公司。</p><p>1900 年，正当爱立信公司高速发展的时候，创始人拉什 · 爱立信决定辞去总经理职务。次年，他又辞任董事长，并逐步出售他持有的爱立信公司的股票（1905 年全部卖完）。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879817266816.png" alt></p><center><div>拉什 · 爱立信</div></center><p>1926 年 12 月 17 日，拉什 · 爱立信逝世，安葬在距离斯德哥尔摩不远的博基尔卡。按照他的遗嘱，墓地没有立石碑。</p><p>1946 年，拉什 · 爱立信百年诞辰之际，他的家乡为他立了一座石碑，上面刻着——<strong>“瑞典电话工业见证了他的成就”</strong>。</p><h2 id="█-遭遇股权危机，险些沦落敌手"><a class="header-anchor" href="#█-遭遇股权危机，险些沦落敌手">¶</a>█  遭遇股权危机，险些沦落敌手</h2><p>1914 年，第一次世界大战爆发，爱立信的海外市场受到重创。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879817662718.png" alt></p><center><div>瑞典地处波罗的海，战争导致出海口被封，爱立信的设备根本运不出去。</div></center><p>1917 年，俄国十月革命爆发，新成立的布尔什维克政府将爱立信在俄国的工厂和业务全部国有化，夺取了价值约 2000 万瑞典克朗的资产，使得爱立信公司雪上加霜。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879818274520.jpeg" alt></p><center><div>被夺走的工厂，后来被改名为 “红色黎明”</div></center><p>1918 年，为了度过经营危机，L.M.Ericsson 与 SAT 公司正式合并，成为 <strong>Allmänna Telefonaktiebolaget LM Ericsson</strong> 公司。</p><p>合并之后的新公司，得到了瑞典政府支付的约 5000 万克朗电话网络运营费用，大大缓解了经营压力。</p><p>不久后，新公司迎来了一个更大的危机，关于<strong>控制权</strong>的危机。</p><p>当时的情况是这样的：1909 年，SAT 公司创始人亨里克 · 塞德格伦去世时，将公司所有权转移给了一个基金会和他的家人。后来，SAT 公司与 L.M.Ericsson 公司合并，基金会和亨里克 · 塞德格伦的家人继而拥有了新公司的大部分控制权。</p><p>再后来，一战期间的巨额经营亏损，使得他们面临巨大的经济压力，于是，他们将爱立信公司的股权卖给了<strong>卡尔 · 弗雷德里克 · 温克兰茨</strong>（Karl Henrik Wincrantz）。</p><p>温克兰茨是谁？温克兰茨原本是 SAT 公司旗下斯德哥尔摩电信的总裁，1925 年，他被任命为爱立信公司的总裁。</p><p>为了巩固自己的权力，温克兰茨一直在努力增加自己的持股比例。</p><p>1928 年，在温克兰茨的推动下，爱立信公司开始发行 “A” 和“B”股。其中，“B”股只有 “A” 股千分之一的投票权。</p><p>温克兰茨希望通过持有少数 “A” 股来控制公司。同时，他主导发行了大量的 “B” 股，筹措公司发展所需的资金。这一时期，公司更名为 Telefon AB LM Ericsson。</p><p>温克兰茨增持股票肯定需要资金，但自己并没有这么多资金。于是，他找到了国际金融家<strong>伊瓦尔 · 克鲁格</strong>（Ivar Kreuger）。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879818656822.jpeg" alt></p><center><div>伊瓦尔 · 克鲁格</div></center><p>伊瓦尔 · 克鲁格帮助温克兰茨控制了爱立信公司。后来，克鲁格与温克兰茨闹翻，干脆赶走了温克兰茨，委任了自己的亲信担任爱立信公司的总裁。</p><p>克鲁格是一个做火柴生意起家的商人，非常精明，也非常不靠谱。为了从资本市场骗取资金，他长期谎报自己的资产规模和旗下企业的盈利能力。</p><p>1931 年，经济大萧条愈演愈烈，克鲁格资金断链。为了偿还债务，他找到了 ITT 的主席，索申尼斯 · 奔尼（Sosthenes Behn），把自己的爱立信股票以 1100 万美元的价格出售给 ITT。</p><p>ITT 是什么公司？美国国际电话电报公司，爱立信最大的竞争对手。这一举动，相当于把爱立信的控制权拱手交给了死对头。</p><p>1932 年 3 月，克鲁格自杀身亡。此时，ITT 拥有爱立信三分之一的股份。</p><p>事情被揭露之后，瑞典举国哗然。自己的民族企业，竟然被对手完全控制，这是无法接受的事情。</p><p>不过好在瑞典法律规定，禁止外国利益在瑞典公司中行使多数表决权，导致 ITT 公司没有办法完全控制爱立信公司。</p><p>后来，瑞典三大银行——斯堪的纳维亚银行、斯德哥尔摩恩斯基尔达银行和瑞典商业银行——迅速采取行动，拯救爱立信。他们与 ITT 进行谈判，逐渐增加了对爱立信公司的控股，夺回了控制权。</p><p>当时，负责牵头拯救行动的是瓦伦堡家族的<strong>小马库斯 · 瓦伦堡</strong>（Marcus Wallenberg Jr），斯德哥尔摩恩斯基尔达银行就属于他的瓦伦堡家族。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879819009724.jpeg" alt></p><center><div>小马库斯 · 瓦伦堡</div></center><p>后来，经过数十年的漫长周旋，一直到 1960 年，小马库斯 · 瓦伦堡才完全收回了 ITT 所持有的爱立信公司股份。爱立信公司也由此彻底摆脱了伊瓦尔 · 克鲁格事件的阴影。</p><h2 id="█-专注技术研发，成功反超对手"><a class="header-anchor" href="#█-专注技术研发，成功反超对手">¶</a>█  专注技术研发，成功反超对手</h2><p>二战时期，爱立信的业务再度因为出海口问题遭受重创。它的很多国外资产都被战争摧毁，销售额也大幅下降。</p><p>这期间，爱立信不得不临时转行，进行军工生产，为军队制造电话、飞机仪表、机枪和弹药等，维持生存。</p><p>二战结束后，全球电话市场需求激增，爱立信公司的业务也逐渐开始复苏。</p><p>1960 年，爱立信开始业务聚焦，砍掉了电信业务之外的无关业务，专注通信设备的研发。</p><p>当时，爱立信启动了一种名为 AKE 的商用电子交换系统的研发。到了 60 年代末，爱立信意识到，AKE 系统已经跟不上时代，它的速度太慢而且价格过于昂贵。</p><p>因为技术和产品的落后，爱立信在市场竞争中屡次输给自己的对手——ITT、GTE 和西门子等。</p><p>1969 年底，爱立信在一个大额合同上再次输给了 ITT。这次失败，迫使爱立信管理层下定决心，与瑞典电报公司 Televerket 联手，共同开发有竞争力的新型产品。</p><p>于是，1970 年 4 月，爱立信与 Televerket 正式签署协议，成立一家名为 <strong>Ellemtel Utvecklings AB</strong> 的联合研发公司。该公司的主要任务，就是开发一种先进的自动化数字电话交换系统，名为 <strong>AX 系统</strong>。</p><p>1976 年，经过不懈努力，Ellemtel 公司成功研发出世界上首台全数字交换机——<strong>AXE 交换机</strong>。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879819313226.png" alt></p><center><div>AXE 是爱立信历史上最重要和最成功的产品</div></center><p>AXE 是一个划时代的产品。它采用模块化的软硬件设计方式，易于制造和测试，也易于维修。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879819539828.png" alt></p><center><div>AXE 设备</div></center><p>因为技术上非常领先，在推出的两年时间里，AXE 几乎赢得了所有主要的国际电信合同。领导 AXE 开发团队的年轻工程师 Björn Svedberg，1977 年直接被任命为公司总裁。</p><p>AXE 成功商用后，Ellemtel 完成了自己的使命，逐步将研究成果移交给了爱立信和 Televerket。后来，Televerket 将自己的 Ellemtel 股份出售给爱立信，Ellemtel 也因此被完全整合到爱立信中。</p><h2 id="█-移动通信浪潮，百年名企沉浮"><a class="header-anchor" href="#█-移动通信浪潮，百年名企沉浮">¶</a>█ 移动通信浪潮，百年名企沉浮</h2><p>20 世纪 80 年代初，爱立信的数字交换技术继续在行业保持领先。</p><p>这一时期，因为沉迷于自己的 AXE 系统，爱立信错过了移动通信技术崛起的第一波浪潮。等到对手纷纷有所成就后，爱立信公司才反应过来，赶紧调整自身的战略方向，转战蜂窝移动通信市场。</p><p>1981 年 9 月，爱立信在沙特阿拉伯建设完成了世界第一个投入商业运营的 NMT 网络（比瑞典自己还早了 1 个月）。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879819790330.jpeg" alt></p><center><div>项目签约现场</div></center><p>1988 年，爱立信决定继续聚焦核心业务。这一年，它以 2.17 亿美元的价格，将自己的计算机和终端业务出售给了芬兰公司诺基亚。</p><p>与此同时，爱立信最主要的竞争对手，美国 AT&amp;T 公司，因为垄断被美国政府强行拆分。爱立信从中受益，很快占据了全球 40% 的移动系统市场。</p><p>后来，到了 2G 时代。欧洲基于 NMT 推出了 GSM，爱立信也及时地推出了自己的产品。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879820007232.png" alt></p><center><div>爱立信的 2G GSM 原型机</div></center><p>这期间，爱立信保持了连续 10 年<strong>年均 35% 以上</strong>的惊人增长，成为了世界上最大的电话及蜂窝移动通信设备商之一。</p><p>1995 年，爱立信的收入达到 76.1 亿瑞典克朗。1996 年，爱立信全球研发工程师达到 18000 名。1997 年，爱立信在世界移动市场上的份额达到 40%，拥有大约 5400 万用户。</p><p>1998 年，<strong>斯温 · 克里斯特 · 尼尔森</strong>（Sven-Christer Nilsson）当选为爱立信公司的 CEO。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879820245334.png" alt></p><center><div>斯温 · 克里斯特 · 尼尔森</div></center><p>在他的领导下，爱立信进行了重大的组织架构调整。</p><p>他将公司业务分为三个板块，分别是网络运营商部门、消费品部门（包括手机业务）和企业解决方案部门。（是不是有点眼熟？）</p><p>除了重组之外，尼尔森还宣布了 11000 人的裁员计划。</p><p>1999 年，爱立信与高通公司解决了为期两年的 CDMA 技术专利官司。作为和解的一部分，爱立信收购了高通的无线基础设施业务。</p><p>这一年，爱立信的手机业务在与诺基亚的竞争中落后，导致市场份额从 15.1% 下降到 10.5%。当时，爱立信 70% 的收入来自基础设施销售，而 21% 来自手机销售。</p><p>1999 年 7 月，因为业务重组失败，尼尔森被迫辞职。</p><p>进入 21 世纪，爱立信的霉运没有结束。2000 年，因为产品质量问题以及工厂发生的火灾意外，爱立信亏损 240 亿瑞典克朗。</p><p>2001 年，爱立信宣布将其手机的生产外包给<strong>伟创力</strong>国际有限公司，自己则集中力量于手机的技术研发、设计以及市场推广。同时，爱立信大幅裁剪了消费品部门的员工人数。</p><p>同年 10 月，爱立信与日本索尼公司分别出资 50%，组建了<strong>索尼爱立信移动通信公司</strong>，专门生产手机产品。对于这家公司，相信大家都比较熟悉。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879820498536.jpeg" alt></p><p>2002 年，在全球金融危机的持续影响下，爱立信再次遭受巨额亏损。</p><p>面对亏损，爱立信一方面推出了降低运营成本、提高效率的 “成本控制计划”；另一方面，调整市场战略，将公司的核心业务做了全面的优化与整合，出售了一些非核心业务。</p><p>2002 年 6 月，爱立信以 4 亿美元的价格，将自己的微电子部门卖给了<strong>英飞凌</strong>科技股份公司（当时是西门子的子公司）。</p><p>2003 年，随着全球通信产业回暖，加上之前的一系列战略调整显露成效，爱立信宣告结束亏损，恢复盈利。</p><p>复苏后的爱立信，在全球 3G 市场上表现突出，拥有 40% 的 3G WCDMA 市场份额，是当之无愧的全球第一设备商。</p><h2 id="█-遭遇中国对手，迎来严峻挑战"><a class="header-anchor" href="#█-遭遇中国对手，迎来严峻挑战">¶</a>█ 遭遇中国对手，迎来严峻挑战</h2><p>爱立信与中国的历史渊源已超过百年。早在 1892 年，爱立信就接到了来自中国的订单（2000 个电话机），并为中国供货。1906 年，中国代表团还前往斯德哥尔摩，参观了爱立信总部。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879820869638.png" alt></p><center><div>当时的会面场景</div></center><p>一个多世纪以来，爱立信在中国电信发展史上贡献了多个 “第一”。</p><p>中国第一部人工交换机（1900 年）和第一部自动交换机（1924 年），就是来自爱立信。1987 年中国第一套移动电话系统在广州开通，设备也是来自爱立信。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879821103340.jpeg" alt></p><center><div>中国第一套移动电话系统</div></center><p><img src="/public/2022/04/01/history_ericsson/640-164879821453442.png" alt></p><center><div>改革开放后，国内也引进了 AXE（1985 年照片）</div></center><p>爱立信一直非常重视中国市场，不仅成立了合资公司和独资公司，还在中国设立了爱立信学院和研究院。</p><p>不过，拉什 · 爱立信当年卖电话到这个国家的时候，一定不会想到，一百多年后，这个国家会走出来两个名不见经传的小公司，把他开创的通信霸业给搅得鸡犬不宁。</p><p>这两个小公司，当然就是华为和中兴。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879821693844.jpeg" alt></p><p>在这两家公司的挑战和冲击下，爱立信公司在 21 世纪的市场份额不断下滑，CEO 频繁更换。那些年，伴随爱立信的坏消息总是一个接着一个，不是出售业务，就是裁员。</p><p>2013 年，华为全年销售收入正式超过爱立信，爱立信被迫将全球第一的位置拱手相让。</p><p>2016 年，爱立信计划关闭瑞典境内的所有工厂，结束在瑞典制造产品 140 年的历史。</p><p>2017 年，爱立信净亏损 44.76 亿美元，全年裁员达到 1.7 万人。</p><h2 id="█-外部环境变化，业绩迅速复苏"><a class="header-anchor" href="#█-外部环境变化，业绩迅速复苏">¶</a>█ 外部环境变化，业绩迅速复苏</h2><p>2018 年之后，爱立信的形势有了明显的好转，原因包括多个方面。</p><p>首先，就是 5G 市场增长带来的商业机会。</p><p>爱立信非常重视 5G，投入了大量的资源进行研发。2014 年，爱立信就发布了全球首台 5G 移动终端原型。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879822068446.jpeg" alt></p><p>2016 年，爱立信发布了一款号称 “全球首个 5G NR 无线设备” 的 5G 基站——AIR 6468。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879822338648.jpeg" alt></p><p>2017 年 2 月，爱立信推出了自己的 5G 平台。2018 年 1 月，爱立信发布了首个 5G 小基站 “5G Radio Dot”，吸引了行业的广泛关注。</p><p><img src="/public/2022/04/01/history_ericsson/640-164879822621150.png" alt></p><center><div>5G NR DOT 点系统</div></center><p>除了 5G 之外，另一个帮助爱立信业绩复苏的主要原因，是微妙变化的外部环境。</p><p>正如大家所知道的，中美贸易摩擦，美国对中国通信设备商进行强力打压，多个国家宣布 “禁用” 华为和中兴。于是，欧美国家的设备商就有了难得的市场机会。</p><p>综合种种因素，爱立信的业绩迅速转好，扭亏为盈，股价攀升。</p><p>2020 年，爱立信全年净销售额达到 2324 亿瑞典克朗（约合 278 亿美元），同比上涨 2%；净利润 176 亿瑞典克郎（约合 21 亿美元），相比 2019 年，翻了近十倍。</p><h2 id="█-结语"><a class="header-anchor" href="#█-结语">¶</a>█  结语</h2><p>爱立信，是通信行业历史最悠久的企业之一（准确来说，是 145 年的历史）。</p><p>在很长的一段时间里，它都是世界排名第一的通信设备制造商。爱立信的很多技术创新，改变了通信行业的发展走向。很多经典的通信产品和知名的通信项目，都是出于这家企业。</p><p>在一百年的发展过程中，爱立信有过辉煌，也有过挫折，但是它仍然屹立不倒，在世界通信第一阵营中牢牢占据自己的位置。这充分说明，这家企业有着自己的技术积累和文化底蕴，有属于自己的 “韧性”。</p><p>如今，5G 的竞争还在继续，百年老店爱立信的奋斗之路也在继续。面对变幻莫测的市场环境，爱立信究竟会走向何方呢？它还会续写另一段百年辉煌吗？</p><p>（全文完）</p><p><strong>参考文献：</strong></p><p>1、<a href="https://www.ericsson.com/en/about-us/history/company" target="_blank" rel="noopener">https://www.ericsson.com/en/about-us/history/company</a></p><p>2、<a href="https://en.wikipedia.org/wiki/Ericsson" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Ericsson</a></p><p>3、《改变世界》，2009 年出版</p><p>4、<a href="https://ethw.org/Lars_Magnus_Ericsson" target="_blank" rel="noopener">https://ethw.org/Lars_Magnus_Ericsson</a></p><p>5、<a href="https://www.company-histories.com/Telefonaktiebolaget-LM-Ericsson-Company-History.html" target="_blank" rel="noopener">https://www.company-histories.com/Telefonaktiebolaget-LM-Ericsson-Company-History.html</a></p><p><img src="/public/2022/04/01/history_ericsson/640-164879825241752.gif" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;文章来源：&lt;br&gt;
鲜枣课堂（ID：xzclasscom）&lt;br&gt;
&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NTY1MjY0MQ==&amp;amp;mid=2650814278&amp;amp;idx=1&amp;amp;sn=26083fed8d8dd76340e063fd42a59dea&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;19 世纪中叶，电报业务在欧洲大陆逐渐开始普及。&lt;/p&gt;
&lt;p&gt;1853 年，北欧小国瑞典动用 “海盗基金”（不是海盗的钱，是政府用来打海盗的钱），架设了自己的第一条电报线路，从首都斯德哥尔摩到乌普萨拉。&lt;/p&gt;
&lt;p&gt;为了确保负责这条线路的正常运营，瑞典政府还成立了自己的第一家电报公司，名字叫 Televerket。&lt;/p&gt;
&lt;p&gt;当时，Televerket 公司急需大量的电报硬件设备。于是，乌普萨拉电报局的局长，&lt;strong&gt;安东 · 亨里克 · 奥勒&lt;/strong&gt;（Anton Henric Öller），决定创办一家公司，为 Televerket 生产、修理和改进电报机。&lt;/p&gt;
&lt;p&gt;不久后，这家电气设备维修公司正式成立，名字叫奥勒公司（Öller &amp;amp; Co）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/public/2022/04/01/history_ericsson/640.png&quot; alt&gt;&lt;/p&gt;
&lt;center&gt;&lt;div&gt;安东 · 亨里克 · 奥勒，瑞典电信业的先驱&lt;/div&gt;&lt;/center&gt;
&lt;p&gt;奥勒公司名义上是一家公司，但实际上就是一个手工作坊，规模很小，只能靠 Televerket 公司的资助才能维持生存。&lt;/p&gt;
&lt;p&gt;在奥勒公司的员工中，有一个勤奋的小伙子，当时专门负责维修电报设备以及其它机械设备。他的名字，叫做&lt;strong&gt;拉什 · 玛格纳斯 · 爱立信&lt;/strong&gt;（Lars Magnus Ericsson）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/public/2022/04/01/history_ericsson/640-16487839499382.png&quot; alt&gt;&lt;/p&gt;
&lt;center&gt;&lt;div&gt; 拉什 · 玛格纳斯 · 爱立信&lt;/div&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="通信" scheme="https://talengu.github.io/public/categories/%E9%80%9A%E4%BF%A1/"/>
    
    
      <category term="通信" scheme="https://talengu.github.io/public/tags/%E9%80%9A%E4%BF%A1/"/>
    
      <category term="历史" scheme="https://talengu.github.io/public/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>二零年RSS杂谈</title>
    <link href="https://talengu.github.io/public/2022/01/14/rss_talk2020/"/>
    <id>https://talengu.github.io/public/2022/01/14/rss_talk2020/</id>
    <published>2022-01-14T01:02:57.000Z</published>
    <updated>2022-01-14T01:02:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>2020年了，笔者还是使用RSS的原始人。RSS，Really Simple Syndication是一种信息聚合工具。在5G时代信息即将大爆炸之前，我来谈谈rss的杂七杂八吧。我们来打个赌，你不会看完这篇文章。</p><a id="more"></a><p>软件的交互设计有很多心理学理论的应用。比如微信、QQ的三级页面设计，一般经过3次点击就能到达功能或设置。这符合认知原理，人认知记忆能力一般为3-5个的组合。日常生活中要记电话号码，可以3-4-4这样记。软件交互中还有利用人的习惯奖励机制的提醒红点的设计，吸引你去点击，获取红点消失的奖励。对我来说，较难控制住不受这些设计的影响。在《习惯的力量》一书了解到，直接逃离这些环境可有效解决控制不住的问题。比如工作的时候，把手机关进柜子，工作1个小时，然后再回复信息，当然重要电话还是要立即接的。</p><p>铺天盖地的广告，马路上，电视中，手机里，PC页面充斥着各种广告等等。大多数人可能养成了自动过滤的广告的习惯，然而我的情况是一直在用去广告的插件，并没有养成自动忽略广告的习惯。可怜兮兮，难道只有我是有广告洁癖的嘛？广告有点浪费生命。</p><p>我饱受广告的困扰。web的去广告方法，我可使用某款chrome插件可以将web界面上的小红点，推荐信息模块全部屏蔽掉的。哪里不看点哪里，贼方便。</p><p>移动端的广告去掉太难了，我一生气卸载了知乎 b站等等应用，终于有了一个清爽的手机。</p><p>那我还是想获取一些新的内容，根据二八定律，是有20%的网络资料包含了80%的信息，也就是干货，也可能被我这种操作忽略掉了，那一套RSS应用体系应运而生。</p><p>谈谈推荐算法，知乎推荐的都是啥呀，程序员都懂的，把我一个屌丝的形象勾勒的这么明显。于是我回答问题，人在美国，刚下飞机，年薪百万，老婆在旁？</p><p>很多人会说，RSS一定会获取到有用的信息吗，这取决于信息源的可靠程度。也就是需要你自己去选择，由于它是不含推荐算法的，就不会根据你选择的，再给你推荐一些可能是非常有用的。</p><p>再谈谈知识焦虑，每天觉得有大量知识需要吸收。大家都明白mark了也并不会看的，但还是mark很多，但你并不会有时间或者精力去看。既然不会看，那就不mark了，用到啥学啥，或许是个不错的策略。那RSS的即时性还是不错的，最好能当天把信息清理一下，star一些当前重要的东西，然后一周整理一下，像阮一峰老师。吸收完，把它输出出去，与人交流，给人讲明白，能够记得更深。（费曼学习法，把自己当成老师）。</p><p>让我们再回到RSS，RSS是个淘汰的东西，和微信的公众号的形式有点像。然后倒霉的我又在微信的公众号上难以自拔，常常花很多时间在这上面。推荐算法厉害呀，就是让你看得爽。自我节制太难，那就改变环境。于是，我去掉了很多公众号，保留一些本地生活工作的公众号，微信上专注与朋友们侃大山。</p><p>还有一点难受是，各个平台，相互串在一起，在这个地方看了，在其他地方又换了一个马甲它继续晃悠在眼前。信息源在多平台发布，然后信息重叠。</p><p>看来all in one 势在必行，RSS被谷歌放弃后，很多网站傲娇地不提供RSS服务了，毕竟流量至上，钱要赚的，我一直想做一个这种爬的工具，但我不希望有大量使用爬，也就是我们还是要尊重网站的盈利以及持续发展的，这也是仅仅方便个人的信息处理，优化你的自动信息的处理，再也不用一个个打开网站，然后看信息看广告，还要被推荐不重用的信息。这也算我个人的想法。人在于折腾，于是我开始折腾ttrss rsshub等开源软件。</p><p>自由软件的好处，在于自由定制，参与发展，利益化会尽量变慢或者没有，方便的同时并不忘隐私保护。</p><p>我想说的是，<strong>技术应当给人们带来自由和发展，而非接管人们的注意力，浪费宝贵的时间。</strong></p><p>写在5G信息大爆发前，与大家共同反思与成长。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年了，笔者还是使用RSS的原始人。RSS，Really Simple Syndication是一种信息聚合工具。在5G时代信息即将大爆炸之前，我来谈谈rss的杂七杂八吧。我们来打个赌，你不会看完这篇文章。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="https://talengu.github.io/public/categories/%E6%9D%82%E8%B0%88/"/>
    
      <category term="工具" scheme="https://talengu.github.io/public/categories/%E6%9D%82%E8%B0%88/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="RSS" scheme="https://talengu.github.io/public/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>征服14座高峰：凡事皆有可能</title>
    <link href="https://talengu.github.io/public/2022/01/09/14peak/"/>
    <id>https://talengu.github.io/public/2022/01/09/14peak/</id>
    <published>2022-01-09T16:49:44.000Z</published>
    <updated>2022-01-09T16:49:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简介</strong></p><p>14 Peaks: Nothing Is Impossible (2021)</p><p>无畏的尼泊尔登山运动员尼姆斯·普贾开始了一项看似不可能完成的任务：在7个月内登顶全球14座8000米高峰。（2019年度完成的Possible plan）</p><p>最近，我看完了该记录片，摘录了些语句，鼓励自己不断进取，征服人生的一座座高峰，追寻梦想，不忘初心！</p><p><img src="/public/2022/01/09/14peak/2022-01-09-16-49-12.png" alt></p><a id="more"></a><h2 id="追寻梦想！"><a class="header-anchor" href="#追寻梦想！">¶</a>追寻梦想！</h2><p><img src="/public/2022/01/09/14peak/2022-01-09-17-20-35.JPG" alt></p><h2 id="不忘初心！"><a class="header-anchor" href="#不忘初心！">¶</a>不忘初心！</h2><p><img src="/public/2022/01/09/14peak/20220109_hello.JPG" alt></p><h2 id="最后"><a class="header-anchor" href="#最后">¶</a>最后</h2><p>山不向我走来，我便向他走去！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;14 Peaks: Nothing Is Impossible (2021)&lt;/p&gt;
&lt;p&gt;无畏的尼泊尔登山运动员尼姆斯·普贾开始了一项看似不可能完成的任务：在7个月内登顶全球14座8000米高峰。（2019年度完成的Possible plan）&lt;/p&gt;
&lt;p&gt;最近，我看完了该记录片，摘录了些语句，鼓励自己不断进取，征服人生的一座座高峰，追寻梦想，不忘初心！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/public/2022/01/09/14peak/2022-01-09-16-49-12.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="影视" scheme="https://talengu.github.io/public/categories/%E5%BD%B1%E8%A7%86/"/>
    
    
      <category term="记录片" scheme="https://talengu.github.io/public/tags/%E8%AE%B0%E5%BD%95%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>【转】一文看懂Linux内核！Linux内核架构和工作原理详解</title>
    <link href="https://talengu.github.io/public/2021/12/23/linux/linux_in_one/"/>
    <id>https://talengu.github.io/public/2021/12/23/linux/linux_in_one/</id>
    <published>2021-12-23T22:45:31.000Z</published>
    <updated>2021-12-23T22:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>全文导读</p><ul><li><a href>Linux 内核预备工作</a></li><li><a href>Linux 内核体系结构简析</a></li><li><a href>Linux 体系结构和内核结构区别</a></li><li><a href>Linux 驱动的 platform 机制</a></li><li><a href>Linux 内核体系结构</a></li><li><a href>内核模块</a></li><li><a href>Linux 内核学习经验总结</a></li><li><a href>结尾</a></li></ul><a id="more"></a><h2 id="Linux-内核预备工作"><a class="header-anchor" href="#Linux-内核预备工作">¶</a>Linux 内核预备工作</h2><p>理解 Linux 内核最好预备的知识点：</p><p>懂 C 语言<br>懂一点操作系统的知识<br>熟悉少量相关算法<br>懂计算机体系结构</p><p>Linux 内核的特点：</p><p>结合了 unix 操作系统的一些基础概念</p><img src="/public/2021/12/23/linux/linux_in_one/174749211_2_20191103041018392.jpeg" alt="174749211_2_20191103041018392" style="zoom:50%;"><img src="/public/2021/12/23/linux/linux_in_one/174749211_3_20191103041018455.jpeg" alt="174749211_3_20191103041018455" style="zoom:60%;"><p>Linux 内核的任务：</p><ol><li><p>从技术层面讲，内核是硬件与软件之间的一个中间层。作用是将应用层序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。</p></li><li><p>从应用程序的层面讲，应用程序与硬件没有联系，只与内核有联系，内核是应用程序知道的层次中的最底层。在实际工作中内核抽象了相关细节。</p></li><li><p>内核是一个资源管理程序。负责将可用的共享资源 (CPU 时间、磁盘空间、网络连接等) 分配得到各个系统进程。</p></li><li><p>内核就像一个库，提供了一组面向系统的命令。系统调用对于应用程序来说，就像调用普通函数一样。<br>内核实现策略：</p></li><li><p>微内核。最基本的功能由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信。</p></li><li><p>宏内核。内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。目前支持模块的动态装卸 (裁剪)。Linux 内核就是基于这个策略实现的。<br>哪些地方用到了内核机制？</p></li><li><p>进程（在 cpu 的虚拟内存中分配地址空间，各个进程的地址空间完全独立; 同时执行的进程数最多不超过 cpu 数目）之间进行通   信，需要使用特定的内核机制。</p></li><li><p>进程间切换 (同时执行的进程数最多不超过 cpu 数目)，也需要用到内核机制。</p></li></ol><p>进程切换也需要像 FreeRTOS 任务切换一样保存状态，并将进程置于闲置状态 / 恢复状态。</p><ol start="3"><li><p>进程的调度。确认哪个进程运行多长的时间。<br>Linux 进程</p></li><li><p>采用层次结构，每个进程都依赖于一个父进程。内核启动 init 程序作为第一个进程。该进程负责进一步的系统初始化操作。init 进程是进程树的根，所有的进程都直接或者间接起源于该进程。</p></li><li><p>通过 pstree 命令查询。实际上得系统第一个进程是 systemd，而不是 init（这也是疑问点）</p></li><li><p>系统中每一个进程都有一个唯一标识符 (ID), 用户（或其他进程）可以使用 ID 来访问进程。</p></li></ol><p>Linux 内核源代码的目录结构</p><p>Linux 内核源代码包括三个主要部分：</p><ol><li><p>内核核心代码，包括第 3 章所描述的各个子系统和子模块，以及其它的支撑子系统，例如电源管理、Linux 初始化等</p></li><li><p>其它非核心代码，例如库文件（因为 Linux 内核是一个自包含的内核，即内核不依赖其它的任何软件，自己就可以编译通过）、固件集合、KVM（虚拟机技术）等</p></li><li><p>编译脚本、配置文件、帮助文档、版权说明等辅助性文件</p></li></ol><p>使用 ls 命令看到的内核源代码的顶层目录结构，具体描述如下。</p><p>include/ ---- 内核头文件，需要提供给外部模块（例如用户空间代码）使用。</p><p>kernel/ ---- Linux 内核的核心代码，包含了 3.2 小节所描述的进程调度子系统，以及和进程调度相关的模块。</p><p>mm/ ---- 内存管理子系统（3.3 小节）。</p><p>fs/ ---- VFS 子系统（3.4 小节）。</p><p>net/ ---- 不包括网络设备驱动的网络子系统（3.5 小节）。</p><p>ipc/ ---- IPC（进程间通信）子系统。</p><p>arch// ---- 体系结构相关的代码，例如 arm, x86 等等。<br>    arch//mach- ---- 具体的 machine/board 相关的代码。<br>    arch//include/asm ---- 体系结构相关的头文件。<br>    arch//boot/dts ---- 设备树（Device Tree）文件。</p><p>init/ ---- Linux 系统启动初始化相关的代码。<br>block/ ---- 提供块设备的层次。<br>sound/ ---- 音频相关的驱动及子系统，可以看作 “音频子系统”。<br>drivers/ ---- 设备驱动（在 Linux kernel 3.10 中，设备驱动占了 49.4 的代码量）。</p><p>lib/ ---- 实现需要在内核中使用的库函数，例如 CRC、FIFO、list、MD5 等。<br>crypto/ ----- 加密、解密相关的库函数。<br>security/ ---- 提供安全特性（SELinux）。<br>virt/ ---- 提供虚拟机技术（KVM 等）的支持。<br>usr/ ---- 用于生成 initramfs 的代码。<br>firmware/ ---- 保存用于驱动第三方设备的固件。</p><p>samples/ ---- 一些示例代码。<br>tools/ ---- 一些常用工具，如性能剖析、自测试等。</p><p>Kconfig, Kbuild, Makefile, scripts/ ---- 用于内核编译的配置文件、脚本等。</p><p>COPYING ---- 版权声明。<br>MAINTAINERS ---- 维护者名单。<br>CREDITS ---- Linux 主要的贡献者名单。<br>REPORTING-BUGS ---- Bug 上报的指南。</p><p>Documentation, README ---- 帮助、说明文档。</p><h2 id="Linux-内核体系结构简析"><a class="header-anchor" href="#Linux-内核体系结构简析">¶</a>Linux 内核体系结构简析</h2><p><img src="/public/2021/12/23/linux/linux_in_one/174749211_4_20191103041018502.jpeg" alt="174749211_4_20191103041018502"></p><p>图 1 Linux 系统层次结构</p><p>最上面是用户（或应用程序）空间。这是用户应用程序执行的地方。用户空间之下是内核空间，Linux 内核正是位于这里。GNU C Library （glibc）也在这里。它提供了连接内核的系统调用接口，还提供了在用户空间应用程序和内核之间进行转换的机制。这点非常重要，因为内核和用户空间的应用程序使用的是不同的保护地址空间。每个用户空间的进程都使用自己的虚拟地址空间，而内核则占用单独的地址空间。</p><p>Linux 内核可以进一步划分成 3 层。最上面是系统调用接口，它实现了一些基本的功能，例如 read 和 write。系统调用接口之下是内核代码，可以更精确地定义为独立于体系结构的内核代码。这些代码是 Linux 所支持的所有处理器体系结构所通用的。在这些代码之下是依赖于体系结构的代码，构成了通常称为 BSP（Board Support Package）的部分。这些代码用作给定体系结构的处理器和特定于平台的代码。</p><p>Linux 内核实现了很多重要的体系结构属性。在或高或低的层次上，内核被划分为多个子系统。Linux 也可以看作是一个整体，因为它会将所有这些基本服务都集成到内核中。这与微内核的体系结构不同，后者会提供一些基本的服务，例如通信、I/O、内存和进程管理，更具体的服务都是插入到微内核层中的。每种内核都有自己的优点，不过这里并不对此进行讨论。</p><p>随着时间的流逝，Linux 内核在内存和 CPU 使用方面具有较高的效率，并且非常稳定。但是对于 Linux 来说，最为有趣的是在这种大小和复杂性的前提下，依然具有良好的可移植性。Linux 编译后可在大量处理器和具有不同体系结构约束和需求的平台上运行。一个例子是 Linux 可以在一个具有内存管理单元（MMU）的处理器上运行，也可以在那些不提供 MMU 的处理器上运行。</p><p>Linux 内核的 uClinux 移植提供了对非 MMU 的支持。</p><p>图 2 是 Linux 内核的体系结构</p><p><img src="/public/2021/12/23/linux/linux_in_one/174749211_5_20191103041018549.jpeg" alt="174749211_5_20191103041018549"></p><p>图 2 Linux 内核体系结构</p><p>Linux 内核的主要组件有：系统调用接口、进程管理、内存管理、虚拟文件系统、网络堆栈、设备驱动程序、硬件架构的相关代码。</p><p>（1）系统调用接口</p><p>SCI 层提供了某些机制执行从用户空间到内核的函数调用。正如前面讨论的一样，这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 ./linux/kernel 中您可以找到 SCI 的实现，并在 ./linux/arch 中找到依赖于体系结构的部分。</p><p>（2）进程管理</p><p>进程管理的重点是进程的执行。在内核中，这些进程称为线程，代表了单独的处理器虚拟化（线程代码、数据、堆栈和 CPU 寄存器）。在用户空间，通常使用进程 这个术语，不过 Linux 实现并没有区分这两个概念（进程和线程）。内核通过 SCI 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSIX] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSIX 机制）。</p><p>进程管理还包括处理活动进程之间共享 CPU 的需求。内核实现了一种新型的调度算法，不管有多少个线程在竞争 CPU，这种算法都可以在固定时间内进行操作。这种算法就称为 O(1) 调度程序，这个名字就表示它调度多个线程所使用的时间和调度一个线程所使用的时间是相同的。O(1) 调度程序也可以支持多处理器（称为对称多处理器或 SMP）。您可以在 ./linux/kernel 中找到进程管理的源代码，在 ./linux/arch 中可以找到依赖于体系结构的源代码。</p><p>（3）内存管理</p><p>内核所管理的另外一个重要资源是内存。为了提高效率，如果由硬件管理虚拟内存，内存是按照所谓的内存页 方式进行管理的（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。</p><p>（4）虚拟文件系统</p><p>虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 SCI 和内核所支持的文件系统之间提供了一个交换层（请参看图 4）。</p><p><img src="/public/2021/12/23/linux/linux_in_one/174749211_6_20191103041018596.jpeg" alt="174749211_6_20191103041018596"></p><p>图 3 Linux 文件系统层次结构</p><p>在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。它们是给定文件系统（超过 50 个）的插件。文件系统的源代码可以在 ./linux/fs 中找到。文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集（与具体文件系统无关）。这个缓存层通过将数据保留一段时间（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。</p><p>（5）网络堆栈</p><p>网络堆栈在设计上遵循模拟协议本身的分层体系结构。回想一下，Internet Protocol (IP) 是传输协议（通常称为传输控制协议或 TCP）下面的核心网络层协议。TCP 上面是 socket 层，它是通过 SCI 进行调用的。socket 层是网络子系统的标准 API，它为各种网络协议提供了一个用户接口。从原始帧访问到 IP 协议数据单元（PDU），再到 TCP 和 User Datagram Protocol (UDP)，socket 层提供了一种标准化的方法来管理连接，并在各个终点之间移动数据。内核中网络源代码可以在 ./linux/net 中找到。</p><p>（6）设备驱动程序</p><p>Linux 内核中有大量代码都在设备驱动程序中，它们能够运转特定的硬件设备。Linux 源码树提供了一个驱动程序子目录，这个目录又进一步划分为各种支持设备，例如 Bluetooth、I2C、serial 等。设备驱动程序的代码可以在 ./linux/drivers 中找到。</p><p>（7）依赖体系结构的代码</p><p>尽管 Linux 很大程度上独立于所运行的体系结构，但是有些元素则必须考虑体系结构才能正常操作并实现更高效率。./linux/arch 子目录定义了内核源代码中依赖于体系结构的部分，其中包含了各种特定于体系结构的子目录（共同组成了 BSP）。对于一个典型的桌面系统来说，使用的是 x86 目录。每个体系结构子目录都包含了很多其他子目录，每个子目录都关注内核中的一个特定方面，例如引导、内核、内存管理等。这些依赖体系结构的代码可以在 ./linux/arch 中找到。</p><p>如果 Linux 内核的可移植性和效率还不够好，Linux 还提供了其他一些特性，它们无法划分到上面的分类中。作为一个生产操作系统和开源软件，Linux 是测试新协议及其增强的良好平台。Linux 支持大量网络协议，包括典型的 TCP/IP，以及高速网络的扩展（大于 1 Gigabit Ethernet [GbE] 和 10 GbE）。Linux 也可以支持诸如流控制传输协议（SCTP）之类的协议，它提供了很多比 TCP 更高级的特性（是传输层协议的接替者）。</p><p>Linux 还是一个动态内核，支持动态添加或删除软件组件。被称为动态可加载内核模块，它们可以在引导时根据需要（当前特定设备需要这个模块）或在任何时候由用户插入。</p><p>Linux 最新的一个增强是可以用作其他操作系统的操作系统（称为系统管理程序）。最近，对内核进行了修改，称为基于内核的虚拟机（KVM）。这个修改为用户空间启用了一个新的接口，它可以允许其他操作系统在启用了 KVM 的内核之上运行。除了运行 Linux 的其他实例之外， Microsoft Windows 也可以进行虚拟化。惟一的限制是底层处理器必须支持新的虚拟化指令。</p><h2 id="Linux-体系结构和内核结构区别"><a class="header-anchor" href="#Linux-体系结构和内核结构区别">¶</a>Linux 体系结构和内核结构区别</h2><p>1．当被问到 Linux 体系结构（就是 Linux 系统是怎么构成的）时，我们可以参照下图这么回答：<br>从大的方面讲，Linux 体系结构可以分为两块：<br>（1）用户空间：用户空间中又包含了，用户的应用程序，C 库<br>（2）内核空间：内核空间包括，系统调用，内核，以及与平台架构相关的代码</p><p><img src="/public/2021/12/23/linux/linux_in_one/174749211_7_20191103041018642.jpeg" alt="174749211_7_20191103041018642"></p><p>2．Linux 体系结构要分成用户空间和内核空间的原因：</p><p>1）现代 CPU 通常都实现了不同的工作模式。</p><p>以 ARM 为例：ARM 实现了 7 种工作模式，不同模式下 CPU 可以执行的指令或者访问的寄存器不同：<br>（1）用户模式  usr<br>（2）系统模式  sys<br>（3）管理模式  svc<br>（4）快速中断  fiq<br>（5）外部中断  irq<br>（6）数据访问终止 abt<br>（7）未定义指令异常</p><p>以（2）X86 为例：X86 实现了 4 个不同级别的权限，Ring0—Ring3 ;Ring0 下可以执行特权指令，可以访问 IO 设备；Ring3 则有很多的限制</p><p>2）所以，Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了 2 部分；</p><p>3．用户空间和内核空间是程序执行的两种不同状态，我们可以通过 “系统调用” 和“硬件中断“来完成用户空间到内核空间的转移</p><p>4．Linux 的内核结构（注意区分 LInux 体系结构和 Linux 内核结构）</p><p><img src="/public/2021/12/23/linux/linux_in_one/174749211_8_20191103041018705.jpeg" alt="174749211_8_20191103041018705"></p><h2 id="Linux-驱动的-platform-机制"><a class="header-anchor" href="#Linux-驱动的-platform-机制">¶</a>Linux 驱动的 platform 机制</h2><p>Linux 的这种 platform driver 机制和传统的 device_driver 机制相比，一个十分明显的优势在于 platform 机制将本身的资源注册进内核，由内核统一管理，在驱动程序中使用这些资源时通过 platform_device 提供的标准接口进行申请并使用。这样提高了驱动和资源管理的独立性，并且拥有较好的可移植性和安全性。下面是 SPI 驱动层次示意图，Linux 中的 SPI 总线可理解为 SPI 控制器引出的总线：</p><p><img src="/public/2021/12/23/linux/linux_in_one/174749211_9_20191103041018752.jpeg" alt="174749211_9_20191103041018752"></p><p>和传统的驱动一样，platform 机制也分为三个步骤：</p><p>1、总线注册阶段：</p><p>内核启动初始化时的 main.c 文件中的 kernel_init()→do_basic_setup()→driver_init()→platform_bus_init()→bus_register(&amp;platform_bus_type)，注册了一条 platform 总线（虚拟总线，platform_bus）。</p><p>2、添加设备阶段：</p><p>设备注册的时候 Platform_device_register()→platform_device_add()→(pdev→dev.bus = &amp;platform_bus_type)→device_add()，就这样把设备给挂到虚拟的总线上。</p><p>3、驱动注册阶段：</p><p>Platform_driver_register()→driver_register()→bus_add_driver()→driver_attach()→bus_for_each_dev(), 对在每个挂在虚拟的 platform bus 的设备作__driver_attach()→driver_probe_device(), 判断 drv→bus→match() 是否执行成功，此时通过指针执行 platform_match→strncmp(pdev→name , drv→name , BUS_ID_SIZE), 如果相符就调用 really_probe(实际就是执行相应设备的 platform_driver→probe(platform_device)。) 开始真正的探测，如果 probe 成功，则绑定设备到该驱动。</p><p>从上面可以看出，platform 机制最后还是调用了 bus_register() , device_add() , driver_register() 这三个关键的函数。</p><p>下面看几个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span>           </span></span><br><span class="line"><span class="class">(/<span class="title">include</span>/<span class="title">linux</span>/<span class="title">Platform_device</span>.<span class="title">h</span>)</span></span><br><span class="line"><span class="class">&#123;</span>        </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>    * name;        </span><br><span class="line"><span class="keyword">int</span>        id;        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span>    <span class="title">dev</span>;</span>        </span><br><span class="line">u32        num_resources;        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span>    * <span class="title">resource</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Platform_device 结构体描述了一个 platform 结构的设备，在其中包含了一般设备的结构体 struct device  dev; 设备的资源结构体 struct resource   * resource; 还有设备的名字 const char * name。（注意，这个名字一定要和后面 platform_driver.driver àname 相同，原因会在后面说明。）</p><p>该结构体中最重要的就是 resource 结构，这也是之所以引入 platform 机制的原因。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span>                            </span></span><br><span class="line"><span class="class">( /<span class="title">include</span>/<span class="title">linux</span>/<span class="title">ioport</span>.<span class="title">h</span>)</span></span><br><span class="line"><span class="class">&#123;</span>        </span><br><span class="line"><span class="keyword">resource_size_t</span> start;        </span><br><span class="line"><span class="keyword">resource_size_t</span> end;        </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;        </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">其中 flags位表示该资源的类型，start和end分别表示该资源的起始地址和结束地址(/include/linux/Platform_device.h)：</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span>              </span></span><br><span class="line"><span class="class">&#123;</span>        </span><br><span class="line"><span class="keyword">int</span> (*probe)(struct platform_device *);        </span><br><span class="line"><span class="keyword">int</span> (*remove)(struct platform_device *);        </span><br><span class="line"><span class="keyword">void</span> (*shutdown)(struct platform_device *);        </span><br><span class="line"><span class="keyword">int</span> (*suspend)(struct platform_device *, <span class="keyword">pm_message_t</span> state);        </span><br><span class="line"><span class="keyword">int</span> (*suspend_late)(struct platform_device *, <span class="keyword">pm_message_t</span> state);        </span><br><span class="line"><span class="keyword">int</span> (*resume_early)(struct platform_device *);        </span><br><span class="line"><span class="keyword">int</span> (*resume)(struct platform_device *);        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">Platform_driver结构体描述了一个platform结构的驱动。其中除了一些函数指针外，还有一个一般驱动的device_driver结构。</span><br></pre></td></tr></table></figure><p>名字要一致的原因：</p><p>上面说的驱动在注册的时候会调用函数 bus_for_each_dev(), 对在每个挂在虚拟的 platform bus 的设备作__driver_attach()→driver_probe_device(), 在此函数中会对 dev 和 drv 做初步的匹配，调用的是 drv-&gt;bus-&gt;match 所指向的函数。platform_driver_register 函数中 drv-&gt;driver.bus = &amp;platform_bus_type，所以 drv-&gt;bus-&gt;match 就为 platform_bus_type→match, 为 platform_match 函数，该函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">platform_match</span><span class="params">(struct device * dev, struct device_driver * drv)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> = <span class="title">container_of</span>(<span class="title">dev</span>, <span class="title">struct</span> <span class="title">platform_device</span>, <span class="title">dev</span>);</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">strncmp</span>(pdev-&gt;name, drv-&gt;name, BUS_ID_SIZE) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是比较 dev 和 drv 的 name，相同则会进入 really_probe（）函数，从而进入自己写的 probe 函数做进一步的匹配。所以 dev→name 和 driver→drv→name 在初始化时一定要填一样的。</p><p>不同类型的驱动，其 match 函数是不一样的，这个 platform 的驱动，比较的是 dev 和 drv 的名字，还记得 usb 类驱动里的 match 吗？它比较的是 Product ID 和 Vendor ID。</p><p>个人总结 Platform 机制的好处：</p><p>1、提供 platform_bus_type 类型的总线，把那些不是总线型的 soc 设备都添加到这条虚拟总线上。使得，总线——设备——驱动的模式可以得到普及。</p><p>2、提供 platform_device 和 platform_driver 类型的数据结构，将传统的 device 和 driver 数据结构嵌入其中，并且加入 resource 成员，以便于和 Open Firmware 这种动态传递设备资源的新型 bootloader 和 kernel 接轨。</p><h2 id="Linux-内核体系结构"><a class="header-anchor" href="#Linux-内核体系结构">¶</a>Linux 内核体系结构</h2><p>因为 Linux 内核是单片的，所以它比其他类型的内核占用空间最大，复杂度也最高。这是一个设计特性，在 Linux 早期引起了相当多的争论，并且仍然带有一些与单内核固有的相同的设计缺陷。</p><img src="/public/2021/12/23/linux/linux_in_one/174749211_10_20191103041018783.jpeg" alt="174749211_10_20191103041018783" style="zoom:50%;"><p>为了解决这些缺陷，Linux 内核开发人员所做的一件事就是使内核模块可以在运行时加载和卸载，这意味着您可以动态地添加或删除内核的特性。这不仅可以向内核添加硬件功能，还可以包括运行服务器进程的模块，比如低级别虚拟化，但也可以替换整个内核，而不需要在某些情况下重启计算机。<br>想象一下，如果您可以升级到 Windows 服务包，而不需要重新启动……</p><h2 id="内核模块"><a class="header-anchor" href="#内核模块">¶</a>内核模块</h2><p>如果 Windows 已经安装了所有可用的驱动程序，而您只需要打开所需的驱动程序怎么办? 这本质上就是内核模块为 Linux 所做的。内核模块，也称为可加载内核模块 (LKM)，对于保持内核在不消耗所有可用内存的情况下与所有硬件一起工作是必不可少的。</p><p><img src="/public/2021/12/23/linux/linux_in_one/174749211_11_20191103041018908.jpeg" alt="174749211_11_20191103041018908"></p><p>模块通常向基本内核添加设备、文件系统和系统调用等功能。lkm 的文件扩展名是. ko，通常存储在 / lib/modules 目录中。由于模块的特性，您可以通过在启动时使用 menuconfig 命令将模块设置为 load 或 not load，或者通过编辑 / boot/config 文件，或者使用 modprobe 命令动态地加载和卸载模块，轻松定制内核。</p><p>第三方和封闭源码模块在一些发行版中是可用的，比如 Ubuntu，默认情况下可能无法安装，因为这些模块的源代码是不可用的。该软件的开发人员 (即 nVidia、ATI 等) 不提供源代码，而是构建自己的模块并编译所需的. ko 文件以便分发。虽然这些模块像 beer 一样是免费的，但它们不像 speech 那样是免费的，因此不包括在一些发行版中，因为维护人员认为它通过提供非免费软件 “污染” 了内核。</p><p>内核并不神奇，但对于任何正常运行的计算机来说，它都是必不可少的。Linux 内核不同于 OS X 和 Windows，因为它包含内核级别的驱动程序，并使许多东西 “开箱即用”。希望您能对软件和硬件如何协同工作以及启动计算机所需的文件有更多的了解。</p><h2 id="Linux-内核学习经验总结"><a class="header-anchor" href="#Linux-内核学习经验总结">¶</a>Linux 内核学习经验总结</h2><p>开篇</p><p>学习内核，每个人都有自己的学习方法，仁者见仁智者见智。以下是我在学习过程中总结出来的东西，对自身来说，我认为比较有效率，拿出来跟大家交流一下。</p><p>内核学习，一偏之见；疏漏难免，恳请指正。</p><p>为什么写这篇博客</p><p>刚开始学内核的时候，不要执着于一个方面，不要专注于一个子系统就一头扎到实际的代码行中去，因为这样的话，牵涉的面会很广，会碰到很多困难，容易产生挫败感，一个函数体中（假设刚开始的时候正在学习某个方面的某个具体的功能函数）很可能掺杂着其他各个子系统方面设计理念（多是大量相关的数据结构或者全局变量，用于支撑该子系统的管理工作）下相应的代码实现，这个时候看到这些东西，纷繁芜杂，是没有头绪而且很不理解的，会产生很多很多的疑问，（这个时候如果对这些疑问纠缠不清，刨根问底，那么事实上就是在学习当前子系统的过程中频繁的去涉足其他子系统，这时候注意力就分散了），而事实上等了解了各个子系统后再回头看这些东西的话，就简单多了，而且思路也会比较清晰。所以，要避免 “只见树木，不见森林”，不要急于深入到底层代码中去，不要过早研究底层代码。</p><p>我在大二的时候刚开始接触内核，就犯了这个错误，一头扎到内存管理里头，去看非常底层的实现代码，虽然也是建立在内存管理的设计思想的基础上，但是相对来说，比较孤立，因为此时并没有学习其它子系统，应该说无论是视野还是思想，都比较狭隘，所以代码中牵涉到的其它子系统的实现我都直接跳过了，这一点还算聪明，当然也是迫不得已的。</p><p>我的学习方法</p><p>刚开始，我认为主要的问题在于你知道不知道，而不是理解不理解，某个子系统的实现采用了某种策略、方法，而你在学习中需要做的就是知道有这么一回事儿，然后才是理解所描述的策略或者方法。</p><p>根据自己的学习经验，刚开始学习内核的时候，我认为要做的是在自己的脑海中建立起内核的大体框架，理解各个子系统的设计理念和构建思想，这些理念和思想会从宏观上呈献给你清晰的脉络，就像一个去除了枝枝叶叶的大树的主干，一目了然；当然，肯定还会涉及到具体的实现方法、函数，但是此时接触到的函数或者方法位于内核实现的较高的层次，是主（要）函数，已经了解到这些函数，针对的是哪些设计思想，实现了什么样的功能，达成了什么样的目的，混个脸熟的说法在这儿也是成立的。至于该主函数所调用的其它的辅助性函数就等同于枝枝叶叶了，不必太早就去深究。此时，也就初步建立起了内核子系统框架和代码实现之间的关联，关联其实很简单，比如一看到某个函数名字，就想起这个函数是针对哪个子系统的，实现了什么功能。</p><p>我认为此时要看的就是 LKD3，这本书算是泛泛而谈，主要就是从概念，设计，大的实现方法上描述各个子系统，而对于具体的相关的函数实现的代码讲解很少涉及 (对比于 ULK3，此书主要就是关于具体函数代码的具体实现的深入分析，当然，你也可以看，但是过早看这本书，会感觉很痛苦，很枯燥无味，基本上都是函数的实现)，很少，但不是没有，这就很好，满足我们当前的需求，还避免我们过早深入到实际的代码中去。而且本书在一些重要的点上还给出了写程序时的注意事项，算是指导性建议。主要的子系统包括：内存管理，进程管理和调度，系统调用，中断和异常，内核同步，时间和定时器管理，虚拟文件系统，块 I/O 层，设备和模块。（这里的先后顺序其实就是 LKD3 的目录的顺序）。</p><p>我学习的时候是三本书交叉着看的，先看 LKD3，专于一个子系统，主要就是了解设计的原理和思想，当然也会碰到对一些主要函数的介绍，但大多就是该函数基于前面介绍的思想和原理完成了什么样的功能，该书并没有就函数本身的实现进行深入剖析。然后再看 ULK3 和 PLKA 上看同样的子系统，但是并不仔细分析底层具体函数的代码，只是粗略地、不求甚解地看，甚至不看。因为，有些时候，在其中一本书的某个点上，卡壳了，不是很理解了，在另外的书上你可能就碰到对同一个问题的不同角度的描述，说不准哪句话就能让你豁然开朗，如醍醐灌顶。我经常碰到这种情况。</p><p>并不是说学习过程中对一些函数体的实现完全就忽略掉，只要自己想彻底了解其代码实现，没有谁会阻止你。我是在反复阅读过程中慢慢深入的。比如 VFS 中文件打开需要对路径进行分析，需要考虑的细节不少 (.././ 之类的)，但是其代码实现是很好理解的。再比如，CFS 调度中根据 shedule latency、队列中进程个数及其 nice 值(使用的是动态优先级) 计算出分配给进程的时间片，没理由不看的，这个太重要了，而且也很有意思。</p><p>ULK3 也会有设计原理与思想之类的概括性介绍，基本上都位于某个主题的开篇段落。但是更多的是对支持该原理和思想的主要函数实现的具体分析，同样在首段，一句话综述函数的功能，然后对函数的实现以 1、2、3，或者 a、b、c 步骤的形式进行讲解。我只是有选择性的看，有时候对照着用 source insight 打开的源码，确认一下代码大体上确实是按书中所描述的步骤实现的，就当是增加感性认识。由于步骤中掺杂着各种针对不同实现目的安全性、有效性检查，如果不理解就先跳过。这并不妨碍你对函数体功能实现的整体把握。</p><p>PLKA 介于 LKD3 和 ULK3 之间。我觉得 PLKA 的作者（看照片，真一德国帅小伙，技术如此了得）肯定看过 ULK，无论他的本意还是有意，总之 PLKA 还是跟 ULK 有所不同，对函数的仔细讲解都做补充说明，去掉函数体中边边角角的情况，比如一些特殊情况的处理，有效性检查等，而不妨碍对整个函数体功能的理解，这些他都有所交代，做了声明；而且，就像 LKD3 一样，在某些点上也给出了指导性编程建议。作者们甚至对同一个主要函数的讲解的着重点都不一样。这样的话，对我们学习的人而言，有助于加深理解。另外，我认为很重要的一点就是 PLKA 针对的 2.6.24 的内核版本，而 ULK 是 2.6.11，LKD3 是 2.6.34。在某些方面 PLKA 比较接近现代的实现。其实作者们之所以分别选择 11 或者 24，都是因为在版本发行树中，这两个版本在某些方面都做了不小的变动，或者说是具有标志性的转折点（这些信息大多是在书中的引言部分介绍的，具体的细节我想不起来了）。</p><p>Intel V3，针对 X86 的 CPU，本书自然是系统编程的权威。内核部分实现都可以在本书找到其根源。所以，在读以上三本书某个子系统的时候，不要忘记可以在 V3 中相应章节找到一些基础性支撑信息。</p><p>在读书过程中，会产生相当多的疑问，这一点是确信无疑的。大到搞不明白一个设计思想，小到不理解某行代码的用途。各个方面，各种疑问，你完全可以把不理解的地方都记录下来 (不过，我并没有这么做，没有把疑问全部记下来，只标记了很少一部分我认为很关键的几个问题)，专门写到一张纸上，不对，一个本上，我确信会产生这么多的疑问，不然内核相关的论坛早就可以关闭了。其实，大部分的问题（其中很多问题都是你知道不知道有这么一回事的问题）都可以迎刃而解，只要你肯回头再看，书读百遍，其义自现。多看几遍，前前后后的联系明白个七七八八是没有问题的。我也这么做了，针对某些子系统也看了好几遍，切身体会。</p><p>当你按顺序学习这些子系统的时候，前面的章节很可能会引用后面的章节，就像 PLKA 的作者说的那样，完全没有向后引用是不可能的，他能做的只是尽量减少这种引用而又不损害你对当前问题的理解。不理解，没关系，跳过就行了。后面的章节同样会有向前章节的引用，不过这个问题就简单一些了 ，你可以再回头去看相应的介绍，当时你不太理解的东西，很可能这个时候就知道了它的设计的目的以及具体的应用。不求甚解只是暂时的。比如说，内核各个子系统之间的交互和引用在代码中的体现就是实现函数穿插调用，比如你在内存管理章节学习了的内存分配和释放的函数，而你是了解内存在先的，在学习驱动或者模块的时候就会碰到这些函数的调用，这样也就比较容易接受，不至于太过茫然；再比如，你了解了系统时间和定时器的管理，再回头看中断和异常中 bottom half 的调度实现，你对它的理解就会加深一层。</p><p>子系统进行管理工作需要大量的数据结构。子系统之间交互的一种方式就是各个子系统各自的主要数据结构通过指针成员相互引用。学习过程中，参考书上在讲解某个子系统的时候会对数据结构中主要成员的用途解释一下，但肯定不会覆盖全部（成员比较多的情况，例如 task_struct），对其它子系统基于某个功能实现的引用可能解释了，也可能没做解释，还可能说这个变量在何处会做进一步说明。所以，不要纠结于一个不理解的点上，暂且放过，回头还可以看的。之间的联系可以在对各个子系统都有所了解之后再建立起来。其实，我仍然在强调先理解概念和框架的重要性。</p><p>等我们完成了建立框架这一步，就可以选择一个比较感兴趣的子系统，比如驱动、网络，或者文件系统之类的。这个时候你再去深入了解底层代码实现，相较于一开始就钻研代码，更容易一些，而且碰到了不解之处，或者忘记了某个方面的实现，此时你完全可以找到相应的子系统，因为你知道在哪去找，查漏补缺，不仅完成了对当前函数的钻研，而且可以回顾、温习以前的内容，融会贯通的时机就在这里了。</p><p>《深入理解 linux 虚拟内存》(2.4 内核版本)，LDD3，《深入理解 linux 网络技术内幕》，几乎每一个子系统都需要一本书的容量去讲解，所以说，刚开始学习不宜对某个模块太过深入，等对各个子系统都有所了解了，再有针对性的去学习一个特定的子系统。这时候对其它系统的援引都可以让我们不再感到茫然、复杂，不知所云。</p><p>比如，LDD3 中的以下所列章节：构造和运行模块，并发和竞态，时间、延迟及延缓操作, 分配内存，中断处理等，都属于驱动开发的支撑性子系统，虽说本书对这些子系统都专门开辟一个章节进行讲解，但是详细程度怎么能比得上 PLKA，ULK3，LKD3 这三本书，看完这三本书，你会发现读 LDD3 这些章节的时候简直跟喝白开水一样，太随意了，因为 LDD3 的讲解比之 LKD3 更粗略。打好了基础，PCI、USB、TTY 驱动，块设备驱动，网卡驱动，需要了解和学习的东西就比较有针对性了。这些子系统就属于通用子系统，了解之后，基于这些子系统的子系统的开发—驱动 (需进一步针对硬件特性) 和网络(需进一步理解各种协议)—相对而言，其学习难度大大降低，学习进度大大加快，学习效率大大提升。说着容易做来难。达到这样一种效果的前提就是：必须得静下心来，认真读书，要看得进去，PLKA，ULK3 厚得都跟砖头块儿一样，令人望之生畏，如果没有兴趣，没有热情，没有毅力，无论如何都是不行，因为需要时间，需要很长时间。我并不是说必须打好了基础才可以进行驱动开发，只是说打好了基础的情况下进行开发会更轻松，更有效率，而且自己对内核代码的驾驭能力会更强大。这只是我个人见解，我自己的学习方式，仅供参考。</p><p>语言</p><p>PLKA 是个德国人用德语写的，后来翻译成英文，又从英文翻译成中文，我在网上书店里没有找到它的纸质英文版，所以就买了中文版的。ULK3 和 LKD3 都是英文版的。大牛们写的书，遣词造句真的是简洁，易懂，看原版对我们学习计算机编程的程序员来说完全不成问题，最好原汁原味。如果一本书确实翻译地很好，我们当然可以看中文版的，用母语进行学习，理解速度和学习进度当然是很快的，不作他想。看英文的时候不要脑子里想着把他翻译成中文，没必要。</p><p>API 感想</p><p>“比起知道你所用技术的重要性，成为某一个特别领域的专家是不重要的。知道某一个具体 API 调用一点好处都没有，当你需要他的时候只要查询下就好了。” 这句话源于我看到的一篇翻译过来的博客。我想强调的就是，这句话针应用型编程再合适不过，但是内核 API 就不完全如此。</p><p>内核相当复杂，学习起来很不容易，但是当你学习到一定程度，你会发现，如果自己打算写内核代码，到最后要关注的仍然是 API 接口，只不过这些 API 绝大部分是跨平台的，满足可移植性。内核黑客基本上已经标准化、文档化了这些接口，你所要做的只是调用而已。当然，在使用的时候，最好对可移植性这一话题在内核中的编码约定烂熟于心，这样才会写出可移植性的代码。就像应用程序一样，可以使用开发商提供的动态库 API，或者使用开源 API。同样是调用 API，不同点在于使用内核 API 要比使用应用 API 了解的东西要多出许多。</p><p>当你了解了操作系统的实现—这些实现可都是对应用程序的基础性支撑啊—你再去写应用程序的时候，应用程序中用到的多线程，定时器，同步锁机制等等等等，使用共享库 API 的时候，联系到操作系统，从而把对该 API 的文档描述同自己所了解到的这些方面在内核中的相应支撑性实现结合起来进行考虑，这会指导你选择使用哪一个 API 接口，选出效率最高的实现方式。对系统编程颇有了解的话，对应用编程不无益处，甚至可以说是大有好处。</p><p>设计实现的本质，知道还是理解</p><p>操作系统是介于底层硬件和应用软件之间的接口，其各个子系统的实现很大程度上依赖于硬件特性。书上介绍这些子系统的设计和实现的时候，我们读过了，也就知道了，如果再深入考虑一下，为什么整体架构要按照这种方式组织，为什么局部函数要遵循这样的步骤处理，知其然，知其所以然，如果你知道了某个功能的实现是因为芯片就是这么设计的，CPU 就是这么做的，那么你的疑问也就基本上到此为止了。再深究，就是芯片架构方面的设计与实现，对于程序员来讲，无论是系统还是应用程序员，足迹探究到这里，已经解决了很多疑问，因为我们的工作性质偏软，而这些东西实在是够硬。</p><p>比如，ULK3 中讲解的中断和异常的实现，究其根源，那是因为 Intel x86 系列就是这么设计的，去看看 Intel V3 手册中相应章节介绍，都可以为 ULK3 中描述的代码实现方式找到注解。还有时间和定时器管理，同样可以在 Intel V3 对 APIC 的介绍中获取足够的信息，操作系统就是依据这些硬件特性来实现软件方法定义的。</p><p>又是那句话，不是理解不理解的问题，而是知道不知道的问题。有时候，知道了，就理解了。在整个学习过程中，知道，理解，知道，理解，知道……，交叉反复。为什么开始和结尾都是知道，而理解只是中间步骤呢？世界上万事万物自有其规律，人类只是发现而已，实践是第一位的，实践就是知道的过程，实践产生经验，经验的总结就是理论，理论源于实践，理论才需要理解。我们学习内核，深入研究，搞来搞去，又回到了芯片上，芯片是物质的，芯片的功用基于自然界中物质本有的物理和电子特性。追本溯源，此之谓也。</p><p>动手写代码</p><p>纸上得来终觉浅，绝知此事要躬行。只看书是绝对不行的，一定要结合课本给出的编程建议自己敲代码。刚开始就以模块形式测试好了，或者自己编译一个开发版本的内核。一台机器的话，使用 UML 方式调试，内核控制路走到哪一步，单步调试看看程序执行过程，比书上的讲解更直观明了。一定要动手实际操作。</p><p>参考书</p><p>LDD3          Linux Device Driver 3rd</p><p>LKD3          Linux Kernel Development 3rd</p><p>ULK3          Understanding the Linux Kernel 3rd</p><p>PLKA          Professional Linux Kernel Architecture</p><p>UML            User Mode Linux</p><p>Intel V3       Intel? 64 and IA-32 Architectures Software Developer’s Manual Volume 3 (3A, 3B &amp; 3C): System Programming Guide</p><p>作者在写书的时候，都是以自己的理解组织内容，从自己的观点看待一个主题，关注点跟作者自身有很大的关系。出书的时间有先后，后来人针对同一个主题想要出书而又不落入窠臼，最好有自己的切入方式，从自己的角度讲解相关问题，这才值得出这本书，千篇一律是个掉价的行为，书就不值钱了。</p><p>尽信书不如无书。</p><p><a href="http://lwn.net/Articles/419855/" target="_blank" rel="noopener">http://lwn.net/Articles/419855/</a> 此处是一篇关于 LKD3 的书评，指出了其中的错误，当你读完的时候，不妨去找找，看一下自己在其中所描述的地方有什么特别的印象。</p><p><a href="http://lwn.net/Articles/161190" target="_blank" rel="noopener">http://lwn.net/Articles/161190</a> / 此处是一篇对 ULK3 的介绍，我认为其中很关键的几句话就可以给本书定位：</p><blockquote><p>Many of the key control paths in the kernel are described, step by step;</p><p>一步一步地讲述内核控制路径的实现。</p><p>The level of detail sometimes makes it hard to get a sense for the big picture, but it does help somebody trying to figure out how a particular function works.</p><p>对代码讲解的详细程度有时候很难让读者把握住它的主旨大意，但是确实有助于读者理解一个特定的函数到底是如何工作的。</p><p>Indeed, that is perhaps the key feature which differentiates this book. It is very much a “how it works” book, designed to help people understand the code.</p><p>事实上，这也正是本书与众不同的地方。更像一个 “如何工作” 的书，帮助读者理解代码实现。</p><p>It presents kernel functions and data structures, steps the reader through them, but does not, for example, emphasize the rules for using them. UTLK is a study guide, not a programming manual.</p><p>本书描述了内核函数和数据结构，引导读者穿行于其间，但是，并没有着重强调使用它们的法则。UTLK 是一本学习指南，而不是编程手册。</p></blockquote><p>这几句话对本书的描述非常到位。基于此，作为指导性原则，我们就可以很有效率地使用它了。</p><p>看一本技术书籍，书中的序言部分绝对是首先应该翻阅的，其次就是目录。我发现在阅读过程中我会频繁的查看目录，甚至是喜欢看目录。</p><h2 id="结尾"><a class="header-anchor" href="#结尾">¶</a>结尾</h2><p>兴趣的力量是无穷的。兴趣能带来激情，如果工作可以和兴趣结合到一起，工作起来才会有热情，那么工作就不只是工作了，更是一种享受。</p><p>Linux，我的兴趣，我的动力，我的方向，我的未来！</p><p>原文连接多处：<br>图片来自：<a href="http://www.360doc.com/content/19/1103/16/36367108_870849346.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/19/1103/16/36367108_870849346.shtml</a><br> <a href="http://www.openpcba.com/web/contents/get?id=4638&amp;tid=15" target="_blank" rel="noopener">http://www.openpcba.com/web/contents/get?id=4638&amp;tid=15</a>【已失效】</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;全文导读&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href&gt;Linux 内核预备工作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;Linux 内核体系结构简析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;Linux 体系结构和内核结构区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;Linux 驱动的 platform 机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;Linux 内核体系结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;内核模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;Linux 内核学习经验总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href&gt;结尾&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://talengu.github.io/public/categories/Linux/"/>
    
    
      <category term="内核开发" scheme="https://talengu.github.io/public/tags/%E5%86%85%E6%A0%B8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>【转】《中华古籍资源库》中国国家图书馆</title>
    <link href="https://talengu.github.io/public/2021/12/16/readings/zhonghuaguji/"/>
    <id>https://talengu.github.io/public/2021/12/16/readings/zhonghuaguji/</id>
    <published>2021-12-16T22:45:31.000Z</published>
    <updated>2021-12-16T22:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>简介</strong></p><p>“中华古籍资源库”是“中华古籍保护计划”的重要成果。2016年9月28日，“中华古籍资源库”正式开通运行，陆续发布国家图书馆藏善本和普通古籍、法国国家图书馆藏敦煌遗书、天津图书馆藏普通古籍、日本永青文库捐赠汉籍、云南省图书馆善本古籍、芷兰斋藏稿抄校本等古籍影像资源，总量超过3.3万部。</p><p>《中华古籍资源库》！！！<br>网址：<a href="http://www.nlc.cn/pcab/zy/zhgj_zyk/" target="_blank" rel="noopener">http://www.nlc.cn/pcab/zy/zhgj_zyk/</a><br>查询：<a href="http://read.nlc.cn/thematDataSearch/toGujiIndex" target="_blank" rel="noopener">http://read.nlc.cn/thematDataSearch/toGujiIndex</a></p><img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216225907506.png" alt="image-20211216225907506" style="zoom:30%;"><a id="more"></a><p>比如：《九章算数》的古籍</p><img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216231340351.png" alt="image-20211216231340351" style="zoom:30%;"><img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216231141739.png" alt="image-20211216231141739" style="zoom:30%;"><p>比如：卷第九的勾股</p><img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216232009068.png" alt="image-20211216232009068" style="zoom:50%;"><ul><li><p>数字古籍国家图书馆收藏古籍15万部，其中善本古籍直接继承了南宋缉熙殿、元翰林国史院、明文渊阁、清内阁大库等皇家珍藏，以及明清以来许多私人藏书家的毕生所聚。宋元旧椠、明清精刻琳琅满目。通过全彩影像数字化和缩微胶卷转化影像方式建设，从2016年9月28日起陆续在线发布，目前已发布馆藏古籍2万余部，国家图书馆超过三分之二的善本古籍实现了在线阅览。</p></li><li><p>数字方志地方志文献为我国所特有，也是国家图书馆独具特色的馆藏之一，所存文献数量与品质极高。该数据库以国家图书馆藏地方志文献建设，主要包括为清代（含清代）以前的方志资源6529种。</p></li><li><p>赵城金藏《赵城金藏》被誉为国家图书馆四大镇馆之宝之一。《赵城金藏》是在金代刻的一部大藏，因为它藏在赵城县（今属山西洪洞县）广胜寺，所以后人将它定名为《赵城金藏》。全藏约七千卷左右，六千多万字，现存四千余卷。2017年12月28日，国家图书馆《赵城金藏》1281件正式发布。</p></li><li><p>宋人文集国家图书馆精选所藏宋人文集善本二百七十五部，首选宋元刊本，次及明清精抄精刻，或经名家校勘题跋之本，通过缩微胶卷还原数字影像，并辅以详细书目建成本全文影像数据库，目前已发布275部，免费呈献公众利用。</p></li><li><p>碑帖菁华以国家图书馆藏有的历代甲骨、青铜器、石刻等类拓片二十三万余件为基础建设的数据库，内容涉及历史、地理、政治、经济、军事、民族、民俗、文学、艺术、科技、建筑等方面。2019年11月12日又新增发布2595种馆藏明清碑刻拓片数字资源，现有元数据2.5万余条，影像3.1万余幅。</p></li><li><p>甲骨世界被誉为二十世纪四大文献发现之一的甲骨文，集文献性、文物性、收藏性于一身，是研究我国商朝晚期不可多得的珍贵史料，该库包括甲骨实物元数据2964条，影像5932幅；甲骨拓片元数据2975条，影像3177幅。</p></li><li><p>西夏文献以国家图书馆保存的西夏、元代孤本及各种西夏的珍贵实物资料为基础建设的数据库。包括西夏文献书目数据124条，原件影像近5000拍。</p></li><li><p>西夏论著包括西夏研究论文篇名数据1200余条。</p></li><li><p>年画撷英国家图书馆收藏了杨柳青、朱仙镇等地制作的4000余幅年画作品，从中精选出一部分制作了该库，并为每种年画编写了内容说明，重点介绍了该年画的故事梗概、历史背景、制作特色和相关知识。目前发布元数据及影像302组。</p></li><li><p>前尘旧影该资源库收录了国家图书馆收藏的新旧照片3074组，真实生动地记录了过去的社会事件、历史人物、城乡面貌、名胜古迹和建筑服饰等，人们可从中解读出不同历史时期特定事物的形象特征和真实信息，具有十分重要的历史价值。</p></li><li><p>敦煌遗珍国际敦煌项目（IDP）建设的数据库，发布来自敦煌和丝绸之路上的写本、绘画、纺织品及器物的信息和图片，其中包括国家图书馆藏敦煌写卷影像18万余拍。</p></li><li><p>徽州善本家谱徽州善本家谱印刷资料数据库是中国国家图书馆与法国远东学院的合作项目，收录了中国国家图书馆藏善本古籍中徽州家谱243种286部，配有书影5437幅。</p></li><li><p>中华医药典籍资源库（测试版）图书馆收藏的文献典籍是整理研究的基础资料，为使读者能够通过互联网检索、利用中医文献资源，国家图书馆（国家古籍保护中心）将逐步建设中华医药典藏资源库，目前首批对221种中医古籍影像进行发布测试。</p></li><li><p>云南图书馆古籍云南省图书馆将该馆古籍数字资源共139种727册提供给国家图书馆（国家古籍保护中心），这批资源均是云南省图书馆所藏珍贵的、有代表性的古籍文献，特别是明代云南丽江木氏土司家族著述，更是明代少数民族汉文著述的代表。该批资源于2019年11月12日正式在线发布。</p></li><li><p>天津图书馆古籍为进一步丰富古籍数字资源品种和版本，满足广大读者使用需求，2014年底，天津图书馆向国家图书馆（国家古籍保护中心）提供总量约5,800余种300万拍明清古籍数字资源，该批资源经加工后，于2018年9月28日、2019年1月28日分两批发布。</p></li><li><p>上海图书馆家谱上海图书馆现藏有家谱近3万余种30余万册共计365个姓氏，收藏的家谱覆盖全国27个省、自治区及直辖市，是国内外收藏中国家谱原件最多的公藏机构，有着“全球中国家谱第一藏”之美誉。国家图书馆与上海图书馆合作，征集该馆所藏明清家谱资源2200余种，在国图网站发布使用。</p></li><li><p>中华古籍善本联合书目中华古籍善本国际联合书目系统是由中文善本书国际联合目录项目发展而来的新数据库，著录了三十余家海内外图书馆所藏古籍善本，数据达2万多条，并配有1.4万余幅书影。</p></li><li><p>东文研汉籍影像库东京大学东洋文化研究所收藏有大量中国古籍，其中包括东方文化学院东京研究所的旧藏以及大木幹一、长泽规矩也、仓石武四郎等各具特色的个人收藏。2009年11月，东洋文化研究所将所藏中文古籍4000余种，以数字化方式无偿提供给中国国家图书馆，在国图网站上面向读者提供服务。</p></li><li><p>哈佛大学善本特藏哈佛大学哈佛燕京图书馆藏中文善本古籍特藏，以其质量之高、数量之大著称于世。为了方便海内外学人便捷地利用这些资料进行研究，同时以数字化形式保存这些中华古籍精品，2009年国家图书馆与哈佛大学哈佛燕京图书达成协议，对哈佛燕京图书馆所藏中文善本和齐如山专藏进行数字化。目前在线发布经部和史部善本数字资源741部，另有齐如山戏曲小说专藏204种。</p></li><li><p>法藏敦煌遗书2015年，在法国国家图书馆与中国国家图书馆达成合作意向，由法国国家图书馆向中国国家图书馆赠送馆藏全部敦煌遗书高清数字资源。在双方共同努力下，实现了这批敦煌遗书的数字化回归，并于2018年3月5日正式在线发布，共计5300余号3.1万余拍。</p></li><li><p>中华寻根网中华寻根网是国家图书馆与澳门基金会开展的文化合作项目，是以提供姓氏源流和家谱资源服务为核心、方便海内外华人寻根问祖活动的网络平台。“中华寻根网”目前提供500多个姓氏源流、2000多部家谱和6000种其他文献的阅览，以及自建家谱，交流联谊的互动服务。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“中华古籍资源库”是“中华古籍保护计划”的重要成果。2016年9月28日，“中华古籍资源库”正式开通运行，陆续发布国家图书馆藏善本和普通古籍、法国国家图书馆藏敦煌遗书、天津图书馆藏普通古籍、日本永青文库捐赠汉籍、云南省图书馆善本古籍、芷兰斋藏稿抄校本等古籍影像资源，总量超过3.3万部。&lt;/p&gt;
&lt;p&gt;《中华古籍资源库》！！！&lt;br&gt;
网址：&lt;a href=&quot;http://www.nlc.cn/pcab/zy/zhgj_zyk/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.nlc.cn/pcab/zy/zhgj_zyk/&lt;/a&gt;&lt;br&gt;
查询：&lt;a href=&quot;http://read.nlc.cn/thematDataSearch/toGujiIndex&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://read.nlc.cn/thematDataSearch/toGujiIndex&lt;/a&gt;&lt;/p&gt;
&lt;img src=&quot;/public/2021/12/16/readings/zhonghuaguji/image-20211216225907506.png&quot; alt=&quot;image-20211216225907506&quot; style=&quot;zoom:30%;&quot;&gt;
    
    </summary>
    
      <category term="书籍" scheme="https://talengu.github.io/public/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="资源" scheme="https://talengu.github.io/public/tags/%E8%B5%84%E6%BA%90/"/>
    
      <category term="古籍" scheme="https://talengu.github.io/public/tags/%E5%8F%A4%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>2021 年科隆游戏展奖项提名名单</title>
    <link href="https://talengu.github.io/public/2021/09/01/2021games/"/>
    <id>https://talengu.github.io/public/2021/09/01/2021games/</id>
    <published>2021-09-01T12:00:00.000Z</published>
    <updated>2021-09-01T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>帝国时代3，现在帝国4！<br>2021 年科隆游戏展奖项提名名单正式公布</p><a id="more"></a><p>8 月 23 日，2021 年科隆游戏展的奖项提名名单已经全部揭晓，本次直接涉及游戏的奖项有 21 个，其中获得提名的游戏分别为：</p><p>最佳微软 Xbox 游戏：《艾尔登法环》（万代南梦宫娱乐）；《孤岛惊魂 6》（育碧）；《光环无限》（微软）</p><p>最佳任天堂 Switch 游戏：《舞力全开 2022》（育碧）；《马里奥 + 疯狂兔子星耀之愿》 (育碧)</p><p>最佳 PC 游戏：《帝国时代 4》(微软)；《艾尔登法环》（万代南梦宫娱乐）；《塞伯利亚之谜: 世界之前》 (Astragon Entertainment)</p><p>最佳索尼 PlayStation 游戏：《艾尔登法环》（万代南梦宫娱乐）；《破晓传说》（万代南梦宫娱乐）；《黑相集：灰冥界》 (万代南梦宫娱乐)</p><p>最佳动作冒险游戏：《艾尔登法环》（万代南梦宫娱乐）；《马里奥 + 疯狂兔子星耀之愿》 (育碧)；《塞伯利亚之谜: 世界之前》 (Astragon Entertainment)</p><p>最佳动作游戏：《孤岛惊魂 6》（育碧）；《光环：无限》（微软）；《彩虹六号：异种》（育碧）</p><p>最佳家庭游戏：《舞力全开 2022》（育碧）；《Run Prop, Run!》（PlayTogether Studio）；《Super Dungeon Maker》 (Rokaplay)</p><p>最佳独立游戏：《Dorfromantik》（Toukana Interactive）；《Inua》（Arte France）；《Lost in Random》（EA）</p><p>最佳角色扮演游戏：《艾尔登法环》（万代南梦宫娱乐）；《Encased》（科赫传媒）；《破晓传说》（万代南梦宫娱乐）</p><p>最佳模拟游戏：《攀登者：天空是极限》(Art Games Studio)；《模拟农场 22》 (Astragon Entertainment)</p><p>最佳体育游戏：《攀登者：天空是极限》(Art Games Studio)；《FIFA22》（EA）；《Riders Republic》（育碧）</p><p>最佳策略游戏：《帝国时代 4》 (微软)；《英雄连 3》 (世嘉)；《马里奥 + 疯狂兔子星耀之愿》 (育碧)</p><p>最佳多人游戏：《光环无限》（微软）；《Riders Republic》（育碧）；《黑相集：灰冥界》 (万代南梦宫娱乐)</p><p>持续时间最长游戏：《Apex 游戏》（EA）；《黑色沙漠》 (Pearl Abyss Corp.)；《末日地带: 隔离的世界》 (Assemble Entertainment)</p><p>最具原创性的游戏：《骰子遗产》（科赫传媒/Destinybit）；《Riders Republic》（育碧）；《Terrorbane》 (轻语互动)</p><p>2021 年科隆游戏展将会于 8 月 25 日至 8 月 29 日举办，将保留现场展览的形式，同时线上数字展形式也将同步举行。</p><hr><p><strong>参考</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;帝国时代3，现在帝国4！&lt;br&gt;
2021 年科隆游戏展奖项提名名单正式公布&lt;/p&gt;
    
    </summary>
    
      <category term="游戏" scheme="https://talengu.github.io/public/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="日常杂记" scheme="https://talengu.github.io/public/tags/%E6%97%A5%E5%B8%B8%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【转】在 C/C++ 程序中打印当前函数调用栈</title>
    <link href="https://talengu.github.io/public/2021/08/25/c_debug/"/>
    <id>https://talengu.github.io/public/2021/08/25/c_debug/</id>
    <published>2021-08-25T23:18:52.000Z</published>
    <updated>2021-08-25T23:18:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>背景</strong></p><p>2011 年 6 月 11 日 <a href="http://www.wuzesheng.com/?author=2" title="由 小武哥 发布" target="_blank" rel="noopener">小武哥</a></p><p>前几天帮同事跟踪的一个程序莫名退出，没有 core dump(当然 ulimit 是打开的) 的问题。我们知道，正常情况下，如果程序因为某种异常条件退出的话，应该会产生 core dump，而如果程序正常退出的话，应该是直接或者间接的调用了 exit() 相关的函数。基于这个事实，我想到了这样一个办法，在程序开始时，通过系统提供的 atexit()，向系统注册一个回调函数，在程序调用 exit() 退出的时候，这个回调函数就会被调用，然后我们在回调函数中打印出当前的函数调用栈，由此便可以知道 exit() 是在哪里调用，从而上述问题便迎刃而解了。上述方法用来解决类似问题是非常行之有效的。在上面，我提到了在 “回调函数中打印出当前的函数调用栈”，相信细心的朋友应该注意到这个了，本文的主要内容就是详细介绍，如何在程序中打印中当前的函数调用栈。</p><a id="more"></a><p>我之前写过一篇题目为《<a href="http://www.wuzesheng.com/?p=1123" target="_blank" rel="noopener">介绍几个关于 C/C++ 程序调试的函数</a>》的文章，看到这里，请读者朋友先看一下前面这篇，因为本文是以前面这篇文章为基础的。我正是用了 backtrace() 和 backtrace_symbols() 这两个函数实现的，下面是一个简单的例子，通过这个例子我们来介绍具体的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo .h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio .h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib .h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stacktrace</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stackstrace begin:\n"</span>);</span><br><span class="line">    print_stacktrace();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun1();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stacktrace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">void</span> * <span class="built_in">array</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> stack_num = backtrace(<span class="built_in">array</span>, size);</span><br><span class="line">    <span class="keyword">char</span> ** stacktrace = backtrace_symbols(<span class="built_in">array</span>, stack_num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stack_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, stacktrace[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(stacktrace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（说明：下面的介绍采用的环境是 ubuntu 11.04, x86_64, gcc-4.5.2）</p><ol><li><p>通过下面的方式编译运行：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ gcc test.cc -o test1</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ ./test1</span><br><span class="line">stackstrace begin:</span><br><span class="line">./test1() [0x400645]</span><br><span class="line">./test1() [0x400607]</span><br><span class="line">./test1() [0x400612]</span><br><span class="line">./test1() [0x40061d]</span><br><span class="line">./test1() [0x4005ed]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xff) [0x7f5c59a91eff]</span><br><span class="line">./test1() [0x400529]</span><br></pre></td></tr></table></figure><p>从上面的运行结果中，我们的确看到了函数的调用栈，但是都是 16 进制的地址，会有点小小的不爽。当然我们可以通过反汇编得到每个地址对应的函数，但这个还是有点麻烦了。不急，且听我慢慢道来，看第 2 步。</p></li><li><p>通过下面的方式编译运行：</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ gcc test.cc -rdynamic -o test2</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ ./test2</span><br><span class="line">stackstrace begin:</span><br><span class="line">./test2(_Z16print_stacktracev+0x26) [0x4008e5]</span><br><span class="line">./test2(_Z4fun1v+0x13) [0x4008a7]</span><br><span class="line">./test2(_Z4fun2v+0x9) [0x4008b2]</span><br><span class="line">./test2(_Z4fun3v+0x9) [0x4008bd]</span><br><span class="line">./test2(main+0x9) [0x40088d]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xff) [0x7f9370186eff]</span><br><span class="line">./test2() [0x4007c9]</span><br></pre></td></tr></table></figure><p>这下终于可以看到函数的名字了，对比一下 2 和 1 的编译过程，2 比 1 多了一个 <strong>- rdynamic</strong> 的选项，让我们来看看这个选项是干什么的 (来自 gcc mannual 的说明):</p><pre><code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rdynamic</span><br><span class="line">Pass the flag -export-dynamic to the ELF linker, on targets that support it. This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. This option is needed for some uses of "dlopen" or to allow obtaining backtraces from within a program.</span><br></pre></td></tr></table></figure></code></pre><p>从上面的说明可以看出，它的主要作用是让链接器把所有的符号都加入到动态符号表中，这下明白了吧。不过这里还有一个问题，这里的函数名都是 mangle 过的，需要 demangle 才能看到原始的函数。关于 c++ 的 mangle/demangle 机制，不了解的朋友可以在搜索引擎上搜一下，我这里就不多就介绍了。这里介绍如何用命令来 demangle，通过 c++filt 命令便可以:</p><pre><code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ c++filt &lt; &lt;&lt; "_Z16print_stacktracev"</span><br><span class="line">print_stacktrace()</span><br></pre></td></tr></table></figure></code></pre><p>写到这里，大部分工作就 ok 了。不过不知道大家有没有想过这样一个问题，同一个函数可以在代码中多个地方调用，如果我们只是知道函数，而不知道在哪里调用的，有时候还是不够方便，bingo，这个也是有办法的，可以通过 address2line 命令来完成，我们用第 2 步中编译出来的 test2 来做实验 (address2line 的 - f 选项可以打出函数名, -C 选项也可以 demangle)：</p><pre><code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ addr2line -a 0x4008a7 -e test2 -f</span><br><span class="line">0x00000000004008a7</span><br><span class="line">_Z4fun1v</span><br><span class="line">??:0</span><br></pre></td></tr></table></figure></code></pre><p>Oh no，怎么打出来的位置信息是乱码呢？不急，且看我们的第 3 步。</p><ol start="3"><li><p>通过下面的方式编译运行：</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ gcc test.cc -rdynamic -g -o test3</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ ./test3</span><br><span class="line">stackstrace begin:</span><br><span class="line">./test3(_Z16print_stacktracev+0x26) [0x4008e5]</span><br><span class="line">./test3(_Z4fun1v+0x13) [0x4008a7]</span><br><span class="line">./test3(_Z4fun2v+0x9) [0x4008b2]</span><br><span class="line">./test3(_Z4fun3v+0x9) [0x4008bd]</span><br><span class="line">./test3(main+0x9) [0x40088d]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xff) [0x7fa9558c1eff]</span><br><span class="line">./test3() [0x4007c9]</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ addr2line -a 0x4008a7 -e test3 -f -C</span><br><span class="line">0x00000000004008a7</span><br><span class="line">fun1()</span><br><span class="line">/home/wuzesheng/work/test/test.cc:20</span><br></pre></td></tr></table></figure></li></ol><p>看上面的结果，我们不仅得到了调用栈，而且可以得到每个函数的名字，以及被调用的位置，大功告成。在这里需要说明一下的是，第 3 步比第 2 步多了一个 - g 选项，-g 选项的主要作用是生成调试信息，位置信息就属于调试信息的范畴，经常用 gdb 的朋友相信不会对这个选项感到陌生。</p><h3 id="在-C-C-程序里打印调用栈信息"><a class="header-anchor" href="#在-C-C-程序里打印调用栈信息">¶</a>在 C/C++ 程序里打印调用栈信息</h3><p>我们知道，GDB 的 backtrace 命令可以查看堆栈信息。但很多时候，GDB 根本用不上。比如说，在线上环境中可能没有 GDB，即使有，也不太可能让我们直接在上面调试。如果能让程序自己输出调用栈，那是最好不过了。本文介绍和调用椎栈相关的几个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">    backtrace, backtrace_symbols, backtrace_symbols_fd - support <span class="keyword">for</span> application self-debugging</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">void</span> **buffer, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> **<span class="title">backtrace_symbols</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">const</span> *buffer, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace_symbols_fd</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">const</span> *buffer, <span class="keyword">int</span> size, <span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>以上内容源自这几个函数的 man 手册。</p><p>先简单介绍一下这几个函数的功能：<strong>backtrace</strong>：获取当前的调用栈信息，结果存储在 buffer 中，返回值为栈的深度，参数 size 限制栈的最大深度，即最大取 size 步的栈信息。<strong>backtrace_symbols</strong>：把 backtrace 获取的栈信息转化为字符串，以字符指针数组的形式返回，参数 size 限定转换的深度，一般用 backtrace 调用的返回值。<strong>backtrace_symbols_fd</strong>：它的功能和 backtrace_symbols 差不多，只不过它不把转换结果返回给调用方，而是写入 fd 指定的文件描述符。</p><p>Man 手册里，给出了一个简单的实例，我们看一下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  SIZE 100 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, nptrs;</span><br><span class="line">    <span class="keyword">void</span> *buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span> **strings;</span><br><span class="line">    nptrs = backtrace(buffer, SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"backtrace() returned %d addresses\n"</span>, nptrs);</span><br><span class="line">      </span><br><span class="line"> <span class="comment">/* The call backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)  </span></span><br><span class="line"><span class="comment">  *  would produce similar output to the following: */</span></span><br><span class="line">        strings = backtrace_symbols(buffer, nptrs);</span><br><span class="line">    <span class="keyword">if</span> (strings == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"backtrace_symbols"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nptrs; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strings[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(strings);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* "static" means don't export the symbol... */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myfunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myfunc3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> ncalls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ncalls &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        myfunc(ncalls - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        myfunc2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">if</span>  (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s num-calls\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);  </span><br><span class="line">    &#125;</span><br><span class="line">    myfunc(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cc prog.c -o prog</span></span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./prog 0</span></span><br><span class="line">backtrace() returned 6 addresses</span><br><span class="line">./prog() [0x80485a3]</span><br><span class="line">./prog() [0x8048630]</span><br><span class="line">./prog() [0x8048653]</span><br><span class="line">./prog() [0x80486a7]</span><br></pre></td></tr></table></figure><p>这样，是输出了调用栈，不过只是以十六进制输出函数地址而已，可读性很差。仔细看下 man 手册，原来很简单，编译时加上个参数：</p><p>重新编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cc -rdynamic  prog.c -o prog</span></span><br></pre></td></tr></table></figure><p>通过 gcc 手册，我们可以也解下参数的说明:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-rdynamic</span><br><span class="line">        Pass the flag -export-dynamic to the ELF linker, on targets that support it. This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. This option is needed for some uses of "dlopen" or to allow obtaining backtraces from within a program.</span><br></pre></td></tr></table></figure><p>再执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./prog 0</span></span><br><span class="line">backtrace() returned 6 addresses</span><br><span class="line">./prog(myfunc3+0x1f) [0x8048763]</span><br><span class="line">./prog() [0x80487f0]</span><br><span class="line">./prog(myfunc+0x21) [0x8048813]</span><br><span class="line">./prog(main+0x52) [0x8048867]</span><br><span class="line">/lib/libc.so.6(__libc_start_main+0xe6) [0xaf9cc6]</span><br><span class="line">./prog() [0x80486b1]</span><br></pre></td></tr></table></figure><p>这回，可以看到函数名了。是不是很酷呢？把它封装到你的调试代码中吧。</p><hr><p><strong>原地址</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2011 年 6 月 11 日 &lt;a href=&quot;http://www.wuzesheng.com/?author=2&quot; title=&quot;由 小武哥 发布&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小武哥&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前几天帮同事跟踪的一个程序莫名退出，没有 core dump(当然 ulimit 是打开的) 的问题。我们知道，正常情况下，如果程序因为某种异常条件退出的话，应该会产生 core dump，而如果程序正常退出的话，应该是直接或者间接的调用了 exit() 相关的函数。基于这个事实，我想到了这样一个办法，在程序开始时，通过系统提供的 atexit()，向系统注册一个回调函数，在程序调用 exit() 退出的时候，这个回调函数就会被调用，然后我们在回调函数中打印出当前的函数调用栈，由此便可以知道 exit() 是在哪里调用，从而上述问题便迎刃而解了。上述方法用来解决类似问题是非常行之有效的。在上面，我提到了在 “回调函数中打印出当前的函数调用栈”，相信细心的朋友应该注意到这个了，本文的主要内容就是详细介绍，如何在程序中打印中当前的函数调用栈。&lt;/p&gt;
    
    </summary>
    
      <category term="c语言" scheme="https://talengu.github.io/public/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://talengu.github.io/public/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>RSS跟踪github文件更新+某管子更新</title>
    <link href="https://talengu.github.io/public/2021/07/24/rss_github_file/"/>
    <id>https://talengu.github.io/public/2021/07/24/rss_github_file/</id>
    <published>2021-07-24T12:00:00.000Z</published>
    <updated>2021-07-24T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>好久没有更新博客了。RSS这种形式的信息获取方式，似乎又流行起来。</p><a id="more"></a><h2 id="github文件更新"><a class="header-anchor" href="#github文件更新">¶</a>github文件更新</h2><p>github上面有很多不错的资源。我的流程是：github readme文件更新-&gt;svn下载对应文件-&gt;生成rss文件。</p><p>这里为什么要这么复杂，因为github仓库更新多了好多不需要的rss信息，而且github文件下载比较慢。</p><p>最后效果，获取《经济学人》和《纽约客》的更新～</p><p><img src="/public/2021/07/24/rss_github_file/rss_result.png" alt="image-20210724005152399"></p><h3 id="下载脚本"><a class="header-anchor" href="#下载脚本">¶</a>下载脚本</h3><p>解析readme中的地址，自动下载，并生成rss源。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># /etc/cron.hour </span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> rfeed <span class="keyword">import</span> * <span class="comment"># 为生成rss.xml的库</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line">URL=<span class="string">"https://raw.githubusercontent.com/hehonghui/the-economist-ebooks/master/README.md"</span></span><br><span class="line">BASE_URL=<span class="string">"http://your_vps_host/download/"</span></span><br><span class="line"></span><br><span class="line">SVN_BASE_URL=<span class="string">"https://github.com/hehonghui/the-economist-ebooks/trunk/"</span></span><br><span class="line"></span><br><span class="line">s=<span class="string">"""</span></span><br><span class="line"><span class="string">* [经济学人 - 周刊, 点击这里下载最新一期](01_economist/te_2021.02.27) , 每周五十一点更新</span></span><br><span class="line"><span class="string">* [纽约客 - 周刊, 点击这里下载最新一期](02_new_yorker/2021.03.01) , 每周六上午更新</span></span><br><span class="line"><span class="string">* [卫报 - 每周两期](09_guardian/), 每周三、周日更新</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">s = request.urlopen(URL).read().decode(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">res= re.findall(<span class="string">r"\[.+\]\((0.+)\)"</span>,s)[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># generate xml</span></span><br><span class="line">res_list=[]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">res_list+=sorted(glob(item.split(<span class="string">'/'</span>)[<span class="number">0</span>]+<span class="string">"/*"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">item_list=[]</span><br><span class="line">print(item_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> res_list:</span><br><span class="line">    _one = Item(</span><br><span class="line">title = item[<span class="number">3</span>:],</span><br><span class="line">        link = BASE_URL+item,</span><br><span class="line">description = <span class="string">'pdf etc. &lt;a href="%s"&gt;link&lt;/a&gt; '</span>% (BASE_URL+item),</span><br><span class="line">        author = <span class="string">"hehonghui"</span>,</span><br><span class="line">        guid = Guid(BASE_URL+item),</span><br><span class="line">        pubDate = datetime.datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>)) <span class="comment"># year, month, date, hh, mm, ss</span></span><br><span class="line">    item_list+=[_one]</span><br><span class="line"></span><br><span class="line">feed = Feed(</span><br><span class="line">        title = <span class="string">"经济学人+纽约客更新"</span>,</span><br><span class="line">        link = <span class="string">"https://www.xxxxx.biz/atom/updated.xml"</span>,</span><br><span class="line">        description = <span class="string">"更新经济学人，纽约客"</span>,</span><br><span class="line">        language = <span class="string">"en-US"</span>,</span><br><span class="line">        lastBuildDate = datetime.datetime.now(),</span><br><span class="line">        items = item_list)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_file</span><span class="params">(file_name, contents)</span>:</span></span><br><span class="line">    fh = open(file_name, <span class="string">'w'</span>)</span><br><span class="line">    fh.write(contents)</span><br><span class="line">    fh.close()</span><br><span class="line"></span><br><span class="line">save_to_file(<span class="string">'test.xml'</span>, feed.rss())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># start downing </span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> res_list:</span><br><span class="line">    print(<span class="string">"downing %s"</span>%item)</span><br><span class="line">    os.popen(<span class="string">"svn checkout %s %s"</span>%(SVN_BASE_URL+item,item))</span><br><span class="line"></span><br><span class="line">    _now=sorted(glob(item.split(<span class="string">'/'</span>)[<span class="number">0</span>]+<span class="string">"/*"</span>))</span><br><span class="line">    print(_now)</span><br><span class="line">    <span class="keyword">if</span> len(_now)&gt;=<span class="number">5</span>: <span class="comment"># 最多5个，免得服务器下载过多。</span></span><br><span class="line">        <span class="keyword">for</span> _d <span class="keyword">in</span> _now[:<span class="number">-5</span>]:</span><br><span class="line">            os.popen(<span class="string">"rm -rf %s"</span>%_d)</span><br></pre></td></tr></table></figure><p>在linux亦可使用<a href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html" target="_blank" rel="noopener">crontab</a>定时启动下载任务。在 <code>/etc/cron.hourly/</code> 设置即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">date &gt;&gt; test.log</span><br><span class="line">python3 down_ecomic.py &gt;&gt;test.log</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><h2 id="下载某管音频，自动转成mp3格式"><a class="header-anchor" href="#下载某管音频，自动转成mp3格式">¶</a>下载某管音频，自动转成mp3格式</h2><p>某管自带rss的，所以只要用feedparser解析一下，然后调用youtube_dl下载一哈。各种码包自行安装，哈。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2020-04-18</span></span><br><span class="line"><span class="comment"># /etc/cron.hour # https://www.runoob.com/w3cnote/linux-crontab-tasks.html</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> rfeed <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line">URL=<span class="string">"https://www.youtube.com/feeds/videos.xml?channel_id=UCFhp6N5z8W9Ann2eyHAzbbA"</span></span><br><span class="line">rss = feedparser.parse(URL)</span><br><span class="line">entries=rss[<span class="string">'entries'</span>][:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">BASE_URL=<span class="string">"http://xxxxx/down_youtube/"</span></span><br><span class="line"></span><br><span class="line">item_list=[]</span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> entries:</span><br><span class="line">    print(entry[<span class="string">'title'</span>])</span><br><span class="line">    print(entry[<span class="string">'published'</span>])</span><br><span class="line">    print(entry[<span class="string">'link'</span>])</span><br><span class="line">    <span class="comment">#print(entry['summary'])</span></span><br><span class="line">    new_link=BASE_URL+<span class="string">"book_audios/%s.mp3"</span>%entry[<span class="string">'yt_videoid'</span>]</span><br><span class="line">    _one = Item(</span><br><span class="line">title = entry[<span class="string">'title'</span>],</span><br><span class="line">        link = new_link,</span><br><span class="line">description = <span class="string">'audio: &lt;a href="%s"&gt;mp3&lt;/a&gt; %s'</span>% (new_link,entry[<span class="string">'summary'</span>]),</span><br><span class="line">        author = <span class="string">"Youtube"</span>,</span><br><span class="line">        guid = Guid(new_link),</span><br><span class="line">        pubDate = datetime.datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>)) <span class="comment"># year, month, date, hh, mm, ss</span></span><br><span class="line">    item_list+=[_one]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">feed = Feed(</span><br><span class="line">        title = <span class="string">"知乎读书会更新"</span>,</span><br><span class="line">        link = <span class="string">"https://www.xxxxx.biz/atom/updated.xml"</span>,</span><br><span class="line">        description = <span class="string">"更新Youtube知乎读书会"</span>,</span><br><span class="line">        language = <span class="string">"en-US"</span>,</span><br><span class="line">        lastBuildDate = datetime.datetime.now(),</span><br><span class="line">        items = item_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_file</span><span class="params">(file_name, contents)</span>:</span></span><br><span class="line">    fh = open(file_name, <span class="string">'w'</span>)</span><br><span class="line">    fh.write(contents)</span><br><span class="line">    fh.close()</span><br><span class="line"></span><br><span class="line">save_to_file(<span class="string">'audio.xml'</span>, feed.rss())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> rename</span><br><span class="line"><span class="keyword">import</span> youtube_dl</span><br><span class="line"></span><br><span class="line"><span class="comment"># start downing </span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">"book_audios/"</span>):</span><br><span class="line">    os.makedirs(<span class="string">"book_audios/"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">audio_download</span><span class="params">(youtube_url)</span>:</span></span><br><span class="line">    <span class="comment"># 定义某些下载参数</span></span><br><span class="line">    ydl_opts = &#123;</span><br><span class="line">        <span class="string">'format'</span>: <span class="string">'bestaudio/best'</span>,</span><br><span class="line">     <span class="comment">#   'download_archive': 'downloaded_songs.txt',</span></span><br><span class="line">        <span class="string">'outtmpl'</span>: <span class="string">'book_audios/%(id)s.%(ext)s'</span>,</span><br><span class="line">        <span class="string">'postprocessors'</span>: [&#123;</span><br><span class="line">            <span class="string">'key'</span>: <span class="string">'FFmpegExtractAudio'</span>,</span><br><span class="line">            <span class="string">'preferredcodec'</span>: <span class="string">'mp3'</span>,</span><br><span class="line">            <span class="string">'preferredquality'</span>: <span class="string">'192'</span>,</span><br><span class="line">            &#125;],</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> youtube_dl.YoutubeDL(ydl_opts) <span class="keyword">as</span> ydl:</span><br><span class="line">        ydl.download([youtube_url])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#download('https://www.youtube.com/watch?v=JElpSrsmbTU')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> entries:</span><br><span class="line">    <span class="keyword">if</span> entry[<span class="string">'yt_videoid'</span>]+<span class="string">'.mp3'</span> <span class="keyword">not</span> <span class="keyword">in</span> os.listdir(<span class="string">'book_audios'</span>):</span><br><span class="line">        print(<span class="string">"downing %s, %s"</span>%(entry[<span class="string">'title'</span>], entry[<span class="string">'link'</span>]))</span><br><span class="line">        audio_download(entry[<span class="string">'link'</span>])</span><br><span class="line">   </span><br><span class="line">    _now=sorted(glob(<span class="string">"book_audios/*"</span>),key=os.path.getctime)</span><br><span class="line">    print(_now)</span><br><span class="line">    <span class="keyword">if</span> len(_now)&gt;=<span class="number">6</span>: <span class="comment"># 多余删除</span></span><br><span class="line">        <span class="keyword">for</span> _d <span class="keyword">in</span> _now[:<span class="number">-5</span>]:</span><br><span class="line">            os.popen(<span class="string">"rm -rf %s"</span>%_d)</span><br></pre></td></tr></table></figure><h2 id="下载某管视频"><a class="header-anchor" href="#下载某管视频">¶</a>下载某管视频</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2020-04-18</span></span><br><span class="line"><span class="comment"># /etc/cron.hour # https://www.runoob.com/w3cnote/linux-crontab-tasks.html</span></span><br><span class="line"><span class="comment"># pip install feedparser youtube_dl</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> rfeed <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> rename</span><br><span class="line"><span class="keyword">import</span> youtube_dl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_file</span><span class="params">(file_name, contents)</span>:</span></span><br><span class="line">    fh = open(file_name, <span class="string">'w'</span>)</span><br><span class="line">    fh.write(contents)</span><br><span class="line">    fh.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">audio_download</span><span class="params">(youtube_url, file_root, only_audio=False)</span>:</span></span><br><span class="line">    <span class="comment"># 定义某些下载参数</span></span><br><span class="line">    ydl_opts = &#123;</span><br><span class="line">        <span class="string">'format'</span>: <span class="string">'best'</span>,</span><br><span class="line">        <span class="string">'outtmpl'</span>: file_root+<span class="string">'/%(id)s.%(ext)s'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment"># 定义某些下载参数</span></span><br><span class="line">    ydl_opts_a = &#123;</span><br><span class="line">        <span class="string">'format'</span>: <span class="string">'bestaudio/best'</span>,</span><br><span class="line">     <span class="comment">#   'download_archive': 'downloaded_songs.txt',</span></span><br><span class="line">        <span class="string">'outtmpl'</span>: file_root+<span class="string">'/%(id)s.%(ext)s'</span>,</span><br><span class="line">        <span class="string">'postprocessors'</span>: [&#123;</span><br><span class="line">            <span class="string">'key'</span>: <span class="string">'FFmpegExtractAudio'</span>,</span><br><span class="line">            <span class="string">'preferredcodec'</span>: <span class="string">'mp3'</span>,</span><br><span class="line">            <span class="string">'preferredquality'</span>: <span class="string">'192'</span>,</span><br><span class="line">            &#125;],</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> only_audio:</span><br><span class="line">        ydl_opts = ydl_opts_a</span><br><span class="line">    <span class="keyword">with</span> youtube_dl.YoutubeDL(ydl_opts) <span class="keyword">as</span> ydl:</span><br><span class="line">        ydl.download([youtube_url])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YoutubeDowner</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, yurl, burl, file_root, feed_title, only_audio=False)</span>:</span></span><br><span class="line">        self.yurl = yurl</span><br><span class="line">        self.burl = burl</span><br><span class="line">        self.file_root = file_root</span><br><span class="line">        self.feed_title = feed_title</span><br><span class="line">        self.feed_des = feed_title</span><br><span class="line">        self.only_audio = only_audio</span><br><span class="line">        self.type_name = <span class="string">"mp4"</span></span><br><span class="line">        <span class="keyword">if</span> only_audio:</span><br><span class="line">            self.type_name = <span class="string">"mp3"</span></span><br><span class="line"></span><br><span class="line">        rss = feedparser.parse(yurl)</span><br><span class="line">        self.entries = rss[<span class="string">'entries'</span>][:<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_root):</span><br><span class="line">            os.makedirs(file_root)</span><br><span class="line">        self.generate_xml()</span><br><span class="line"></span><br><span class="line">        self.down()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_xml</span><span class="params">(self)</span>:</span></span><br><span class="line">        item_list = []</span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> self.entries:</span><br><span class="line">            print(entry[<span class="string">'title'</span>],entry[<span class="string">'published'</span>],entry[<span class="string">'link'</span>])</span><br><span class="line">           <span class="comment"># print(entry['summary'])</span></span><br><span class="line">            date_s = entry[<span class="string">'published'</span>].split(<span class="string">'T'</span>)[<span class="number">0</span>].split(<span class="string">'-'</span>)</span><br><span class="line">            dates = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> date_s]</span><br><span class="line">            <span class="comment"># print(dates)</span></span><br><span class="line">            new_link = self.burl + <span class="string">"/%s.%s"</span> % (entry[<span class="string">'yt_videoid'</span>],self.type_name) <span class="comment"># 下载的实际地址</span></span><br><span class="line">            print(<span class="string">'%s: &lt;a href="%s"&gt;%s&lt;/a&gt; &lt;pre&gt;%s&lt;/pre&gt;'</span> % (self.type_name,new_link,self.type_name,entry[<span class="string">'summary'</span>]))</span><br><span class="line">            _one = Item(</span><br><span class="line">                    title = entry[<span class="string">'title'</span>],</span><br><span class="line">                link = new_link,</span><br><span class="line">                description = <span class="string">'%s: &lt;a href="%s"&gt;%s&lt;/a&gt; &lt;pre&gt;%s&lt;/pre&gt;'</span> % (self.type_name,new_link,self.type_name,entry[<span class="string">'summary'</span>]),</span><br><span class="line">                author = <span class="string">"Youtube"</span>,</span><br><span class="line">                guid = Guid(new_link),</span><br><span class="line">                pubDate = datetime.datetime(dates[<span class="number">0</span>], dates[<span class="number">1</span>], dates[<span class="number">2</span>], <span class="number">6</span>, <span class="number">0</span>)) <span class="comment"># year, month, date, hh, mm, ss</span></span><br><span class="line">            item_list+=[_one]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        feed = Feed(</span><br><span class="line">                title = self.feed_title,</span><br><span class="line">                link = <span class="string">"https://www.xxxxx.biz/atom/updated.xml"</span>,</span><br><span class="line">                description = self.feed_des,</span><br><span class="line">                language = <span class="string">"en-US"</span>,</span><br><span class="line">                lastBuildDate = datetime.datetime.now(),</span><br><span class="line">                items = item_list)</span><br><span class="line"></span><br><span class="line">        save_to_file(<span class="string">'%s.xml'</span> % self.file_root, feed.rss())</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">down</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> self.entries:</span><br><span class="line">            <span class="keyword">if</span> entry[<span class="string">'yt_videoid'</span>]+<span class="string">'.'</span>+self.type_name <span class="keyword">not</span> <span class="keyword">in</span> os.listdir(self.file_root):</span><br><span class="line">                print(<span class="string">"downing %s, %s"</span>%(entry[<span class="string">'title'</span>], entry[<span class="string">'link'</span>]))</span><br><span class="line">                audio_download(entry[<span class="string">'link'</span>], self.file_root, self.only_audio)</span><br><span class="line">    </span><br><span class="line">        _now = sorted(glob(self.file_root + <span class="string">"/*"</span>),key=os.path.getctime)</span><br><span class="line">        print(_now)</span><br><span class="line">        <span class="keyword">if</span> len(_now)&gt;=<span class="number">6</span>: <span class="comment"># 多余删除</span></span><br><span class="line">            <span class="keyword">for</span> _d <span class="keyword">in</span> _now[:<span class="number">-5</span>]:</span><br><span class="line">                os.popen(<span class="string">"rm -rf %s"</span>%_d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># url_rss = "https://www.youtube.com/feeds/videos.xml?channel_id=UCSs4A6HYKmHA2MG_0z-F0xw"</span></span><br><span class="line"><span class="comment"># url_base="http://xxxxx/"</span></span><br><span class="line"><span class="comment"># root="rss2"</span></span><br><span class="line"><span class="comment"># title="李永乐老师"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># YoutubeDowner(url_rss, url_base, root, title)</span></span><br></pre></td></tr></table></figure><p>最后效果如下：</p><p><img src="/public/2021/07/24/rss_github_file/20220511-00-35-57.png" alt></p><p>祝大家使用愉快！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好久没有更新博客了。RSS这种形式的信息获取方式，似乎又流行起来。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://talengu.github.io/public/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="RSS" scheme="https://talengu.github.io/public/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>选择困难者的福音？层次分析法</title>
    <link href="https://talengu.github.io/public/2021/04/02/math_AHP/"/>
    <id>https://talengu.github.io/public/2021/04/02/math_AHP/</id>
    <published>2021-04-02T12:00:00.000Z</published>
    <updated>2021-04-02T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>摘要</strong></p><p>日常生活中，我们面临很多的选择，选择工作offer，选择买哪个牌子的手机，选择哪个地方旅行等等。这些选择难以定量的衡量，有很多不确定性。内心小纠结，我选择了这个，万一那个好呢，怎么办？请看层次分析法。</p><p>层次分析法(Analytic Hierarchy Process，简称 AHP)是对一些较为复杂、较为模糊的问题作出决策的简易方法，它特别适用于那些难于完全定量分析的问题。它是美国运筹学家 T. L. Saaty 教授于上世纪 70 年代初期提出的一种简便、灵活而又实用的多准则决策方法。</p><p>运用层次分析法建模，大体上可按下面四个步骤进行</p><ul><li>建立递阶层次结构模型</li><li>构造出各层次中的所有判断矩阵</li><li>层次单排序及一致性检验</li><li>层次总排序及一致性检验。（一般不用）</li></ul><a id="more"></a><p>让我们从offer大佬的例子开始吧！</p><p>举个栗子，今年有位大学生，有三个offer，C1 C2 C3。</p><p>第一步，建立层次模型。</p><ul><li>目标层A：找工作的目标，自己满意程度。<ul><li>这个程度怎么计算呢？比如工作1。</li></ul></li><li>准则层B：研究课题、发展前途、待遇、同事情况、地理位置、单位名气等等。<ul><li>尽量列全一点，不需要排列重要顺序。</li><li>小于等于9个，后面要两两拍脑袋给出相对的重要层度，给多了不得把脑袋拍疼了。</li><li>也可以有子准则层，比如待遇中的放假、工作环境等等，列出也小于9个。</li></ul></li><li>方案层C：就是我们的offer</li></ul><img src="/public/2021/04/02/math_AHP/image-20200406145535585.png" alt="image-20200406145535585" style="zoom:50%;"><h2 id="构造-A-B-之间判断矩阵"><a class="header-anchor" href="#构造-A-B-之间判断矩阵">¶</a>构造 A B 之间判断矩阵</h2><p>准则层B与目标A之间的关系。为了求出准则层中(B1-6) 对目标的重要层度的排序。比如对于该生工作满意度第一重要是待遇，然后是地点，其实该生自己也很模糊。就是固定A，然后求B中准则，对A重要性的排序。</p><h3 id="我们怎么对B中的准则们的重要排序呢？"><a class="header-anchor" href="#我们怎么对B中的准则们的重要排序呢？">¶</a>我们怎么对B中的准则们的重要排序呢？</h3><p>直接给每一个准则，0-1的评分，然后排序。经常会想，给完分之后，这个不合理呀要不我再给哪个准则加加分。所以这样的方法常常会因考虑不周全、顾此失彼而使决策者提出与他实际认为的重要性程度不相一致的数据。</p><p>我们可以将这个过程细化，我就比较两个准则对于目标的重要性，然后通过下面的矩阵方法，求出优先顺序。</p><p>还能通过一个一致性检验，来检验在你评分的过程中，有没有自相矛盾的地方，当然这种方法允许一些自相矛盾。反正评分的时候尊从内心拍脑袋就对了。</p><p>所以我们拿出一个B1 与 B2 对于目标的重要，想一想然后给出B2/B1，填入下面的表格中的(2,1)的位置。</p><p>整个矩阵i,j 与j，i 是取倒数的关系，所以只要做一半。</p><p>在找工作的目标下，准则i与j相对的重要性表示，B2/B1 的值。采用9个标度。而相比不重要刻度取倒数就可以了</p><table><thead><tr><th>准则i比j的比较</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td></td><td>相同重要</td><td></td><td>比较重要</td><td></td><td>明显重要</td><td></td><td>强烈重要</td><td></td><td>极端重要</td></tr></tbody></table><p>最后的两两相对重要表格</p><img src="/public/2021/04/02/math_AHP/image-20200406145640316.png" alt="image-20200406145640316" style="zoom:50%;"><p>对角线对称的两个数互为倒数，即 $$a_{ji}=\frac{1}{a_{ij}}$$  B1/B2 不就是和 B2/B1互为倒数嘛</p><p>从心理学观点来看，分级太多会超越人们的判断能力，既增加了作判断的难度， 又容易因此而提供虚假数据。Saaty 等人还用实验方法比较了在各种不同标度下人们判断结果的正确性，实验结果也表明，采用 1~9 标度最为合适。</p><p>判断矩阵的一致性指标步骤：</p><ul><li>1）计算一致性指标 CI 。$$CI=\frac{ \lambda_{max}-n}{n-1}$$</li><li>2）查表，平均随机一致性指标 RI。</li></ul><table><thead><tr><th>n</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>RI</td><td>0</td><td>0</td><td>0.58</td><td>0.90</td><td>1.12</td><td>1.24</td><td>1.32</td><td>1.41</td><td>1.45</td></tr></tbody></table><blockquote><p><em>RI</em> 的值是这样得到的，用随机方法构造500个样本矩阵:随机地从1~9及其倒数中抽取数字构造正互反矩阵，求得最大特征根的平均值 $$\bar \lambda_{max}$$ 并定义$$RI=\frac{\bar \lambda_{max}-n}{n-1}$$</p></blockquote><ul><li>3）计算一致性比例CR。 $$CR=\frac{CI}{RI}$$，当$$CR&lt;0.10$$ 时，认为判断矩阵的一致性是可以接受的，否则应对判断矩阵作适当修正。</li></ul><p>如果一个矩阵满足上面的条件，那么它最大特征值对应的特征向量就可以认为是每个维度的重要性权重。</p><h2 id="构造-B-C-之间判断矩阵"><a class="header-anchor" href="#构造-B-C-之间判断矩阵">¶</a>构造 B C 之间判断矩阵</h2><p>相同的方法，在同一B准则下，考虑不同工作的优先顺序。求工作排序的方法，和上面一样。</p><img src="/public/2021/04/02/math_AHP/image-20200406162644137.png" alt="image-20200406162644137" style="zoom:50%;"><p>python代码<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AHP</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, criteria, b)</span>:</span></span><br><span class="line">        self.RI = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.58</span>, <span class="number">0.9</span>, <span class="number">1.12</span>, <span class="number">1.24</span>, <span class="number">1.32</span>, <span class="number">1.41</span>, <span class="number">1.45</span>, <span class="number">1.49</span>)</span><br><span class="line">        self.criteria = criteria</span><br><span class="line">        self.b = b</span><br><span class="line">        self.num_criteria = criteria.shape[<span class="number">0</span>]</span><br><span class="line">        self.num_project = b[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cal_weights</span><span class="params">(self, input_matrix)</span>:</span></span><br><span class="line">        input_matrix = np.array(input_matrix)</span><br><span class="line">        n, n1 = input_matrix.shape</span><br><span class="line">        <span class="keyword">assert</span> n == n1, <span class="string">'不是一个方阵'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> np.abs(input_matrix[i, j] * input_matrix[j, i] - <span class="number">1</span>) &gt; <span class="number">1e-7</span>:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(<span class="string">'不是反互对称矩阵'</span>)</span><br><span class="line"></span><br><span class="line">        eigenvalues, eigenvectors = np.linalg.eig(input_matrix)</span><br><span class="line"></span><br><span class="line">        max_idx = np.argmax(eigenvalues)</span><br><span class="line">        max_eigen = eigenvalues[max_idx].real</span><br><span class="line">        eigen = eigenvectors[:, max_idx].real</span><br><span class="line">        eigen = eigen / eigen.sum()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">9</span>:</span><br><span class="line">            CR = <span class="literal">None</span></span><br><span class="line">            warnings.warn(<span class="string">'无法判断一致性'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            CI = (max_eigen - n) / (n - <span class="number">1</span>)</span><br><span class="line">            CR = CI / self.RI[n]</span><br><span class="line">        <span class="keyword">return</span> max_eigen, CR, eigen</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        max_eigen, CR, criteria_eigen = self.cal_weights(self.criteria)</span><br><span class="line">        print(<span class="string">'准则层：最大特征值&#123;:&lt;5f&#125;,CR=&#123;:&lt;5f&#125;,检验&#123;&#125;通过'</span>.format(max_eigen, CR, <span class="string">''</span> <span class="keyword">if</span> CR &lt; <span class="number">0.1</span> <span class="keyword">else</span> <span class="string">'不'</span>))</span><br><span class="line">        print(<span class="string">'准则层权重=&#123;&#125;\n'</span>.format(criteria_eigen))</span><br><span class="line"></span><br><span class="line">        max_eigen_list, CR_list, eigen_list = [], [], []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.b:</span><br><span class="line">            max_eigen, CR, eigen = self.cal_weights(i)</span><br><span class="line">            max_eigen_list.append(max_eigen)</span><br><span class="line">            CR_list.append(CR)</span><br><span class="line">            eigen_list.append(eigen)</span><br><span class="line"></span><br><span class="line">        pd_print = pd.DataFrame(eigen_list,</span><br><span class="line">                                index=[<span class="string">'准则'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num_criteria)],</span><br><span class="line">                                columns=[<span class="string">'方案'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num_project)],</span><br><span class="line">                                )</span><br><span class="line">        pd_print.loc[:, <span class="string">'最大特征值'</span>] = max_eigen_list</span><br><span class="line">        pd_print.loc[:, <span class="string">'CR'</span>] = CR_list</span><br><span class="line">        pd_print.loc[:, <span class="string">'一致性检验'</span>] = pd_print.loc[:, <span class="string">'CR'</span>] &lt; <span class="number">0.1</span></span><br><span class="line">        print(<span class="string">'方案层'</span>)</span><br><span class="line">        print(pd_print)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 目标层</span></span><br><span class="line">        obj = np.dot(criteria_eigen.reshape(<span class="number">1</span>, <span class="number">-1</span>), np.array(eigen_list))</span><br><span class="line">        print(<span class="string">'\n目标层'</span>, obj)</span><br><span class="line">        print(<span class="string">'最优选择是方案&#123;&#125;'</span>.format(np.argmax(obj)))</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 准则重要性矩阵</span></span><br><span class="line">    criteria = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">7</span>, <span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span> / <span class="number">3</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">5</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">5</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对每个准则，方案优劣排序</span></span><br><span class="line">    b1 = np.array([[<span class="number">1</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span> / <span class="number">8</span>], [<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">3</span>], [<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>]])</span><br><span class="line">    b2 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span> / <span class="number">5</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">    b3 = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span>]])</span><br><span class="line">    b4 = np.array([[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">    b5 = np.array([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span> / <span class="number">2</span>], [<span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">4</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    b = [b1, b2, b3, b4, b5]</span><br><span class="line">    a = AHP(criteria, b).run()</span><br></pre></td></tr></table></figure><h2 id="层次分析法与控制变量法"><a class="header-anchor" href="#层次分析法与控制变量法">¶</a>层次分析法与控制变量法</h2><p>我们的任务是选择工作，最后使得我们满意，直接选择我们当然一头雾水。所以我们设立一些准则，然后对这些准则对于目标的重要性排序。</p><p>这又有点像概率图模型，只是赋权的方法，是相互比较的方法。</p><h2 id="选择困难者的福音？"><a class="header-anchor" href="#选择困难者的福音？">¶</a>选择困难者的福音？</h2><p>层次分析法对人们的思维过程进行了加工整理，提出了一套系统分析问题的方法，为科学管理和决策提供了较有说服力的依据。</p><p>在应用层次分析法研究问题时，遇到的主要困难有两个:(1) 如何根据实际情况抽象出较为贴切的层次结构;(2) 如何将某些定性的量作比较接近实际定量化处理。</p><p>层次分析法的其局限性<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：(1) 它在很大程度上依赖于人们的经验，主观因素的影响很大，它至多只能排除思维过程中的严重非一致性，却无法排除决策者个人可能存在的严重片面性。(2) 比较、 判断过程较为粗糙，不能用于精度要求较高的决策问题。</p><p>所以，AHP 至多只能算是一种半定量(或定性与定量结合)的方法。本文仅供参考，不负法律责任，哈哈。</p><p>参考</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>幼鹰me 知乎 <a href="https://zhuanlan.zhihu.com/p/101505929" target="_blank" rel="noopener">层次分析法原理与Python实现</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>司守奎《数学建模算法与程序》第八章 层次分析法 P167 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;日常生活中，我们面临很多的选择，选择工作offer，选择买哪个牌子的手机，选择哪个地方旅行等等。这些选择难以定量的衡量，有很多不确定性。内心小纠结，我选择了这个，万一那个好呢，怎么办？请看层次分析法。&lt;/p&gt;
&lt;p&gt;层次分析法(Analytic Hierarchy Process，简称 AHP)是对一些较为复杂、较为模糊的问题作出决策的简易方法，它特别适用于那些难于完全定量分析的问题。它是美国运筹学家 T. L. Saaty 教授于上世纪 70 年代初期提出的一种简便、灵活而又实用的多准则决策方法。&lt;/p&gt;
&lt;p&gt;运用层次分析法建模，大体上可按下面四个步骤进行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立递阶层次结构模型&lt;/li&gt;
&lt;li&gt;构造出各层次中的所有判断矩阵&lt;/li&gt;
&lt;li&gt;层次单排序及一致性检验&lt;/li&gt;
&lt;li&gt;层次总排序及一致性检验。（一般不用）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数学" scheme="https://talengu.github.io/public/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="数学" scheme="https://talengu.github.io/public/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="层次分析法" scheme="https://talengu.github.io/public/tags/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>地表最强大的还有这 14 位程序员</title>
    <link href="https://talengu.github.io/public/2020/04/09/cs_fonters/"/>
    <id>https://talengu.github.io/public/2020/04/09/cs_fonters/</id>
    <published>2020-04-09T12:39:04.000Z</published>
    <updated>2020-04-09T12:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>原标题：除了 Linus，地表最强大的还有这 14 位程序员，速来膜拜！</p><p>导语：IT world 曾经做过一次调查，这个世界上最强大的 15 位程序员，到底是？</p><blockquote><p>文 / IT world</p></blockquote><blockquote><p>译 / 优达菌</p><p>转自 / 优达学城 2018</p><p>原文地址 <a href="https://www.sohu.com/a/223302790_700886" target="_blank" rel="noopener">https://www.sohu.com/a/223302790_700886</a></p></blockquote><p>当和技术基友谈论起 “谁是世界上最顶级的程序员” 的话题时，总是分分钟能引发骂战，优秀的程序员太多了，要评出最优秀的，貌似真的不容易。</p><p>IT world 曾经就做过一次调查，当说到谁是世界上健在且最顶级的程序员时，这 15 个人的名字总是能浮现出来，是公认的还是有争议的，是真 · 大神还是伪 · 大神？一起来看看吧~</p><img src="/public/2020/04/09/cs_fonters/3e28c4606b644378b652dc9c3716da02.jpeg" style="zoom:33%;"><a id="more"></a><h2 id="Margaret-Hamilton"><a class="header-anchor" href="#Margaret-Hamilton">¶</a>Margaret Hamilton</h2><img src="/public/2020/04/09/cs_fonters/264f0ac3e2254ea8b1f91eac42632e1c.jpeg" style="zoom:33%;"><p>作为 15 位上榜者中唯一女性，玛格丽特被誉为是 “<strong>阿波罗飞行控制软件背后的大脑</strong>”。</p><p>作为查尔斯 · 斯塔克 · 德雷珀实验室（Charles Stark Draper Laboratory）软件工程部的老大，她组建了一个团队，负责设计和制造阿波罗舰载飞行控制器软件和空间实验室。</p><p>基于这段经历，她开发了通用系统语言（Universal Systems Language）和开发先于事实（ Development Before the Fact）的范例，首先提出异步软件、优先调度和高可信度的软件设计理念。“软件工程（ software engineering）” 这个名字，公认是由她首先发明的。</p><p>1986 年，玛格丽特获得了奥古斯塔 · 埃达 · 洛夫莱斯奖，2003 年获得 NASA 卓越太空行动奖。</p><p><strong>世人评价：</strong></p><p>“她发明了测试，很大程度上规范了美国的计算机工程” —— ford_beeblebrox</p><p>“在她之前，计算机编程只是个数学分支。然而这个宇宙空间的飞行控制系统，清晰地将编程引入到一个截然不同的领域。” —— Dan Allen</p><p>“... 她发明了‘软件工程’这个词，并作出了最好的示范。” —— David Hamilton</p><h2 id="Donald-Knuth"><a class="header-anchor" href="#Donald-Knuth">¶</a>Donald Knuth</h2><img src="/public/2020/04/09/cs_fonters/e964fa2bfe7d4e0784b4d1dcc84dd883.jpeg" style="zoom:33%;"><p>唐纳德 · 克努斯的中文名叫 “高德纳”，几乎是中国程序员永远的偶像之一。他最主要的成就，<strong>就是《计算机编程艺术》的作者。</strong></p><p>高德纳写出了计算机编程领域的红宝书，发明了 Tex 数字排版系统，获得了无数的荣耀。1971 年，他获得了第一届葛丽丝 · 穆雷 · 霍普奖（Grace Murray Hopper Award） 奖。1974 年获得了图灵奖，当时他才 36 岁....1979 年又获得了美国国家科学奖章，95 年解锁 IEEE 约翰 · 冯 · 诺依曼奖章，98 年，他入选为计算机历史博物馆名人堂的成员之一。</p><p><strong>世人评价：</strong></p><p>“... 《计算机编程艺术》这本书，估计是有史以来关于计算机编程最牛逼的贡献。”—— 匿名</p><p>“他发明的 TeX ，是我所用过的唯一一个几乎没有 bug 的计算机软件，真让人心悦诚服”—— Jaap Weel</p><p>“如果你要问我的话，他简直是前无古人后无来者！” —— Mitch Rees-Jones</p><h2 id="Ken-Thompson"><a class="header-anchor" href="#Ken-Thompson">¶</a>Ken Thompson</h2><img src="/public/2020/04/09/cs_fonters/71e925e1580c419fbae8df0829706e92.jpeg" style="zoom:33%;"><p><strong>作为 “Unix 之父”，肯 · 汤普森足够在这个榜单占据一席之地。</strong></p><p>他与丹尼斯 · 里奇（Dennis Ritchie）共同创造了 Unix 操作系统。此外，他还发明了 B 语言、UTF-8 字符编码规范、ed 文本编辑器，同时也是 Go 语言的共同开发者之一。</p><p>肯 · 汤普森获奖无数，1983 年他获得图灵奖，1994 年获得 IEEE 计算机先锋奖，1998 年获颁美国国家科技奖章。在 1997 年入选成为计算机历史博物馆名人堂的一员。</p><p><strong>世人评论：</strong></p><p>“... 他可能是有史以来最具成就的程序员了。Unix 内核，Unix 工具，国际象棋程序世界冠军 Belle，Plan 9，Go 语言，无人可比” —— Pete Prokopowicz</p><p>“他所做出的贡献影响深刻，而且经得住时间的考验，时至今日，我们还在享受着他的智慧成果。” —— Jan Jannink</p><h2 id="Richard-Stallman"><a class="header-anchor" href="#Richard-Stallman">¶</a>Richard Stallman</h2><img src="/public/2020/04/09/cs_fonters/efe61b0807d541e3b1c3e8c77210d977.jpeg" style="zoom:33%;"><p><strong>作为 Emacs 和 GCC 的缔造者，是他最大的成就之一。</strong></p><p>理查德是 GNU 项目的创立者，为其开发了很多核心工具，如 Emacs、GCC、GDB 和 GNU Make 等等。他还创办了自由软件基金会。1990 年荣获葛丽丝 · 穆雷 · 霍普奖，1998 年获得 EFF 先锋奖.</p><p><strong>世人评论：</strong></p><p>“他在编程上的造诣和思想，形成了一整套计算机编程的亚文化。” —— Dan Dunay</p><p>“我并不百分百认同他，但不可否认，他的确是足够载入史册的伟大的程序员。” —— Marko Poutiainen</p><p>“假设 Linux 写出来的时候，如果没有 GNU 工程的前期工作会怎么样。多亏了他！” —— John Burnette</p><h2 id="Anders-Hejlsberg"><a class="header-anchor" href="#Anders-Hejlsberg">¶</a>Anders Hejlsberg</h2><img src="/public/2020/04/09/cs_fonters/a1a41004e6af4e9390d7a6aa0b85acf6.jpeg" style="zoom:33%;"><p>身为 <strong>Turbo Pascal 的缔造者兼 C# 之父</strong>，安德斯也是非常牛逼的！Turbo Pascl 可谓是历史上最受欢迎的编译器之一，也是首个集成开发环境（IDE）。他还主导开发了 Turbo Pascal 的继任者 Delphi ，他还是 C# 的首席架构师。</p><p>2001 年，他荣获了 Dr. Dobb 的杰出编程奖</p><p>生平： Turbo Pascal 的原作者，是最流行的 Pascal 编译器和第一个集成开发环境。而后，领导了 Turbo Pascal 的继任者 Delphi 的构建。C# 的主要设计师和架构师。2001 年荣获 Dr. Dobb’s 杂志颁发的 “杰出编程奖”。</p><p><strong>世人评论：</strong></p><p>“他用汇编语言写了 Pascal 编译器，支持当时 PC 端的两种主流操作系统（DOS 和 CP/M）。用它来编译链接程序并运行的时间，从几分钟减少到了几秒钟。” —— Steve Wood</p><h2 id="Doug-Cutting"><a class="header-anchor" href="#Doug-Cutting">¶</a>Doug Cutting</h2><img src="/public/2020/04/09/cs_fonters/239b715dcfaf4c4e9800dbdbd68009b2.jpeg" style="zoom:33%;"><p>康婷开发了 Lucene 搜索引擎、 网络爬虫 Nutch 和分布式大型数据处理工具 Hadoop。此外，他还是一位坚定而热情的开源支持者（Lucene、Nutch 以及 Hadoop 都是开源的）。他还担任过前 Apache 软件基金的理事。</p><p><strong>世人评论：</strong></p><p>“... 他写出了杰出的搜索引擎框架（Lucene/solr），为世界开启大数据之门（Hadoop）。” —— Rajesh Rao</p><h2 id="Sanjay-Ghemawat"><a class="header-anchor" href="#Sanjay-Ghemawat">¶</a><strong>Sanjay Ghemawat</strong></h2><img src="/public/2020/04/09/cs_fonters/b9ba05338ce64e1e893af0cb86e8af6e.jpeg" style="zoom:33%;"><p>这位谷歌核心架构师，参与设计和实现了一些谷歌大型分布式系统的功能，包括 MapReduce、BigTable、Spanner 和谷歌文件系统。还编写了 Unix 的 ical 日历系统。</p><p>他于 2009 年入选美国国家工程院。2012 年荣获 ACM 计算机科学奖。</p><p><strong>世人评论：</strong></p><p>“Jeff Dean 的左膀右臂。” —— Ahmet Alp Balkan</p><h2 id="Jeff-Dean"><a class="header-anchor" href="#Jeff-Dean">¶</a>Jeff Dean</h2><img src="/public/2020/04/09/cs_fonters/a2e2f5bed1484e2ea60d7e84f1a9c5de.jpeg" style="zoom:33%;"><p>身为谷歌搜索索引的大脑，他参与设计和实现了许多谷歌大型分布式系统的功能，包括网页爬虫，索引搜索，AdSense，MapReduce，BigTable 和 Spanner。</p><p>2009 年，杰夫获得美国国家工程院奖。2012 年荣获 ACM SIGOPS 马克 · 维瑟奖和 ACM 计算机科学奖。</p><p><strong>世人评论：</strong></p><p>“... 他在数据挖掘领域（GFS、MapReduce、BigTable）上取得了重大突破。” —— Natu Lauchande</p><h2 id="Linus-Torvalds"><a class="header-anchor" href="#Linus-Torvalds">¶</a>Linus Torvalds</h2><img src="/public/2020/04/09/cs_fonters/5bc1912d08ad47b3be77809a49a6d532.jpeg" style="zoom:33%;"><p>他是 Linux 的缔造者，创建了 Linux 内核与开源的版本控制系统 Git。</p><p>1998 年，他获得了 EFF 先锋奖，2000 年荣获英国电脑学会授予的洛夫莱斯勋章，2012 年的千禧技术奖，2014 年 IEEE 计算机学会授予的计算机先锋奖。他同样入选了 2008 年的计算机历史博物馆名人堂。</p><p><strong>世人评论：</strong></p><p>“他只花了几年，就写出了 Linux 内核，而 GNU Hurd（一个 GNU 开发的内核项目）历经 25 年，却还是一个 demo。” —— Erich Ficker</p><p>“他是程序员的程序员。” —— Dan Allen</p><h2 id="John-Carmack"><a class="header-anchor" href="#John-Carmack">¶</a>John Carmack</h2><img src="/public/2020/04/09/cs_fonters/939e4ce41e844230a7481f54271d6969.jpeg" style="zoom:33%;"><p>他是 《毁灭战士》Doom 之父， ID Software 的联合创始人，开发了一系列极具影响力的 FPS 游戏，比如《德军总部 3D》（Wolfenstein 3D）、《毁灭战士》（Doom）和《雷神之锤》（Quake）等。</p><p>他还是计算机图形技术领域的先锋，在图形学上多次取得重要突破：包括自适应性图块刷新（adaptive tile refresh），二叉空间分割（BSP），以及表面缓存技术等等。</p><p>他在 2001 年入选交互式艺术与科学学院名人堂，并在 2007 年和 2008 年两次获得艾美奖工程和技术类奖项，并于 2010 年获得游戏开发者选择终身成就奖。</p><p><strong>世人评价：</strong></p><p>“他写第一个渲染引擎的时候不到 20 岁。真是个天才。” —— Alex Dolinsky</p><p>“... 德军总部 3D、毁灭战士还有雷神之锤，这些革命性的游戏，影响了一代游戏设计师。” —— dniblock</p><p>“给他一个周末，他可以写出任何东西....” —— Greg Naughton</p><p>“他是编程界的莫扎特...” —— Chris Morris</p><h2 id="Fabrice-Bellard"><a class="header-anchor" href="#Fabrice-Bellard">¶</a>Fabrice Bellard</h2><img src="/public/2020/04/09/cs_fonters/75c0a9b71a5c4209ae5bceeab7a5d7f9.jpeg" style="zoom:33%;"><p>他是 QEMU 之父，是众多著名开源软件的作者，包括硬件模拟和虚拟化的平台 QEMU，处理多媒体数据的 FFmpeg，还有 Tiny C 编译器和 LZEXE，这是一个执行文件压缩的软件。</p><p>他是 2000 年和 2001 年 C 语言混乱代码大赛的冠军，2011 年 荣获 Google-O'Reilly 开源奖。此外，他还解锁了计算圆周率小数点后位数最多的世界纪录成就。</p><p><strong>世人评价：</strong></p><p>“我觉得他的工作实在是太伟大了。” —— raphinou</p><p>“他简直是世界上最高产的程序员...” —— Pavan Yara</p><h2 id="Jon-Skeet"><a class="header-anchor" href="#Jon-Skeet">¶</a>Jon Skeet</h2><img src="/public/2020/04/09/cs_fonters/35fc5db1746e495da75a89f408d92e3e.jpeg" style="zoom:33%;"><p>“他根本不需要调试器，他盯下代码，bug 便会羞愧地原形毕露。” 这是世人对他的评价，他作为 Stack Overflow 传说级贡献者，保持着有史以来在 Stack Overflow 上最高的声誉，要知道，他平均每月解答高达 390 个问题！！！</p><p>此外，他还是 Google 工程师，《C# in Depth》的作者。</p><p>“如果他的代码没有通过编译，那么编译器应该道歉。” —— Dan Dyer</p><p>“他根本不需要什么编程规范，他的代码本身就是编程规范。” —— 匿名</p><h2 id="Adam-D-Angelo"><a class="header-anchor" href="#Adam-D-Angelo">¶</a>Adam D'Angelo</h2><img src="/public/2020/04/09/cs_fonters/8cb005da7eb146e9a32b8ed72c07012d.jpeg" style="zoom:33%;"><p>他是” 海外知乎 “—— Quora 的创始人之一，他最早是 Facebook 工程师时，为其搭建了 News Feeds 的基础功能，成为了 Facebook 的 CTO 和 工程 VP。后面离职创办了现在的 Quora 。</p><p>他的经历很传奇，2001 年以还是一名高中生的他，在美国计算机奥林匹克竞赛排名上第八位。在 2004 年 ACM 国际大学生编程大赛获得银牌。2005 年闯入了 Topcoder 大学生算法编程挑战赛的决赛。</p><p>他是马克 · 扎克伯格的所谓的 6 个人之一（不懂请 Google）</p><p><strong>世人评论：</strong></p><p>“这是一位万能的程序员。” —— 匿名</p><h2 id="Petr-Mitrechev"><a class="header-anchor" href="#Petr-Mitrechev">¶</a><strong>Petr Mitrechev</strong></h2><img src="/public/2020/04/09/cs_fonters/a526c7c7edc04910bed60b68bb36990f.jpeg" style="zoom:33%;"><p>他被誉为 <strong>“有史以来最具竞赛能力的程序员”</strong>，的确，看看他的履历就知道了：2000 年和 2002 年，他在国际信息学奥林匹克竞赛中两次获得金牌。2006 年，赢得 Google 代码挑战赛和 TopCoder 公开算法大赛冠军。他还是两次 Facebook 黑客杯的冠军。</p><p><strong>世人评价：</strong></p><p>“他简直是竞技程序员的偶像，即使是在我们印度” —— Kavish Dwivedi</p><h2 id="Gennady-Korotkevich"><a class="header-anchor" href="#Gennady-Korotkevich">¶</a><strong>Gennady Korotkevich</strong></h2><img src="/public/2020/04/09/cs_fonters/75da2050fc004f0d84956dc62fdd4dae.jpeg" style="zoom:33%;"><p>榜单最后一位，是位竞技编程小神童，他是国际信息学奥林匹克竞赛的历史中，年纪最小参赛者（11 岁），并且 6 次获得金牌 (2007~2012)。2013 年，他在 ACM 国际大学生编程大赛获胜，同时还是 2014 Facebook 黑客杯的获胜者。</p><p>写这篇文章的时候，他在 Codeforces 榜排名第一 （ID：Tourist）、TopCoder 榜也是第一。</p><p><strong>世人评价：</strong></p><p>“当之无愧的编程神童！” —— Prateek Joshi</p><p><strong>大神级别的程序员太多了！并不是一篇文章就能说明白道清楚，如果你还有推荐的大神，欢迎在本文评论中和大家分享下。</strong></p><p>— 完 —</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原标题：除了 Linus，地表最强大的还有这 14 位程序员，速来膜拜！&lt;/p&gt;
&lt;p&gt;导语：IT world 曾经做过一次调查，这个世界上最强大的 15 位程序员，到底是？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文 / IT world&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;译 / 优达菌&lt;/p&gt;
&lt;p&gt;转自 / 优达学城 2018&lt;/p&gt;
&lt;p&gt;原文地址 &lt;a href=&quot;https://www.sohu.com/a/223302790_700886&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.sohu.com/a/223302790_700886&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当和技术基友谈论起 “谁是世界上最顶级的程序员” 的话题时，总是分分钟能引发骂战，优秀的程序员太多了，要评出最优秀的，貌似真的不容易。&lt;/p&gt;
&lt;p&gt;IT world 曾经就做过一次调查，当说到谁是世界上健在且最顶级的程序员时，这 15 个人的名字总是能浮现出来，是公认的还是有争议的，是真 · 大神还是伪 · 大神？一起来看看吧~&lt;/p&gt;
&lt;img src=&quot;/public/2020/04/09/cs_fonters/3e28c4606b644378b652dc9c3716da02.jpeg&quot; style=&quot;zoom:33%;&quot;&gt;
    
    </summary>
    
      <category term="计算机科学" scheme="https://talengu.github.io/public/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="人物" scheme="https://talengu.github.io/public/tags/%E4%BA%BA%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>博客模版</title>
    <link href="https://talengu.github.io/public/2019/07/25/template/"/>
    <id>https://talengu.github.io/public/2019/07/25/template/</id>
    <published>2019-07-25T12:00:00.000Z</published>
    <updated>2020-02-11T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>前言主要说明文章的写作意图，概要介绍文中涉及的背景、主要内容、与其他文章关系等。对于长文，这个部分可以写摘要。</p><p>本文为Hexo博客模版文件，以Markdown语言书写。<a href="#%E9%99%84%EF%BC%9Amarkdown%E8%AF%AD%E6%B3%95">模版markdown语法</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">前言一般放到主页，可利用 &lt;!-- more --&gt; 隔断。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="构思与起草"><a class="header-anchor" href="#构思与起草">¶</a>构思与起草</h2><ul><li>对文章的阅读群体、写作意图和反馈（Audience Intention Response AIR）要有一个清楚的认识。照顾沟通对象的需要、你的意图（信息）以及希望的反馈。</li><li>在思维导图上，放上你需要的关键名词，然后依次在它基础上添加动词，在加上形容词。最后以一定顺序组织你将要阐述的信息。比如重要性排序，对比优势劣势，方案的不同层面，时间上逻辑上的因果性等等。</li></ul><h2 id="主体内容"><a class="header-anchor" href="#主体内容">¶</a>主体内容</h2><p>文章的主要内容，包括你对跟进过程或发现成果的描述，以数据、事实证据以及其他的信息支撑主要内容。在你的论说中，你应该把对客观事实的描述和写作者对事情的主管阐述区分开来。</p><p>当你在报告中对一个观点进行陈述的时候，你需要记住以下几点：</p><ul><li>清晰的呈现事实</li><li>有逻辑地提出论据</li><li>引用相关的语录、简明易懂的事实和例子来支持你的论点</li><li>给出支持或反对该行为的理由</li><li>始终围绕主要观点进行讨论</li><li>处理好重要的假设关系</li><li>区分说明（具体阐述）和论证（有理有据）</li></ul><h2 id="写作检查"><a class="header-anchor" href="#写作检查">¶</a>写作检查</h2><p>主体内容完成后，要进行写作检查。</p><ul><li>保证信息的准确性，时间地点等信息的准确。</li><li>确保语法规范性</li><li>段落写作<ul><li>主题句，核心思想</li><li>使用关联词，但勿滥<ul><li>表示转折：虽然，尽管，但是，相反的是，另一方面</li><li>对已阐述观点的强调：此外，与此同时，除此以外，再补充一点</li><li>阐述结果：结果是，相应的结果是，因此</li></ul></li><li>简单的句子 15-25</li></ul></li><li>精心选择词语<ul><li>同一个意思，换一下说法</li><li>少用名词，多用动词。我们想用名词表达意思，采用动名组合，或者一个意群搭配上动词会更有力。</li><li>多用主动动词，少用被动动词</li></ul></li><li>核对标点符号，逗号，与分号。英文的话，检查一下拼写</li><li>注意行为的语气</li><li>保持连贯性，使用一种统一的方式表达。</li></ul><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><p>一个清晰的总结应该概括全部论点。</p><h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2><ul><li>逻辑清楚，达情切意<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。准备看一些基础的逻辑学。</li><li>写完要读两遍，修改错别字，标点，语序连接等等。</li><li>修改可以反着读，正着读对熟悉的材料会有一种连贯性忽略掉错误或者不顺的地方。</li></ul><h2 id="附：markdown语法"><a class="header-anchor" href="#附：markdown语法">¶</a>附：markdown语法</h2><h3 id="head"><a class="header-anchor" href="#head">¶</a>head</h3><p>文件head，设置标题、日期、分类、标签、评论、版权、是否使用公式，如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 模版文件</span><br><span class="line">date: 2019-07-25 12:00:00</span><br><span class="line">updated: 2019-07-25 12:00:00</span><br><span class="line">categories:</span><br><span class="line">  - 博客搭建</span><br><span class="line">  - 模版文件</span><br><span class="line">tags:</span><br><span class="line">  - Writing</span><br><span class="line">comments: true</span><br><span class="line">copyright: true</span><br><span class="line">math: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="图"><a class="header-anchor" href="#图">¶</a>图</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 使用标准markdown</span><br><span class="line">![GDP](http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用html</span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png"</span> <span class="attr">width</span>=<span class="string">"60%"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 图1 2019年国内生产总值及其增速度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 白色图片用table提供辨识度</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png"</span> <span class="attr">width</span>=<span class="string">"60%"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 图1 2019年国内生产总值及其增速度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两行代码生成下面的图和标题。</p><center><img src="http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png" width="60%"></center><p>图 1 展示的是2015-2019年的GDP和增长速度<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，直方图数据反应国内生产总值在2015-2019年度均平稳增长。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png"</span>&gt;</span>图1     <span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png"</span>&gt;</span>图2 <span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><table><tr><td><center><img src="http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png">图1     </center></td><td><center><img src="http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png">图2 </center></td></tr></table><h3 id="表"><a class="header-anchor" href="#表">¶</a>表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align=&apos;center&apos;&gt; 表1 2018年年末人口数及其构成&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">| 指标       | 年末数（万人） | 比重（%） |</span><br><span class="line">| ---------- | -------------- | --------- |</span><br><span class="line">| 全国总人口 | 139538         | 100.0     |</span><br><span class="line">| 其中：城镇 | 83137          | 59.58     |</span><br><span class="line">| 乡村       | 56401          | 40.42     |</span><br></pre></td></tr></table></figure><p>这两行代码生成下面的表和标题。</p><div align="center">表1 2018年年末人口数及其构成</div><table><thead><tr><th>指标</th><th>年末数（万人）</th><th>比重（%）</th></tr></thead><tbody><tr><td>全国总人口</td><td>139538</td><td>100.0</td></tr><tr><td>城镇</td><td>83137</td><td>59.58</td></tr><tr><td>乡村</td><td>56401</td><td>40.42</td></tr></tbody></table><p>从表1得出2018年年末，城镇人口占总人口的59.58%，乡村人口占总人口的40.42%，城镇人口已大比例超过乡村人口。</p><h3 id="公式"><a class="header-anchor" href="#公式">¶</a>公式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">f=w_1 x_1 + w_2 x_2</span><br><span class="line">\tag&#123;1&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>在Markdown中可用Tex代码渲染数学公式，渲染效果为公式（1）。如图2，Tex公式可以在<a href="http://latex.codecogs.com/eqneditor/editor.php" target="_blank" rel="noopener">Latex编辑器网站</a> 可视化编写$$f=w_1 x_1 + w_2 x_2\tag{1}$$</p><center><img src="https://img-blog.csdnimg.cn/20200425095309901.png" width="60%"><div> 图2 Latex在线编辑器</div></center><h3 id="定理证明"><a class="header-anchor" href="#定理证明">¶</a>定理证明</h3><p><strong>定理 3.1</strong> 如果时域混合场积分方程是时域电场积分方程与时域磁场积分方程的线性组合……</p><p><strong>证明：</strong></p><p>首先，由于 ……</p><p>……</p><p>根据 ……，结论得证。                        ■</p><h3 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h3><p>参考的分类：</p><ul><li>链接直接在原文中给出。</li><li>引用他人文章中的段落或者意识给出引用的链接。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">**参考**</span><br><span class="line"></span><br><span class="line">[^statics_report_2019]: 国家统计局 [2019年国民经济和社会发展统计公报](http://www.stats.gov.cn/tjsj/zxfb/202002/t20200228_1728913.html) 2020-02-28</span><br><span class="line"></span><br><span class="line">[^hetang]: 朱自清《荷塘清韵》北京大学出版社  2010-1</span><br></pre></td></tr></table></figure><h3 id="添加iframes"><a class="header-anchor" href="#添加iframes">¶</a>添加iframes</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &#123;&#125;替换为视频id，同时去掉&#123;&#125; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 小破站 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://player.bilibili.com/player.html?bvid=&#123;&#125;"</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"430"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 腾讯视频 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://v.qq.com/iframe/player.html?vid=&#123;&#125;"</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"430"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 优酷视频 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">src</span>=<span class="string">'https://player.youku.com/embed/&#123;&#125;'</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"430"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- PDF --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">src</span>=<span class="string">'https://arxiv.org/pdf/1406.2661.pdf'</span> <span class="attr">width</span>=<span class="string">"800"</span> <span class="attr">height</span>=<span class="string">"450"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">src</span>=<span class="string">'https://www.sohu.com/a/287817933_100118081'</span> <span class="attr">width</span>=<span class="string">"800"</span> <span class="attr">height</span>=<span class="string">"450"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><iframe src="https://player.bilibili.com/player.html?bvid=BV1Wb411v7WN" width="640" height="430"></iframe><iframe src="https://v.qq.com/txp/iframe/player.html?vid=u0951gpf8u2" width="640" height="430"></iframe><p>TODO:markdown 空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;</span><br></pre></td></tr></table></figure><hr><p><strong>参考</strong></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>朱自清《荷塘清韵》北京大学出版社  2010-1 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>国家统计局 <a href="http://www.stats.gov.cn/tjsj/zxfb/202002/t20200228_1728913.html" target="_blank" rel="noopener">2019年国民经济和社会发展统计公报</a> 2020-02-28 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前言主要说明文章的写作意图，概要介绍文中涉及的背景、主要内容、与其他文章关系等。对于长文，这个部分可以写摘要。&lt;/p&gt;
&lt;p&gt;本文为Hexo博客模版文件，以Markdown语言书写。&lt;a href=&quot;#%E9%99%84%EF%BC%9Amarkdown%E8%AF%AD%E6%B3%95&quot;&gt;模版markdown语法&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;前言一般放到主页，可利用 &amp;lt;!-- more --&amp;gt; 隔断。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="https://talengu.github.io/public/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="工具" scheme="https://talengu.github.io/public/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="博客模版" scheme="https://talengu.github.io/public/tags/%E5%8D%9A%E5%AE%A2%E6%A8%A1%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>机器学习系列</title>
    <link href="https://talengu.github.io/public/2019/07/23/AI/ML_summary/"/>
    <id>https://talengu.github.io/public/2019/07/23/AI/ML_summary/</id>
    <published>2019-07-23T12:00:00.000Z</published>
    <updated>2019-07-23T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong></p><p>路漫漫其修远兮，吾将上下而求索。2013年，大二接触人工智能课，讲逻辑推理，专家系统等等，神经网络只是一部分，打开当时老师的ppt，还能看到BP等算法。接着在2015年，上了模式识别课程，有一些启发式算法，KNN K-means等算法，同时神经网络也已经有了 GoogLeNet 等深层网络，热门的GAN网络也在2014年被提出。后面，机遇巧合，本科毕业时选了人工智能的坑，直到3年后的现在算是明白了一点。接下来的三年的目标还是<a href="https://talengu.github.io/public/2018/10/01/AI/how_algorithm_engineer/">【成为一名优秀的算法工程师】</a>。</p><p>回望入坑 <strong>机器学习</strong>，没有系统地整理过相关知识。于是想着手整理一份自己笔记系列。本文为序。</p><blockquote><p>雄关漫道真如铁，而今迈步从头越。</p></blockquote><p><img src="/public/2019/07/23/AI/ML_summary/1564034058070.png" alt="1564034058070"></p><div align="center"> 图1 机器学习知识框架</div>如图1 所示，整个系列将由五个部分组成。<a id="more"></a><h2 id="一、机器学习基础"><a class="header-anchor" href="#一、机器学习基础">¶</a>一、机器学习基础</h2><h2 id="二、监督学习"><a class="header-anchor" href="#二、监督学习">¶</a>二、监督学习</h2><img src="/public/2019/07/23/AI/ML_summary/1564034419203.png" alt="1564034419203" style="zoom:67%;"><div align="center"> 图 监督学习</div><h2 id="三、无监督学习"><a class="header-anchor" href="#三、无监督学习">¶</a>三、无监督学习</h2><img src="/public/2019/07/23/AI/ML_summary/1564034460034.png" alt="1564034460034" style="zoom:67%;"><div align="center"> 图 无监督学习</div><h2 id="四、学习理论"><a class="header-anchor" href="#四、学习理论">¶</a>四、学习理论</h2><img src="/public/2019/07/23/AI/ML_summary/xuexililun.png" alt="xuexililun" style="zoom:67%;"><div align="center"> 图 学习理论</div><h3 id="4-1-正则化"><a class="header-anchor" href="#4-1-正则化">¶</a>4.1 <a href="regulation_baysian.md">正则化</a></h3><h2 id="五、强化学习"><a class="header-anchor" href="#五、强化学习">¶</a>五、强化学习</h2><h2 id="六、参考与规划"><a class="header-anchor" href="#六、参考与规划">¶</a>六、参考与规划</h2><p><strong>目标</strong>通过阅读以上基本书，打牢自己的理论基础。</p><p><strong>书籍</strong></p><ul><li>PRML Bishop</li><li>机器学习 周志华</li><li>统计学习 李航</li><li>深度学习 Goodfellow</li><li>模式识别 张学工</li></ul><p><strong>课程</strong></p><p><a href="https://www.bilibili.com/video/av70839977" target="_blank" rel="noopener">https://www.bilibili.com/video/av70839977</a></p><p><strong>博客编写</strong></p><ul><li>前言介绍，包括作者，背景，原始paper，和以上基本书的对应章节。</li><li>原理阐述，算法步骤写出。</li><li>案例分析</li><li>利用python写出代码，先用scilearn写。</li><li>总结，预告。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路漫漫其修远兮，吾将上下而求索。2013年，大二接触人工智能课，讲逻辑推理，专家系统等等，神经网络只是一部分，打开当时老师的ppt，还能看到BP等算法。接着在2015年，上了模式识别课程，有一些启发式算法，KNN K-means等算法，同时神经网络也已经有了 GoogLeNet 等深层网络，热门的GAN网络也在2014年被提出。后面，机遇巧合，本科毕业时选了人工智能的坑，直到3年后的现在算是明白了一点。接下来的三年的目标还是&lt;a href=&quot;https://talengu.github.io/public/2018/10/01/AI/how_algorithm_engineer/&quot;&gt;【成为一名优秀的算法工程师】&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;回望入坑 &lt;strong&gt;机器学习&lt;/strong&gt;，没有系统地整理过相关知识。于是想着手整理一份自己笔记系列。本文为序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;雄关漫道真如铁，而今迈步从头越。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/public/2019/07/23/AI/ML_summary/1564034058070.png&quot; alt=&quot;1564034058070&quot;&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt; 图1 机器学习知识框架&lt;/div&gt;
如图1 所示，整个系列将由五个部分组成。
    
    </summary>
    
      <category term="机器学习" scheme="https://talengu.github.io/public/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="人工智能" scheme="https://talengu.github.io/public/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
      <category term="机器学习" scheme="https://talengu.github.io/public/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
