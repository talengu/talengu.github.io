<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一塘</title>
  
  
  <link href="/public/atom.xml" rel="self"/>
  
  <link href="https://talengu.github.io/public/"/>
  <updated>2022-12-11T12:00:00.000Z</updated>
  <id>https://talengu.github.io/public/</id>
  
  <author>
    <name>一塘</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「转」九张图一览 Linux 性能工具 全景图</title>
    <link href="https://talengu.github.io/public/2022/12/11/linux/linux_tools/"/>
    <id>https://talengu.github.io/public/2022/12/11/linux/linux_tools/</id>
    <published>2022-12-11T12:00:00.000Z</published>
    <updated>2022-12-11T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>当今时代，绝大多数企业的应用都是运行在 Linux 操作系统上，所以对应用进行性能诊断和性能优化时，离不开 Linux 的各种性能观测工具和性能优化工具。</p><p>笔者使用过的常见的 Linux 性能观测和性能优化工具有：</p><ul><li>top/uptime</li><li>ps/pstree</li><li>df/du/free/lsblk</li><li>ip/ifconfig/ping/telnet</li><li>route/dig/nslookup</li><li>lsof/netstat/ss</li><li>tcpdump/tshark/wireshark</li><li>netstat/vmstat/iostat/pidstat/dstat/mpstat</li><li>sar/sysctl/ethtool</li></ul><p>最近在拜读国际著名的 LINUX 性能专家 Brendan Gregg 的个人博客和技术书籍，摘抄了如下九张图，一览 Linux 性能工具全景图，大家共勉！</p><a id="more"></a><h2 id="2-Linux-性能工具全景图"><a class="header-anchor" href="#2-Linux-性能工具全景图">¶</a><strong>2. Linux 性能工具全景图</strong></h2><ul><li>linux performance observability tools</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-2eadd97c53a3f20f255394c3d90ea914_r.jpg" alt></p><ul><li>linux static performance tools</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-20032bac53c856c5733259eece5c2f76_r.jpg" alt></p><ul><li>linux performance benchmark tools</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-de23423f2eb9deb5410b7128c933f9a9_r.jpg" alt></p><ul><li>linux performance tuning tools</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-cdf37de145763b762ba5af1a620f9686_r.jpg" alt></p><ul><li>linux performance observability: sar</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-eee71a6bf3865367741137da03031411_r.jpg" alt></p><ul><li>linux performance observability: perf-tools</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-1c0134fefbb04597db98ae455a40fad5_r.jpg" alt></p><ul><li><a href="https://www.zhihu.com/search?q=linux%20bcc&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2795830055%7D" target="_blank" rel="noopener">linux bcc</a>/BPF Tracing tools</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-ffe70303f4d64828ca931d987b12a6d8_r.jpg" alt></p><ul><li>bpftrace/eBPF Tools</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-5985d44e43738933c0b54c89cc20ec09_r.jpg" alt></p><ul><li>BPF Performance Tools: Linux System and Application Observability</li></ul><p><img src="/public/2022/12/11/linux/linux_tools/v2-0f53016fa1d993ffbbf6fc520e318784_r.jpg" alt></p><h2 id="后记"><a class="header-anchor" href="#后记">¶</a>后记</h2><p>更多 LINUX 性能资料，大家可以访问大师的个人网站和和技术书籍</p><ul><li><a href="https://www.brendangregg.com/" target="_blank" rel="noopener">https://www.brendangregg.com/</a></li><li>《性能之巅：洞悉系统、企业与云计算》（《Systems Performance: Enterprise and the Cloud, 2nd Edition (2020)》）</li><li>《洞悉 Linux 系统和应用性能》（《BPF Performance Tools》）</li><li>ps: 要说 LINUX 内核近几年 (和今后几年）最引人注目的发展模块，那就是 <a href="https://www.zhihu.com/search?q=bpf&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2795830055%7D" target="_blank" rel="noopener">bpf</a> 了，完全值得花点精力学习跟进下。</li><li>如何更深入地学习 Linux？ - michaelli的回答 - 知乎<a href="https://www.zhihu.com/question/23564190/answer/2795830055" target="_blank" rel="noopener">https://www.zhihu.com/question/23564190/answer/2795830055</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;当今时代，绝大多数企业的应用都是运行在 Linux 操作系统上，所以对应用进行性能诊断和性能优化时，离不开 Linux 的各种性能观测工具和性能优化工具。&lt;/p&gt;
&lt;p&gt;笔者使用过的常见的 Linux 性能观测和性能优化工具有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;top/uptime&lt;/li&gt;
&lt;li&gt;ps/pstree&lt;/li&gt;
&lt;li&gt;df/du/free/lsblk&lt;/li&gt;
&lt;li&gt;ip/ifconfig/ping/telnet&lt;/li&gt;
&lt;li&gt;route/dig/nslookup&lt;/li&gt;
&lt;li&gt;lsof/netstat/ss&lt;/li&gt;
&lt;li&gt;tcpdump/tshark/wireshark&lt;/li&gt;
&lt;li&gt;netstat/vmstat/iostat/pidstat/dstat/mpstat&lt;/li&gt;
&lt;li&gt;sar/sysctl/ethtool&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最近在拜读国际著名的 LINUX 性能专家 Brendan Gregg 的个人博客和技术书籍，摘抄了如下九张图，一览 Linux 性能工具全景图，大家共勉！&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://talengu.github.io/public/categories/linux/"/>
    
    
      <category term="linux" scheme="https://talengu.github.io/public/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>tcp ip 协议族</title>
    <link href="https://talengu.github.io/public/2022/12/08/linux_network/tcp_ip/"/>
    <id>https://talengu.github.io/public/2022/12/08/linux_network/tcp_ip/</id>
    <published>2022-12-08T12:00:00.000Z</published>
    <updated>2022-12-08T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>tcp ip 协议族</p><a id="more"></a><p><img src="/public/2022/12/08/linux_network/tcp_ip/tcp_ip.jpeg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;tcp ip 协议族&lt;/p&gt;
    
    </summary>
    
      <category term="linux 网络" scheme="https://talengu.github.io/public/categories/linux-%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://talengu.github.io/public/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>「转」连接跟踪（conntrack）：原理、应用及 Linux 内核实现</title>
    <link href="https://talengu.github.io/public/2022/12/04/linux_network/conntrack_linux/"/>
    <id>https://talengu.github.io/public/2022/12/04/linux_network/conntrack_linux/</id>
    <published>2022-12-04T12:00:00.000Z</published>
    <updated>2022-12-04T12:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a class="header-anchor" href="#摘要">¶</a>摘要</h2><p>本文介绍连接跟踪（connection tracking，conntrack，CT）的原理，应用，及其在 Linux 内核中的实现。</p><p>代码分析基于内核 <code>4.19</code>。为使行文简洁，所贴代码只保留了核心逻辑，但都给出了代码 所在的源文件，如有需要请查阅。</p><p>水平有限，文中不免有错误之处，欢迎指正交流。</p><p>连接跟踪是许多网络应用的基础。例如，Kubernetes Service、ServiceMesh sidecar、 软件四层负载均衡器 LVS/IPVS、Docker network、OVS、iptables 主机防火墙等等，都依赖 连接跟踪功能。</p><a id="more"></a><h2 id="1-1-概念"><a class="header-anchor" href="#1-1-概念">¶</a>1.1 概念</h2><p>连接跟踪，顾名思义，就是<strong>跟踪（并记录）连接的状态</strong>。</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/node-conntrack.png" alt></p><p>Fig 1.1. 连接跟踪及其内核位置示意图</p><p>例如，上图是一台 IP 地址为 <code>10.1.1.2</code> 的 Linux 机器，我们能看到这台机器上有三条 连接：</p><ol><li>机器访问外部 HTTP 服务的连接（目的端口 80）</li><li>外部访问机器内 FTP 服务的连接（目的端口 21）</li><li>机器访问外部 DNS 服务的连接（目的端口 53）</li></ol><p>连接跟踪所做的事情就是发现并跟踪这些连接的状态，具体包括：</p><ul><li>从数据包中提取<strong>元组</strong>（tuple）信息，辨别<strong>数据流</strong>（flow）和对应的<strong>连接</strong>（connection）</li><li>为所有连接维护一个<strong>状态数据库</strong>（conntrack table），例如连接的创建时间、发送 包数、发送字节数等等</li><li>回收过期的连接（GC）</li><li>为更上层的功能（例如 NAT）提供服务</li></ul><p>需要注意的是，<strong>连接跟踪中所说的“连接”，概念和 TCP/IP 协议中“面向连接”（ connection oriented）的 “连接” 并不完全相同</strong>，简单来说：</p><ul><li>TCP/IP 协议中，连接是一个四层（Layer 4）的概念。<ul><li>TCP 是有连接的，或称面向连接的（connection oriented），发送出去的包都要求对端应答（ACK），并且有重传机制</li><li>UDP 是无连接的，发送的包无需对端应答，也没有重传机制</li></ul></li><li>CT 中，一个元组（tuple）定义的一条数据流（flow ）就表示一条连接（connection）。<ul><li>后面会看到 UDP 甚至是 <strong>ICMP 这种三层协议在 CT 中也都是有连接记录的</strong></li><li>但<strong>不是所有协议都会被连接跟踪</strong></li></ul></li></ul><p>本文中用到 “连接” 一词时，大部分情况下指的都是后者，即 “连接跟踪” 中的“连接”。</p><h2 id="1-2-原理"><a class="header-anchor" href="#1-2-原理">¶</a>1.2 原理</h2><p>了解以上概念之后，我们来思考下连接跟踪的技术原理。</p><p>要跟踪一台机器的所有连接状态，就需要</p><ol><li><strong>拦截（或称过滤）流经这台机器的每一个数据包，并进行分析</strong>。</li><li>根据这些信息<strong>建立</strong>起这台机器上的<strong>连接信息数据库</strong>（conntrack table）。</li><li>根据拦截到的包信息，不断更新数据库</li></ol><p>例如，</p><ol><li>拦截到一个 TCP <code>SYNC</code> 包时，说明正在尝试建立 TCP 连接，需要创建一条新 conntrack entry 来记录这条连接</li><li>拦截到一个属于已有 conntrack entry 的包时，需要更新这条 conntrack entry 的收发包数等统计信息</li></ol><p>除了以上两点功能需求，还要考虑<strong>性能问题</strong>，因为连接跟踪要对每个包进行过滤和分析 。性能问题非常重要，但不是本文重点，后面介绍实现时会进一步提及。</p><p>之外，这些功能最好还有配套的管理工具来更方便地使用。</p><h2 id="1-3-设计：Netfilter"><a class="header-anchor" href="#1-3-设计：Netfilter">¶</a>1.3 设计：Netfilter</h2><p><strong>Linux 的连接跟踪是在 <a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Netfilter</a> 中实现的。</strong></p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/netfilter-design.png" alt></p><p>Fig 1.2. Netfilter architecture inside Linux kernel</p><p><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Netfilter</a> 是 Linux 内核中一个对数据 包进行<strong>控制、修改和过滤</strong>（manipulation and filtering）的框架。它在内核协议 栈中设置了若干 hook 点，以此对数据包进行拦截、过滤或其他处理。</p><blockquote><p>说地更直白一些，hook 机制就是在数据包的必经之路上设置若干检测点，所有到达这 些检测点的包都必须接受检测，根据检测的结果决定：</p><ol><li>放行：不对包进行任何修改，退出检测逻辑，继续后面正常的包处理</li><li>修改：例如修改 IP 地址进行 NAT，然后将包放回正常的包处理逻辑</li><li>丢弃：安全策略或防火墙功能</li></ol><p>连接跟踪模块只是完成连接信息的采集和录入功能，并不会修改或丢弃数据包，后者是其 他模块（例如 NAT）基于 Netfilter hook 完成的。</p></blockquote><p>Netfilter 是最古老的内核框架之一，1998 年开始开发，2000 年合并到 <code>2.4.x</code> 内 核主线版本 [5]。</p><h2 id="1-4-设计：进一步思考"><a class="header-anchor" href="#1-4-设计：进一步思考">¶</a>1.4 设计：进一步思考</h2><p>现在提到连接跟踪（conntrack），可能首先都会想到 Netfilter。但由上节讨论可知， 连接跟踪概念是独立于 Netfilter 的，<strong>Netfilter 只是 Linux 内核中的一种连接跟踪实现</strong>。</p><p>换句话说，<strong>只要具备了 hook 能力，能拦截到进出主机的每个包，完全可以在此基础上自 己实现一套连接跟踪</strong>。</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/cilium-conntrack.png" alt></p><p>Fig 1.3. Cilium's conntrack and NAT architectrue</p><p>云原生网络方案 Cilium 在 <code>1.7.4+</code> 版本就实现了这样一套独立的连接跟踪和 NAT 机制 （完备功能需要 Kernel <code>4.19+</code>）。其基本原理是：</p><ol><li>基于 BPF hook 实现数据包的拦截功能（等价于 netfilter 里面的 hook 机制）</li><li>在 BPF hook 的基础上，实现一套全新的 conntrack 和 NAT</li></ol><p>因此，即便<a href="https://github.com/cilium/cilium/issues/12879" target="_blank" rel="noopener">卸载 Netfilter</a> ，也不会影响 Cilium 对 Kubernetes ClusterIP、NodePort、ExternalIPs 和 LoadBalancer 等功能的支持 [2]。</p><p>由于这套连接跟踪机制是独立于 Netfilter 的，因此它的 conntrack 和 NAT 信息也没有 存储在内核的（也就是 Netfilter 的）conntrack table 和 NAT table。所以常规的 <code>conntrack/netstats/ss/lsof</code> 等工具是看不到的，要使用 Cilium 的命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cilium bpf nat list</span><br><span class="line">$ cilium bpf ct list global</span><br></pre></td></tr></table></figure><p>配置也是独立的，需要在 Cilium 里面配置，例如命令行选项 <code>--bpf-ct-tcp-max</code>。</p><p>另外，本文会多次提到连接跟踪模块和 NAT 模块独立，但<strong>出于性能考虑，具体实现中 二者代码可能是有耦合的</strong>。例如 Cilium 做 conntrack 的垃圾回收（GC）时就会顺便把 NAT 里相应的 entry 回收掉，而非为 NAT 做单独的 GC。</p><h2 id="1-5-应用"><a class="header-anchor" href="#1-5-应用">¶</a>1.5 应用</h2><p>来看几个 conntrack 的具体应用。</p><h3 id="1-5-1-网络地址转换（NAT）"><a class="header-anchor" href="#1-5-1-网络地址转换（NAT）">¶</a>1.5.1 网络地址转换（NAT）</h3><p>网络地址转换（NAT），名字表达的意思也比较清楚：对（数据包的）网络地址（<code>IP + Port</code>）进行转换。</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/node-nat.png" alt></p><p>Fig 1.4. NAT 及其内核位置示意图</p><p>例如上图中，机器自己的 IP <code>10.1.1.2</code> 是能与外部正常通信的，但 <code>192.168</code> 网段是私有 IP 段，外界无法访问，也就是说源 IP 地址是 <code>192.168</code> 的包，其<strong>应答包是无 法回来的</strong>。因此，</p><ul><li>当源地址为 <code>192.168</code> 网段的包要出去时，机器会先将源 IP 换成机器自己的 <code>10.1.1.2</code> 再发送出去；</li><li>收到应答包时，再进行相反的转换。</li></ul><p>这就是 NAT 的基本过程。</p><p>Docker 默认的 <code>bridge</code> 网络模式就是这个原理 [4]。每个容器会分一个私有网段的 IP 地址，这个 IP 地址可以在宿主机内的不同容器之间通信，但容器流量出宿主机时要进行 NAT。</p><p>NAT 又可以细分为几类：</p><ul><li>SNAT：对源地址（source）进行转换</li><li>DNAT：对目的地址（destination）进行转换</li><li>Full NAT：同时对源地址和目的地址进行转换</li></ul><p>以上场景属于 SNAT，将不同私有 IP 都映射成同一个 “公有 IP”，以使其能访问外部网络服 务。这种场景也属于正向代理。</p><p>NAT 依赖连接跟踪的结果。连接跟踪<strong>最重要的使用场景</strong>就是 NAT。</p><h4 id="四层负载均衡（L4LB）"><a class="header-anchor" href="#四层负载均衡（L4LB）">¶</a>四层负载均衡（L4LB）</h4><p>再将范围稍微延伸一点，讨论一下 NAT 模式的四层负载均衡。</p><p>四层负载均衡是根据包的四层信息（例如 <code>src/dst ip, src/dst port, proto</code>）做流量分发。</p><p>VIP（Virtual IP）是四层负载均衡的一种实现方式：</p><ul><li>多个后端真实 IP（Real IP）挂到同一个虚拟 IP（VIP）上</li><li>客户端过来的流量先到达 VIP，再经负载均衡算法转发给某个特定的后端 IP</li></ul><p>如果在 VIP 和 Real IP 节点之间使用的 NAT 技术（也可以使用其他技术），那客户端访 问服务端时，L4LB 节点将做双向 NAT（Full NAT），数据流如下图所示：</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/nat.png" alt></p><p>Fig 1.5. L4LB: Traffic path in NAT mode [3]</p><h3 id="1-5-2-有状态防火墙"><a class="header-anchor" href="#1-5-2-有状态防火墙">¶</a>1.5.2 有状态防火墙</h3><p>有状态防火墙（stateful firewall）是相对于早期的<strong>无状态防火墙</strong>（stateless firewall）而言的：早期防火墙只能写 <code>drop syn to port 443</code> 或者 <code>allow syn to port 80</code> 这种非常简单直接 的规则，<strong>没有 flow 的概念</strong>，因此无法实现诸如 <strong>“如果这个 ack 之前已经有 syn， 就 allow，否则 drop”</strong> 这样的规则，使用非常受限 [6]。</p><p>显然，要实现有状态防火墙，就必须记录 flow 和状态，这正是 conntrack 做的事情。</p><p>来看个更具体的防火墙应用：OpenStack 主机防火墙解决方案 —— 安全组（security group）。</p><h4 id="OpenStack-安全组"><a class="header-anchor" href="#OpenStack-安全组">¶</a>OpenStack 安全组</h4><p>简单来说，安全组实现了<strong>虚拟机级别</strong>的安全隔离，具体实现是：在 node 上连接 VM 的 网络设备上做有状态防火墙。在当时，最能实现这一功能的可能就是 Netfilter/iptables。</p><p>回到宿主机内网络拓扑问题： OpenStack 使用 OVS bridge 来连接一台宿主机内的所有 VM。 如果只从网络连通性考虑，那每个 VM 应该直接连到 OVS bridge <code>br-int</code>。但这里问题 就来了 [7]：</p><ul><li>（较早版本的）OVS 没有 conntrack 模块，</li><li>Linux 中有 conntrack 模块，但基于 conntrack 的防火墙<strong>工作在 IP 层</strong>（L3），通过 iptables 控制，</li><li>而 <strong>OVS 是 L2 模块</strong>，无法使用 L3 模块的功能，</li></ul><p>最终结果是：无法在 OVS （连接虚拟机）的设备上做防火墙。</p><p>所以，2016 之前 OpenStack 的解决方案是，在每个 OVS 和 VM 之间再加一个 Linux bridge ，如下图所示，</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/ovs-compute.png" alt></p><p>Fig 1.6. Network topology within an OpenStack compute node, picture from <a href="https://thesaitech.wordpress.com/2017/09/24/how-to-trace-the-tap-interfaces-and-linux-bridges-on-the-hypervisor-your-openstack-vm-is-on/" target="_blank" rel="noopener">Sai's Blog</a></p><p>Linux bridge 也是 L2 模块，按道理也无法使用 iptables。但是，<strong>它有一个 L2 工具 ebtables，能够跳转到 iptables</strong>，因此间接支持了 iptables，也就能用到 Netfilter/iptables 防火墙的功能。</p><p>这种暴力堆砌的方式不仅丑陋、增加网络复杂性，而且会导致性能问题。因此， RedHat 在 2016 年提出了一个 OVS conntrack 方案 [7]，从那以后，才有可能干掉 Linux bridge 而仍然具备安全组的功能。</p><h2 id="1-6-小结"><a class="header-anchor" href="#1-6-小结">¶</a>1.6 小结</h2><p>以上是理论篇，接下来看一下内核实现。</p><p>Netfilter 由几个模块构成，其中最主要的是<strong>连接跟踪</strong>（CT）模块和<strong>网络地址转换</strong>（NAT）模块。</p><p>CT 模块的主要职责是识别出可进行连接跟踪的包。 CT 模块独立于 NAT 模块，但主要目的是服务于后者。</p><h2 id="2-1-Netfilter-框架"><a class="header-anchor" href="#2-1-Netfilter-框架">¶</a>2.1 Netfilter 框架</h2><h3 id="5-个-hook-点"><a class="header-anchor" href="#5-个-hook-点">¶</a>5 个 hook 点</h3><p><img src="/public/2022/12/04/linux_network/conntrack_linux/hooks.png" alt></p><p>图 2.1. The 5 hook points in netfilter framework</p><p>如上图所示，Netfilter 在内核协议栈的包处理路径上提供了 5 个 hook 点，分别是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/netfilter_ipv4.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_PRE_ROUTING    0 <span class="comment">/* After promisc drops, checksum checks. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_LOCAL_IN       1 <span class="comment">/* If the packet is destined for this box. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_FORWARD        2 <span class="comment">/* If the packet is destined for another interface. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_LOCAL_OUT      3 <span class="comment">/* Packets coming from a local process. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_POST_ROUTING   4 <span class="comment">/* Packets about to hit the wire. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_NUMHOOKS       5</span></span><br></pre></td></tr></table></figure><p>用户可以在这些 hook 点注册自己的处理函数（handlers）。当有数据包经过 hook 点时， 就会调用相应的 handlers。</p><blockquote><p>另外还有一套 <code>NF_INET_</code> 开头的定义，<code>include/uapi/linux/netfilter.h</code>。 这两套是等价的，从注释看，<code>NF_IP_</code> 开头的定义可能是为了保持兼容性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">enum</span> nf_inet_hooks &#123;</span><br><span class="line">&gt;  NF_INET_PRE_ROUTING,</span><br><span class="line">&gt;  NF_INET_LOCAL_IN,</span><br><span class="line">&gt;  NF_INET_FORWARD,</span><br><span class="line">&gt;  NF_INET_LOCAL_OUT,</span><br><span class="line">&gt;  NF_INET_POST_ROUTING,</span><br><span class="line">&gt;  NF_INET_NUMHOOKS</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h3 id="hook-返回值类型"><a class="header-anchor" href="#hook-返回值类型">¶</a>hook 返回值类型</h3><p>hook 函数对包进行判断或处理之后，需要返回一个判断结果，指导接下来要对这个包做什 么。可能的结果有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/netfilter.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_DROP   0  <span class="comment">// 已丢弃这个包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_ACCEPT 1  <span class="comment">// 接受这个包，结束判断，继续下一步处理</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_STOLEN 2  <span class="comment">// 临时 hold 这个包，不用再继续穿越协议栈了。常见的情形是缓存分片之后的包（等待重组）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_QUEUE  3  <span class="comment">// 应当将包放到队列</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_REPEAT 4  <span class="comment">// 当前处理函数应当被再次调用</span></span></span><br></pre></td></tr></table></figure><h3 id="hook-优先级"><a class="header-anchor" href="#hook-优先级">¶</a>hook 优先级</h3><p>每个 hook 点可以注册多个处理函数（handler）。在注册时必须指定这些 handlers 的<strong>优先级</strong>，这样触发 hook 时能够根据优先级依次调用处理函数。</p><h2 id="2-2-过滤规则的组织"><a class="header-anchor" href="#2-2-过滤规则的组织">¶</a>2.2 过滤规则的组织</h2><p><code>iptables</code> 是配置 Netfilter 过滤功能的用户空间工具。为便于管理， 过滤规则按功能分为若干 table：</p><ul><li>raw</li><li>filter</li><li>nat</li><li>mangle</li></ul><p>这不是本文重点。更多信息可参考 <a href="chrome-extension://ijllcpnolfcooahcekpamkbidhejabll/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener">(译) 深入理解 iptables 和 netfilter 架构</a></p><p>连接跟踪模块用于维护<strong>可跟踪协议</strong>（trackable protocols）的连接状态。 也就是说，连接跟踪<strong>针对的是特定协议的包，而不是所有协议的包</strong>。 稍后会看到它支持哪些协议。</p><h2 id="3-1-重要结构体和函数"><a class="header-anchor" href="#3-1-重要结构体和函数">¶</a>3.1 重要结构体和函数</h2><p>重要结构体：</p><ul><li><code>struct nf_conntrack_tuple {}</code>: 定义一个 tuple。<ul><li><code>struct nf_conntrack_man {}</code>：tuple 的 manipulable part。<ul><li><code>struct nf_conntrack_man_proto {}</code>：manipulable part 中协议相关的部分。</li></ul></li></ul></li><li><code>struct nf_conntrack_l4proto {}</code>: 支持连接跟踪的<strong>协议需要实现的方法集</strong>（以及其他协议相关字段）。</li><li><code>struct nf_conntrack_tuple_hash {}</code>：哈希表（conntrack table）中的表项（entry）。</li><li><code>struct nf_conn {}</code>：<strong>定义一个 flow</strong>。</li></ul><p>重要函数：</p><ul><li><p><code>hash_conntrack_raw()</code>：根据 tuple 计算出一个 32 位的哈希值（hash key）。</p></li><li><p><code>nf_conntrack_in()</code>：<strong>连接跟踪模块的核心，包进入连接跟踪的地方</strong>。</p></li><li><p><code>resolve_normal_ct() -&gt; init_conntrack() -&gt; ct = __nf_conntrack_alloc(); l4proto-&gt;new(ct)</code></p><p>创建一个新的连接记录（conntrack entry），然后初始化。</p></li><li><p><code>nf_conntrack_confirm()</code>：确认前面通过 <code>nf_conntrack_in()</code> 创建的新连接（是否被丢弃）。</p></li></ul><h2 id="3-2-struct-nf-conntrack-tuple-：元组（Tuple）"><a class="header-anchor" href="#3-2-struct-nf-conntrack-tuple-：元组（Tuple）">¶</a>3.2 <code>struct nf_conntrack_tuple {}</code>：元组（Tuple）</h2><p>Tuple 是连接跟踪中最重要的概念之一。</p><p><strong>一个 tuple 定义一个单向（unidirectional）flow</strong>。内核代码中有如下注释：</p><blockquote><p>//include/net/netfilter/nf_conntrack_tuple.h</p><p>A <code>tuple</code> is a structure containing the information to uniquely identify a connection. ie. if two packets have the same tuple, they are in the same connection; if not, they are not.</p></blockquote><h3 id="结构体定义"><a class="header-anchor" href="#结构体定义">¶</a>结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//include/net/netfilter/nf_conntrack_tuple.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为方便 NAT 的实现，内核将 tuple 结构体拆分为 "manipulatable" 和 "non-manipulatable" 两部分</span></span><br><span class="line"><span class="comment">// 下面结构体中的 _man 是 manipulatable 的缩写</span></span><br><span class="line">                                               <span class="comment">// ude/uapi/linux/netfilter.h</span></span><br><span class="line">                                               <span class="keyword">union</span> nf_inet_addr &#123;</span><br><span class="line">                                                   __u32            all[<span class="number">4</span>];</span><br><span class="line">                                                   __be32           ip;</span><br><span class="line">                                                   __be32           ip6[<span class="number">4</span>];</span><br><span class="line">                                                   <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>   <span class="title">in</span>;</span></span><br><span class="line">                                                   <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span>  <span class="title">in6</span>;</span></span><br><span class="line"><span class="comment">/* manipulable part of the tuple */</span>         /  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_man</span> &#123;</span>                  /</span><br><span class="line">    <span class="keyword">union</span> nf_inet_addr           u3; --&gt;--/</span><br><span class="line">    <span class="keyword">union</span> nf_conntrack_man_proto u;  --&gt;--\</span><br><span class="line">                                           \   <span class="comment">// include/uapi/linux/netfilter/nf_conntrack_tuple_common.h</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> l3num; <span class="comment">// L3 proto            \  // 协议相关的部分</span></span><br><span class="line">&#125;;                                            <span class="keyword">union</span> nf_conntrack_man_proto &#123;</span><br><span class="line">                                                  __be16 all;<span class="comment">/* Add other protocols here. */</span></span><br><span class="line"></span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; tcp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; udp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 id;   &#125; icmp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; dccp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; sctp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 key;  &#125; gre;</span><br><span class="line">                                              &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> &#123;</span> <span class="comment">/* This contains the information to distinguish a connection. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_man</span> <span class="title">src</span>;</span>  <span class="comment">// 源地址信息，manipulable part</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">union</span> nf_inet_addr u3;</span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">            __be16 all; <span class="comment">/* Add other protocols here. */</span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; tcp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; udp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">u_int8_t</span> type, code; &#125; icmp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; dccp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; sctp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 key;          &#125; gre;</span><br><span class="line">        &#125; u;</span><br><span class="line">        <span class="keyword">u_int8_t</span> protonum; <span class="comment">/* The protocol. */</span></span><br><span class="line">        <span class="keyword">u_int8_t</span> dir;      <span class="comment">/* The direction (for tuplehash) */</span></span><br><span class="line">    &#125; dst;                       <span class="comment">// 目的地址信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Tuple 结构体中只有两个字段 src 和 dst</strong>，分别保存源和目的信息。<code>src</code> 和 <code>dst</code> 自身也是结构体，能保存不同类型协议的数据。以 IPv4 UDP 为例，五元组分别保存在如下字段：</p><ul><li><code>dst.protonum</code>：协议类型</li><li><code>src.u3.ip</code>：源 IP 地址</li><li><code>dst.u3.ip</code>：目的 IP 地址</li><li><code>src.u.udp.port</code>：源端口号</li><li><code>dst.u.udp.port</code>：目的端口号</li></ul><h3 id="CT-支持的协议"><a class="header-anchor" href="#CT-支持的协议">¶</a>CT 支持的协议</h3><p>从以上定义可以看到，连接跟踪模块<strong>目前只支持以下六种协议</strong>：TCP、UDP、ICMP、DCCP、SCTP、GRE。</p><p><strong>注意其中的 ICMP 协议</strong>。大家可能会认为，连接跟踪模块依据包的三层和四层信息做 哈希，而 ICMP 是三层协议，没有四层信息，因此 ICMP 肯定不会被 CT 记录。但<strong>实际上 是会的</strong>，上面代码可以看到，ICMP 使用了其头信息中的 ICMP <code>type</code>和 <code>code</code> 字段来 定义 tuple。</p><h2 id="3-3-struct-nf-conntrack-l4proto-：协议需要实现的方法集合"><a class="header-anchor" href="#3-3-struct-nf-conntrack-l4proto-：协议需要实现的方法集合">¶</a>3.3 <code>struct nf_conntrack_l4proto {}</code>：协议需要实现的方法集合</h2><p>支持连接跟踪的协议都需要实现 <code>struct nf_conntrack_l4proto {}</code> 结构体 中定义的方法，例如 <code>pkt_to_tuple()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_l4proto.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_l4proto</span> &#123;</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> l3proto; <span class="comment">/* L3 Protocol number. */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span>  l4proto; <span class="comment">/* L4 Protocol number. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从包（skb）中提取 tuple</span></span><br><span class="line">    <span class="keyword">bool</span> (*pkt_to_tuple)(struct sk_buff *skb, ... struct nf_conntrack_tuple *tuple);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对包进行判决，返回判决结果（returns verdict for packet）</span></span><br><span class="line">    <span class="keyword">int</span> (*packet)(struct nf_conn *ct, <span class="keyword">const</span> struct sk_buff *skb ...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新连接。如果成功返回 TRUE；如果返回的是 TRUE，接下来会调用 packet() 方法</span></span><br><span class="line">    <span class="keyword">bool</span> (*<span class="keyword">new</span>)(struct nf_conn *ct, <span class="keyword">const</span> struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> dataoff);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前数据包能否被连接跟踪。如果返回成功，接下来会调用 packet() 方法</span></span><br><span class="line">    <span class="keyword">int</span> (*error)(struct net *net, struct nf_conn *tmpl, struct sk_buff *skb, ...);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-4-struct-nf-conntrack-tuple-hash-：哈希表项"><a class="header-anchor" href="#3-4-struct-nf-conntrack-tuple-hash-：哈希表项">¶</a>3.4 <code>struct nf_conntrack_tuple_hash {}</code>：哈希表项</h2><p>conntrack 将活动连接的状态存储在一张哈希表中（<code>key: value</code>）。</p><p><code>hash_conntrack_raw()</code> 根据 tuple 计算出一个 32 位的哈希值（key）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">hash_conntrack_raw</span><span class="params">(struct nf_conntrack_tuple *tuple, struct net *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    get_random_once(&amp;nf_conntrack_hash_rnd, <span class="keyword">sizeof</span>(nf_conntrack_hash_rnd));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The direction must be ignored, so we hash everything up to the</span></span><br><span class="line"><span class="comment">     * destination ports (which is a multiple of 4) and treat the last three bytes manually.  */</span></span><br><span class="line">    u32 seed = nf_conntrack_hash_rnd ^ net_hash_mix(net);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = (<span class="keyword">sizeof</span>(tuple-&gt;src) + <span class="keyword">sizeof</span>(tuple-&gt;dst.u3)) / <span class="keyword">sizeof</span>(u32);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jhash2((u32 *)tuple, n, seed ^ ((tuple-&gt;dst.u.all &lt;&lt; <span class="number">16</span>) | tuple-&gt;dst.protonum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意其中是如何利用 tuple 的不同字段来计算哈希的。</p><p><code>nf_conntrack_tuple_hash</code> 是哈希表中的表项（value）:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_tuple.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每条连接在哈希表中都对应两项，分别对应两个方向（egress/ingress）</span></span><br><span class="line"><span class="comment">// Connections have two entries in the hash table: one for each way</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_node</span>   <span class="title">hnnode</span>;</span>   <span class="comment">// 指向该哈希对应的连接 struct nf_conn，采用 list 形式是为了解决哈希冲突</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> <span class="title">tuple</span>;</span>    <span class="comment">// N 元组，前面详细介绍过了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-5-struct-nf-conn-：连接（connection）"><a class="header-anchor" href="#3-5-struct-nf-conn-：连接（connection）">¶</a>3.5 <code>struct nf_conn {}</code>：连接（connection）</h2><p><strong>Netfilter 中每个 flow 都称为一个 connection</strong>，即使是对那些非面向连接的协议（例 如 UDP）。每个 connection 用 <code>struct nf_conn {}</code> 表示，主要字段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack.h</span></span><br><span class="line"></span><br><span class="line">                                                  <span class="comment">// include/linux/skbuff.h</span></span><br><span class="line">                                        ------&gt;   <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack</span> &#123;</span></span><br><span class="line">                                        |             <span class="keyword">atomic_t</span> use;  <span class="comment">// 连接引用计数？</span></span><br><span class="line">                                        |         &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> &#123;</span>                        |</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack</span>            <span class="title">ct_general</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> <span class="title">tuplehash</span>[<span class="title">IP_CT_DIR_MAX</span>];</span> <span class="comment">// 哈希表项，数组是因为要记录两个方向的 flow</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> status; <span class="comment">// 连接状态，见下文</span></span><br><span class="line">    u32 timeout;          <span class="comment">// 连接状态的定时器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">possible_net_t</span> ct_net;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>    <span class="title">nat_bysource</span>;</span></span><br><span class="line">                                                        <span class="comment">// per conntrack: protocol private data</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">master</span>;</span>                             <span class="keyword">union</span> nf_conntrack_proto &#123;</span><br><span class="line">                                                       /    <span class="comment">/* insert conntrack proto private data here */</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> mark;    <span class="comment">/* 对 skb 进行特殊标记 */</span>      /     <span class="class"><span class="keyword">struct</span> <span class="title">nf_ct_dccp</span> <span class="title">dccp</span>;</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> secmark;                               /      <span class="class"><span class="keyword">struct</span> <span class="title">ip_ct_sctp</span> <span class="title">sctp</span>;</span></span><br><span class="line">                                                    /       <span class="class"><span class="keyword">struct</span> <span class="title">ip_ct_tcp</span> <span class="title">tcp</span>;</span></span><br><span class="line">    <span class="keyword">union</span> nf_conntrack_proto proto; ----------&gt;----/        <span class="class"><span class="keyword">struct</span> <span class="title">nf_ct_gre</span> <span class="title">gre</span>;</span></span><br><span class="line">&#125;;                                                          <span class="keyword">unsigned</span> <span class="keyword">int</span> tmpl_padto;</span><br><span class="line">                                                        &#125;;</span><br></pre></td></tr></table></figure><p><strong>连接的状态集合 enum ip_conntrack_status</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// include/uapi/linux/netfilter/nf_conntrack_common.h</span><br><span class="line"></span><br><span class="line">enum ip_conntrack_status &#123;</span><br><span class="line">    IPS_EXPECTED      = (1 &lt;&lt; IPS_EXPECTED_BIT),</span><br><span class="line">    IPS_SEEN_REPLY    = (1 &lt;&lt; IPS_SEEN_REPLY_BIT),</span><br><span class="line">    IPS_ASSURED       = (1 &lt;&lt; IPS_ASSURED_BIT),</span><br><span class="line">    IPS_CONFIRMED     = (1 &lt;&lt; IPS_CONFIRMED_BIT),</span><br><span class="line">    IPS_SRC_NAT       = (1 &lt;&lt; IPS_SRC_NAT_BIT),</span><br><span class="line">    IPS_DST_NAT       = (1 &lt;&lt; IPS_DST_NAT_BIT),</span><br><span class="line">    IPS_NAT_MASK      = (IPS_DST_NAT | IPS_SRC_NAT),</span><br><span class="line">    IPS_SEQ_ADJUST    = (1 &lt;&lt; IPS_SEQ_ADJUST_BIT),</span><br><span class="line">    IPS_SRC_NAT_DONE  = (1 &lt;&lt; IPS_SRC_NAT_DONE_BIT),</span><br><span class="line">    IPS_DST_NAT_DONE  = (1 &lt;&lt; IPS_DST_NAT_DONE_BIT),</span><br><span class="line">    IPS_NAT_DONE_MASK = (IPS_DST_NAT_DONE | IPS_SRC_NAT_DONE),</span><br><span class="line">    IPS_DYING         = (1 &lt;&lt; IPS_DYING_BIT),</span><br><span class="line">    IPS_FIXED_TIMEOUT = (1 &lt;&lt; IPS_FIXED_TIMEOUT_BIT),</span><br><span class="line">    IPS_TEMPLATE      = (1 &lt;&lt; IPS_TEMPLATE_BIT),</span><br><span class="line">    IPS_UNTRACKED     = (1 &lt;&lt; IPS_UNTRACKED_BIT),</span><br><span class="line">    IPS_HELPER        = (1 &lt;&lt; IPS_HELPER_BIT),</span><br><span class="line">    IPS_OFFLOAD       = (1 &lt;&lt; IPS_OFFLOAD_BIT),</span><br><span class="line"></span><br><span class="line">    IPS_UNCHANGEABLE_MASK = (IPS_NAT_DONE_MASK | IPS_NAT_MASK |</span><br><span class="line">                 IPS_EXPECTED | IPS_CONFIRMED | IPS_DYING |</span><br><span class="line">                 IPS_SEQ_ADJUST | IPS_TEMPLATE | IPS_OFFLOAD),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-6-nf-conntrack-in-：进入连接跟踪"><a class="header-anchor" href="#3-6-nf-conntrack-in-：进入连接跟踪">¶</a>3.6 <code>nf_conntrack_in()</code>：进入连接跟踪</h2><p><img src="/public/2022/12/04/linux_network/conntrack_linux/netfilter-conntrack.png" alt></p><p>Fig. Netfilter 中的连接跟踪点</p><p>如上图所示，Netfilter 在四个 Hook 点对包进行跟踪：</p><ol><li><p><code>PRE_ROUTING</code> 和 <code>LOCAL_OUT</code>：<strong>调用 nf_conntrack_in() 开始连接跟踪</strong>， 正常情况下会创建一条新连接记录，然后将 conntrack entry 放到 <strong>unconfirmed list</strong>。</p><p>为什么是这两个 hook 点呢？因为它们都是<strong>新连接的第一个包最先达到的地方</strong>，</p><ul><li><code>PRE_ROUTING</code> 是<strong>外部主动和本机建连</strong>时包最先到达的地方</li><li><code>LOCAL_OUT</code> 是<strong>本机主动和外部建连</strong>时包最先到达的地方</li></ul></li><li><p><code>POST_ROUTING</code> 和 <code>LOCAL_IN</code>：<strong>调用 nf_conntrack_confirm() 将 nf_conntrack_in() 创建的连接移到 confirmed list</strong>。</p><p>同样要问，为什么在这两个 hook 点呢？因为如果新连接的第一个包没有被丢弃，那这 是它们<strong>离开 netfilter 之前的最后 hook 点</strong>：</p><ul><li><strong>外部主动和本机建连</strong>的包，如果在中间处理中没有被丢弃，<code>LOCAL_IN</code> 是其被送到应用（例如 nginx 服务）之前的最后 hook 点</li><li><strong>本机主动和外部建连</strong>的包，如果在中间处理中没有被丢弃，<code>POST_ROUTING</code> 是其离开主机时的最后 hook 点</li></ul></li></ol><p>下面的代码可以看到<strong>这些 handler 是如何注册到 Netfilter hook 点的</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_proto.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Connection tracking may drop packets, but never alters them, so make it the first hook.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> <span class="title">ipv4_conntrack_ops</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_conntrack_in,       <span class="comment">// 调用 nf_conntrack_in() 进入连接跟踪</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_PRE_ROUTING,     <span class="comment">// PRE_ROUTING hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_conntrack_local,    <span class="comment">// 调用 nf_conntrack_in() 进入连接跟踪</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_LOCAL_OUT,       <span class="comment">// LOCAL_OUT hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_confirm,            <span class="comment">// 调用 nf_conntrack_confirm()</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_POST_ROUTING,    <span class="comment">// POST_ROUTING hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK_CONFIRM,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_confirm,            <span class="comment">// 调用 nf_conntrack_confirm()</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_LOCAL_IN,        <span class="comment">// LOCAL_IN hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK_CONFIRM,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>nf_conntrack_in()</code> 是<strong>连接跟踪模块的核心</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">nf_conntrack_in(struct net *net, <span class="keyword">u_int8_t</span> pf, <span class="keyword">unsigned</span> <span class="keyword">int</span> hooknum, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">tmpl</span> = <span class="title">nf_ct_get</span>(<span class="title">skb</span>, &amp;<span class="title">ctinfo</span>);</span> <span class="comment">// 获取 skb 对应的 conntrack_info 和连接记录</span></span><br><span class="line">  <span class="keyword">if</span> (tmpl || ctinfo == IP_CT_UNTRACKED) &#123;        <span class="comment">// 如果记录存在，或者是不需要跟踪的类型</span></span><br><span class="line">      <span class="keyword">if</span> ((tmpl &amp;&amp; !nf_ct_is_template(tmpl)) || ctinfo == IP_CT_UNTRACKED) &#123;</span><br><span class="line">          NF_CT_STAT_INC_ATOMIC(net, ignore);     <span class="comment">// 无需跟踪的类型，增加 ignore 计数</span></span><br><span class="line">          <span class="keyword">return</span> NF_ACCEPT;                       <span class="comment">// 返回 NF_ACCEPT，继续后面的处理</span></span><br><span class="line">      &#125;</span><br><span class="line">      skb-&gt;_nfct = <span class="number">0</span>;                             <span class="comment">// 不属于 ignore 类型，计数器置零，准备后续处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_l4proto</span> *<span class="title">l4proto</span> = __<span class="title">nf_ct_l4proto_find</span>(...);</span>    <span class="comment">// 提取协议相关的 L4 头信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l4proto-&gt;error != <span class="literal">NULL</span>) &#123;                   <span class="comment">// skb 的完整性和合法性验证</span></span><br><span class="line">      <span class="keyword">if</span> (l4proto-&gt;error(net, tmpl, skb, dataoff, pf, hooknum) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          NF_CT_STAT_INC_ATOMIC(net, error);</span><br><span class="line">          NF_CT_STAT_INC_ATOMIC(net, invalid);</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">  <span class="comment">// 开始连接跟踪：提取 tuple；创建新连接记录，或者更新已有连接的状态</span></span><br><span class="line">  resolve_normal_ct(net, tmpl, skb, ... l4proto);</span><br><span class="line"></span><br><span class="line">  l4proto-&gt;packet(ct, skb, dataoff, ctinfo); <span class="comment">// 进行一些协议相关的处理，例如 UDP 会更新 timeout</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctinfo == IP_CT_ESTABLISHED_REPLY &amp;&amp; !test_and_set_bit(IPS_SEEN_REPLY_BIT, &amp;ct-&gt;status))</span><br><span class="line">      nf_conntrack_event_cache(IPCT_REPLY, ct);</span><br><span class="line">out:</span><br><span class="line">  <span class="keyword">if</span> (tmpl)</span><br><span class="line">      nf_ct_put(tmpl); <span class="comment">// 解除对连接记录 tmpl 的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致流程：</p><ol><li>尝试获取这个 skb 对应的连接跟踪记录</li><li>判断是否需要对这个包做连接跟踪，如果不需要，更新 ignore 计数（<code>conntrack -S</code> 能看到这个计数）， 返回 <code>NF_ACCEPT</code>；如果需要，就<strong>初始化这个 skb 的引用计数</strong>。</li><li>从包的 L4 header 中提取信息，初始化协议相关的 <code>struct nf_conntrack_l4proto {}</code> 变量，其中包含了该协议的<strong>连接跟踪相关的回调方法</strong>。</li><li>调用该协议的 <code>error()</code> 方法检查包的完整性、校验和等信息。</li><li>调用 <code>resolve_normal_ct()</code> <strong>开始连接跟踪</strong>，它会创建新 tuple，新 conntrack entry，或者更新已有连接的状态。</li><li>调用该协议的 <code>packet()</code> 方法进行一些协议相关的处理，例如对于 UDP，如果 status bit 里面设置了 <code>IPS_SEEN_REPLY</code> 位，就会更新 timeout。timeout 大小和协 议相关，越小越越可以防止 DoS 攻击（DoS 的基本原理就是将机器的可用连接耗尽）</li></ol><h2 id="3-7-init-conntrack-：创建新连接记录"><a class="header-anchor" href="#3-7-init-conntrack-：创建新连接记录">¶</a>3.7 <code>init_conntrack()</code>：创建新连接记录</h2><p>如果连接不存在（flow 的第一个包），<code>resolve_normal_ct()</code> 会调用 <code>init_conntrack</code> ，后者进而会调用 <code>new()</code> 方法创建一个新的 conntrack entry。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a new conntrack</span></span><br><span class="line"><span class="keyword">static</span> noinline <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> *</span></span><br><span class="line"><span class="class"><span class="title">init_conntrack</span>(<span class="title">struct</span> <span class="title">net</span> *<span class="title">net</span>, <span class="title">struct</span> <span class="title">nf_conn</span> *<span class="title">tmpl</span>,</span></span><br><span class="line"><span class="class">           <span class="title">const</span> <span class="title">struct</span> <span class="title">nf_conntrack_tuple</span> *<span class="title">tuple</span>,</span></span><br><span class="line"><span class="class">           <span class="title">const</span> <span class="title">struct</span> <span class="title">nf_conntrack_l4proto</span> *<span class="title">l4proto</span>,</span></span><br><span class="line"><span class="class">           <span class="title">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">dataoff</span>, <span class="title">u32</span> <span class="title">hash</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">ct</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 conntrack table 中分配一个 entry，如果哈希表满了，会在内核日志中打印</span></span><br><span class="line">    <span class="comment">// "nf_conntrack: table full, dropping packet" 信息，通过 `dmesg -T` 能看到</span></span><br><span class="line">    ct = __nf_conntrack_alloc(net, zone, tuple, &amp;repl_tuple, GFP_ATOMIC, hash);</span><br><span class="line"></span><br><span class="line">    l4proto-&gt;<span class="keyword">new</span>(ct, skb, dataoff); <span class="comment">// 协议相关的方法</span></span><br><span class="line"></span><br><span class="line">    local_bh_disable();             <span class="comment">// 关闭软中断</span></span><br><span class="line">    <span class="keyword">if</span> (net-&gt;ct.expect_count) &#123;</span><br><span class="line">        <span class="built_in">exp</span> = nf_ct_find_expectation(net, zone, tuple);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>) &#123;</span><br><span class="line">            <span class="comment">/* Welcome, Mr. Bond.  We've been expecting you... */</span></span><br><span class="line">            __set_bit(IPS_EXPECTED_BIT, &amp;ct-&gt;status);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* exp-&gt;master safe, refcnt bumped in nf_ct_find_expectation */</span></span><br><span class="line">            ct-&gt;master = <span class="built_in">exp</span>-&gt;master;</span><br><span class="line">            ct-&gt;mark = <span class="built_in">exp</span>-&gt;master-&gt;mark;</span><br><span class="line">            ct-&gt;secmark = <span class="built_in">exp</span>-&gt;master-&gt;secmark;</span><br><span class="line">            NF_CT_STAT_INC(net, expect_new);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now it is inserted into the unconfirmed list, bump refcount */</span></span><br><span class="line">    <span class="comment">// 至此这个新的 conntrack entry 已经被插入 unconfirmed list</span></span><br><span class="line">    nf_conntrack_get(&amp;ct-&gt;ct_general);</span><br><span class="line">    nf_ct_add_to_unconfirmed_list(ct);</span><br><span class="line"></span><br><span class="line">    local_bh_enable();              <span class="comment">// 重新打开软中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>-&gt;expectfn)</span><br><span class="line">            <span class="built_in">exp</span>-&gt;expectfn(ct, <span class="built_in">exp</span>);</span><br><span class="line">        nf_ct_expect_put(<span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每种协议需要实现自己的 <code>l4proto-&gt;new()</code> 方法，代码见：<code>net/netfilter/nf_conntrack_proto_*.c</code>。 例如 TCP 协议对应的 <code>new()</code> 方法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_proto_tcp.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called when a new connection for this protocol found. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">tcp_new</span><span class="params">(struct nf_conn *ct, <span class="keyword">const</span> struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> dataoff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (new_state == TCP_CONNTRACK_SYN_SENT) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;ct-&gt;proto.tcp, <span class="number">0</span>, <span class="keyword">sizeof</span>(ct-&gt;proto.tcp));</span><br><span class="line">        <span class="comment">/* SYN packet */</span></span><br><span class="line">        ct-&gt;proto.tcp.seen[<span class="number">0</span>].td_end = segment_seq_plus_len(ntohl(th-&gt;seq), skb-&gt;len, dataoff, th);</span><br><span class="line">        ct-&gt;proto.tcp.seen[<span class="number">0</span>].td_maxwin = ntohs(th-&gt;window);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前包会影响后面包的状态判断，<code>init_conntrack()</code> 会设置 <code>struct nf_conn</code> 的 <code>master</code> 字段。面向连接的协议会用到这个特性，例如 TCP。</p><h2 id="3-8-nf-conntrack-confirm-：确认包没有被丢弃"><a class="header-anchor" href="#3-8-nf-conntrack-confirm-：确认包没有被丢弃">¶</a>3.8 <code>nf_conntrack_confirm()</code>：确认包没有被丢弃</h2><p><code>nf_conntrack_in()</code> 创建的新 conntrack entry 会插入到一个 <strong>未确认连接</strong>（ unconfirmed connection）列表。</p><p>如果这个包之后没有被丢弃，那它在经过 <code>POST_ROUTING</code> 时会被 <code>nf_conntrack_confirm()</code> 方法处理，原理我们在分析过了 3.6 节的开头分析过了。 <code>nf_conntrack_confirm()</code> 完成之后，状态就变为了 <code>IPS_CONFIRMED</code>，并且连接记录从 <strong>未确认列表</strong>移到<strong>正常</strong>的列表。</p><p>之所以把创建一个新 entry 的过程分为创建（new）和确认（confirm）两个阶段 ，是因为<strong>包在经过 nf_conntrack_in() 之后，到达 nf_conntrack_confirm() 之前 ，可能会被内核丢弃</strong>。这样会导致系统残留大量的半连接状态记录，在性能和安全性上都 是很大问题。分为两步之后，可以加快半连接状态 conntrack entry 的 GC。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_core.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Confirm a connection: returns NF_DROP if packet must be dropped. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nf_conntrack_confirm</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">ct</span> = (<span class="title">struct</span> <span class="title">nf_conn</span> *)<span class="title">skb_nfct</span>(<span class="title">skb</span>);</span></span><br><span class="line">    <span class="keyword">int</span> ret = NF_ACCEPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ct) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nf_ct_is_confirmed(ct))</span><br><span class="line">            ret = __nf_conntrack_confirm(skb);</span><br><span class="line">        <span class="keyword">if</span> (likely(ret == NF_ACCEPT))</span><br><span class="line">            nf_ct_deliver_cached_events(ct);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>confirm 逻辑，省略了各种错误处理逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Confirm a connection given skb; places it in hash table */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__nf_conntrack_confirm(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">ct</span>;</span></span><br><span class="line">    ct = nf_ct_get(skb, &amp;ctinfo);</span><br><span class="line"></span><br><span class="line">    local_bh_disable();               <span class="comment">// 关闭软中断</span></span><br><span class="line"></span><br><span class="line">    hash = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;ct-&gt;tuplehash[IP_CT_DIR_REPLY].hnnode.pprev;</span><br><span class="line">    reply_hash = hash_conntrack(net, &amp;ct-&gt;tuplehash[IP_CT_DIR_REPLY].tuple);</span><br><span class="line"></span><br><span class="line">    ct-&gt;timeout += nfct_time_stamp;   <span class="comment">// 更新连接超时时间，超时后会被 GC</span></span><br><span class="line">    atomic_inc(&amp;ct-&gt;ct_general.use);  <span class="comment">// 设置连接引用计数？</span></span><br><span class="line">    ct-&gt;status |= IPS_CONFIRMED;      <span class="comment">// 设置连接状态为 confirmed</span></span><br><span class="line"></span><br><span class="line">    __nf_conntrack_hash_insert(ct, hash, reply_hash);  <span class="comment">// 插入到连接跟踪哈希表</span></span><br><span class="line"></span><br><span class="line">    local_bh_enable();                <span class="comment">// 重新打开软中断</span></span><br><span class="line"></span><br><span class="line">    nf_conntrack_event_cache(master_ct(ct) ? IPCT_RELATED : IPCT_NEW, ct);</span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>连接跟踪的处理逻辑中需要频繁关闭和打开软中断</strong>，此外还有各种锁， 这是短连高并发场景下连接跟踪性能损耗的主要原因？。</p><p>NAT 是与连接跟踪独立的模块。</p><h2 id="4-1-重要数据结构和函数"><a class="header-anchor" href="#4-1-重要数据结构和函数">¶</a>4.1 重要数据结构和函数</h2><p><strong>重要数据结构：</strong></p><p>支持 NAT 的协议需要实现其中的方法：</p><ul><li><code>struct nf_nat_l3proto {}</code></li><li><code>struct nf_nat_l4proto {}</code></li></ul><p><strong>重要函数：</strong></p><ul><li><code>nf_nat_inet_fn()</code>：NAT 的核心函数，在<strong>除 NF_INET_FORWARD 之外的其他 hook 点都会被调用</strong>。</li></ul><h2 id="4-2-NAT-模块初始化"><a class="header-anchor" href="#4-2-NAT-模块初始化">¶</a>4.2 NAT 模块初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_nat_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_hook</span> <span class="title">nat_hook</span> = &#123;</span></span><br><span class="line">    .parse_nat_setup    = nfnetlink_parse_nat_setup,</span><br><span class="line">    .decode_session        = __nf_nat_decode_session,</span><br><span class="line">    .manip_pkt        = nf_nat_manip_pkt,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">nf_nat_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nf_nat_bysource = nf_ct_alloc_hashtable(&amp;nf_nat_htable_size, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    nf_ct_helper_expectfn_register(&amp;follow_master_nat);</span><br><span class="line"></span><br><span class="line">    RCU_INIT_POINTER(nf_nat_hook, &amp;nat_hook);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">module_init(nf_nat_init);</span><br></pre></td></tr></table></figure><h2 id="4-3-struct-nf-nat-l3proto-：协议相关的-NAT-方法集"><a class="header-anchor" href="#4-3-struct-nf-nat-l3proto-：协议相关的-NAT-方法集">¶</a>4.3 <code>struct nf_nat_l3proto {}</code>：协议相关的 NAT 方法集</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_nat_l3proto.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_l3proto</span> &#123;</span></span><br><span class="line">    u8    l3proto; <span class="comment">// 例如，AF_INET</span></span><br><span class="line"></span><br><span class="line">    u32     (*secure_port    )(<span class="keyword">const</span> struct nf_conntrack_tuple *t, __be16);</span><br><span class="line">    <span class="keyword">bool</span>    (*manip_pkt      )(struct sk_buff *skb, ...);</span><br><span class="line">    <span class="keyword">void</span>    (*csum_update    )(struct sk_buff *skb, ...);</span><br><span class="line">    <span class="keyword">void</span>    (*csum_recalc    )(struct sk_buff *skb, u8 proto, ...);</span><br><span class="line">    <span class="keyword">void</span>    (*decode_session )(struct sk_buff *skb, ...);</span><br><span class="line">    <span class="keyword">int</span>     (*nlattr_to_range)(struct nlattr *tb[], struct nf_nat_range2 *range);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-4-struct-nf-nat-l4proto-：协议相关的-NAT-方法集"><a class="header-anchor" href="#4-4-struct-nf-nat-l4proto-：协议相关的-NAT-方法集">¶</a>4.4 <code>struct nf_nat_l4proto {}</code>：协议相关的 NAT 方法集</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_nat_l4proto.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_l4proto</span> &#123;</span></span><br><span class="line">    u8 l4proto; <span class="comment">// Protocol number，例如 IPPROTO_UDP, IPPROTO_TCP</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传入的 tuple 和 NAT 类型（SNAT/DNAT）修改包的 L3/L4 头</span></span><br><span class="line">    <span class="keyword">bool</span> (*manip_pkt)(struct sk_buff *skb, *l3proto, *tuple, maniptype);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个唯一的 tuple</span></span><br><span class="line">    <span class="comment">// 例如对于 UDP，会根据 src_ip, dst_ip, src_port 加一个随机数生成一个 16bit 的 dst_port</span></span><br><span class="line">    <span class="keyword">void</span> (*unique_tuple)(*l3proto, tuple, struct nf_nat_range2 *range, maniptype, struct nf_conn *ct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the address range is exhausted the NAT modules will begin to drop packets.</span></span><br><span class="line">    <span class="keyword">int</span> (*nlattr_to_range)(struct nlattr *tb[], struct nf_nat_range2 *range);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>各协议实现的方法，见：<code>net/netfilter/nf_nat_proto_*.c</code>。例如 TCP 的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_nat_proto_tcp.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_l4proto</span> <span class="title">nf_nat_l4proto_tcp</span> = &#123;</span></span><br><span class="line">    .l4proto        = IPPROTO_TCP,</span><br><span class="line">    .manip_pkt        = tcp_manip_pkt,</span><br><span class="line">    .in_range        = nf_nat_l4proto_in_range,</span><br><span class="line">    .unique_tuple        = tcp_unique_tuple,</span><br><span class="line">    .nlattr_to_range    = nf_nat_l4proto_nlattr_to_range,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-5-nf-nat-inet-fn-：进入-NAT"><a class="header-anchor" href="#4-5-nf-nat-inet-fn-：进入-NAT">¶</a>4.5 <code>nf_nat_inet_fn()</code>：进入 NAT</h2><p>NAT 的核心函数是 <code>nf_nat_inet_fn()</code>，它会在以下 hook 点被调用：</p><ul><li><code>NF_INET_PRE_ROUTING</code></li><li><code>NF_INET_POST_ROUTING</code></li><li><code>NF_INET_LOCAL_OUT</code></li><li><code>NF_INET_LOCAL_IN</code></li></ul><p>也就是除了 <code>NF_INET_FORWARD</code> 之外其他 hook 点都会被调用。</p><p><strong>在这些 hook 点的优先级</strong>：<strong>Conntrack &gt; NAT &gt; Packet Filtering</strong>。 <strong>连接跟踪的优先级高于 NAT</strong> 是因为 NAT 依赖连接跟踪的结果。</p><p><img src="/public/2022/12/04/linux_network/conntrack_linux/hook-to-nat.png" alt></p><p>Fig. NAT</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">nf_nat_inet_fn(<span class="keyword">void</span> *priv, struct sk_buff *skb, <span class="keyword">const</span> struct nf_hook_state *state)</span><br><span class="line">&#123;</span><br><span class="line">    ct = nf_ct_get(skb, &amp;ctinfo);</span><br><span class="line">    <span class="keyword">if</span> (!ct)    <span class="comment">// conntrack 不存在就做不了 NAT，直接返回，这也是我们为什么说 NAT 依赖 conntrack 的结果</span></span><br><span class="line">        <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line"></span><br><span class="line">    nat = nfct_nat(ct);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ctinfo) &#123;</span><br><span class="line">    <span class="keyword">case</span> IP_CT_RELATED:</span><br><span class="line">    <span class="keyword">case</span> IP_CT_RELATED_REPLY: <span class="comment">/* Only ICMPs can be IP_CT_IS_REPLY.  Fallthrough */</span></span><br><span class="line">    <span class="keyword">case</span> IP_CT_NEW: <span class="comment">/* Seen it before? This can happen for loopback, retrans, or local packets. */</span></span><br><span class="line">        <span class="keyword">if</span> (!nf_nat_initialized(ct, maniptype)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_entries</span> *<span class="title">e</span> = <span class="title">rcu_dereference</span>(<span class="title">lpriv</span>-&gt;<span class="title">entries</span>);</span> <span class="comment">// 获取所有 NAT 规则</span></span><br><span class="line">            <span class="keyword">if</span> (!e)</span><br><span class="line">                <span class="keyword">goto</span> null_bind;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e-&gt;num_hook_entries; i++) &#123; <span class="comment">// 依次执行 NAT 规则</span></span><br><span class="line">                <span class="keyword">if</span> (e-&gt;hooks[i].hook(e-&gt;hooks[i].priv, skb, state) != NF_ACCEPT )</span><br><span class="line">                    <span class="keyword">return</span> ret;                         <span class="comment">// 任何规则返回非 NF_ACCEPT，就停止当前处理</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nf_nat_initialized(ct, maniptype))</span><br><span class="line">                    <span class="keyword">goto</span> do_nat;</span><br><span class="line">            &#125;</span><br><span class="line">null_bind:</span><br><span class="line">            nf_nat_alloc_null_binding(ct, state-&gt;hook);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Already setup manip</span></span><br><span class="line">            <span class="keyword">if</span> (nf_nat_oif_changed(state-&gt;hook, ctinfo, nat, state-&gt;out))</span><br><span class="line">                <span class="keyword">goto</span> oif_changed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* ESTABLISHED */</span></span><br><span class="line">        <span class="keyword">if</span> (nf_nat_oif_changed(state-&gt;hook, ctinfo, nat, state-&gt;out))</span><br><span class="line">            <span class="keyword">goto</span> oif_changed;</span><br><span class="line">    &#125;</span><br><span class="line">do_nat:</span><br><span class="line">    <span class="keyword">return</span> nf_nat_packet(ct, ctinfo, state-&gt;hook, skb);</span><br><span class="line">oif_changed:</span><br><span class="line">    nf_ct_kill_acct(ct, ctinfo, skb);</span><br><span class="line">    <span class="keyword">return</span> NF_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查询 conntrack 记录，如果不存在，就意味着无法跟踪这个连接，那就更不可能做 NAT 了，因此直接返回。</p><p>如果找到了 conntrack 记录，并且是 <code>IP_CT_RELATED</code>、<code>IP_CT_RELATED_REPLY</code> 或 <code>IP_CT_NEW</code> 状态，就去获取 NAT 规则。如果没有规则，直接返回 <code>NF_ACCEPT</code>，对包不 做任何改动；如果有规则，最后执行 <code>nf_nat_packet</code>，这个函数会进一步调用 <code>manip_pkt</code> 完成对包的修改，如果失败，包将被丢弃。</p><h3 id="Masquerade"><a class="header-anchor" href="#Masquerade">¶</a>Masquerade</h3><p>NAT 模块</p><ul><li>一般配置方式：<code>Change IP1 to IP2 if matching XXX</code>。</li><li>高级配置方式：<code>Change IP1 to dev1's IP if matching XXX</code>，这种方式称为 Masquerade。</li></ul><p>Masquerade 优缺点：</p><ul><li>优点：<strong>当设备（网卡）的 IP 地址发生变化时，NAT 规则无需做任何修改</strong>。</li><li>缺点：<strong>性能比第一种方式要差</strong>。</li></ul><h2 id="4-6-nf-nat-packet-：执行-NAT"><a class="header-anchor" href="#4-6-nf-nat-packet-：执行-NAT">¶</a>4.6 <code>nf_nat_packet()</code>：执行 NAT</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_nat_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do packet manipulations according to nf_nat_setup_info. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">nf_nat_packet</span><span class="params">(struct nf_conn *ct, <span class="keyword">enum</span> ip_conntrack_info ctinfo,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">unsigned</span> <span class="keyword">int</span> hooknum, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> nf_nat_manip_type mtype = HOOK2MANIP(hooknum);</span><br><span class="line">    <span class="keyword">enum</span> ip_conntrack_dir dir = CTINFO2DIR(ctinfo);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> verdict = NF_ACCEPT;</span><br><span class="line"></span><br><span class="line">    statusbit = (mtype == NF_NAT_MANIP_SRC? IPS_SRC_NAT : IPS_DST_NAT)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dir == IP_CT_DIR_REPLY)     <span class="comment">// Invert if this is reply dir</span></span><br><span class="line">        statusbit ^= IPS_NAT_MASK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ct-&gt;status &amp; statusbit)     <span class="comment">// Non-atomic: these bits don't change. */</span></span><br><span class="line">        verdict = nf_nat_manip_pkt(skb, ct, mtype, dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> verdict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">nf_nat_manip_pkt</span><span class="params">(struct sk_buff *skb, struct nf_conn *ct,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">enum</span> nf_nat_manip_type mtype, <span class="keyword">enum</span> ip_conntrack_dir dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> <span class="title">target</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We are aiming to look like inverse of other direction. */</span></span><br><span class="line">    nf_ct_invert_tuplepr(&amp;target, &amp;ct-&gt;tuplehash[!dir].tuple);</span><br><span class="line"></span><br><span class="line">    l3proto = __nf_nat_l3proto_find(target.src.l3num);</span><br><span class="line">    l4proto = __nf_nat_l4proto_find(target.src.l3num, target.dst.protonum);</span><br><span class="line">    <span class="keyword">if</span> (!l3proto-&gt;manip_pkt(skb, <span class="number">0</span>, l4proto, &amp;target, mtype)) <span class="comment">// 协议相关处理</span></span><br><span class="line">        <span class="keyword">return</span> NF_DROP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-1-查看-加载-卸载-nf-conntrack-模块"><a class="header-anchor" href="#5-1-查看-加载-卸载-nf-conntrack-模块">¶</a>5.1 查看 / 加载 / 卸载 nf_conntrack 模块</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ modinfo nf_conntrack</span><br><span class="line">filename:       /lib/modules/5.15.0-46-generic/kernel/net/netfilter/nf_conntrack.ko</span><br><span class="line">license:        GPL</span><br><span class="line"><span class="built_in">alias</span>:          nf_conntrack-10</span><br><span class="line"><span class="built_in">alias</span>:          nf_conntrack-2</span><br><span class="line"><span class="built_in">alias</span>:          ip_conntrack</span><br><span class="line">srcversion:     30B45E5822722ACEDE23A4B</span><br><span class="line">depends:        nf_defrag_ipv6,libcrc32c,nf_defrag_ipv4</span><br><span class="line">retpoline:      Y</span><br><span class="line">intree:         Y</span><br><span class="line">name:           nf_conntrack</span><br><span class="line">vermagic:       5.15.0-46-generic SMP mod_unload modversions</span><br><span class="line">sig_id:         PKCS<span class="comment">#7</span></span><br><span class="line">signer:         Build time autogenerated kernel key</span><br><span class="line">sig_key:        17:6F:92:2F:58:6B:B2:28:13:DC:71:DC:5A:97:EE:BA:D8:4B:C7:DE</span><br><span class="line">sig_hashalgo:   sha512</span><br><span class="line">signature:      0B:32:AA:93:F4:31:52:9C:FE:0D:80:B4:F6:7C:30:63:4C:F6:03:AA:</span><br><span class="line">                ...</span><br><span class="line">                E9:1F:45:C6:77:C2:29:99:B4:3D:1A:D2</span><br><span class="line">parm:           tstamp:Enable connection tracking flow timestamping. (bool)</span><br><span class="line">parm:           acct:Enable connection tracking flow accounting. (bool)</span><br><span class="line">parm:           nf_conntrack_helper:Enable automatic conntrack helper assignment (default 0) (bool)</span><br><span class="line">parm:           expect_hashsize:uint</span><br><span class="line">parm:           enable_hooks:Always <span class="built_in">enable</span> conntrack hooks (bool)</span><br></pre></td></tr></table></figure><p>卸载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rmmod nf_conntrack_netlink nf_conntrack</span><br></pre></td></tr></table></figure><p>重新加载：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ modprobe nf_conntrack</span><br><span class="line"></span><br><span class="line"># 加载时还可以指定额外的配置参数，例如：</span><br><span class="line">$ modprobe nf_conntrack nf_conntrack_helper=1 expect_hashsize=131072</span><br></pre></td></tr></table></figure><h2 id="5-2-sysctl-配置项"><a class="header-anchor" href="#5-2-sysctl-配置项">¶</a>5.2 sysctl 配置项</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -a | grep nf_conntrack</span><br><span class="line">net.netfilter.nf_conntrack_acct = 0</span><br><span class="line">net.netfilter.nf_conntrack_buckets = 262144                 # hashsize = nf_conntrack_max/nf_conntrack_buckets</span><br><span class="line">net.netfilter.nf_conntrack_checksum = 1</span><br><span class="line">net.netfilter.nf_conntrack_count = 2148</span><br><span class="line">... # DCCP options</span><br><span class="line">net.netfilter.nf_conntrack_events = 1</span><br><span class="line">net.netfilter.nf_conntrack_expect_max = 1024</span><br><span class="line">... # IPv6 options</span><br><span class="line">net.netfilter.nf_conntrack_generic_timeout = 600</span><br><span class="line">net.netfilter.nf_conntrack_helper = 0</span><br><span class="line">net.netfilter.nf_conntrack_icmp_timeout = 30</span><br><span class="line">net.netfilter.nf_conntrack_log_invalid = 0</span><br><span class="line">net.netfilter.nf_conntrack_max = 1048576                    # conntrack table size</span><br><span class="line">... # SCTP options</span><br><span class="line">net.netfilter.nf_conntrack_tcp_be_liberal = 0</span><br><span class="line">net.netfilter.nf_conntrack_tcp_loose = 1</span><br><span class="line">net.netfilter.nf_conntrack_tcp_max_retrans = 3</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_close = 10</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_established = 21600</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_last_ack = 30</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_max_retrans = 300</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_syn_recv = 60</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_syn_sent = 120</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_unacknowledged = 300</span><br><span class="line">net.netfilter.nf_conntrack_timestamp = 0</span><br><span class="line">net.netfilter.nf_conntrack_udp_timeout = 30</span><br><span class="line">net.netfilter.nf_conntrack_udp_timeout_stream = 180</span><br></pre></td></tr></table></figure><h2 id="5-3-监控"><a class="header-anchor" href="#5-3-监控">¶</a>5.3 监控</h2><h3 id="丢包监控"><a class="header-anchor" href="#丢包监控">¶</a>丢包监控</h3><p><code>/proc/net/stat</code> 下面有一些关于 conntrack 的详细统计：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/net/stat/nf_conntrack</span><br><span class="line">entries   searched found    new      invalid  ignore   delete   delete_list insert   insert_failed drop     early_drop icmp_error  expect_new expect_create expect_delete search_restart</span><br><span class="line">000008e3  00000000 00000000 00000000 0000309d 001e72d4 00000000 00000000    00000000 00000000      00000000 00000000   000000ee    00000000   00000000      00000000       000368d7</span><br><span class="line">000008e3  00000000 00000000 00000000 00007301 002b8e8c 00000000 00000000    00000000 00000000      00000000 00000000   00000170    00000000   00000000      00000000       00035794</span><br><span class="line">000008e3  00000000 00000000 00000000 00001eea 001e6382 00000000 00000000    00000000 00000000      00000000 00000000   00000059    00000000   00000000      00000000       0003f166</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>此外，还可以用 <code>conntrack</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ conntrack -S</span><br><span class="line">cpu=0   found=0 invalid=743150 ignore=238069 insert=0 insert_failed=0 drop=195603 early_drop=118583 error=16 search_restart=22391652</span><br><span class="line">cpu=1   found=0 invalid=2004   ignore=402790 insert=0 insert_failed=0 drop=44371  early_drop=34890  error=0  search_restart=1225447</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>ignore：不需要做连接跟踪的包（回忆前面，只有特定协议的包才会做连接跟踪）</li></ul><h3 id="conntrack-table-使用量监控"><a class="header-anchor" href="#conntrack-table-使用量监控">¶</a>conntrack table 使用量监控</h3><p>可以定期采集系统的 conntrack 使用量，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_count</span><br><span class="line">257273</span><br></pre></td></tr></table></figure><p>并与最大值比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_max</span><br><span class="line">262144</span><br></pre></td></tr></table></figure><h2 id="6-1-连接太多导致-conntrack-table-被打爆"><a class="header-anchor" href="#6-1-连接太多导致-conntrack-table-被打爆">¶</a>6.1 连接太多导致 conntrack table 被打爆</h2><h3 id="现象"><a class="header-anchor" href="#现象">¶</a>现象</h3><h4 id="业务层（应用层）现象"><a class="header-anchor" href="#业务层（应用层）现象">¶</a>业务层（应用层）现象</h4><ol><li><p>存在随机、偶发的<strong>新建连接</strong>超时（connect timeout）。</p><p>例如，如果业务用的是 Java，那对应的是 <code>jdbc4.CommunicationsException</code> communications link failure 之类的错误。</p></li><li><p><strong>已有连接</strong>正常。</p><p>也就是没有 read timeout 或 write timeout 之类的报错，报错都集中为 connect timeout。</p></li></ol><h4 id="网络层现象"><a class="header-anchor" href="#网络层现象">¶</a>网络层现象</h4><ol><li><p>抓包会看到三次握手的<strong>第一个 SYN 包被宿主机静默丢弃了</strong>。</p><p>需要注意的是，常规的网卡统计（<code>ifconfig</code>）和内核统计（<code>/proc/net/softnet_stat</code>） <strong>无法反映出这些丢包</strong>。</p></li><li><p><code>1s+</code> 之后出发 SYN 重传，或者还没重传连接就关闭了。</p><p><strong>第一个 SYN 的重传是 1s，这个是内核代码里写死的，不可配置</strong>（具体实现见 <a href="#ch_8.1">附录</a>）。</p><p>再考虑到其他一些耗时，第一次重传的实际间隔要大于 1s。 如果客户端设置的超时时间很小，例如 <code>1.05s</code>，那可能来不及重传连接就被关闭了，然后向上层报 connect timeout 错误。</p></li></ol><h4 id="操作系统层现象"><a class="header-anchor" href="#操作系统层现象">¶</a>操作系统层现象</h4><p>内核日志中有如下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ demsg -T</span><br><span class="line">[Tue Apr  6 18:12:30 2021] nf_conntrack: nf_conntrack: table full, dropping packet</span><br><span class="line">[Tue Apr  6 18:12:30 2021] nf_conntrack: nf_conntrack: table full, dropping packet</span><br><span class="line">[Tue Apr  6 18:12:30 2021] nf_conntrack: nf_conntrack: table full, dropping packet</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>另外，<code>cat /proc/net/stat/nf_conntrack</code> 或 <code>conntrack -S</code> 能看到有 drop 统计。</p><h3 id="确认-conntrack-table-被打爆"><a class="header-anchor" href="#确认-conntrack-table-被打爆">¶</a>确认 conntrack table 被打爆</h3><p>遇到以上现象，基本就是 conntrack 表被打爆了。确认：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_count</span><br><span class="line">257273</span><br><span class="line"></span><br><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_max</span><br><span class="line">net.netfilter.nf_conntrack_max = 262144</span><br></pre></td></tr></table></figure><p>如果有 conntrack count 监控会看的更清楚，因为我们命令行查看时，高峰可能过了。</p><h3 id="解决方式"><a class="header-anchor" href="#解决方式">¶</a>解决方式</h3><p>优先级从高到低：</p><ol><li><p>调大 conntrack 表</p><p>运行时配置（经实际测试，<strong>不会对现有连接造成影响</strong>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.netfilter.nf_conntrack_max=524288</span><br><span class="line">$ sysctl -w net.netfilter.nf_conntrack_buckets=131072 # 推荐配置 hashsize=nf_conntrack_count/4</span><br></pre></td></tr></table></figure><p>持久化配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;net.netfilter.nf_conntrack_max = 524288&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">$ echo &apos;net.netfilter.nf_conntrack_buckets = 131072&apos; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>影响：连接跟踪模块<strong>会多用一些内存</strong>。具体多用多少内存，可参考 <a href="#ch_8.2">附录</a>。</p></li><li><p>减小 GC 时间</p><p>还可以调小 conntrack 的 GC（也叫 timeout）时间，加快过期 entry 的回收。</p><p><code>nf_conntrack</code> 针对不同 TCP 状态（established、fin_wait、time_wait 等）的 entry 有不同的 GC 时间。</p><p>例如，<strong>默认的 established 状态的 GC 时间是 423000s（5 天）</strong>。设置成这么长的 <strong>可能原因</strong>是：TCP/IP 协议中允许 established 状态的连接无限期不发送任何东西（但仍然活着） [8]，协议的具体实现（Linux、BSD、Windows 等）会设置各自允许的最大 idle timeout。为防止 GC 掉这样长时间没流量但实际还活着的连接，就设置一个足够保守的 timeout 时间。[8] 中建议这个值不小于 2 小时 4 分钟（作为对比和参考， <strong>Cilium 自己实现的 CT 中，默认 established GC 是 6 小时</strong>）。 但也能看到一些厂商推荐比这个小得多的配置，例如 20 分钟。</p><p>如果对自己的网络环境和需求非常清楚，那可以将这个时间调到一个合理的、足够小的值； 如果不是非常确定的话，还是<strong>建议保守一些，例如设置 6 个小时</strong> —— 这已经比默认值 5 天小多了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sysctl -w net.netfilter.nf_conntrack_tcp_timeout_established = 21600</span><br></pre></td></tr></table></figure><p>持久化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;net.netfilter.nf_conntrack_tcp_timeout_established = 21600&apos; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>其他几个 timeout 值（尤其是 <code>nf_conntrack_tcp_timeout_time_wait</code>，默认 <code>120s</code>）也可以适当调小， 但还是那句话：<strong>如果不确定潜在后果，千万不要激进地调小</strong>。</p></li></ol><p>连接跟踪是一个非常基础且重要的网络模块，但只有在少数场景下才会引起普通开发者的注意。</p><p>例如，L4LB 短时高并发场景下，LB 节点每秒接受大量并发短连接，可能导致 conntrack table 被打爆。此时的现象是：</p><ul><li>客户端和 L4LB 建连失败，失败可能是随机的，也可能是集中在某些时间点。</li><li>客户端重试可能会成功，也可能会失败。</li><li>在 L4LB 节点抓包看，客户端过来的 TCP SYNC 包 L4LB 收到了，但没有回 ACK。即，包 被静默丢弃了（silently dropped）。</li></ul><p>此时的原因可能是 conntrack table 太小，也可能是 GC 不够及 时，甚至是 <a href="https://github.com/cilium/cilium/pull/12729" target="_blank" rel="noopener">GC 有 bug</a>。</p><h2 id="8-1-第一个-SYN-包的重传间隔计算（Linux-4-19-118-实现）"><a class="header-anchor" href="#8-1-第一个-SYN-包的重传间隔计算（Linux-4-19-118-实现）">¶</a>8.1 第一个 SYN 包的重传间隔计算（Linux 4.19.118 实现）</h2><p>调用路径：<code>tcp_connect() -&gt; tcp_connect_init() -&gt; tcp_timeout_init()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp_output.c</span></span><br><span class="line"><span class="comment">/* Do all connect socket setups that can be done AF independent. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcp_connect_init</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inet_csk(sk)-&gt;icsk_rto = tcp_timeout_init(sk);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/net/tcp.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u32 <span class="title">tcp_timeout_init</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取 SYN-RTO：如果这个 socket 上没有 BPF 程序，或者有 BPF 程序但执行失败，都返回 -1</span></span><br><span class="line">    <span class="comment">// 除非用户自己编写 BPF 程序并 attach 到 cgroup/socket，否则这里都是没有 BPF 的，因此这里返回 -1</span></span><br><span class="line">    timeout = tcp_call_bpf(sk, BPF_SOCK_OPS_TIMEOUT_INIT, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>)                <span class="comment">// timeout == -1，接下来使用默认值</span></span><br><span class="line">        timeout = TCP_TIMEOUT_INIT;  <span class="comment">// 宏定义，等于系统的 HZ 数，也就是 1 秒，见下面</span></span><br><span class="line">    <span class="keyword">return</span> timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/net/tcp.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_RTO_MAX    ((unsigned)(120*HZ))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_RTO_MIN    ((unsigned)(HZ/5))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_TIMEOUT_MIN    (2U) <span class="comment">/* Min timeout for TCP timers in jiffies */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_TIMEOUT_INIT ((unsigned)(1*HZ))    <span class="comment">/* RFC6298 2.1 initial RTO value    */</span></span></span><br></pre></td></tr></table></figure><h2 id="8-2-根据-nf-conntrack-max-计算-conntrack-模块所需的内存"><a class="header-anchor" href="#8-2-根据-nf-conntrack-max-计算-conntrack-模块所需的内存">¶</a>8.2 根据 nf_conntrack_max 计算 conntrack 模块所需的内存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/slabinfo | head -n2; cat /proc/slabinfo | grep conntrack</span><br><span class="line">slabinfo - version: 2.1</span><br><span class="line"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span><br><span class="line">nf_conntrack      512824 599505    320   51    4 : tunables    0    0    0 : slabdata  11755  11755      0</span><br></pre></td></tr></table></figure><p>其中的 <strong>objsize 表示这个内核对象</strong>（这里对应的是 <code>struct nf_conn</code>）的大小， 单位是<strong>字节</strong>，所以以上输出表明<strong>每个 conntrack entry 占用 320 字节的内存空间</strong>。</p><p>如果忽略内存碎片（内存分配单位为 slab），那<strong>不同 size 的 conntrack table 占用的内存</strong>如下：</p><ul><li><code>nf_conntrack_max=512K</code>: <code>512K * 320Byte = 160MB</code></li><li><code>nf_conntrack_max=1M</code>: <code>1M * 320Byte = 320MB</code></li></ul><p>更精确的计算，可以参考 [9]。</p><ol><li><a href="https://wiki.aalto.fi/download/attachments/69901948/netfilter-paper.pdf" target="_blank" rel="noopener">Netfilter connection tracking and NAT implementation</a>. Proc. Seminar on Network Protocols in Operating Systems, Dept. Commun. and Networking, Aalto Univ. 2013.</li><li><a href="https://docs.cilium.io/en/v1.7/gettingstarted/kubeproxy-free/" target="_blank" rel="noopener">Cilium: Kubernetes without kube-proxy</a></li><li><a href="chrome-extension://ijllcpnolfcooahcekpamkbidhejabll/blog/k8s-l4lb/" target="_blank" rel="noopener">L4LB for Kubernetes: Theory and Practice with Cilium+BGP+ECMP</a></li><li><a href="https://docs.docker.com/network/bridge/" target="_blank" rel="noopener">Docker bridge network mode</a></li><li><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Wikipedia: Netfilter</a></li><li><a href="https://blog.cloudflare.com/conntrack-tales-one-thousand-and-one-flows/" target="_blank" rel="noopener">Conntrack tales - one thousand and one flows</a></li><li><a href="https://www.redhat.com/en/blog/how-connection-tracking-open-vswitch-helps-openstack-performance" target="_blank" rel="noopener">How connection tracking in Open vSwitch helps OpenStack performance</a></li><li><a href="https://tools.ietf.org/html/rfc5382#section-5" target="_blank" rel="noopener">NAT Behavioral Requirements for TCP</a>, RFC5382</li><li><a href="https://johnleach.co.uk/posts/2009/06/17/netfilter-conntrack-memory-usage/" target="_blank" rel="noopener">Netfilter Conntrack Memory Usage</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;摘要&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#摘要&quot;&gt;¶&lt;/a&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文介绍连接跟踪（connection tracking，conntrack，CT）的原理，应用，及其在 Linux 内核中的实现。&lt;/p&gt;
&lt;p&gt;代码分析基于内核 &lt;code&gt;4.19&lt;/code&gt;。为使行文简洁，所贴代码只保留了核心逻辑，但都给出了代码 所在的源文件，如有需要请查阅。&lt;/p&gt;
&lt;p&gt;水平有限，文中不免有错误之处，欢迎指正交流。&lt;/p&gt;
&lt;p&gt;连接跟踪是许多网络应用的基础。例如，Kubernetes Service、ServiceMesh sidecar、 软件四层负载均衡器 LVS/IPVS、Docker network、OVS、iptables 主机防火墙等等，都依赖 连接跟踪功能。&lt;/p&gt;
    
    </summary>
    
      <category term="连接跟踪" scheme="https://talengu.github.io/public/categories/%E8%BF%9E%E6%8E%A5%E8%B7%9F%E8%B8%AA/"/>
    
    
      <category term="conntrack" scheme="https://talengu.github.io/public/tags/conntrack/"/>
    
  </entry>
  
  <entry>
    <title>「202211月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/11/26/test/202211_obsidian/"/>
    <id>https://talengu.github.io/public/2022/11/26/test/202211_obsidian/</id>
    <published>2022-11-26T16:00:04.000Z</published>
    <updated>2022-11-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 0 📅 : 0 🔖 : 0</p><a id="more"></a><h2 id="✅-0"><a class="header-anchor" href="#✅-0">¶</a>✅ : 0</h2><h2 id="📅-0"><a class="header-anchor" href="#📅-0">¶</a>📅 : 0</h2><h2 id="🔖-0"><a class="header-anchor" href="#🔖-0">¶</a>🔖 : 0</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 0 📅 : 0 🔖 : 0&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>「202211月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/11/15/test/202211/"/>
    <id>https://talengu.github.io/public/2022/11/15/test/202211/</id>
    <published>2022-11-15T16:00:04.000Z</published>
    <updated>2022-11-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 1</p><a id="more"></a><h2 id="🔖微软官方小工具更新，这些新特性你或许也能用得上"><a class="header-anchor" href="#🔖微软官方小工具更新，这些新特性你或许也能用得上">¶</a>🔖<a href="https://sspai.com/post/76649" target="_blank" rel="noopener">微软官方小工具更新，这些新特性你或许也能用得上</a></h2><p>pubdata:2022-11-06 03:40:00markdate:2022-11-17 17:18:09.571032</p><p><img src="/public/2022/11/15/test/202211/2022-11-17-171809571032.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 1&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>「202210月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/10/26/test/202210_obsidian/"/>
    <id>https://talengu.github.io/public/2022/10/26/test/202210_obsidian/</id>
    <published>2022-10-26T16:00:04.000Z</published>
    <updated>2022-10-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 0 📅 : 2 🔖 : 8</p><a id="more"></a><h2 id="✅-0"><a class="header-anchor" href="#✅-0">¶</a>✅ : 0</h2><h2 id="📅-2"><a class="header-anchor" href="#📅-2">¶</a>📅 : 2</h2><p>📅 转载一下-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>📅 tracker更新-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a></p><h2 id="🔖-8"><a class="header-anchor" href="#🔖-8">¶</a>🔖 : 8</h2><p>🔖肝下50万字的《Linux内核精通》笔记，你的底层原理水平将从入门到入魔【建议收藏】-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖计算机组成原理(万字爆肝整理)-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖 <a href="https://xiaolincoding.com/network/" target="_blank" rel="noopener">图解网络介绍</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>🔖 <a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener">常用设计模式有哪些？</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>🔖 智能家庭网关-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>🔖 <a href="https://sadh.life/post/builtins/" target="_blank" rel="noopener">Understanding all of Python, through its builtins</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>🔖 操作系统自学-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>🔖 机器人计划-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 0 📅 : 2 🔖 : 8&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>「202210月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/10/15/test/202210/"/>
    <id>https://talengu.github.io/public/2022/10/15/test/202210/</id>
    <published>2022-10-15T16:00:04.000Z</published>
    <updated>2022-10-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 2</p><a id="more"></a><h2 id="🔖一日一技｜Obsidian-Command-进阶用法三则"><a class="header-anchor" href="#🔖一日一技｜Obsidian-Command-进阶用法三则">¶</a>🔖<a href="https://sspai.com/post/75847" target="_blank" rel="noopener">一日一技｜Obsidian Command 进阶用法三则</a></h2><p>pubdata:2022-10-01 07:00:00markdate:2022-10-08 11:41:38.979766</p><p><img src="/public/2022/10/15/test/202210/2022-10-08-114138979766.jpg" alt="img"></p><h2 id="🔖用代码编辑器进行知识管理：我用-VSCode-构建自己的笔记系统"><a class="header-anchor" href="#🔖用代码编辑器进行知识管理：我用-VSCode-构建自己的笔记系统">¶</a>🔖<a href="https://sspai.com/post/75940" target="_blank" rel="noopener">用代码编辑器进行知识管理：我用 VSCode 构建自己的笔记系统</a></h2><p>pubdata:2022-09-28 03:29:57markdate:2022-10-09 04:14:05.692239</p><p><img src="/public/2022/10/15/test/202210/2022-10-09-041405692239.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 2&lt;/p&gt;
    
    </summary>
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/categories/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
    
      <category term="月度汇报" scheme="https://talengu.github.io/public/tags/%E6%9C%88%E5%BA%A6%E6%B1%87%E6%8A%A5/"/>
    
  </entry>
  
  <entry>
    <title>「202209月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/09/26/test/202209_obsidian/"/>
    <id>https://talengu.github.io/public/2022/09/26/test/202209_obsidian/</id>
    <published>2022-09-26T16:00:04.000Z</published>
    <updated>2022-09-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 0 📅 : 2 🔖 : 10</p><a id="more"></a><h2 id="✅-0"><a class="header-anchor" href="#✅-0">¶</a>✅ : 0</h2><h2 id="📅-2"><a class="header-anchor" href="#📅-2">¶</a>📅 : 2</h2><p>📅升级电脑-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W35.md">C日常/2022-W35.md</a><br>📅 添加rss-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a></p><h2 id="🔖-10"><a class="header-anchor" href="#🔖-10">¶</a>🔖 : 10</h2><p>🔖 <a href="https://www.appinn.com/umi-ocr/" target="_blank" rel="noopener">Umi-OCR - 免费的离线 OCR 文字识别软件[Windows] - 小众软件</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖 设计模式-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖 苏炳添向母校捐赠100万元！-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖 <a href="https://github.com/dlvhdr/gh-dash" target="_blank" rel="noopener">gh-dash</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖 <a href="https://nginxproxymanager.com/" target="_blank" rel="noopener">Nginx Proxy Manager</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>🔖1、<a href="https://knots3d.com/knots/en_us/ALL" target="_blank" rel="noopener">Knots 3D</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>🔖 <a href="https://m.runoob.com/typescript/" target="_blank" rel="noopener">TypeScript 教程 | 菜鸟教程</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>🔖 <a href="https://m.runoob.com/js/" target="_blank" rel="noopener">Javascript 教程 | 菜鸟教程</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>🔖 Makefile-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>🔖 <a href="https://www.zhihu.com/question/450738311/answer/2635126508?utm_medium=social&amp;utm_oi=619610399826382848&amp;utm_psn=1545021439438381056&amp;utm_source=ZHShareTargetIDMore" target="_blank" rel="noopener">windows 有什么好用的截图软件？ - 知乎</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 0 📅 : 2 🔖 : 10&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「202209月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/09/15/test/202209/"/>
    <id>https://talengu.github.io/public/2022/09/15/test/202209/</id>
    <published>2022-09-15T16:00:04.000Z</published>
    <updated>2022-09-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 3</p><a id="more"></a><h2 id="🔖WireGuard-基础教程：wg-quick-路由策略解读"><a class="header-anchor" href="#🔖WireGuard-基础教程：wg-quick-路由策略解读">¶</a>🔖<a href="https://icloudnative.io/posts/linux-routing-of-wireguard/" target="_blank" rel="noopener">WireGuard 基础教程：wg-quick 路由策略解读</a></h2><p>pubdata:2022-08-31 01:06:37markdate:2022-09-03 06:23:25.656749</p><p><img src="/public/2022/09/15/test/202209/2022-09-03-062325656749.jpg" alt="img"></p><h2 id="🔖微软官方超实用-15-小工具集-PowerToys-v0-62-0-发布，新增文本提取器-OCR-功能"><a class="header-anchor" href="#🔖微软官方超实用-15-小工具集-PowerToys-v0-62-0-发布，新增文本提取器-OCR-功能">¶</a>🔖<a href="https://www.appinn.com/powertoys-v0-62-0/" target="_blank" rel="noopener">微软官方超实用 15+ 小工具集 PowerToys v0.62.0 发布，新增文本提取器 OCR 功能</a></h2><p>pubdata:2022-09-07 04:11:14markdate:2022-09-08 04:19:59.942860</p><p><img src="/public/2022/09/15/test/202209/2022-09-08-041959942860.jpg" alt="img"></p><h2 id="🔖Stream-Deck-太贵了？触屏音箱也能成为你的直播助手"><a class="header-anchor" href="#🔖Stream-Deck-太贵了？触屏音箱也能成为你的直播助手">¶</a>🔖<a href="https://sspai.com/post/75789" target="_blank" rel="noopener">Stream Deck 太贵了？触屏音箱也能成为你的直播助手</a></h2><p>pubdata:2022-09-19 06:31:44markdate:2022-09-21 03:28:05.514939</p><p><img src="/public/2022/09/15/test/202209/2022-09-21-032805514939.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 3&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「202208月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/08/26/test/202208_obsidian/"/>
    <id>https://talengu.github.io/public/2022/08/26/test/202208_obsidian/</id>
    <published>2022-08-26T16:00:04.000Z</published>
    <updated>2022-08-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 1 📅 : 1 🔖 : 26</p><a id="more"></a><h2 id="✅-1"><a class="header-anchor" href="#✅-1">¶</a>✅ : 1</h2><p>✅自动生成rss月报-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a></p><h2 id="📅-1"><a class="header-anchor" href="#📅-1">¶</a>📅 : 1</h2><p>📅 加上地区统计-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a></p><h2 id="🔖-26"><a class="header-anchor" href="#🔖-26">¶</a>🔖 : 26</h2><p>🔖 <a href="https://github.com/serhack/pdf-diff" target="_blank" rel="noopener">GitHub - serhack/pdf-diff: A tool for visualizing differences between two pdf files.</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="http://arthurchiao.art/blog/conntrack-design-and-implementation-zh/" target="_blank" rel="noopener">连接跟踪（conntrack）：原理、应用及 Linux 内核实现</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="https://codemirror.net/docs/guide/" target="_blank" rel="noopener">CodeMirror System Guide</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/357334969?utm_id=0" target="_blank" rel="noopener">mac使用VNC远程访问Ubuntu图形界面</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="https://mp.weixin.qq.com/s/FBJ_GIvdwNbvGKVKeroZjA" target="_blank" rel="noopener">冠军私教课</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="https://cloud.tencent.com/developer/article/1585686" target="_blank" rel="noopener">如何统计 Hexo 网站的访问地区和IP - 腾讯云开发者社区-腾讯云</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>🔖 <a href="https://www.appinn.com/navidrome/" target="_blank" rel="noopener">Navidrome - 开源音乐服务器，自建云端音乐播放器 - 小众软件</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W30.md">C日常/2022-W30.md</a><br>🔖 <a href="https://sspai.com/post/73443" target="_blank" rel="noopener">力量训练：办卡之前需要了解的训练基础与细节制定 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W30.md">C日常/2022-W30.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/495262462" target="_blank" rel="noopener">网站低代码开发</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖长大后，如果是时间修剪了我们的好奇心，我们应该责怪时间吗？-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖半导体行业的组成-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖Weylus – 共享屏幕，将平板作为电脑触摸屏使用[Win/macOS/Linux]-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖跨平台开发 <a href="https://beeware.org/" target="_blank" rel="noopener">BeeWare</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖资本论复旦大学-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 Linux三剑客-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖pdf补丁丁-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://www.wdbyte.com/java/char-image.html_1-%E5%AD%97%E7%AC%A6%E5%9B%BE%E6%A1%88%E6%80%9D%E8%B7%AF" target="_blank" rel="noopener">字符作画，我用字符画个冰墩墩 | 未读代码</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/474337723?utm_source=ZHShareTargetIDMore&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">一文让你读懂Linux五大模块内核源码，内核整体架构设计（超详细）</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/483731291?utm_source=ZHShareTargetIDMore&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">学习数学思维推荐阅读的五本数学书籍</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖Snapdrop for Android – 在电脑与 Android 手机间互传文件-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖Photoview – 支持人脸识别的开源、自托管本地相册-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖GitHub - LibrePhotos/librephotos: A self-hosted open source photo management service. This is the repository of the backend.-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://www.cnblogs.com/imxiaobei/p/13619630.html" target="_blank" rel="noopener">一文搞懂后台高性能服务器设计的常见套路, BAT 高频面试系列 - 编程指北 - 博客园</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://www.appinn.com/dual-subtitles/" target="_blank" rel="noopener">YouTube™ 双字幕 - 显示双语字幕（包括自动翻译）、字幕下载，以及自定义字幕样式[Chrome/Edge] - 小众软件</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://mp.weixin.qq.com/s/cd-uS5NDIreT02GaHpdxlw" target="_blank" rel="noopener">一文搞懂WiFi的所有知识点</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/122523174" target="_blank" rel="noopener">Doxygen 中文文档</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 1 📅 : 1 🔖 : 26&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「202208月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/08/15/test/202208/"/>
    <id>https://talengu.github.io/public/2022/08/15/test/202208/</id>
    <published>2022-08-15T16:00:04.000Z</published>
    <updated>2022-08-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 5</p><a id="more"></a><h2 id="🔖AVNC-–-Android-上的开源-VNC-客户端"><a class="header-anchor" href="#🔖AVNC-–-Android-上的开源-VNC-客户端">¶</a>🔖<a href="https://www.appinn.com/avnc-for-android/" target="_blank" rel="noopener">AVNC – Android 上的开源 VNC 客户端</a></h2><p>pubdata:2022-08-07 04:59:52markdate:2022-08-07 17:42:37.878979</p><p><img src="/public/2022/08/15/test/202208/2022-08-07-174237878979.jpg" alt="img"></p><h2 id="🔖TigerVNC-–-高性能、跨平台开源-VNC-服务器与客户端"><a class="header-anchor" href="#🔖TigerVNC-–-高性能、跨平台开源-VNC-服务器与客户端">¶</a>🔖<a href="https://www.appinn.com/tigervnc/" target="_blank" rel="noopener">TigerVNC – 高性能、跨平台开源 VNC 服务器与客户端</a></h2><p>pubdata:2022-08-08 04:30:32markdate:2022-08-09 00:48:54.680756</p><p><img src="/public/2022/08/15/test/202208/2022-08-09-004854680756.jpg" alt="img"></p><h2 id="🔖Notion-又一开源替代品，诞生了！"><a class="header-anchor" href="#🔖Notion-又一开源替代品，诞生了！">¶</a>🔖<a href="https://zhuanlan.zhihu.com/p/552965032" target="_blank" rel="noopener">Notion 又一开源替代品，诞生了！</a></h2><p>pubdata:2022-08-12 04:42:26markdate:2022-08-13 16:16:00.234349</p><p><img src="/public/2022/08/15/test/202208/2022-08-13-161600234349.jpg" alt="img"></p><h2 id="🔖如何写一份高可读性的软件工程设计文档"><a class="header-anchor" href="#🔖如何写一份高可读性的软件工程设计文档">¶</a>🔖<a href="https://zhuanlan.zhihu.com/p/552095835" target="_blank" rel="noopener">如何写一份高可读性的软件工程设计文档</a></h2><p>pubdata:2022-08-10 09:00:14markdate:2022-08-20 02:27:47.773301</p><p><img src="/public/2022/08/15/test/202208/2022-08-20-022747773301.jpg" alt="img"></p><h2 id="🔖StrokesPlus-net-–-一款很厉害的鼠标手势软件，还有大佬汉化、以及持续更新脚本"><a class="header-anchor" href="#🔖StrokesPlus-net-–-一款很厉害的鼠标手势软件，还有大佬汉化、以及持续更新脚本">¶</a>🔖<a href="https://www.appinn.com/strokesplus-net/" target="_blank" rel="noopener">StrokesPlus.net – 一款很厉害的鼠标手势软件，还有大佬汉化、以及持续更新脚本</a></h2><p>pubdata:2022-08-24 04:29:23markdate:2022-08-25 03:51:08.820884</p><p><img src="/public/2022/08/15/test/202208/2022-08-25-035108820884.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 5&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「202207月度汇报」obsidian</title>
    <link href="https://talengu.github.io/public/2022/07/26/test/202207_obsidian/"/>
    <id>https://talengu.github.io/public/2022/07/26/test/202207_obsidian/</id>
    <published>2022-07-26T16:00:04.000Z</published>
    <updated>2022-07-26T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>统计 ✅ : 6 📅 : 3 🔖 : 47</p><a id="more"></a><h2 id="✅-6"><a class="header-anchor" href="#✅-6">¶</a>✅ : 6</h2><p>✅目标图标系统-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>✅ <a href="https://blog.csdn.net/hhhhhyyyyy8/article/details/102133863" target="_blank" rel="noopener">Linux内核数据包bridge上转发流程_hhhhhyyyyy8的博客-CSDN博客_br_multicast_flood</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>✅ 邮箱转rss-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a><br>✅  hacker news rss添加-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a><br>✅ 经济学人转载leader文章-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a><br>✅ github博客评论系统是否换成【不换】-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a></p><h2 id="📅-3"><a class="header-anchor" href="#📅-3">¶</a>📅 : 3</h2><p>📅 端口触发 端口转发-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>📅 全屋智能-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>📅 改进-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a></p><h2 id="🔖-47"><a class="header-anchor" href="#🔖-47">¶</a>🔖 : 47</h2><p>🔖 ish保持后台运行-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>🔖 <a href="https://www.jianshu.com/p/f29ca723db4f" target="_blank" rel="noopener">Git 运行配置（git config、gitk、git gui） - michael_jia - 简书</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>🔖<a href="https://www.cnblogs.com/xuanbjut/p/12624702.html" target="_blank" rel="noopener">wmctrl像xmonad那样方便地用快捷键来控制任务窗口的显示 - pycod - 博客园</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>🔖 <a href="https://blog.csdn.net/anlian523/article/details/113627568" target="_blank" rel="noopener">VSCode复制代码时去掉样式/语法高亮/代码高亮/黑色背景_anlian523的博客-CSDN博客_idea复制代码不带黑色背景</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>🔖 <a href="https://blog.csdn.net/dog250/article/details/121400218" target="_blank" rel="noopener">为什么除法，开方，求对数比乘法，乘方，求指数更难_dog250的博客-CSDN博客</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖学习小林博客的写法-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖一万字统计学梳理-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖腾讯 彻底搞清楚tcp-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖0x5f3759df这个快速开方中的常数的数学依据是什么？-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖https流程-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖使用 Clion + QEMU/GDB 远程调试Linux内核（分享自知乎网）<a href="https://zhuanlan.zhihu.com/p/412604505?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/412604505?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖TCP/IP协议到底在讲什么？ <a href="http://www.zhihu.com/question/51074319?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">http://www.zhihu.com/question/51074319?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【什么是动态规划（Dynamic Programming）？动态规划的意义是什么？】阮行止：… <a href="https://www.zhihu.com/question/23995189/answer/613096905?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/23995189/answer/613096905?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【为什么有人说弄懂了《算法导论》的 90%，就超越了 90%的程序员？】启舰：… <a href="https://www.zhihu.com/question/315201616/answer/1960517601?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/315201616/answer/1960517601?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【vs code】【keil】优雅地使用vs code代替keil。by 童话与云 👉 <a href="https://www.zhihu.com/zvideo/1422934459457253376?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/zvideo/1422934459457253376?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖图解网络 - 75张图带你了解网络设备、网络地址规划、静态路由、实战演练（分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖vscode-journal：vscode中写日记/便签/提醒，配合nutstore与安卓、ios同步_TeQuL的博客-CSDN博客-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖结构体（结构体嵌套、结构体指针、结构体参数传递） - 蓝海人 - 博客园-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖Feedme - 8大 RSS 阅读器第三方客户端[Android] - 小众软件-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖聪明人必学的停车小技巧！。by Felicidades 👉 <a href="https://www.zhihu.com/zvideo/1414008107094093824?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/zvideo/1414008107094093824?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖在线 DOS 游戏 - 近 2000 款怀旧游戏，仙剑、红警、三国志、大富翁、明星志愿、大航海、主题医院等 - 小众软件-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖Feeddd · 重新掌控你的订阅源-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【如何长时间高效学习？】硬核学长2077：… <a href="https://www.zhihu.com/question/28358499/answer/1762418904?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/28358499/answer/1762418904?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【你身边的学霸都有怎样的学习方法或习惯？】硬核学长2077：… <a href="https://www.zhihu.com/question/54265751/answer/1995587976?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/54265751/answer/1995587976?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖【如何不痛苦地早起？】铁木君：… <a href="https://www.zhihu.com/question/22120300/answer/1887544838?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/22120300/answer/1887544838?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖[[obsidian_tips]]-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖<a href="https://sspai.com/post/72757" target="_blank" rel="noopener">随时可用的 PC 体验是这样「炼」成的，Windows 新版睡眠机制详解 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖<a href="https://blog.csdn.net/who538592/article/details/79483323" target="_blank" rel="noopener">TC流量控制_who538592的博客-CSDN博客_tc流量控制</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>🔖 <a href="https://sspai.com/post/74090" target="_blank" rel="noopener">大家都说好的蛋白粉，我们应该如何取舍 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>🔖 <a href="https://zhuanlan.zhihu.com/p/508345279" target="_blank" rel="noopener">我的obsidian插件开发的学习过程</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>🔖 <a href="https://blog.csdn.net/Haywardwang/article/details/108626491" target="_blank" rel="noopener">python 词云构建_Haywardwang的博客-CSDN博客</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>🔖 <a href="https://blog.csdn.net/weixin_56842628/article/details/117921526?utm_medium=distribute.wap_relevant.none-task-blog-2~default~baidujs_title~default-9-117921526-blog-108626491.wap_blog_relevant_default&amp;spm=1001.2101.3001.4242.6&amp;utm_relevant_index=10" target="_blank" rel="noopener">如何用Python制作简单又好看的词云？来瞅瞅吧~_小熊爱Python的博客-CSDN博客_python词云代码简单</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>🔖 <a href="https://sspai.com/post/73779" target="_blank" rel="noopener">跨时空圆桌：伟大创作者们如何安排日常生活 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://www.appinn.com/typing-learner/" target="_blank" rel="noopener">Typing Learner - 硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」[Windows/macOS] - 小众软件</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://www.zhihu.com/question/391756708/answer/2556173863" target="_blank" rel="noopener">SpaceX的可回收火箭有什么神奇之处，为何其他航天大国还不能仿造？ - YY硕 的回答 - 知乎</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://mp.weixin.qq.com/s/KBKO4C1d4CkyHAPEkh8D4Q" target="_blank" rel="noopener">这几个通信协议的动图不错</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://oorkan.medium.com/emojifying-your-linux-terminal-9a5c1e8f6b3c" target="_blank" rel="noopener">Emojifying your Linux terminal  🚀</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://sspai.com/post/74167" target="_blank" rel="noopener">为 WSL 配置这些新功能，不用虚拟机也能体验完整 Linux - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖<a href="https://sspai.com/post/72274" target="_blank" rel="noopener">意识先行，工具辅助：谈谈我们该怎样分辨虚假信息</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖<a href="https://zhuanlan.zhihu.com/p/495262462" target="_blank" rel="noopener">网站低代码开发</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 学习体系化，效率提升-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>🔖 <a href="https://sspai.com/post/73958" target="_blank" rel="noopener">玩转 Obsidian 08：利用 Dataview 打造自动化 HomePage - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>🔖 <a href="https://post.m.smzdm.com/p/adwgg2rd/" target="_blank" rel="noopener">小爱同学，打开我的三菱空调——米家空调伴侣2使用分享_智能家居_什么值得买</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>🔖 <a href="https://sspai.com/post/73829" target="_blank" rel="noopener">用 59 分钟，找到工具的效率之源 - 少数派</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>🔖 <a href="https://cloud.tencent.com/developer/article/1879646" target="_blank" rel="noopener">tcpdump是在哪儿抓到的包？ - 腾讯云开发者社区-腾讯云</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>🔖 <a href="https://www.jianshu.com/p/79bcf09aed25" target="_blank" rel="noopener">IPTables五----ebtables - marshalzxy - 简书</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>🔖 <a href="https://david-waiting.medium.com/a-beginners-guide-to-generic-routing-encapsulation-fb2b4fb63abb" target="_blank" rel="noopener">A Beginner’s Guide to Generic Routing Encapsulation</a>-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;统计 ✅ : 6 📅 : 3 🔖 : 47&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「202207月度汇报」ttrss</title>
    <link href="https://talengu.github.io/public/2022/07/15/test/202207/"/>
    <id>https://talengu.github.io/public/2022/07/15/test/202207/</id>
    <published>2022-07-15T16:00:04.000Z</published>
    <updated>2022-07-15T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>total: 13</p><a id="more"></a><h2 id="🔖BGmi-–-自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人"><a class="header-anchor" href="#🔖BGmi-–-自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人">¶</a>🔖<a href="https://www.appinn.com/bgmi/" target="_blank" rel="noopener">BGmi – 自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人</a></h2><p>pubdata:2022-06-30 02:48:00markdate:2022-07-01 06:32:58.020141</p><p><img src="/public/2022/07/15/test/202207/2022-07-01-063258020141.jpg" alt="img"></p><h2 id="🔖老牌截图工具-PicPick-更新，新增录屏功能，支持-MP4-GIF-格式"><a class="header-anchor" href="#🔖老牌截图工具-PicPick-更新，新增录屏功能，支持-MP4-GIF-格式">¶</a>🔖<a href="https://www.appinn.com/picpick-6-2/" target="_blank" rel="noopener">老牌截图工具 PicPick 更新，新增录屏功能，支持 MP4/GIF 格式</a></h2><p>pubdata:2022-06-29 07:19:19markdate:2022-07-02 04:11:20.453414</p><p><img src="/public/2022/07/15/test/202207/2022-07-02-041120453414.jpg" alt="img"></p><h2 id="🔖白板与笔记融合：我的四个氢图使用场景"><a class="header-anchor" href="#🔖白板与笔记融合：我的四个氢图使用场景">¶</a>🔖<a href="https://sspai.com/post/73246" target="_blank" rel="noopener">白板与笔记融合：我的四个氢图使用场景</a></h2><p>pubdata:2022-06-30 03:30:02markdate:2022-07-03 01:08:35.583781</p><p><img src="/public/2022/07/15/test/202207/2022-07-03-010835583781.jpg" alt="img"></p><h2 id="🔖跨时空圆桌：伟大创作者们如何安排日常生活"><a class="header-anchor" href="#🔖跨时空圆桌：伟大创作者们如何安排日常生活">¶</a>🔖<a href="https://sspai.com/post/73779" target="_blank" rel="noopener">跨时空圆桌：伟大创作者们如何安排日常生活</a></h2><p>pubdata:2022-06-15 09:30:00markdate:2022-07-03 01:50:35.971655</p><p><img src="/public/2022/07/15/test/202207/2022-07-03-015035971655.jpg" alt="img"></p><h2 id="🔖Typing-Learner-–-硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」-Windows-macOS"><a class="header-anchor" href="#🔖Typing-Learner-–-硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」-Windows-macOS">¶</a>🔖<a href="https://www.appinn.com/typing-learner/" target="_blank" rel="noopener">Typing Learner – 硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」[Windows/macOS]</a></h2><p>pubdata:2022-07-03 04:07:39markdate:2022-07-04 05:06:58.902152</p><p><img src="/public/2022/07/15/test/202207/2022-07-04-050658902152.jpg" alt="img"></p><h2 id="🔖创建自己的第一个-Power-Automate-工作流，从此繁琐操作是路人"><a class="header-anchor" href="#🔖创建自己的第一个-Power-Automate-工作流，从此繁琐操作是路人">¶</a>🔖<a href="https://sspai.com/post/73710" target="_blank" rel="noopener">创建自己的第一个 Power Automate 工作流，从此繁琐操作是路人</a></h2><p>pubdata:2022-07-05 10:44:47markdate:2022-07-06 11:29:55.648077</p><p><img src="/public/2022/07/15/test/202207/2022-07-06-112955648077.jpg" alt="img"></p><h2 id="🔖为-WSL-配置这些新功能，不用虚拟机也能体验完整-Linux"><a class="header-anchor" href="#🔖为-WSL-配置这些新功能，不用虚拟机也能体验完整-Linux">¶</a>🔖<a href="https://sspai.com/post/74167" target="_blank" rel="noopener">为 WSL 配置这些新功能，不用虚拟机也能体验完整 Linux</a></h2><p>pubdata:2022-07-08 03:30:00markdate:2022-07-09 03:08:43.747852</p><p><img src="/public/2022/07/15/test/202207/2022-07-09-030843747852.jpg" alt="img"></p><h2 id="🔖当飞盘成为人类的玩具，我们该如何参与这场游戏"><a class="header-anchor" href="#🔖当飞盘成为人类的玩具，我们该如何参与这场游戏">¶</a>🔖<a href="https://sspai.com/post/73505" target="_blank" rel="noopener">当飞盘成为人类的玩具，我们该如何参与这场游戏</a></h2><p>pubdata:2022-06-06 08:00:00markdate:2022-07-10 01:36:40.114938</p><p><img src="/public/2022/07/15/test/202207/2022-07-10-013640114938.jpg" alt="img"></p><h2 id="🔖走进小众但不冷门的房车世界"><a class="header-anchor" href="#🔖走进小众但不冷门的房车世界">¶</a>🔖<a href="https://sspai.com/post/74043" target="_blank" rel="noopener">走进小众但不冷门的房车世界</a></h2><p>pubdata:2022-07-01 08:04:43markdate:2022-07-10 02:09:34.733003</p><p><img src="/public/2022/07/15/test/202207/2022-07-10-020934733003.jpg" alt="img"></p><h2 id="🔖从盲目崇拜到理性使用，谈谈我眼中的「双向链接」"><a class="header-anchor" href="#🔖从盲目崇拜到理性使用，谈谈我眼中的「双向链接」">¶</a>🔖<a href="https://sspai.com/post/73407" target="_blank" rel="noopener">从盲目崇拜到理性使用，谈谈我眼中的「双向链接」</a></h2><p>pubdata:2022-05-27 06:31:27markdate:2022-07-11 14:31:37.724795</p><p><img src="/public/2022/07/15/test/202207/2022-07-11-143137724795.jpg" alt="img"></p><h2 id="🔖打开终端总有好心情：我的美化方案及配置分享"><a class="header-anchor" href="#🔖打开终端总有好心情：我的美化方案及配置分享">¶</a>🔖<a href="https://sspai.com/post/74216" target="_blank" rel="noopener">打开终端总有好心情：我的美化方案及配置分享</a></h2><p>pubdata:2022-07-11 08:00:51markdate:2022-07-12 04:52:00.122103</p><p><img src="/public/2022/07/15/test/202207/2022-07-12-045200122103.jpg" alt="img"></p><h2 id="🔖咖啡美酒冷泡茶，这些消暑饮品在家就能动手做"><a class="header-anchor" href="#🔖咖啡美酒冷泡茶，这些消暑饮品在家就能动手做">¶</a>🔖<a href="https://sspai.com/post/74196" target="_blank" rel="noopener">咖啡美酒冷泡茶，这些消暑饮品在家就能动手做</a></h2><p>pubdata:2022-07-10 07:17:11markdate:2022-07-12 05:03:55.504330</p><p><img src="/public/2022/07/15/test/202207/2022-07-12-050355504330.jpg" alt="img"></p><h2 id="🔖语雀，即将开源！"><a class="header-anchor" href="#🔖语雀，即将开源！">¶</a>🔖<a href="https://zhuanlan.zhihu.com/p/540713275" target="_blank" rel="noopener">语雀，即将开源！</a></h2><p>pubdata:2022-07-12 08:19:47markdate:2022-07-14 10:28:28.713392</p><p><img src="/public/2022/07/15/test/202207/2022-07-14-102828713392.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;total: 13&lt;/p&gt;
    
    </summary>
    
      <category term="转载" scheme="https://talengu.github.io/public/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="转载" scheme="https://talengu.github.io/public/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>「转」Linux内核数据包bridge上转发流程</title>
    <link href="https://talengu.github.io/public/2022/07/06/linux/linux_bridge_forward/"/>
    <id>https://talengu.github.io/public/2022/07/06/linux/linux_bridge_forward/</id>
    <published>2022-07-06T16:00:04.000Z</published>
    <updated>2022-07-06T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://blog.csdn.net/hhhhhyyyyy8/article/details/102133863" target="_blank" rel="noopener">blog.csdn.net</a>@hhhhhyyyyy8 @4.15.1</p></blockquote><h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>linux 内核源代码变动怎么这么大，handle_bridge 函数居然没有了，本来接着准备以 3.9.1 分析的，但发现和后面的又变了，还是以 4.15.1 现在电脑上用的版本分析吧。</p><p><strong>linux kernel：4.15.1</strong></p><p>best of best [<a href="url">link</a>](<a href="https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg" target="_blank" rel="noopener">https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg</a>)</p><p><img src="/public/2022/07/06/linux/linux_bridge_forward/Netfilter-packet-flow5.svg" alt></p><p>先看三张图片</p><p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76153027" target="_blank" rel="noopener">IMG skb桥转发蓝图</a><img src="/public/2022/07/06/linux/linux_bridge_forward/20191005153149853.jpg" alt></p><p><a href="https://blog.csdn.net/u012247418/article/details/90137663" target="_blank" rel="noopener">IMG linux TCP/IP L2层数据包接收流程</a><img src="/public/2022/07/06/linux/linux_bridge_forward/t_70.png" alt></p><p><a href="https://www.cnblogs.com/xuanxuanBOSS/p/11424290.html" target="_blank" rel="noopener">IMG 浅析ebtables的概念和一些基本应用</a><img src="/public/2022/07/06/linux/linux_bridge_forward/netfilter.png" alt></p><blockquote><p>tips: linux 内核版本不一样，流程函数会发生细微改变。</p></blockquote><a id="more"></a><h2 id="1-br-handle-frame"><a class="header-anchor" href="#1-br-handle-frame">¶</a>1. br_handle_frame()</h2><p>作用：</p><ol><li><p>对于需要转发的报文，调用 <code>NF_BR_PRE_ROUTING</code> 处钩子函数，结束后，进入 <code>br_handle_frame_finish()</code> 函数；</p></li><li><p>对于 STP 报文，调用 <code>NF_BR_LOCAL_IN</code> 处钩子函数，结束后，进入 <code>br_handle_local_finish()</code> 函数，在 <code>br_handle_local_finish()</code> 函数中会调用 <code>br_pass_frame_up()</code> 函数。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return NULL if skb is handled</span></span><br><span class="line"><span class="comment"> * note: already called with rcu_read_lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">rx_handler_result_t</span> <span class="title">br_handle_frame</span><span class="params">(struct sk_buff **pskb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> = *<span class="title">pskb</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line"><span class="keyword">br_should_route_hook_t</span> *rhook;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*如果是环回地址，直接返回RX_HANDLER_PASS*/</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(skb-&gt;pkt_type == PACKET_LOOPBACK))</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*判断源MAC地址是否是有效的地址，不是直接丢弃，源MAC地址不能是多播地址和全0地址*/</span></span><br><span class="line"><span class="keyword">if</span> (!is_valid_ether_addr(eth_hdr(skb)-&gt;h_source))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"><span class="comment">/*判断是否是共享数据包，若是则clone该数据包；若clone时分配内存出错，返回NULL*/</span></span><br><span class="line">skb = skb_share_check(skb, GFP_ATOMIC);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*获取dev对应的网桥端口*/</span></span><br><span class="line">p = br_port_get_rcu(skb-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; BR_VLAN_TUNNEL) &#123;</span><br><span class="line"><span class="keyword">if</span> (br_handle_ingress_vlan_tunnel(skb, p,</span><br><span class="line">  nbp_vlan_group_rcu(p)))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*特殊MAC地址处理*/</span></span><br><span class="line"><span class="comment">//如果目的mac地址是本地链路地址link local reserved addr (01:80:c2:00:00:0X) STP报文</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(is_link_local_ether_addr(dest))) &#123;</span><br><span class="line">u16 fwd_mask = p-&gt;br-&gt;group_fwd_mask_required;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * See IEEE 802.1D Table 7-10 Reserved addresses</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Assignment Value</span></span><br><span class="line"><span class="comment"> * Bridge Group Address01-80-C2-00-00-00</span></span><br><span class="line"><span class="comment"> * (MAC Control) 802.301-80-C2-00-00-01</span></span><br><span class="line"><span class="comment"> * (Link Aggregation) 802.301-80-C2-00-00-02</span></span><br><span class="line"><span class="comment"> * 802.1X PAE address01-80-C2-00-00-03</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 802.1AB LLDP 01-80-C2-00-00-0E</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Others reserved for future standardization</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fwd_mask |= p-&gt;group_fwd_mask;</span><br><span class="line"><span class="keyword">switch</span> (dest[<span class="number">5</span>]) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x00</span>:<span class="comment">/* Bridge Group Address */</span></span><br><span class="line"><span class="comment">/* If STP is turned off,</span></span><br><span class="line"><span class="comment">   then must forward to keep loop detection */</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;br-&gt;stp_enabled == BR_NO_STP ||</span><br><span class="line">    fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line"><span class="keyword">goto</span> forward;</span><br><span class="line">*pskb = skb;</span><br><span class="line">__br_handle_local_finish(skb);</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> <span class="number">0x01</span>:<span class="comment">/* IEEE MAC (Pause) */</span></span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0E</span>:<span class="comment">/* 802.1AB LLDP */</span></span><br><span class="line">fwd_mask |= p-&gt;br-&gt;group_fwd_mask;</span><br><span class="line"><span class="keyword">if</span> (fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line"><span class="keyword">goto</span> forward;</span><br><span class="line">*pskb = skb;</span><br><span class="line">__br_handle_local_finish(skb);</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* Allow selective forwarding for most other protocols */</span></span><br><span class="line">fwd_mask |= p-&gt;br-&gt;group_fwd_mask;</span><br><span class="line"><span class="keyword">if</span> (fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line"><span class="keyword">goto</span> forward;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Deliver packet to local host only */</span></span><br><span class="line"><span class="comment">/*调用NF_BR_LOCAL_IN处钩子函数，结束后，进入br_handle_local_finish函数*/</span></span><br><span class="line">NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, dev_net(skb-&gt;dev),</span><br><span class="line"><span class="literal">NULL</span>, skb, skb-&gt;dev, <span class="literal">NULL</span>, br_handle_local_finish);</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">forward:</span><br><span class="line"><span class="keyword">switch</span> (p-&gt;state) &#123;</span><br><span class="line"><span class="comment">//网桥端口处于转发状态</span></span><br><span class="line"><span class="keyword">case</span> BR_STATE_FORWARDING:</span><br><span class="line">rhook = rcu_dereference(br_should_route_hook);</span><br><span class="line"><span class="keyword">if</span> (rhook) &#123;</span><br><span class="line"><span class="keyword">if</span> ((*rhook)(skb)) &#123;</span><br><span class="line">*pskb = skb;</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line">&#125;</span><br><span class="line">dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* fall through */</span></span><br><span class="line"><span class="comment">/*网桥端口处于学习状态，处于转发状态也会执行下面的代码，因为上面的case没有break。*/</span></span><br><span class="line"><span class="keyword">case</span> BR_STATE_LEARNING:</span><br><span class="line"><span class="comment">/*数据包目的MAC为网桥的Mac，发往本地的数据包*/</span></span><br><span class="line"><span class="keyword">if</span> (ether_addr_equal(p-&gt;br-&gt;dev-&gt;dev_addr, dest))</span><br><span class="line">skb-&gt;pkt_type = PACKET_HOST;</span><br><span class="line"><span class="comment">/*调用NF_BR_PRE_ROUTING处钩子函数，结束后进入br_handle_frame_finish函数*/</span></span><br><span class="line">NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,</span><br><span class="line">dev_net(skb-&gt;dev), <span class="literal">NULL</span>, skb, skb-&gt;dev, <span class="literal">NULL</span>,</span><br><span class="line">br_handle_frame_finish);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">drop:</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关函数</p><h3 id="rx-handler-result-t-枚举类型"><a class="header-anchor" href="#rx-handler-result-t-枚举类型">¶</a><code>rx_handler_result_t</code> 枚举类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> rx_handler_result &#123;</span><br><span class="line">RX_HANDLER_CONSUMED,</span><br><span class="line">RX_HANDLER_ANOTHER,</span><br><span class="line">RX_HANDLER_EXACT,</span><br><span class="line">RX_HANDLER_PASS,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> rx_handler_result <span class="keyword">rx_handler_result_t</span>;</span><br></pre></td></tr></table></figure><h3 id="is-valid-ether-addr"><a class="header-anchor" href="#is-valid-ether-addr">¶</a><code>is_valid_ether_addr()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * is_valid_ether_addr - Determine if the given Ethernet address is valid</span></span><br><span class="line"><span class="comment"> * @addr: Pointer to a six-byte array containing the Ethernet address</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not</span></span><br><span class="line"><span class="comment"> * a multicast address, and is not FF:FF:FF:FF:FF:FF.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return true if the address is valid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Please note: addr must be aligned to u16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_valid_ether_addr</span><span class="params">(<span class="keyword">const</span> u8 *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to</span></span><br><span class="line"><span class="comment"> * explicitly check for it here. */</span></span><br><span class="line"><span class="keyword">return</span> !is_multicast_ether_addr(addr) &amp;&amp; !is_zero_ether_addr(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="br-handle-local-finish"><a class="header-anchor" href="#br-handle-local-finish">¶</a><code>br_handle_local_finish()</code></h3><p><code>br_handle_local_finish()</code> 函数中调用 <code>br_pass_fame_up()</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/* note: already called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">br_handle_local_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span> = <span class="title">br_port_get_rcu</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line"> </span><br><span class="line">__br_handle_local_finish(skb);</span><br><span class="line"> </span><br><span class="line">BR_INPUT_SKB_CB(skb)-&gt;brdev = p-&gt;br-&gt;dev;</span><br><span class="line">br_pass_frame_up(skb);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-br-handle-frame-finish"><a class="header-anchor" href="#2-br-handle-frame-finish">¶</a>2. br_handle_frame_finish()</h2><p>作用：</p><p>网桥设备是否处于混杂模式，如果是，则会发一份到本地进行处理</p><p>如果是广播包，则会进行广播洪泛，并会发一份到本地处理</p><p>如果是组播包，则根据组播表进行组播转发，并发一份数数包到本地处理</p><p>如果是单播包，发往本地的单播包则送到本地处理，在 fdb 表中可以找到转发表项的单播包则进行转发，未知单播包在广播域内进行洪泛</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="comment">/* note: already called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_handle_frame_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span> = <span class="title">br_port_get_rcu</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line"><span class="keyword">enum</span> br_pkt_type pkt_type = BR_PKT_UNICAST;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_fdb_entry</span> *<span class="title">dst</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_mdb_entry</span> *<span class="title">mdst</span>;</span></span><br><span class="line"><span class="keyword">bool</span> local_rcv, mcast_hit = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *dest;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span>;</span></span><br><span class="line">u16 vid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果网桥端口不存在或者网桥端口状态为BR_STATE_DISABLED，则丢弃*/</span></span><br><span class="line"><span class="keyword">if</span> (!p || p-&gt;state == BR_STATE_DISABLED)</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"><span class="comment">/*判断是否允许进入桥内，如果没有开启VLAN则所有数据包都可以进入，</span></span><br><span class="line"><span class="comment">如果开启了VLAN,则根据VLAN相应的规则，从桥上进行数据包转发。*/</span></span><br><span class="line"><span class="keyword">if</span> (!br_allowed_ingress(p-&gt;br, nbp_vlan_group_rcu(p), skb, &amp;vid))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line">nbp_switchdev_frame_mark(p, skb);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* insert into forwarding database after filtering to avoid spoofing */</span></span><br><span class="line">br = p-&gt;br;</span><br><span class="line"><span class="comment">/*如果网桥端口标志有BR_LEARNING,则更新fdb表。</span></span><br><span class="line"><span class="comment">    一般新建网桥端口p-&gt;flags=BR_LEARNING| BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD*/</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; BR_LEARNING)</span><br><span class="line">br_fdb_update(br, p, eth_hdr(skb)-&gt;h_source, vid, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发往本地数据包标记，!!的作用是转换为bool值</span></span><br><span class="line">local_rcv = !!(br-&gt;dev-&gt;flags &amp; IFF_PROMISC);</span><br><span class="line">dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line"><span class="comment">/*目的地址为多播地址*/</span></span><br><span class="line"><span class="keyword">if</span> (is_multicast_ether_addr(dest)) &#123;</span><br><span class="line"><span class="comment">/* by definition the broadcast is also a multicast address */</span></span><br><span class="line"><span class="comment">/*如果目的地址是广播地址，将数据包也发往本地一份*/</span></span><br><span class="line"><span class="keyword">if</span> (is_broadcast_ether_addr(dest)) &#123;</span><br><span class="line">pkt_type = BR_PKT_BROADCAST;</span><br><span class="line">local_rcv = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">pkt_type = BR_PKT_MULTICAST;</span><br><span class="line"><span class="comment">//igmp snooping留给网桥子系统的外部接口函数，</span></span><br><span class="line"><span class="comment">//当网桥接收了igmp数据包后就会调用该函数进行后续处理</span></span><br><span class="line"><span class="keyword">if</span> (br_multicast_rcv(br, p, skb, vid))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果网桥端口状态此时还是BR_STATE_LEARNING,则丢弃。</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;state == BR_STATE_LEARNING)</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"><span class="comment">//将网桥所属的net_device放入skb的私有数据中（struct br_input_skb_cb）</span></span><br><span class="line">BR_INPUT_SKB_CB(skb)-&gt;brdev = br-&gt;dev;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_INET) &amp;&amp;</span><br><span class="line">    (skb-&gt;protocol == htons(ETH_P_ARP) ||</span><br><span class="line">     skb-&gt;protocol == htons(ETH_P_RARP))) &#123;</span><br><span class="line">br_do_proxy_suppress_arp(skb, br, vid, p);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ENABLED(CONFIG_IPV6) &amp;&amp;</span><br><span class="line">   skb-&gt;protocol == htons(ETH_P_IPV6) &amp;&amp;</span><br><span class="line">   br-&gt;neigh_suppress_enabled &amp;&amp;</span><br><span class="line">   pskb_may_pull(skb, <span class="keyword">sizeof</span>(struct ipv6hdr) +</span><br><span class="line"> <span class="keyword">sizeof</span>(struct nd_msg)) &amp;&amp;</span><br><span class="line">   ipv6_hdr(skb)-&gt;nexthdr == IPPROTO_ICMPV6) &#123;</span><br><span class="line">struct nd_msg *msg, _msg;</span><br><span class="line"> </span><br><span class="line">msg = br_is_nd_neigh_msg(skb, &amp;_msg);</span><br><span class="line"><span class="keyword">if</span> (msg)</span><br><span class="line">br_do_suppress_nd(skb, br, vid, p, msg);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">switch</span> (pkt_type) &#123;</span><br><span class="line"><span class="comment">//组播包</span></span><br><span class="line"><span class="keyword">case</span> BR_PKT_MULTICAST:</span><br><span class="line"><span class="comment">//获取组播转发项，设置local_rcv为true，组播包也要发往本地一份。</span></span><br><span class="line">mdst = br_mdb_get(br, skb, vid);</span><br><span class="line"><span class="keyword">if</span> ((mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) &amp;&amp;</span><br><span class="line">    br_multicast_querier_exists(br, eth_hdr(skb))) &#123;</span><br><span class="line"><span class="keyword">if</span> ((mdst &amp;&amp; mdst-&gt;host_joined) ||</span><br><span class="line">    br_multicast_is_router(br)) &#123;</span><br><span class="line">local_rcv = <span class="literal">true</span>;</span><br><span class="line">br-&gt;dev-&gt;stats.multicast++;</span><br><span class="line">&#125;</span><br><span class="line">mcast_hit = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">local_rcv = <span class="literal">true</span>;</span><br><span class="line">br-&gt;dev-&gt;stats.multicast++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//单播包</span></span><br><span class="line"><span class="keyword">case</span> BR_PKT_UNICAST:</span><br><span class="line"><span class="comment">//根据目的MAC地址查找fdb表，看是否有对应的表项</span></span><br><span class="line">dst = br_fdb_find_rcu(br, dest, vid);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果找到目的MAC对应的表项</span></span><br><span class="line"><span class="keyword">if</span> (dst) &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> now = jiffies;</span><br><span class="line"><span class="comment">//送入上层处理</span></span><br><span class="line"><span class="keyword">if</span> (dst-&gt;is_local)</span><br><span class="line"><span class="keyword">return</span> br_pass_frame_up(skb);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (now != dst-&gt;used)</span><br><span class="line">dst-&gt;used = now;</span><br><span class="line"><span class="comment">//根据fdb转发表项进行转发，若这里local_rcv 为1,（即端口处于混杂模式IFF_PROMISC），则会克隆一份再转发</span></span><br><span class="line"><span class="comment">//传入的第一个参数dst-&gt;dst 即为要转发的目的端口</span></span><br><span class="line">br_forward(dst-&gt;dst, skb, local_rcv, <span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//进行广播或者组播洪泛</span></span><br><span class="line"><span class="keyword">if</span> (!mcast_hit)</span><br><span class="line">br_flood(br, skb, pkt_type, local_rcv, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">br_multicast_flood(mdst, skb, local_rcv, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//local_rcv标记为1，送入上层处理。</span></span><br><span class="line"><span class="keyword">if</span> (local_rcv)</span><br><span class="line"><span class="keyword">return</span> br_pass_frame_up(skb);</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">drop:</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-br-pass-frame-up"><a class="header-anchor" href="#3-br-pass-frame-up">¶</a>3.br_pass_frame_up</h2><p>数据包的目的 MAC 是本地的单播报文，广播，组播和网桥处于混杂模式时，报文都会通过 br_pass_frame_up 函数交由上层处理。</p><p>作用：</p><p>调用 NF_BR_LOCAL_IN 处钩子函数，最后调用 br_netif_receive_skb 函数，绕一圈后，交友上层处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">br_pass_frame_up</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">indev</span>, *<span class="title">brdev</span> = <span class="title">BR_INPUT_SKB_CB</span>(<span class="title">skb</span>)-&gt;<span class="title">brdev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span> = <span class="title">netdev_priv</span>(<span class="title">brdev</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_vlan_group</span> *<span class="title">vg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcpu_sw_netstats</span> *<span class="title">brstats</span> = <span class="title">this_cpu_ptr</span>(<span class="title">br</span>-&gt;<span class="title">stats</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//统计网桥设备上的收包流量数据</span></span><br><span class="line">u64_stats_update_begin(&amp;brstats-&gt;syncp);</span><br><span class="line">brstats-&gt;rx_packets++;</span><br><span class="line">brstats-&gt;rx_bytes += skb-&gt;len;</span><br><span class="line">u64_stats_update_end(&amp;brstats-&gt;syncp);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取网桥设备上的VLAN组</span></span><br><span class="line">vg = br_vlan_group_rcu(br);</span><br><span class="line"><span class="comment">/* Bridge is just like any other port.  Make sure the</span></span><br><span class="line"><span class="comment"> * packet is allowed except in promisc modue when someone</span></span><br><span class="line"><span class="comment"> * may be running packet capture.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!(brdev-&gt;flags &amp; IFF_PROMISC) &amp;&amp;</span><br><span class="line">    !br_allowed_egress(vg, skb)) &#123;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录数据包的收包网络设备</span></span><br><span class="line">indev = skb-&gt;dev;</span><br><span class="line"><span class="comment">//将数据包的收包设备改为网桥设备</span></span><br><span class="line"><span class="comment">//当再次进入__netif_receive_skb_core时就不会再次进入桥处理了，因为网桥上没有注册rx_handler 函数</span></span><br><span class="line">skb-&gt;dev = brdev;</span><br><span class="line"><span class="comment">//配置数据包vlan相关信息</span></span><br><span class="line">skb = br_handle_vlan(br, <span class="literal">NULL</span>, vg, skb);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line"><span class="comment">/* update the multicast stats if the packet is IGMP/MLD */</span></span><br><span class="line"><span class="comment">//如果数据包是组播，更新组播数据包的统计信息</span></span><br><span class="line">br_multicast_count(br, <span class="literal">NULL</span>, skb, br_multicast_igmp_type(skb),</span><br><span class="line">   BR_MCAST_DIR_TX);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用NF_BR_LOCAL_IN处钩子函数，最后调用br_netif_receive_skb函数。</span></span><br><span class="line"><span class="keyword">return</span> NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,</span><br><span class="line">       dev_net(indev), <span class="literal">NULL</span>, skb, indev, <span class="literal">NULL</span>,</span><br><span class="line">       br_netif_receive_skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次进入 netif_receive_skb，由于 skb-dev 被设置成了 bridge，而 bridge 设备的 rx_handler 函数是没有被设置的，所以就不会再次进入 bridge 逻辑，而直接进入了主机上层协议栈。</p><p>相关函数</p><h3 id="br-netif-receive-skb"><a class="header-anchor" href="#br-netif-receive-skb">¶</a><code>br_netif_receive_skb()</code></h3><p>可以看到在 br_netif_receive_skb() 函数中调用了 netif_receive_skb() 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">static int</span><br><span class="line">br_netif_receive_skb(struct net *net, struct sock *sk, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">br_drop_fake_rtable(skb);</span><br><span class="line">return netif_receive_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-br-forward"><a class="header-anchor" href="#4-br-forward">¶</a>4. br_forward()</h2><p>不是发往本地的数据包，但在 fdb 表中能找到对应的表项，则进行转发 br_forward()，若在 fdb 表中找不到对应表项就进行洪泛 br_blood().</p><p>作用：</p><p>主要是调用__br_forward() 转发报文</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * br_forward - forward a packet to a specific port</span></span><br><span class="line"><span class="comment"> * @to: destination port</span></span><br><span class="line"><span class="comment"> * @skb: packet being forwarded</span></span><br><span class="line"><span class="comment"> * @local_rcv: packet will be received locally after forwarding</span></span><br><span class="line"><span class="comment"> * @local_orig: packet is locally originated</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Should be called with rcu_read_lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_forward</span><span class="params">(<span class="keyword">const</span> struct net_bridge_port *to,</span></span></span><br><span class="line"><span class="function"><span class="params">struct sk_buff *skb, <span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//should_deliver测试是否应该将该包转发出去</span></span><br><span class="line"><span class="keyword">if</span> (to &amp;&amp; should_deliver(to, skb)) &#123;</span><br><span class="line"><span class="comment">//如果local_rcv为1，表明端口为混杂模式，先clone一份数据包再进行转发</span></span><br><span class="line"><span class="keyword">if</span> (local_rcv)</span><br><span class="line">deliver_clone(to, skb, local_orig);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__br_forward(to, skb, local_orig);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!local_rcv)</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-br-forward"><a class="header-anchor" href="#5-br-forward">¶</a>5. __br_forward()</h2><p>作用:</p><p>__br_forward() 函数根据数据包的来源（local_orig）分别进入不同的钩子点，如果数据包是从本地发出的，则进入 NF_BR_LOCAL_OUT，如果不是本地发出的，则进入 NF_BR_FORWARD 钩子，最后都进入 br_forward_finish() 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __br_forward(<span class="keyword">const</span> struct net_bridge_port *to,</span><br><span class="line"> struct sk_buff *skb, <span class="keyword">bool</span> local_orig)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_vlan_group</span> *<span class="title">vg</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">indev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line"><span class="keyword">int</span> br_hook;</span><br><span class="line"><span class="comment">//获取vlan组，这个组中有许多的vlanid，br_handle_vlan函数就是要在这个组中查找自己的vid</span></span><br><span class="line">vg = nbp_vlan_group_rcu(to);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加vlan的相关配置</span></span><br><span class="line">skb = br_handle_vlan(to-&gt;br, to, vg, skb);</span><br><span class="line"><span class="keyword">if</span> (!skb)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//记录数据包的原始收包网络设备</span></span><br><span class="line">indev = skb-&gt;dev;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将skb的dev修改为出口网络设备</span></span><br><span class="line">skb-&gt;dev = to-&gt;dev;</span><br><span class="line"><span class="comment">/*如果local_orig标志位(判断是否从本地发出的数据包)为false，就进入NF_BR_FORWARD钩子</span></span><br><span class="line"><span class="comment">若为true，就进入NF_BR_LOCAL_OUT钩子点*/</span></span><br><span class="line"><span class="keyword">if</span> (!local_orig) &#123;</span><br><span class="line"><span class="keyword">if</span> (skb_warn_if_lro(skb)) &#123;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不是本地发出的数据包，进入NF_BR_FORWARD</span></span><br><span class="line">br_hook = NF_BR_FORWARD;</span><br><span class="line">skb_forward_csum(skb);</span><br><span class="line">net = dev_net(indev);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(netpoll_tx_running(to-&gt;br-&gt;dev))) &#123;</span><br><span class="line"><span class="keyword">if</span> (!is_skb_forwardable(skb-&gt;dev, skb)) &#123;</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">skb_push(skb, ETH_HLEN);</span><br><span class="line">br_netpoll_send_skb(to, skb);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若是本地发出的数据包，进入NF_BR_LOCAL_OUT处理</span></span><br><span class="line">br_hook = NF_BR_LOCAL_OUT;</span><br><span class="line">net = dev_net(skb-&gt;dev);</span><br><span class="line">indev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入钩子点，最后执行br_forward_finish函数。</span></span><br><span class="line">NF_HOOK(NFPROTO_BRIDGE, br_hook,</span><br><span class="line">net, <span class="literal">NULL</span>, skb, indev, skb-&gt;dev,</span><br><span class="line">br_forward_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-br-forward-finish"><a class="header-anchor" href="#6-br-forward-finish">¶</a>6. br_forward_finish()</h2><p><code>br_forward_finish()</code> 函数比较简单，调用 <code>NF_BR_POST_ROUTING</code> 处的钩子函数，最后进入 <code>br_dev_queue_push_xmit</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_forward_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING,</span><br><span class="line">       net, sk, skb, <span class="literal">NULL</span>, skb-&gt;dev,</span><br><span class="line">       br_dev_queue_push_xmit);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-br-dev-queue-push-xmit"><a class="header-anchor" href="#7-br-dev-queue-push-xmit">¶</a>7. br_dev_queue_push_xmit</h2><p>在 <code>br_dev_queue_push_xmit()</code> 中，会先 <code>skb_push(skb,ETH,HLEN);</code> 将 data 指向二层头部，然后调用 <code>dev_queue_xmit()</code> 发送报文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_dev_queue_push_xmit</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!is_skb_forwardable(skb-&gt;dev, skb))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//注意这句操作</span></span><br><span class="line">skb_push(skb, ETH_HLEN);</span><br><span class="line">br_drop_fake_rtable(skb);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_PARTIAL &amp;&amp;</span><br><span class="line">    (skb-&gt;protocol == htons(ETH_P_8021Q) ||</span><br><span class="line">     skb-&gt;protocol == htons(ETH_P_8021AD))) &#123;</span><br><span class="line"><span class="keyword">int</span> depth;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!__vlan_get_protocol(skb, skb-&gt;protocol, &amp;depth))</span><br><span class="line"><span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">skb_set_network_header(skb, depth);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">dev_queue_xmit(skb);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">drop:</span><br><span class="line">kfree_skb(skb);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-br-flood"><a class="header-anchor" href="#8-br-flood">¶</a>8. br_flood</h2><p><code>br_flood()</code> 也是调用 <code>__br_forward()</code> 函数转发报文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/* called under rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_flood</span><span class="params">(struct net_bridge *br, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">enum</span> br_pkt_type pkt_type, <span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 igmp_type = br_multicast_igmp_type(skb);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span>;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/*遍历网桥设备的port_list，取出所有的网桥端口*/</span></span><br><span class="line">list_for_each_entry_rcu(p, &amp;br-&gt;port_list, <span class="built_in">list</span>) </span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">/* Do not flood unicast traffic to ports that turn it off, nor</span></span><br><span class="line"><span class="comment"> * other traffic if flood off, except for traffic we originate</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (pkt_type) </span><br><span class="line">                &#123;</span><br><span class="line"><span class="keyword">case</span> BR_PKT_UNICAST:</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; BR_FLOOD))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BR_PKT_MULTICAST:</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; BR_MCAST_FLOOD) &amp;&amp; skb-&gt;dev != br-&gt;dev)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> BR_PKT_BROADCAST:</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;flags &amp; BR_BCAST_FLOOD) &amp;&amp; skb-&gt;dev != br-&gt;dev)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Do not flood to ports that enable proxy ARP */</span></span><br><span class="line">                <span class="comment">/*代理arp*/</span></span><br><span class="line"><span class="keyword">if</span> (p-&gt;flags &amp; BR_PROXYARP)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((p-&gt;flags &amp; (BR_PROXYARP_WIFI | BR_NEIGH_SUPPRESS)) &amp;&amp;</span><br><span class="line">    BR_INPUT_SKB_CB(skb)-&gt;proxyarp_replied)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">prev = maybe_deliver(prev, p, skb, local_orig);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(prev))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (prev == p)</span><br><span class="line">br_multicast_count(p-&gt;br, p, skb, igmp_type,</span><br><span class="line">   BR_MCAST_DIR_TX);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!prev)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (local_rcv)</span><br><span class="line">deliver_clone(prev, skb, local_orig);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__br_forward(prev, skb, local_orig);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (!local_rcv)</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-br-mulicast-flood"><a class="header-anchor" href="#9-br-mulicast-flood">¶</a>9. br_mulicast_flood()</h2><hr><p>以后再分析，肚子饿了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/* called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_multicast_flood</span><span class="params">(struct net_bridge_mdb_entry *mdst,</span></span></span><br><span class="line"><span class="function"><span class="params">struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">BR_INPUT_SKB_CB</span>(<span class="title">skb</span>)-&gt;<span class="title">brdev</span>;</span></span><br><span class="line">u8 igmp_type = br_multicast_igmp_type(skb);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port_group</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">rp</span>;</span></span><br><span class="line"> </span><br><span class="line">rp = rcu_dereference(hlist_first_rcu(&amp;br-&gt;router_list));</span><br><span class="line">p = mdst ? rcu_dereference(mdst-&gt;ports) : <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (p || rp) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">port</span>, *<span class="title">lport</span>, *<span class="title">rport</span>;</span></span><br><span class="line"> </span><br><span class="line">lport = p ? p-&gt;port : <span class="literal">NULL</span>;</span><br><span class="line">rport = rp ? hlist_entry(rp, struct net_bridge_port, rlist) :</span><br><span class="line">     <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)lport &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)rport) &#123;</span><br><span class="line">port = lport;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (port-&gt;flags &amp; BR_MULTICAST_TO_UNICAST) &#123;</span><br><span class="line">maybe_deliver_addr(lport, skb, p-&gt;eth_addr,</span><br><span class="line">   local_orig);</span><br><span class="line"><span class="keyword">goto</span> delivered;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">port = rport;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">prev = maybe_deliver(prev, port, skb, local_orig);</span><br><span class="line">delivered:</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(prev))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (prev == port)</span><br><span class="line">br_multicast_count(port-&gt;br, port, skb, igmp_type,</span><br><span class="line">   BR_MCAST_DIR_TX);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)lport &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)port)</span><br><span class="line">p = rcu_dereference(p-&gt;next);</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)rport &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)port)</span><br><span class="line">rp = rcu_dereference(hlist_next_rcu(rp));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (!prev)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (local_rcv)</span><br><span class="line">deliver_clone(prev, skb, local_orig);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__br_forward(prev, skb, local_orig);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (!local_rcv)</span><br><span class="line">kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2><p><a href="http://ebtables.netfilter.org/br_fw_ia/br_fw_ia.html" target="_blank" rel="noopener">ebtables/iptables interaction on a Linux-based bridge</a>@ebtables @2.4.x kernel</p><p><a href="https://blog.csdn.net/sxd2001/article/details/125031113" target="_blank" rel="noopener">Iptables DNAT实现broadcast与unicast之间相互映射</a>@sxd2001 分析ebtables 的redirect 和 iptables 的redirect</p><p><a href="https://blog.csdn.net/Sophisticated_/article/details/87923362" target="_blank" rel="noopener">Linux-4.20.8内核桥收包源码解析（七）--本地（br_pass_frame_up）or 转发（br_forward）</a>@lw_yang @Linux-4.20.8</p><p><a href="http://blog.chinaunix.net/uid-28541347-id-5750406.html" target="_blank" rel="noopener">Linux 3.10 kernel bridge转发逻辑</a>@lvyilong316 @Linux 3.10 kernel</p><p><a href="https://blog.csdn.net/linyt/article/details/5191512" target="_blank" rel="noopener">kernel 网桥代码分析</a>@海枫 @ 2.6.24.4</p><p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76674232" target="_blank" rel="noopener">桥数据包处理函数——br_handle_frame_finish（七）</a>@不留你的名字</p><p><a href="https://www.cnblogs.com/super-king/p/bridge_implement.html" target="_blank" rel="noopener">Bridge实现</a>@SuperKing @linux 2.6.18</p><p><a href="https://www.cnblogs.com/ck1020/p/5894235.html" target="_blank" rel="noopener">LInux下桥接模式详解三</a>@jack.chen @linux 3.10.1</p><p><a href="https://blog.csdn.net/one_clouder/article/details/52877737" target="_blank" rel="noopener">协议栈报文接收之netif_receive_skb函数分析</a>@one_clouder @Linux4.1.12</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址 &lt;a href=&quot;https://blog.csdn.net/hhhhhyyyyy8/article/details/102133863&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;blog.csdn.net&lt;/a&gt;
@hhhhhyyyyy8 @4.15.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;linux 内核源代码变动怎么这么大，handle_bridge 函数居然没有了，本来接着准备以 3.9.1 分析的，但发现和后面的又变了，还是以 4.15.1 现在电脑上用的版本分析吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;linux kernel：4.15.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;best of best [&lt;a href=&quot;url&quot;&gt;link&lt;/a&gt;](&lt;a href=&quot;https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/public/2022/07/06/linux/linux_bridge_forward/Netfilter-packet-flow5.svg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;先看三张图片&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/NW_NW_NW/article/details/76153027&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IMG skb桥转发蓝图&lt;/a&gt;
&lt;img src=&quot;/public/2022/07/06/linux/linux_bridge_forward/20191005153149853.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u012247418/article/details/90137663&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IMG linux TCP/IP L2层数据包接收流程&lt;/a&gt;
&lt;img src=&quot;/public/2022/07/06/linux/linux_bridge_forward/t_70.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xuanxuanBOSS/p/11424290.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IMG 浅析ebtables的概念和一些基本应用&lt;/a&gt;
&lt;img src=&quot;/public/2022/07/06/linux/linux_bridge_forward/netfilter.png&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;tips: linux 内核版本不一样，流程函数会发生细微改变。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://talengu.github.io/public/categories/Linux/"/>
    
    
      <category term="bridge" scheme="https://talengu.github.io/public/tags/bridge/"/>
    
      <category term="netfilter" scheme="https://talengu.github.io/public/tags/netfilter/"/>
    
  </entry>
  
  <entry>
    <title>「转」tcpdump是在哪儿抓到的包？</title>
    <link href="https://talengu.github.io/public/2022/07/01/linux/how_tcpdump/"/>
    <id>https://talengu.github.io/public/2022/07/01/linux/how_tcpdump/</id>
    <published>2022-07-01T16:00:04.000Z</published>
    <updated>2022-07-01T16:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://cloud.tencent.com/developer/article/1879646" target="_blank" rel="noopener">cloud.tencent.com</a></p></blockquote><blockquote><p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对...</p></blockquote><p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对这个问题，我进行了一番学习探究。</p><p>先说结论：通过 PF_PACKET 这个特殊的套接字协议，直接接收来自链路层的帧。数据包<strong>并非没有</strong>进入内核，而是在进入内核后直接跳过了内核中三层 / 四层的协议栈，直达套接字接口，被应用层的 tcpdump 所使用。实际上，在网卡驱动程序通知内核接受到数据帧的时候，数据包就已经进入了内核处理流程。具体的区别，可以见下图。</p><p><img src="/public/2022/07/01/linux/how_tcpdump/1620.png" alt></p><p>内核网络协议栈示意图</p><a id="more"></a><p>先来看看，普通的套接字的收包路径在内核中是怎么样。</p><p>以最常见的以太网网卡，当网卡接口接收到了一个帧，那么接受者知道它一定包含了一个 Ethernet 报头。封包在协议栈向上传递过程中，一定会在报头中包含一个字段，指出下一阶段的处理应该使用哪一个协议。 以太网卡拥有特定的 MAC 地址，在监听数据帧的时候，当看到帧的目的 MAC 地址与自己的地址或者链路层广播地址（FF:FF:FF:FF:FF:FF）相匹配，就会通过 DMA 把该帧读取到内存中的 ring buffer。</p><p>当一个数据帧被写入到内存后，将产生一个硬件中断请求，以通知 CPU 收到了数据包。操作系统为了减少硬中断产生的次数，会采用一个软中断 (softirq) 唤醒 NAPI 子系统。这样会产生一个单独的线程，调用网卡驱动注册的 poll 方法收包，同时禁止网卡产生新的硬中断，这样的效果便是一次中断可以接收多个包。一旦软终端代码判断有 softirq 处于 pending 状态，便会调用软终端处理函数 net_rx_action。</p><p>中断处理函数会在处理循环中调用 NAPI poll 来接收数据包。poll 方法会分配一个 sk_buff 数据结构（include/linux/skbuff.h），表示该数据包的内核视图。然后将数据从缓冲区提取到新建的 sk_buff 中，并对其中的 protocol 字段做初始化，该字段用以识别特定的协议。之后这个字段会被 netif_receive_skb 内核函数查询，用来确定该执行哪个函数来处理三层的封包。字段涉及协议的值都列在了 include/uapi/linux/if_ether.h 中，名字形如 ETH_P_XXX，比如 ip 协议为 ETH_P_IP。而有一种特殊情况，单一封包可以传递给多个处理函数，这就是 tcpdump 等网络嗅探应用会用到的 ETH_P_ALL。</p><p>软终端处理循环的最后是通过 netif_receive_skb 函数将将数据交给 TCP/IP 协议栈的。它会从数据包包头中取出协议信息，然后遍历注册在这个协议上的回调函数列表。这里的列表值得一提，分别是 ptype_all 和 ptype_base。他们是 hash table 数据结构，分别对应通用数据包（ETH_P_ALL 类型）和特定协议的数据包（ETH_P_XXX 类型），其中存放着指向对应协议处理函数的指针，当收到该类型的数据包时便调用对应的处理函数。</p><p>因此，以 IP 数据包为例，当 ETH_P_IP 类型数据包出队后，软中断处理程序 net_rx_action 最终会在 ptype_base 列表中找到 IP 协议的处理函数 ip_rcv() 并调用它，完成数据包向上提交到协议栈。这里略过 IP 协议栈的处理过程，简而言之，在经过 IP 数据包完整性校验、Netfilter 子系统（iptables 的底层实现）、路由子系统等等一些列流程之后，开始准备送往高层协议。这里的处理和 net_rx_action 很相似，从 IP 数据包头部提取出协议类型后，通过名为 inet_protos 的哈希来寻找高层协议的处理函数，每个高层协议都对应一个处理函数，型如 tcp_v4_rcv(), udp_rcv() 等。</p><p>四层协议以较为简单的 UDP 为例，udp_rcv 会对 udp 包进行合法性校验，然后查找是否有愿意接收此数据包的套接字，如果找到，__udp_queue_rcv_skb 会将包放到 socket 的接收队列。最后，所有在这个 socket 上等待数据的进程都会收到通过 sk_data_ready 函数处理的通知。</p><p>以上是一个数据包穿越协议栈到达 socket 的简要过程，实际的内核处理过程会复杂的多，这里只是做简要的描述。以引入本文的主角：PF_PACKET 协议数据包在内核中的处理路径。</p><p>当创建 PF_PACKET 套接字时，与协议相关的数据包类型将被同时注册进 ptype_all 和 ptype_base，接受函数为 packet_rcb()。此时，net_rx_action 函数会拦截所有进入机器的包，并同样通过 netif_receive_skb 函数遍历 ptype_all 后，传递给 PF_PACKET 接受函数。值得一提的是，tcpdump 依赖的 libpcap 库并非使用原始套接字 + recvfrom 的方式收包，而是在内核空间分配一块内核缓冲区，然后用户空间调用 mmap 系统调用映射到用户空间。</p><h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2><p><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/" target="_blank" rel="noopener">Monitoring and Tuning the Linux Networking Stack: Receiving Data</a></p><p><a href="https://www.linuxjournal.com/article/4852" target="_blank" rel="noopener">Inside the Linux Packet Filter</a></p><p><a href="https://km.woa.com/group/17746/articles/show/%E5%9B%BE%E8%A7%A3linux%20tcpdump" target="_blank" rel="noopener">图解 linux tcpdump</a></p><p>《深入理解 Linux 网络技术内幕》</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;原文地址 &lt;a href=&quot;https://cloud.tencent.com/developer/article/1879646&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;cloud.tencent.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对这个问题，我进行了一番学习探究。&lt;/p&gt;
&lt;p&gt;先说结论：通过 PF_PACKET 这个特殊的套接字协议，直接接收来自链路层的帧。数据包&lt;strong&gt;并非没有&lt;/strong&gt;进入内核，而是在进入内核后直接跳过了内核中三层 / 四层的协议栈，直达套接字接口，被应用层的 tcpdump 所使用。实际上，在网卡驱动程序通知内核接受到数据帧的时候，数据包就已经进入了内核处理流程。具体的区别，可以见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/public/2022/07/01/linux/how_tcpdump/1620.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;内核网络协议栈示意图&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://talengu.github.io/public/categories/Linux/"/>
    
    
      <category term="tcpdump" scheme="https://talengu.github.io/public/tags/tcpdump/"/>
    
  </entry>
  
  <entry>
    <title>使用脚本将英文rss转成中文rss</title>
    <link href="https://talengu.github.io/public/2022/05/08/rss_google_translate/"/>
    <id>https://talengu.github.io/public/2022/05/08/rss_google_translate/</id>
    <published>2022-05-08T22:00:04.000Z</published>
    <updated>2022-05-08T22:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>本文中我们将英文rss 自动转成中文 rss供ttrss使用。（利用谷歌翻译）</p><p>方便在手机上进行阅读或者收听。</p><center><img src="/public/2022/05/08/rss_google_translate/20220508-22-28-27.png" width="30%"></center><a id="more"></a><h2 id="举例"><a class="header-anchor" href="#举例">¶</a>举例</h2><p>国外有很多不错的rss源，比如:</p><ul><li><a href="http://www.mckinsey.com/insights/rss" target="_blank" rel="noopener">McKinsey Insights &amp; Publications</a>  <center><img src="/public/2022/05/08/rss_google_translate/20220508-22-18-23.png" width="50%"></center></li></ul>    转成中文rss    <center><img src="/public/2022/05/08/rss_google_translate/20220508-22-20-48.png" width="50%"></center><ul><li><p><a href="http://rss.acast.com/nature" target="_blank" rel="noopener">Nature Podcast</a></p>  <center><img src="/public/2022/05/08/rss_google_translate/20220508-22-25-04.png" width="50%"></center></li></ul>   转成中文rss       <center><img src="/public/2022/05/08/rss_google_translate/20220508-22-26-36.png" width="50%"></center><h2 id="脚本"><a class="header-anchor" href="#脚本">¶</a>脚本</h2><p>使用 Translate 和 BeautifulSoup 项目</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8 </span></span><br><span class="line"><span class="keyword">from</span> pygtrans <span class="keyword">import</span> Translate</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment"># pip 安装</span></span><br><span class="line"><span class="comment"># pip install pygtrans BeautifulSoup -i https://pypi.org/simple</span></span><br><span class="line"><span class="comment"># ref:https://zhuanlan.zhihu.com/p/390801784</span></span><br><span class="line"><span class="comment"># ref:https://beautifulsoup.readthedocs.io/zh_CN/latest/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># client = Translate()</span></span><br><span class="line"><span class="comment"># text = client.translate('Google Translate')</span></span><br><span class="line"><span class="comment"># print(text.translatedText)  # 谷歌翻译</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"></span><br><span class="line">args = sys.argv</span><br><span class="line">URL=<span class="string">"http://www.mckinsey.com/insights/rss"</span></span><br><span class="line"></span><br><span class="line">BASE=<span class="string">"/home/xxx/www/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tran</span><span class="params">(url=URL,out_dir=BASE+<span class="string">"mckinsey_rss.xml"</span>)</span>:</span></span><br><span class="line">    GT = Translate()</span><br><span class="line">    content= request.urlopen(url).read().decode(<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="comment"># 变tag，以使用谷歌翻译</span></span><br><span class="line">    content=content.replace(<span class="string">'title&gt;'</span>, <span class="string">'stitle&gt;'</span>) <span class="comment">#谷歌翻译会将很多titile去掉，所以需要换一个tag</span></span><br><span class="line">    content=content.replace( <span class="string">'&lt;pubDate&gt;'</span>,<span class="string">'&lt;pubDate&gt;&lt;span translate="no"&gt;'</span>) </span><br><span class="line">    <span class="comment"># 谷歌翻译对&lt;span translate="no"&gt; &lt;/span&gt; 不翻译。</span></span><br><span class="line">    content=content.replace( <span class="string">'&lt;/pubDate&gt;'</span>,<span class="string">'&lt;/span&gt;&lt;/pubDate&gt;'</span>)</span><br><span class="line">    <span class="comment">#print(content)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    _text = GT.translate(content)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(out_dir,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        c=_text.translatedText</span><br><span class="line">        <span class="comment"># 还原tag</span></span><br><span class="line">        c=c.replace(<span class="string">'stitle&gt;'</span>, <span class="string">'title&gt;'</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;span translate="no"&gt;'</span>, <span class="string">''</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;/span&gt;&lt;/pubDate&gt;'</span>, <span class="string">'&lt;/pubDate&gt;'</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        f.write(c)</span><br><span class="line">        <span class="comment">#f.write(content)</span></span><br><span class="line">    print(<span class="string">"GT: "</span>+ url +<span class="string">" &gt; "</span>+ out_dir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(args)==<span class="number">1</span>:</span><br><span class="line">    tran()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    tran(args[<span class="number">1</span>],args[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tran_nature</span><span class="params">(url=<span class="string">"http://rss.acast.com/nature"</span>,out_dir=BASE+<span class="string">"nature_rss.xml"</span>)</span>:</span></span><br><span class="line">    GT = Translate()</span><br><span class="line">    </span><br><span class="line">    html_doc=request.urlopen(url).read().decode(<span class="string">'utf8'</span>)</span><br><span class="line">    soup = BeautifulSoup(html_doc)</span><br><span class="line"></span><br><span class="line">    items=soup.find_all(<span class="string">'item'</span>)</span><br><span class="line">    <span class="comment"># nature post内容太多，谷歌api翻译不了，去掉一些</span></span><br><span class="line">    <span class="keyword">for</span> idx,e <span class="keyword">in</span> enumerate(items):</span><br><span class="line">        <span class="keyword">if</span> idx &gt;<span class="number">8</span>:</span><br><span class="line">                e.decompose()</span><br><span class="line">    </span><br><span class="line">    content= str(soup)</span><br><span class="line">    content=content.replace(<span class="string">'title&gt;'</span>, <span class="string">'stitle&gt;'</span>)</span><br><span class="line">    content=content.replace( <span class="string">'&lt;pubdate&gt;'</span>,<span class="string">'&lt;pubDate&gt;&lt;span translate="no"&gt;'</span>)</span><br><span class="line">    content=content.replace( <span class="string">'&lt;/pubdate&gt;'</span>,<span class="string">'&lt;/span&gt;&lt;/pubdate&gt;'</span>)</span><br><span class="line">    <span class="comment">#print(content)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    _text = GT.translate(content)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(out_dir,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        c=_text.translatedText</span><br><span class="line">        c=c.replace(<span class="string">'stitle&gt;'</span>, <span class="string">'title&gt;'</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;span translate="no"&gt;'</span>, <span class="string">''</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;/span&gt;&lt;/pubdate&gt;'</span>, <span class="string">'&lt;/pubDate&gt;'</span>) <span class="comment"># 对于ttrss需要为pubDate才会识别正确</span></span><br><span class="line">        c=c.replace(<span class="string">'&amp;gt'</span>,<span class="string">'&gt;'</span>) <span class="comment"># &amp;gt 会影响识别</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        f.write(c)</span><br><span class="line">        <span class="comment">#f.write(content)</span></span><br><span class="line">    print(<span class="string">"GT: "</span>+ url +<span class="string">" &gt; "</span>+ out_dir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tran_nature()</span><br></pre></td></tr></table></figure><h3 id="定时任务"><a class="header-anchor" href="#定时任务">¶</a>定时任务</h3><blockquote><p>注意激活一下miniconda3 这个命令<code>source /home/xxx/miniconda3/bin/activate</code></p></blockquote><p>放到 <code>/etc/cron.daily/</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">source</span> /home/xxx/miniconda3/bin/activate</span><br><span class="line">python /home/xxx/txxx.py</span><br></pre></td></tr></table></figure><h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2><ul><li><a href="https://blog.csdn.net/wokuailewozihao/article/details/82021709" target="_blank" rel="noopener">利用Google翻译实现网站国际化——js插件</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;本文中我们将英文rss 自动转成中文 rss供ttrss使用。（利用谷歌翻译）&lt;/p&gt;
&lt;p&gt;方便在手机上进行阅读或者收听。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;/public/2022/05/08/rss_google_translate/20220508-22-28-27.png&quot; width=&quot;30%&quot;&gt;
&lt;/center&gt;
    
    </summary>
    
      <category term="工具" scheme="https://talengu.github.io/public/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="python" scheme="https://talengu.github.io/public/tags/python/"/>
    
      <category term="rss" scheme="https://talengu.github.io/public/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>rss统计 基于ttrss的PostgresQL数据库</title>
    <link href="https://talengu.github.io/public/2022/05/08/rss_ttrss_statics/"/>
    <id>https://talengu.github.io/public/2022/05/08/rss_ttrss_statics/</id>
    <published>2022-05-08T22:00:04.000Z</published>
    <updated>2022-05-08T22:00:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>统计ttrss的使用数据。</p><ul><li>月度mark文件分析 OK</li></ul><p>TODO：</p><ul><li>全年阅读报告 doing</li></ul><a id="more"></a><h2 id="按月保存mark的内容"><a class="header-anchor" href="#按月保存mark的内容">¶</a>按月保存mark的内容</h2><p>账号 密码 和你docker文件里面的一致。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按月来保存</span></span><br><span class="line"><span class="keyword">import</span> html2text</span><br><span class="line"><span class="comment"># psycopg2 head</span></span><br><span class="line"><span class="keyword">import</span> psycopg2</span><br><span class="line"><span class="comment"># pip3 install psycopg2-binary</span></span><br><span class="line"><span class="comment"># ref:https://blog.csdn.net/Haiqiang1995/article/details/89069791</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_from_dataset</span><span class="params">(cmd_sql)</span>:</span></span><br><span class="line">    conn = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># read database configuration</span></span><br><span class="line">        params = &#123;</span><br><span class="line">        <span class="string">'host'</span>: <span class="string">"?????"</span>,</span><br><span class="line">        <span class="string">'user'</span>: <span class="string">"????"</span>,</span><br><span class="line">        <span class="string">'password'</span>: <span class="string">"????"</span>,</span><br><span class="line">        <span class="string">'dbname'</span>: <span class="string">"ttrss"</span>,</span><br><span class="line">        'port': ??00</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># connect to the PostgresQL database</span></span><br><span class="line">        conn = psycopg2.connect(**params)</span><br><span class="line">        <span class="comment"># create a new cursor object</span></span><br><span class="line">        cur = conn.cursor()</span><br><span class="line">        <span class="comment"># execute the SELECT statement</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        print(cmd_sql)</span><br><span class="line">        cur.execute(cmd_sql)</span><br><span class="line"></span><br><span class="line">        blob = cur.fetchall()</span><br><span class="line">        <span class="comment"># blob = cur.fetchone()</span></span><br><span class="line">        <span class="comment">#open(path_to_dir + str(blob[0]) + '.jpg', 'wb').write(blob[1])</span></span><br><span class="line">        <span class="comment"># close the communication with the PostgresQL database</span></span><br><span class="line">        cur.close()</span><br><span class="line">    <span class="keyword">except</span> (Exception, psycopg2.DatabaseError) <span class="keyword">as</span> error:</span><br><span class="line">        print(error)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> conn <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            conn.close()</span><br><span class="line">    print(<span class="string">"get_from_dataset success"</span>)</span><br><span class="line">    <span class="keyword">return</span> blob</span><br><span class="line"></span><br><span class="line">_s=<span class="string">"ref_id,feed_id,last_read,last_marked"</span></span><br><span class="line">cmd_sql=<span class="string">"SELECT %s  FROM public.ttrss_user_entries Where marked=TRUE AND last_marked BETWEEN '2022-04-01' And '2022-5-01'"</span> % _s</span><br><span class="line"><span class="comment"># 可以自己改日期</span></span><br><span class="line"></span><br><span class="line">g_content=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> _e <span class="keyword">in</span> sorted(get_from_dataset(cmd_sql),key=<span class="keyword">lambda</span> x:x[<span class="number">3</span>]):</span><br><span class="line">    [ref_id,feed_id,last_read,last_marked] = _e</span><br><span class="line">    _s=<span class="string">"id,title,link,updated,content"</span></span><br><span class="line">    cmd_sql=<span class="string">"SELECT %s FROM public.ttrss_entries WHERE id = %s"</span> % (_s,ref_id)</span><br><span class="line">    [id,title,link,updated,content] =get_from_dataset(cmd_sql)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    g_content += <span class="string">"# [%s](%s)\n"</span>%(title,link)</span><br><span class="line">    g_content +=<span class="string">"pubdata:%s\n"</span>%str(updated)</span><br><span class="line">    g_content +=<span class="string">"markdate:%s\n"</span>%str(last_marked)</span><br><span class="line">    g_content+=html2text.html2text(content)</span><br><span class="line">    </span><br><span class="line">    g_content+=<span class="string">"\n\n"</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">D=<span class="string">"C:\\Users\\talen\\Desktop\\"</span></span><br><span class="line"><span class="keyword">with</span> open(D+<span class="string">"cc.md"</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(g_content)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;
统计ttrss的使用数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;月度mark文件分析 OK&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TODO：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全年阅读报告 doing&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="工具" scheme="https://talengu.github.io/public/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="python" scheme="https://talengu.github.io/public/tags/python/"/>
    
      <category term="rss" scheme="https://talengu.github.io/public/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>「转」GRE隧道测试</title>
    <link href="https://talengu.github.io/public/2022/05/05/linux/gre_test/"/>
    <id>https://talengu.github.io/public/2022/05/05/linux/gre_test/</id>
    <published>2022-05-05T22:52:28.000Z</published>
    <updated>2022-10-05T22:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6988645230987706398" target="_blank" rel="noopener">juejin.cn</a></p></blockquote><p><img src="/public/2022/05/05/linux/gre_test/e31bac5bcb1347a59142486adaf94e30.jpg" alt></p><h2 id="0-前言"><a class="header-anchor" href="#0-前言">¶</a>0. 前言</h2><p>在学习 ipsec 过程中，一般都会涉及到 ipsec 的局限性：ipsec 协议是一种点对点协议，不支持组播，也不能保护组播、广播报文。因此 ipsec 协议无法用于音视频会议等场合，此时通常的解决办法是采用 <strong>GRE Over IPSec</strong> .</p><p>给出的解释是：GRE 协议可以封装组播、广播报文，但是无法对业务内容进行加密；而 ipsec 可以对报文进行加密，但是无法封装组播和广播报文。因此将两种协议结合，因而 GRE over IPSec 协议应运而生。 但是我找了很多资料 (其实没有多少)，都没有找到为什么 GRE 协议支持封装组播和广播报文，而 ipsec 不行；他们作为点对点协议，为什么  GRE 可以而 IPsec  不行呢？因为没有找到答案，所以不能证实自己的想法正确与否，于是通过搭建 GRE 隧道环境，学习 Linux 内核中 GRE 隧道的操作配置原则，希望能从中得到些许启发。</p><p>搭建 GRE 隧道环境实际上是很简单的，因为 Linux 内核已经支持了 GRE 隧道，因此直接在虚拟机 (ubuntu 和 CentOS) 里进行简单的配置即可完成操作。</p><a id="more"></a><p><img src="/public/2022/05/05/linux/gre_test/db260d2dc98445f9988f1c768ca3e744.jpg" alt></p><h2 id="1-Linux-内核支持的隧道类型"><a class="header-anchor" href="#1-Linux-内核支持的隧道类型">¶</a>1. Linux 内核支持的隧道类型</h2><p>目前 Linux 内核已经支持多种隧道类型，包括：IPIP 隧道，GRE 隧道，... 。其余这几个我也没见过。当然除了这几种，还有 ipsec 协议，l2tp 协议，可以的是我目前都还没有用过，实在是暴殄天物，罪过罪过</p><p><img src="/public/2022/05/05/linux/gre_test/412f1154b6c64d74acd7b8cb31f713a5.jpg" alt></p><p><img src="/public/2022/05/05/linux/gre_test/e080bb892ca045a3b92f83ace7642a68.jpg" alt></p><p>下面通过搭建两组拓扑环境，来学习 GRE 隧道的基本规则，然后在此基础上分析下 GRE 和 IPSEC 在组播和广播报文封装的表现出不同行为的可能原因 (另写一遍文章喽)。</p><h2 id="2-GRE-隧道跨-公-网连接相同子网地址主机"><a class="header-anchor" href="#2-GRE-隧道跨-公-网连接相同子网地址主机">¶</a>2. GRE 隧道跨 (公) 网连接相同子网地址主机</h2><h3 id="2-1-拓扑环境"><a class="header-anchor" href="#2-1-拓扑环境">¶</a>2.1 拓扑环境</h3><p><img src="/public/2022/05/05/linux/gre_test/4759759198334a2ebc2c296e548026b0.jpg" alt></p><p>家里设备有限，只有一台电脑，还是通过无线网卡来上网的，因此拓扑环境比较寒酸，其实这些并不重要，只需明白我的两台虚拟机 Ubantu 和 CentOS 通过桥接的方式连在一起，网络上可以通讯即可。</p><p>现在，我准备将两个地址分别为 10.1.2.1/24、10.1.2.2/24 的两台主机 (假的，只是个 IP 地址而已) 通过 GRE 隧道连接起来进行通讯。原则上这两个地址属于不同的子网中(Ubantu 中的子网和 CentOS 中的子网，只是这两个子网的网段相同仅此而已)，无法直接通讯。</p><h3 id="2-1-ubuntu-配置"><a class="header-anchor" href="#2-1-ubuntu-配置">¶</a>2.1 ubuntu 配置</h3><p>首先，我确定了下该虚拟机中是否存在 gre 相关的接口，结果当然是没有了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:/home/toney<span class="comment"># ifconfig -a</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 2409:8a00:18e9:810:141:383c:ac6f:8b11  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 2409:8a00:18e9:810:f8dd:500e:b1a:463b  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 fe80::8e84:574c:7a8b:440a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:fb:db:ad  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 3581  bytes 1030105 (1.0 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1177  bytes 114532 (114.5 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 160  bytes 12920 (12.9 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 160  bytes 12920 (12.9 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2-1-1-添加-GRE-隧道"><a class="header-anchor" href="#2-1-1-添加-GRE-隧道">¶</a>2.1.1 添加 GRE 隧道</h4><blockquote><p>ip tunnel add Tunnel-1 mode gre remote 192.168.1.13 local 192.168.1.10</p></blockquote><p>添加 GRE 隧道时, 需要指定隧道的名称，我这里叫做 Tunnel-1; 因为要搭建 GRE 类型隧道，因此 mode 为 gre。 而 GRE 隧道的地址为 192.168.1.13&lt;========&gt;192.168.1.10。</p><p>由于是第一次执行此命令，底层实际上安装上了 gre 隧道相关的驱动。用户只有在此基础上才能配置 GRE 隧道，不过，无需担心，内核自动完成。</p><p>如果在添加隧道时不指定 remote 和 local 地址，也是可以的，它实际上是只是安装 gre 隧道相关驱动。下面是添加隧道时没有指定 remote 和 local 地址时的结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">root@ubantu:/home/toney<span class="comment"># ip tunnel add Tunnel-1</span></span><br><span class="line">cannot determine tunnel mode (ipip, gre, vti or sit)</span><br><span class="line">root@ubantu:/home/toney<span class="comment"># ifconfig -a</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 2409:8a00:18e9:810:141:383c:ac6f:8b11  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 2409:8a00:18e9:810:200d:99e2:4f3d:cb6f  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 fe80::8e84:574c:7a8b:440a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:fb:db:ad  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 5038  bytes 5896155 (5.8 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2744  bytes 309264 (309.2 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 164  bytes 15044 (15.0 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 164  bytes 15044 (15.0 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">root@ubantu:/home/toney<span class="comment"># ip tunnel add Tunnel-1 mode gre</span></span><br><span class="line">add tunnel <span class="string">"gre0"</span> failed: File exists</span><br><span class="line">root@ubantu:/home/toney<span class="comment"># ifconfig -a</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 2409:8a00:18e9:810:141:383c:ac6f:8b11  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 2409:8a00:18e9:810:200d:99e2:4f3d:cb6f  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 fe80::8e84:574c:7a8b:440a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:fb:db:ad  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 5097  bytes 5900501 (5.9 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2766  bytes 311496 (311.4 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">erspan0: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1450</span><br><span class="line">        ether 00:00:00:00:00:00  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">gre0: flags=128&lt;NOARP&gt;  mtu 1452</span><br><span class="line">        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 1000  (UNSPEC)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">gretap0: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1462</span><br><span class="line">        ether 00:00:00:00:00:00  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 164  bytes 15044 (15.0 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 164  bytes 15044 (15.0 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">root@ubantu:/home/toney<span class="comment">#</span></span><br><span class="line">root@ubantu:/home/toney<span class="comment"># lsmod | grep gre</span></span><br><span class="line">ip_gre                 28672  0</span><br><span class="line">ip_tunnel              24576  1 ip_gre</span><br><span class="line">gre                    16384  1 ip_gre</span><br><span class="line">root@ubantu:/home/toney<span class="comment">#</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果输入完整的命令，则会成功添加上 Tunnel-1 隧道：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">root@ubantu:/home/toney<span class="comment"># ifconfig -a</span></span><br><span class="line">Tunnel-1: flags=144&lt;POINTOPOINT,NOARP&gt;  mtu 1476</span><br><span class="line">        unspec C0-A8-01-0A-00-00-00-87-00-00-00-00-00-00-00-00  txqueuelen 1000  (UNSPEC)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 2409:8a00:18e9:810:141:383c:ac6f:8b11  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 2409:8a00:18e9:810:200d:99e2:4f3d:cb6f  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 fe80::8e84:574c:7a8b:440a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:fb:db:ad  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 5745  bytes 5947674 (5.9 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2965  bytes 329731 (329.7 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">erspan0: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1450</span><br><span class="line">        ether 00:00:00:00:00:00  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">gre0: flags=128&lt;NOARP&gt;  mtu 1452</span><br><span class="line">        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 1000  (UNSPEC)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">gretap0: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1462</span><br><span class="line">        ether 00:00:00:00:00:00  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 169  bytes 15509 (15.5 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 169  bytes 15509 (15.5 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="2-1-2-配置-GRE-隧道接口-IP"><a class="header-anchor" href="#2-1-2-配置-GRE-隧道接口-IP">¶</a>2.1.2 配置 GRE 隧道接口 IP</h4><blockquote><p>ip addr add 10.1.2.1/24 dev Tunnel-1</p></blockquote><p>或者</p><blockquote><p>ifconfig Tunnel-1 10.1.2.1/24</p></blockquote><p>从添加隧道结果来看，Tunnel-1 接口虽然已经成功添加，但是处于 down 状态，此外也没有 IP 地址。 不，等等，那我们在添加隧道时指定的 remote 和 local 是什么呢？</p><p><strong>它是经过 <strong><strong>GRE</strong></strong> 隧道封装后的报文 <strong><strong>IP</strong></strong> 地址，但是针对什么报文进行封装，目前我们尚未配置</strong>。</p><p>配置此接口 IP 的目的是：为了确定哪些报文需要进入 GRE 接口，然后进行隧道封装。为什么需要添加 IP 呢？ 因为我们是通过路由将报文引入到 Tunnel-1 接口的, 如果不填 IP，那么我路由的下一条该写成什么呢， 是吧。</p><p><img src="/public/2022/05/05/linux/gre_test/772109c097cd48cab17c50d4dad64b10.jpg" alt></p><h4 id="2-1-3-激活-GRE-隧道接口-IP"><a class="header-anchor" href="#2-1-3-激活-GRE-隧道接口-IP">¶</a>2.1.3 激活 GRE 隧道接口 IP</h4><blockquote><p>ifconfig Tunnel-1 up</p></blockquote><p>或者</p><blockquote><p>ip link set Tunnel-1 up</p></blockquote><p>至于配置接口 IP 和是否 up 接口，没有什么先后顺序，把他们当做不同的 eth 接口处理即可。</p><p><img src="/public/2022/05/05/linux/gre_test/2410e66154a84a70b95d16a5df32e360.jpg" alt></p><h3 id="2-2-CentOS-配置"><a class="header-anchor" href="#2-2-CentOS-配置">¶</a>2.2 CentOS 配置</h3><p>CentOS 虚拟机的配置和 Ubantu 的配置完全相同，安照此步骤操作即可。</p><blockquote><p>ip tunnel add Tunnel-1 mode gre local 192.168.1.13 remote 192.168.1.10<br>ip link set Tunnel-1 up<br>ip addr add 10.1.2.2/24 dev Tunnel-1</p></blockquote><p>查看配置结果 r 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@toney toney]#</span><br><span class="line">[root@toney toney]#</span><br><span class="line">[root@toney toney]# ifconfig</span><br><span class="line">Tunnel-1  Link encap:UNSPEC  HWaddr C0-A8-01-0D-FF-FF-90-6D-00-00-00-00-00-00-00-00</span><br><span class="line">          inet addr:10.1.2.2  P-t-P:10.1.2.2  Mask:255.255.255.0</span><br><span class="line">          UP POINTOPOINT RUNNING NOARP  MTU:1476  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)</span><br><span class="line"></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:0C:29:DA:34:3C</span><br><span class="line">          inet addr:192.168.1.13  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: 2409:8a00:18e9:810:20c:29ff:feda:343c/64 Scope:Global</span><br><span class="line">          inet6 addr: fe80::20c:29ff:feda:343c/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:3571 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:781 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:236685 (231.1 KiB)  TX bytes:71021 (69.3 KiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:4 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:4 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:240 (240.0 b)  TX bytes:240 (240.0 b)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>路由表信息如下：</p><p><img src="/public/2022/05/05/linux/gre_test/f70bfbe84af74c21bab5b21a5bea3821.jpg" alt></p><h3 id="2-3-ping-包测试通讯链路"><a class="header-anchor" href="#2-3-ping-包测试通讯链路">¶</a>2.3 ping 包测试通讯链路</h3><p>这里有一点需要注意：Linux 系统可能开了 iptables 过滤功能，因此在 ping 时出现了类似 &quot;ICMP host 192.168.1.13 unreachable - admin prohibited, length 116&quot; 信息，详情如下：</p><p><img src="/public/2022/05/05/linux/gre_test/26f4422a5f9d4772ac9a354db2dd9847.jpg" alt></p><p>百度一下, 在两台虚拟机上都执行如下操作即可：</p><blockquote><p>iptables -F</p></blockquote><p>然后在 ping 包测试，数据可通：</p><p><img src="/public/2022/05/05/linux/gre_test/2df9a98e03d54319ad3b00704fc31a32.jpg" alt></p><p><img src="/public/2022/05/05/linux/gre_test/b01f9527ea6842b68acbf612ec34c084.jpg" alt></p><p>至此，基本 GRE 隧道环境搭建成功。</p><h2 id="3-GRE-隧道跨-公-网连接不同子网地址主机"><a class="header-anchor" href="#3-GRE-隧道跨-公-网连接不同子网地址主机">¶</a>3. GRE 隧道跨 (公) 网连接不同子网地址主机</h2><h3 id="3-1-拓扑环境"><a class="header-anchor" href="#3-1-拓扑环境">¶</a>3.1 拓扑环境</h3><p><img src="/public/2022/05/05/linux/gre_test/8752f3648dbc4dc4bd9036f00348ec9c.jpg" alt></p><p><strong>目的：</strong> 通过 GRE 隧道将 20.1.2.1/24、20.1.3.2/24 两个子网连接起来进行通讯。</p><h3 id="3-2-Ubantu-配置"><a class="header-anchor" href="#3-2-Ubantu-配置">¶</a>3.2 Ubantu 配置</h3><h4 id="3-2-1-配置-ens33-子接口-IP"><a class="header-anchor" href="#3-2-1-配置-ens33-子接口-IP">¶</a>3.2.1 配置 ens33 子接口 IP</h4><blockquote><p>ifconfig eth0:1 192.168.100.1/24</p></blockquote><p>查看接口配置如下：</p><p><img src="/public/2022/05/05/linux/gre_test/773d0b1700254e8ba9f847fdc2e79fd4.jpg" alt></p><h4 id="3-2-2-添加另一个-GRE-隧道接口并-up"><a class="header-anchor" href="#3-2-2-添加另一个-GRE-隧道接口并-up">¶</a>3.2.2 添加另一个 GRE 隧道接口并 up</h4><blockquote><p>ip tunnel add Tunnel-2 mode gre local 192.168.100.1 remote 192.168.100.2</p><p>ifconfig Tunnel-2 up</p></blockquote><h4 id="3-2-3-配置隧道接口-IP"><a class="header-anchor" href="#3-2-3-配置隧道接口-IP">¶</a>3.2.3 配置隧道接口 IP</h4><blockquote><p>ifconfig Tunnel-2 20.1.2.1/24</p></blockquote><p><img src="/public/2022/05/05/linux/gre_test/fbefdbdcba514312960176a103139de9.jpg" alt></p><h4 id="3-2-4-添加对端子网路由表"><a class="header-anchor" href="#3-2-4-添加对端子网路由表">¶</a>3.2.4 添加对端子网路由表</h4><p>由于本端没有对端子网 20.1.3.0/24 的路由，因此需要添加路由，将该网段报文引入到 Tunnel-2 接口，这样便可以通过 GRE 隧道进行封装。</p><blockquote><p>route add -net 20.1.3.0/24 gw 20.1.2.1</p></blockquote><p><img src="/public/2022/05/05/linux/gre_test/199432ae8e9e40e8b993ec0a0bca9016.jpg" alt></p><h3 id="3-3-CentOS-配置"><a class="header-anchor" href="#3-3-CentOS-配置">¶</a>3.3 CentOS 配置</h3><h4 id="3-3-1-配置-ens33-子接口-IP"><a class="header-anchor" href="#3-3-1-配置-ens33-子接口-IP">¶</a>3.3.1 配置 ens33 子接口 IP</h4><blockquote><p>ifconfig ens33:1 192.168.100.2/24</p></blockquote><p><img src="/public/2022/05/05/linux/gre_test/e9e2f1e4871f4c42ade68774b4bb4e75.jpg" alt></p><h4 id="3-3-2-添加另一个-GRE-隧道接口并-up"><a class="header-anchor" href="#3-3-2-添加另一个-GRE-隧道接口并-up">¶</a>3.3.2 添加另一个 GRE 隧道接口并 up</h4><blockquote><p>ip tunnel add Tunnel-2 mode gre remote 192.168.100.1 local 192.168.100.2</p><p>ifconfig Tunnel-2 up</p></blockquote><p>结果如下：</p><p><img src="/public/2022/05/05/linux/gre_test/8618b40c1afb497dbc85234fd0c58ad8.jpg" alt></p><h4 id="3-3-3-配置隧道接口-IP"><a class="header-anchor" href="#3-3-3-配置隧道接口-IP">¶</a>3.3.3 配置隧道接口 IP</h4><blockquote><p>ifconfig Tunnel-2 20.1.3.1/24</p></blockquote><h4 id="3-3-4-添加对端子网路由表"><a class="header-anchor" href="#3-3-4-添加对端子网路由表">¶</a>3.3.4 添加对端子网路由表</h4><p>由于本端没有对端子网 20.1.2.0/24 的路由，因此需要添加路由，将该网段报文引入到 Tunnel-2 接口，这样便可以通过 GRE 隧道进行封装。</p><blockquote><p>route add -net 20.1.2.0/24 gw 20.1.3.1</p></blockquote><p><img src="/public/2022/05/05/linux/gre_test/da52fb97c1044858bd28e645df512622.jpg" alt></p><h3 id="3-4-ping-测试链路连通性"><a class="header-anchor" href="#3-4-ping-测试链路连通性">¶</a>3.4 ping 测试链路连通性</h3><p><img src="/public/2022/05/05/linux/gre_test/1a28e720a97746f3a801a824a9ff95fd.jpg" alt></p><p><img src="/public/2022/05/05/linux/gre_test/5d3739151b0843c98c1c7352e91008c3.jpg" alt></p><p>​</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文由 &lt;a href=&quot;http://ksria.com/simpread/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;简悦 SimpRead&lt;/a&gt; 转码， 原文地址 &lt;a href=&quot;https://juejin.cn/post/6988645230987706398&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;juejin.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/public/2022/05/05/linux/gre_test/e31bac5bcb1347a59142486adaf94e30.jpg&quot; alt&gt;&lt;/p&gt;
&lt;h2 id=&quot;0-前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#0-前言&quot;&gt;¶&lt;/a&gt;0. 前言&lt;/h2&gt;
&lt;p&gt;在学习 ipsec 过程中，一般都会涉及到 ipsec 的局限性：ipsec 协议是一种点对点协议，不支持组播，也不能保护组播、广播报文。因此 ipsec 协议无法用于音视频会议等场合，此时通常的解决办法是采用 &lt;strong&gt;GRE Over IPSec&lt;/strong&gt; .&lt;/p&gt;
&lt;p&gt;给出的解释是：GRE 协议可以封装组播、广播报文，但是无法对业务内容进行加密；而 ipsec 可以对报文进行加密，但是无法封装组播和广播报文。因此将两种协议结合，因而 GRE over IPSec 协议应运而生。 但是我找了很多资料 (其实没有多少)，都没有找到为什么 GRE 协议支持封装组播和广播报文，而 ipsec 不行；他们作为点对点协议，为什么  GRE 可以而 IPsec  不行呢？因为没有找到答案，所以不能证实自己的想法正确与否，于是通过搭建 GRE 隧道环境，学习 Linux 内核中 GRE 隧道的操作配置原则，希望能从中得到些许启发。&lt;/p&gt;
&lt;p&gt;搭建 GRE 隧道环境实际上是很简单的，因为 Linux 内核已经支持了 GRE 隧道，因此直接在虚拟机 (ubuntu 和 CentOS) 里进行简单的配置即可完成操作。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://talengu.github.io/public/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="隧道技术" scheme="https://talengu.github.io/public/tags/%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>本地安装rss</title>
    <link href="https://talengu.github.io/public/2022/04/16/rss_local_install/"/>
    <id>https://talengu.github.io/public/2022/04/16/rss_local_install/</id>
    <published>2022-04-16T12:39:04.000Z</published>
    <updated>2022-04-27T12:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>在 “<a href="https://zhuanlan.zhihu.com/p/149452085" target="_blank" rel="noopener">二零年RSS杂谈</a>”中说到，我想建立一种信息的获取系统，免受广告和推荐算法的困扰。</p><p>我希望其的功能包括：</p><ul><li>多终端 Web、PC、 mobile的同步</li><li>全文获取能力</li><li>可自定义过滤规则</li><li>RSS源自定义</li></ul><p>方案：</p><ul><li>RSS源 rsshub</li><li>RSS服务  ttrss</li><li>RSS电脑手机软件：Android的Readably、Feedme，mac的reeder等等。windows上我暂时没有发现，我用的是ttrss的web界面。</li></ul><a id="more"></a><p>rsshub 是由 DIYgod 开发的开源RSS源生成工具，RSShub原始的网站可能不稳定，所以我选择了自己搭建。</p><p>ttrss 是一个rss源管理配置的工具，可获取全文，可自定义过滤规则。</p><p>本教程我们将完成在window电脑通过docker安装，ttrss与全文插件、rsshub的过程。</p><p>服务器的成本还是有点小贵的，我们可以在本地搭建整个服务，即利用docker安装这些服务，开机的时候记得启动这些服务。不爽点：</p><ul><li>需要后台开启docker服务，使得其自动更新信息</li><li>没有公网ip的情况下，无法全网连接服务</li></ul><h2 id="最终ttrss界面"><a class="header-anchor" href="#最终ttrss界面">¶</a>最终ttrss界面</h2><p>在这里我已经添加一些rss源了。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626135803804.png" alt="image-20200626135803804"></p><h2 id="docker-windows安装"><a class="header-anchor" href="#docker-windows安装">¶</a>docker windows安装</h2><p>从<a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">docker 官网</a> 下载windows版本安装。完成后，在图标区会有一个鲸鱼船。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626141604658.png" alt="image-20200626141604658"></p><p>我们使用docker-compose 来进行下一步 网站服务的安装。将下面的资料保存到s<code>docker-compose.yml</code> 然后利用docker-compose方法安装。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">service.rsshub:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">diygod/rsshub</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rsshub</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"1200:1200"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rsshub_data:/app/lib</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">service.rss:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangqiru/ttrss:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ttrss</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8118</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SELF_URL_PATH=http://127.0.0.1:8118/</span> <span class="comment"># please change to your own domain</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_HOST=database.postgres</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PORT=5432</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_NAME=ttrss</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_USER=postgres</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PASS=ttrss</span> <span class="comment"># please change the password</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ENABLE_PLUGINS=auth_internal,fever</span> <span class="comment"># auth_internal is required. Plugins enabled here will be enabled for all users as system plugins</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FEED_LOG_QUIET=true</span></span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">'sh /wait-for.sh $$DB_HOST:$$DB_PORT -- php /configure-db.php &amp;&amp; exec s6-svscan /etc/s6/'</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">database.postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_PASSWORD=ttrss</span> <span class="comment"># please change the password</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgres_data:/var/lib/postgresql/data</span> <span class="comment"># persist postgres data to ~/postgres/data/ on the host</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">service.mercury:</span> <span class="comment"># set Mercury Parser API endpoint to `service.mercury:3000` on TTRSS plugin setting page</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangqiru/mercury-parser-api:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mercury</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">postgres_data:</span></span><br><span class="line">  <span class="attr">rsshub_data:</span></span><br></pre></td></tr></table></figure><p><img src="/public/2022/04/16/rss_local_install/image-20200626140114783.png" alt="image-20200626140114783"></p><p>在地址栏输入<code>cmd</code>，我们就可以打开cmd界面了，然后运行<code>docker-compose up -d</code> ，就可以自动安装全部内容了。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626134626593.png" alt="image-20200626134626593"></p><p>在地址栏输入<code>cmd</code> 然后回车，我们就能进入cmd界面，然后使用docker-compose，进行安装，网速好的话，安装很快。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626140147402.png" alt="image-20200626140147402"></p><p>安装完毕我们就可以使用了，下面是其资源占用情况。</p><table><thead><tr><th></th><th>内容</th><th>占用内存空间（M）</th></tr></thead><tbody><tr><td>mercury</td><td>全文获取ttrss插件</td><td>66.8</td></tr><tr><td>postgres</td><td>ttrss数据库</td><td>6.8</td></tr><tr><td>ttrss</td><td>ttrss工具</td><td>30.2</td></tr><tr><td>rsshub</td><td>rsshub各种b站源等等</td><td>142.4</td></tr><tr><td></td><td></td><td>246.2</td></tr></tbody></table><p><img src="/public/2022/04/16/rss_local_install/image-20200626140407183.png" alt="image-20200626140407183"></p><p>打开 <a href="http://127.0.0.1:8118/" target="_blank" rel="noopener">http://127.0.0.1:8118/</a></p><p>默认账户：admin 密码：password，请第一时间更改。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626143320968.png" alt="image-20200626143320968"></p><h2 id="在chrome安装-rsshub-radar"><a class="header-anchor" href="#在chrome安装-rsshub-radar">¶</a>在chrome安装 rsshub radar</h2><p><img src="/public/2022/04/16/rss_local_install/image-20200626144233385.png" alt="image-20200626144233385"></p><p>并设置到本机的rsshub地址，ttrss地址，如上。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626144330350.png" alt="image-20200626144330350"></p><p>打开bilibili up主的主页就能订阅了，订阅到ttrss。</p><p>这里有问题。需要解决。</p><p><img src="/public/2022/04/16/rss_local_install/image-20200626145153354.png" alt="image-20200626145153354"></p><p>本次安装教程到此结束，下期我们介绍全文获取功能，手机app的联动，即ttrss的设置问题</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#前言&quot;&gt;¶&lt;/a&gt;前言&lt;/h2&gt;
&lt;p&gt;在 “&lt;a href=&quot;https://zhuanlan.zhihu.com/p/149452085&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;二零年RSS杂谈&lt;/a&gt;”中说到，我想建立一种信息的获取系统，免受广告和推荐算法的困扰。&lt;/p&gt;
&lt;p&gt;我希望其的功能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多终端 Web、PC、 mobile的同步&lt;/li&gt;
&lt;li&gt;全文获取能力&lt;/li&gt;
&lt;li&gt;可自定义过滤规则&lt;/li&gt;
&lt;li&gt;RSS源自定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RSS源 rsshub&lt;/li&gt;
&lt;li&gt;RSS服务  ttrss&lt;/li&gt;
&lt;li&gt;RSS电脑手机软件：Android的Readably、Feedme，mac的reeder等等。windows上我暂时没有发现，我用的是ttrss的web界面。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="信息收集" scheme="https://talengu.github.io/public/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="工具" scheme="https://talengu.github.io/public/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="rss" scheme="https://talengu.github.io/public/tags/rss/"/>
    
  </entry>
  
  <entry>
    <title>「转」window软件运行时间</title>
    <link href="https://talengu.github.io/public/2022/04/15/soft_run_time/"/>
    <id>https://talengu.github.io/public/2022/04/15/soft_run_time/</id>
    <published>2022-04-15T12:39:04.000Z</published>
    <updated>2022-04-27T12:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2><p>对关注性能的程序开发人员而言，一个好的计时部件既是益友，也是良师。计时器既可以作为程序组件帮助程序员精确的控制程序进程，又是一件有力的调试武器，在有经验的程序员手里可以尽快的确定程序的性能瓶颈，或者对不同的算法作出有说服力的性能比较。</p><a id="more"></a><p>在Windows平台下，常用的计时器有两种，一种是<code>timeGetTime</code>多媒体计时器，它可以提供毫秒级的计时。但这个精度对很多应用场合而言还是太粗糙了。另一种是<code>QueryPerformanceCount</code>计数器，随系统的不同可以提供微秒级的计数。对于实时图形处理、多媒体数据流处理、或者实时系统构造的程序员，善用<code>QueryPerformanceCount/QueryPerformanceFrequency</code>是一项基本功。</p><p>本文要介绍的，是另一种直接利用<code>Pentium CPU</code>内部时间戳进行计时的高精度计时手段。以下讨论主要得益于<code>《Windows图形编程》</code>一书，第15页－17页，有兴趣的读者可以直接参考该书。关于RDTSC指令的详细讨论，可以参考Intel产品手册。本文仅仅作抛砖之用。</p><p>在 <code>Intel Pentium</code>以上级别的CPU中，有一个称为“时间戳（Time   Stamp）”的部件，它以64位无符号整型数的格式，记录了自CPU上电以来所经过的时钟周期数。由于目前的CPU主频都非常高，因此这个部件可以达到纳秒级的计时精度。这个精确性是上述两种方法所无法比拟的。</p><p>在Pentium以上的CPU中，提供了一条机器指令RDTSC（Read Time   Stamp Counter）来读取这个时间戳的数字，并将其保存在EDX:EAX寄存器对中。由于<code>EDX:EAX</code>寄存器对恰好是Win32平台下C++语言保存函数返回值的寄存器，所以我们可以把这条指令看成是一个普通的函数调用。像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline   unsigned   __int64   GetCycleCount()   </span><br><span class="line">&#123;   </span><br><span class="line">  __asm   RDTSC   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是不行，因为RDTSC不被C++的内嵌汇编器直接支持，所以我们要用_emit伪指令直接嵌入该指令的机器码形式<code>0X0F</code>、<code>0X31</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  inline   unsigned   __int64   GetCycleCount()   </span><br><span class="line">  &#123;   </span><br><span class="line">    __asm   _emit   0x0F   </span><br><span class="line">    __asm   _emit   0x31   </span><br><span class="line">  &#125;   </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">以后在需要计数器的场合，可以像使用普通的Win32   API一样，调用两次GetCycleCount函数，比较两个返回值的差，像这样：</span><br></pre></td></tr></table></figure><p>unsigned   long   t;<br>t   =   (unsigned   long)GetCycleCount();<br>//Do   Something   time-intensive   ...<br>t   -=   (unsigned   long)GetCycleCount();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`《Windows图形编程》`第15页编写了一个类，把这个计数器封装起来。有兴趣的读者可以去参考那个类的代码。作者为了更精确的定时，做了一点小小的改进，把执行`RDTSC`指令的时间，通过连续两次调用`GetCycleCount`函数计算出来并保存了起来，以后每次计时结束后，都从实际得到的计数中减掉这一小段时间，以得到更准确的计时数字。但我个人觉得这一点点改进意义不大。在我的机器上实测，这条指令大概花掉了几十到100多个周期，在`Celeron 800MHz`的机器上，这不过是十分之一微秒的时间。对大多数应用来说，这点时间完全可以忽略不计；而对那些确实要精确到纳秒数量级的应用来说，这个补偿也过于粗糙了。   </span><br><span class="line">    </span><br><span class="line">  这个方法的优点是：   </span><br><span class="line">    </span><br><span class="line">  1. 高精度。可以直接达到纳秒级的计时精度（在1GHz的CPU上每个时钟周期就是一纳秒），这是其他计时方法所难以企及的。   </span><br><span class="line">    </span><br><span class="line">  2. 成本低。`timeGetTime`函数需要链接多媒体库 `winmm.lib`，`QueryPerformance*`函数根据MSDN的说明，需要硬件的支持（虽然我还没有见过不支持的机器）和KERNEL库的支持，所以二者都只能在Windows平台下使用（关于DOS平台下的高精度计时问题，可以参考`《图形程序开发人员指南》`，里面有关于控制定时器8253的详细说明）。但`RDTSC`指令是一条CPU指令，凡是i386平台下Pentium以上的机器均支持，甚至没有平台的限制（我相信i386版本UNIX和Linux下这个方法同样适用，但没有条件试验），而且函数调用的开销是最小的。   </span><br><span class="line">    </span><br><span class="line">  3. 具有和CPU主频直接对应的速率关系。一个计数相当于1/(CPU主频Hz数)秒，这样只要知道了CPU的主频，可以直接计算出时间。这和   `QueryPerformanceCount`不同，后者需要通过`QueryPerformanceFrequency`获取当前计数器每秒的计数次数才能换算成时间。   </span><br><span class="line">    </span><br><span class="line">  这个方法的缺点是：   </span><br><span class="line">    </span><br><span class="line">  1. 现有的C/C++编译器多数不直接支持使用RDTSC指令，需要用直接嵌入机器码的方式编程，比较麻烦。   </span><br><span class="line">    </span><br><span class="line">  2. 数据抖动比较厉害。其实对任何计量手段而言，精度和稳定性永远是一对矛盾。如果用低精度的`timeGetTime`来计时，基本上每次计时的结果都是相同的；而`RDTSC`指令每次结果都不一样，经常有几百甚至上千的差距。这是这种方法高精度本身固有的矛盾。   </span><br><span class="line">    </span><br><span class="line">  关于这个方法计时的最大长度，我们可以简单的用下列公式计算：</span><br></pre></td></tr></table></figure><p>自CPU上电以来的秒数   =   RDTSC读出的周期数   /   CPU主频速率（Hz）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">64位无符号整数所能表达的最大数字是`1.8×10^19`，在我的`Celeron   800`上可以计时大约700年（书中说可以在200MHz的Pentium上计时117年，这个数字不知道是怎么得出来的，与我的计算有出入）。无论如何，我们大可不必关心溢出的问题。   </span><br><span class="line">    </span><br><span class="line">下面是几个小例子，简要比较了三种计时方法的用法与精度   </span><br><span class="line"> ```c</span><br><span class="line">//Timer1.cpp   使用了RDTSC指令的Timer类//KTimer类的定义可以参见《Windows图形编程》P15   </span><br><span class="line">//编译行：CL Timer1.cpp   /link   USER32.lib   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">#include   &quot;KTimer.h&quot;   </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  unsigned   t;   </span><br><span class="line">  KTimer   timer;   </span><br><span class="line">  timer.Start();   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  t   =   timer.Stop();   </span><br><span class="line">  printf(&quot;Lasting   Time:   %d\n&quot;,t);   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">//Timer2.cpp   使用了timeGetTime函数   </span><br><span class="line">//需包含&lt;mmsys.h&gt;，但由于Windows头文件错综复杂的关系   </span><br><span class="line">//简单包含&lt;windows.h&gt;比较偷懒：）   </span><br><span class="line">//编译行：CL   timer2.cpp   /link   winmm.lib     </span><br><span class="line">#include   &lt;windows.h&gt;   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">  </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  DWORD   t1,   t2;   </span><br><span class="line">  t1   =   timeGetTime();   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  t2   =   timeGetTime();   </span><br><span class="line">  printf(&quot;Begin   Time:   %u\n&quot;,   t1);   </span><br><span class="line">  printf(&quot;End   Time:   %u\n&quot;,   t2);   </span><br><span class="line">  printf(&quot;Lasting   Time:   %u\n&quot;,(t2-t1));   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">//Timer3.cpp   使用了QueryPerformanceCounter函数   </span><br><span class="line">//编译行：CL   timer3.cpp   /link   KERNEl32.lib   </span><br><span class="line">#include   &lt;windows.h&gt;   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">  </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  LARGE_INTEGER   t1,   t2,   tc;   </span><br><span class="line">  QueryPerformanceFrequency(&amp;tc);   </span><br><span class="line">  printf(&quot;Frequency:   %u\n&quot;,   tc.QuadPart);   </span><br><span class="line">  QueryPerformanceCounter(&amp;t1);   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  QueryPerformanceCounter(&amp;t2);   </span><br><span class="line">  printf(&quot;Begin   Time:   %u\n&quot;,   t1.QuadPart);   </span><br><span class="line">  printf(&quot;End   Time:   %u\n&quot;,   t2.QuadPart);   </span><br><span class="line">  printf(&quot;Lasting   Time:   %u\n&quot;,(   t2.QuadPart-   t1.QuadPart));   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">////////////////////////////////////////////////   </span><br><span class="line">//以上三个示例程序都是测试1秒钟休眠所耗费的时间   </span><br><span class="line">//测试环境：Celeron   800MHz   /   256M   SDRAM       </span><br><span class="line">//         Windows   2000   Professional   SP2   </span><br><span class="line">//         Microsoft   Visual   C++   6.0   SP5   </span><br><span class="line">////////////////////////////////////////////////</span><br></pre></td></tr></table></figure><p>以下是Timer1的运行结果，使用的是高精度的<code>RDTSC</code>指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lasting   Time:   804586872</span><br></pre></td></tr></table></figure><p>以下是Timer2的运行结果，使用的是最粗糙的<code>timeGetTime API</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Begin   Time:   20254254   </span><br><span class="line">End   Time:   20255255   </span><br><span class="line">Lasting   Time:   1001</span><br></pre></td></tr></table></figure><p>以下是Timer3的运行结果，使用的是<code>QueryPerformanceCount API</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Frequency:   3579545   </span><br><span class="line">Begin   Time:   3804729124   </span><br><span class="line">End   Time:   3808298836   </span><br><span class="line">Lasting   Time:   3569712</span><br></pre></td></tr></table></figure><p>古人说，触类旁通。从一本介绍图形编程的书上得到一个如此有用的实时处理知识，我感到非常高兴。有美不敢自专，希望大家和我一样喜欢这个轻便有效的计时器。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#背景&quot;&gt;¶&lt;/a&gt;背景&lt;/h2&gt;
&lt;p&gt;对关注性能的程序开发人员而言，一个好的计时部件既是益友，也是良师。计时器既可以作为程序组件帮助程序员精确的控制程序进程，又是一件有力的调试武器，在有经验的程序员手里可以尽快的确定程序的性能瓶颈，或者对不同的算法作出有说服力的性能比较。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://talengu.github.io/public/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="软件运行" scheme="https://talengu.github.io/public/tags/%E8%BD%AF%E4%BB%B6%E8%BF%90%E8%A1%8C/"/>
    
  </entry>
  
</feed>
