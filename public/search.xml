<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>征服14座高峰：凡事皆有可能</title>
    <url>/public/2022/01/09/14peak/</url>
    <content><![CDATA[<p><strong>简介</strong></p>
<p>14 Peaks: Nothing Is Impossible (2021)</p>
<p>无畏的尼泊尔登山运动员尼姆斯·普贾开始了一项看似不可能完成的任务：在7个月内登顶全球14座8000米高峰。（2019年度完成的Possible plan）</p>
<p>最近，我看完了该记录片，摘录了些语句，鼓励自己不断进取，征服人生的一座座高峰，追寻梦想，不忘初心！</p>
<p><img src="/public/2022/01/09/14peak/2022-01-09-16-49-12.png" alt></p>
<a id="more"></a>
<h2 id="追寻梦想！"><a class="header-anchor" href="#追寻梦想！">¶</a>追寻梦想！</h2>
<p><img src="/public/2022/01/09/14peak/2022-01-09-17-20-35.JPG" alt></p>
<h2 id="不忘初心！"><a class="header-anchor" href="#不忘初心！">¶</a>不忘初心！</h2>
<p><img src="/public/2022/01/09/14peak/20220109_hello.JPG" alt></p>
<h2 id="最后"><a class="header-anchor" href="#最后">¶</a>最后</h2>
<p>山不向我走来，我便向他走去！</p>
]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>记录片</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 年科隆游戏展奖项提名名单</title>
    <url>/public/2021/09/01/2021games/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>帝国时代3，现在帝国4！<br>
2021 年科隆游戏展奖项提名名单正式公布</p>
<a id="more"></a>
<p>8 月 23 日，2021 年科隆游戏展的奖项提名名单已经全部揭晓，本次直接涉及游戏的奖项有 21 个，其中获得提名的游戏分别为：</p>
<p>最佳微软 Xbox 游戏：《艾尔登法环》（万代南梦宫娱乐）；《孤岛惊魂 6》（育碧）；《光环无限》（微软）</p>
<p>最佳任天堂 Switch 游戏：《舞力全开 2022》（育碧）；《马里奥 + 疯狂兔子星耀之愿》 (育碧)</p>
<p>最佳 PC 游戏：《帝国时代 4》(微软)；《艾尔登法环》（万代南梦宫娱乐）；《塞伯利亚之谜: 世界之前》 (Astragon Entertainment)</p>
<p>最佳索尼 PlayStation 游戏：《艾尔登法环》（万代南梦宫娱乐）；《破晓传说》（万代南梦宫娱乐）；《黑相集：灰冥界》 (万代南梦宫娱乐)</p>
<p>最佳动作冒险游戏：《艾尔登法环》（万代南梦宫娱乐）；《马里奥 + 疯狂兔子星耀之愿》 (育碧)；《塞伯利亚之谜: 世界之前》 (Astragon Entertainment)</p>
<p>最佳动作游戏：《孤岛惊魂 6》（育碧）；《光环：无限》（微软）；《彩虹六号：异种》（育碧）</p>
<p>最佳家庭游戏：《舞力全开 2022》（育碧）；《Run Prop, Run!》（PlayTogether Studio）；《Super Dungeon Maker》 (Rokaplay)</p>
<p>最佳独立游戏：《Dorfromantik》（Toukana Interactive）；《Inua》（Arte France）；《Lost in Random》（EA）</p>
<p>最佳角色扮演游戏：《艾尔登法环》（万代南梦宫娱乐）；《Encased》（科赫传媒）；《破晓传说》（万代南梦宫娱乐）</p>
<p>最佳模拟游戏：《攀登者：天空是极限》(Art Games Studio)；《模拟农场 22》 (Astragon Entertainment)</p>
<p>最佳体育游戏：《攀登者：天空是极限》(Art Games Studio)；《FIFA22》（EA）；《Riders Republic》（育碧）</p>
<p>最佳策略游戏：《帝国时代 4》 (微软)；《英雄连 3》 (世嘉)；《马里奥 + 疯狂兔子星耀之愿》 (育碧)</p>
<p>最佳多人游戏：《光环无限》（微软）；《Riders Republic》（育碧）；《黑相集：灰冥界》 (万代南梦宫娱乐)</p>
<p>持续时间最长游戏：《Apex 游戏》（EA）；《黑色沙漠》 (Pearl Abyss Corp.)；《末日地带: 隔离的世界》 (Assemble Entertainment)</p>
<p>最具原创性的游戏：《骰子遗产》（科赫传媒/Destinybit）；《Riders Republic》（育碧）；《Terrorbane》 (轻语互动)</p>
<p>2021 年科隆游戏展将会于 8 月 25 日至 8 月 29 日举办，将保留现场展览的形式，同时线上数字展形式也将同步举行。</p>
<hr>
<p><strong>参考</strong></p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>日常杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>序言</title>
    <url>/public/2015/01/01/About/</url>
    <content><![CDATA[<p>欢迎来到这里，送你个东西 ~</p>
<p><img src="/public/2015/01/01/About/london.jpeg" alt="london"></p>
<a id="more"></a>
<p>博客算是一种有趣的玩物，体现出一个人很多个性的东西。书籍基本都有个引人入胜的序，我想为我的博客也写个序，如能引人入胜那便是赚到了。开博明意，本博客主要记录学习工作中自然科学、人文社科的芝麻知识点，以及生活的休闲杂记。记忆这东西很神奇，莫名其妙地记住一些事，但也不知不觉丢了些东西。在互联网或者说移动互联网之前，人们的记事方式更多的是纸质的，学习也是按照课本一页页去掌握，如今竞争的压力，信息的爆炸，技术信息发布平台多样，信息短快乱，工作与学习所用的知识点越来越多，越来越细，碎片化地学习无法避免的。</p>
<p>如何去记录这些碎片的知识，整理归纳的方法论需求已经迫在眉睫。在Github上搭建一个带版本控制和评论功能的博客，我认为是个不错的想法。利用Markdown写文档比较方便，不需涉及很多格式设置的问题，风格想换就换，各个博客平台也支持这种语法格式。git对文本的版本控制比较舒服，我可以在多个终端进行编写，同步也方便，合并后利用hexo框架就可以发布。hexo的主题也比较多样，选用的Next主题有很多差价。Next主题在评论支持方面以前使用的是网易云跟帖，但这个功能网易关了，现在使用的Gitment，利用github的isuue功能的评论框架，现在仅支持github用户登录评论，但就用户面来说，我觉得够了，我写的这些博客主要是给自己看的。</p>
<p>对我博客的寄语。希望利用博客建立个人有效的知识体系，锻炼写文章的水平，留下生活中有趣的事物，同时传递出有趣的想法，有效的和各位大牛交流相关领域的经验，在互联网村里共同成长与进步。</p>
<p><a href="build_blog.md">笔者的hexo搭建的过程</a></p>
<p>人是一棵会思考的芦苇，并有一个有趣的灵魂。</p>
<p>不忘初心，活波严谨。</p>
<p><strong>感谢</strong>
The Internet And The World.</p>
<p><strong>联系方式</strong></p>
<ul>
<li>
<p>QQmail: <a href="mailto:tianchenggu@qq.com" target="_blank" rel="noopener">tianchenggu@qq.com</a></p>
</li>
<li>
<p>Gmail:  <a href="mailto:talenapp@gmail.com" target="_blank" rel="noopener">talenapp@gmail.com</a></p>
</li>
<li>
<p>wechat QR</p>
<img src="/public/2015/01/01/About/WechatIMG151.jpeg" alt="WechatIMG151" style="zoom:50%;">
</li>
</ul>
<p><strong>TODOS</strong></p>
<p>Keep It Simple Stupid.</p>
<p>Standing on Shoulders of Giants.
Thank you !!!</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>序言</tag>
      </tags>
  </entry>
  <entry>
    <title>知识记忆软件anki的使用</title>
    <url>/public/2022/04/14/anki_tips/</url>
    <content><![CDATA[<h2 id="anki使用-自建-anki-server"><a class="header-anchor" href="#anki使用-自建-anki-server">¶</a>anki使用 - 自建 anki  server</h2>
<p>当初想设计好用的英语背诵软件，现在发现了anki人家功能全部实现，还要啥自行车。</p>
<p>我当时设计的单词勇士开源Android软件：
<a href="https://github.com/talengu/WordWarrior" target="_blank" rel="noopener">https://github.com/talengu/WordWarrior</a>
现在已弃坑。</p>
<p>我们当然选用docker compose 来安装，相当丝滑。</p>
<p>在使用Anki过程中，主要工作是制作卡组，我们可以只关心内容而不关心技术。</p>
<a id="more"></a>
<h2 id="docker-compose"><a class="header-anchor" href="#docker-compose">¶</a>docker compose</h2>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">service.anki:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kuklinistvan/anki-sync-server</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">anki-container</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8121</span><span class="string">:27701</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/anki-sync-server:/app/data</span> <span class="comment"># anki data</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<h3 id="登陆container"><a class="header-anchor" href="#登陆container">¶</a>登陆container</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it anki-container /bin/sh</span><br><span class="line"></span><br><span class="line">./ankisyncctl.py lsuser             - list users</span><br><span class="line">./ankisyncctl.py adduser &lt;username&gt; - add a new user</span><br><span class="line">./ankisyncctl.py deluser &lt;username&gt; - delete a user</span><br><span class="line">./ankisyncctl.py passwd &lt;username&gt;  - change password of a user</span><br></pre></td></tr></table></figure>
<h2 id="客户端"><a class="header-anchor" href="#客户端">¶</a>客户端</h2>
<img src="/public/2022/04/14/anki_tips/image-20200424005627732.png" alt="image-20200424005627732" style="zoom:33%;">
<h3 id="mac-win-客户端"><a class="header-anchor" href="#mac-win-客户端">¶</a>mac/win 客户端</h3>
<p>从官网下载 【anki mac版本 2.1.21 (f1734a47)】/【Windows PC 客户端】</p>
<p>中文网：<a href="http://www.ankichina.net/" target="_blank" rel="noopener">http://www.ankichina.net/</a></p>
<p>工具-&gt;附加组件-&gt;<code>获取插件</code>，输入 代码：2124817646</p>
<img src="/public/2022/04/14/anki_tips/add_server.png" alt="add_server" style="zoom:30%;">
<img src="/public/2022/04/14/anki_tips/add_on1.png" alt="add_on1" style="zoom:30%;">
<p>插件下载完成后设置ip地址，点击<code>设置</code>。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"msyncUrl"</span>: <span class="string">"http://127.0.0.1:27701/msync/"</span>,</span><br><span class="line">    <span class="attr">"syncUrl"</span>: <span class="string">"http://127.0.0.1:27701/sync/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/public/2022/04/14/anki_tips/addon_2.png" alt="addon_2" style="zoom:30%;">
<p>重启anki，同步并输入输入自定义服务器中配置的账户</p>
<h3 id="Android客户端-AnkiDroid"><a class="header-anchor" href="#Android客户端-AnkiDroid">¶</a>Android客户端 - AnkiDroid</h3>
<p>首先配置服务器地址信息，打开<code>设置-&gt;高级设置-&gt;自定义同步服务器</code>，输入同步地址 和 媒体文件同步地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 同步地址</span><br><span class="line">http://127.0.0.1:27701/</span><br><span class="line"># 媒体文件同步地址</span><br><span class="line">http://127.0.0.1:27701/msync/</span><br></pre></td></tr></table></figure>
<p>然后打开 <code>设置-&gt;AnkiDroid常用设置-&gt;AnkiWeb账户</code>，输入在服务器里面设置的账户和密码。PS：可在服务器重置密码。</p>
<table><tr>
<td><center><img src="/public/2022/04/14/anki_tips/IMG_20200424_010047.jpg">图1    </center></td>
<td><center><img src="/public/2022/04/14/anki_tips/IMG_20200424_011338.jpg">图2      </center></td>
</tr></table>
<p>coco20000 anki 包 <a href="https://www.dazhuanlan.com/2019/11/20/5dd54a6571f01/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/11/20/5dd54a6571f01/</a></p>
<h2 id="其他docker-安装方法"><a class="header-anchor" href="#其他docker-安装方法">¶</a>其他docker 安装方法</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ANKI_SYNC_DATA_DIR=<span class="variable">$HOME</span>/anki-sync-server</span><br><span class="line"><span class="built_in">export</span> HOST_PORT=27701</span><br><span class="line"></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$ANKI_SYNC_DATA_DIR</span>"</span></span><br><span class="line"><span class="comment">#export DOCKER_USER=root</span></span><br><span class="line"><span class="comment">#chown "$DOCKER_USER" "$ANKI_SYNC_DATA_DIR"</span></span><br><span class="line">chmod 700 <span class="string">"<span class="variable">$ANKI_SYNC_DATA_DIR</span>"</span></span><br><span class="line"></span><br><span class="line">docker run -itd \</span><br><span class="line">   -v <span class="string">"<span class="variable">$ANKI_SYNC_DATA_DIR</span>"</span>:/app/data \</span><br><span class="line">   -p <span class="string">"<span class="variable">$HOST_PORT</span>"</span>:27701 \</span><br><span class="line">   --name anki-container \</span><br><span class="line">   --restart always \</span><br><span class="line">   kuklinistvan/anki-sync-server:latest</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>知识管理</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>anki</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>现代数学手册</title>
    <url>/public/2017/05/22/math_handbook/</url>
    <content><![CDATA[<img src="/public/2017/05/22/math_handbook/Screen Shot 2020-03-06 at 13.24.51.png" alt="Screen Shot 2020-03-06 at 13.24.51" style="zoom:33%;">
<img src="/public/2017/05/22/math_handbook/Screen Shot 2020-03-06 at 13.24.27.png" alt="Screen Shot 2020-03-06 at 13.24.27" style="zoom: 33%;">
<img src="/public/2017/05/22/math_handbook/Screen Shot 2020-03-06 at 13.22.44.png" alt="Screen Shot 2020-03-06 at 13.22.44" style="zoom:33%;">
<img src="/public/2017/05/22/math_handbook/Screen Shot 2020-03-06 at 13.23.48.png" alt="Screen Shot 2020-03-06 at 13.23.48" style="zoom:33%;">
<img src="/public/2017/05/22/math_handbook/Screen Shot 2020-03-06 at 13.23.57.png" alt="Screen Shot 2020-03-06 at 13.23.57" style="zoom:33%;">
<p>百度云链接: <a href="https://pan.baidu.com/s/1AwNZNoMLgJcJ5X0G0fpC5w" target="_blank" rel="noopener">https://pan.baidu.com/s/1AwNZNoMLgJcJ5X0G0fpC5w</a> 提取码: pb1n</p>
]]></content>
      <categories>
        <category>现代数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>工具书</tag>
      </tags>
  </entry>
  <entry>
    <title>使用脚本将英文rss转成中文rss</title>
    <url>/public/2022/05/08/rss_google_translate/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>本文中我们将英文rss 自动转成中文 rss供ttrss使用。（利用谷歌翻译）</p>
<p>方便在手机上进行阅读或者收听。
<img src="/public/2022/05/08/rss_google_translate/20220508-22-28-27.png" alt></p>
<a id="more"></a>
<h2 id="举例"><a class="header-anchor" href="#举例">¶</a>举例</h2>
<p>国外有很多不错的rss源，比如:</p>
<ul>
<li>
<p><a href="http://www.mckinsey.com/insights/rss" target="_blank" rel="noopener">McKinsey Insights &amp; Publications</a>
<img src="/public/2022/05/08/rss_google_translate/20220508-22-18-23.png" alt>
转成中文rss
<img src="/public/2022/05/08/rss_google_translate/20220508-22-20-48.png" alt></p>
</li>
<li>
<p><a href="http://rss.acast.com/nature" target="_blank" rel="noopener">Nature Podcast</a>
<img src="/public/2022/05/08/rss_google_translate/20220508-22-25-04.png" alt>
转成中文rss
<img src="/public/2022/05/08/rss_google_translate/20220508-22-26-36.png" alt></p>
</li>
</ul>
<h2 id="脚本"><a class="header-anchor" href="#脚本">¶</a>脚本</h2>
<p>使用 Translate 和 BeautifulSoup 项目</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8 </span></span><br><span class="line"><span class="keyword">from</span> pygtrans <span class="keyword">import</span> Translate</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment"># pip 安装</span></span><br><span class="line"><span class="comment"># pip install pygtrans BeautifulSoup -i https://pypi.org/simple</span></span><br><span class="line"><span class="comment"># ref:https://zhuanlan.zhihu.com/p/390801784</span></span><br><span class="line"><span class="comment"># ref:https://beautifulsoup.readthedocs.io/zh_CN/latest/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># client = Translate()</span></span><br><span class="line"><span class="comment"># text = client.translate('Google Translate')</span></span><br><span class="line"><span class="comment"># print(text.translatedText)  # 谷歌翻译</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"></span><br><span class="line">args = sys.argv</span><br><span class="line">URL=<span class="string">"http://www.mckinsey.com/insights/rss"</span></span><br><span class="line"></span><br><span class="line">BASE=<span class="string">"/home/xxx/www/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tran</span><span class="params">(url=URL,out_dir=BASE+<span class="string">"mckinsey_rss.xml"</span>)</span>:</span></span><br><span class="line">    GT = Translate()</span><br><span class="line">    content= request.urlopen(url).read().decode(<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="comment"># 变tag，以使用谷歌翻译</span></span><br><span class="line">    content=content.replace(<span class="string">'title&gt;'</span>, <span class="string">'stitle&gt;'</span>) <span class="comment">#谷歌翻译会将很多titile去掉，所以需要换一个tag</span></span><br><span class="line">    content=content.replace( <span class="string">'&lt;pubDate&gt;'</span>,<span class="string">'&lt;pubDate&gt;&lt;span translate="no"&gt;'</span>) </span><br><span class="line">    <span class="comment"># 谷歌翻译对&lt;span translate="no"&gt; &lt;/span&gt; 不翻译。</span></span><br><span class="line">    content=content.replace( <span class="string">'&lt;/pubDate&gt;'</span>,<span class="string">'&lt;/span&gt;&lt;/pubDate&gt;'</span>)</span><br><span class="line">    <span class="comment">#print(content)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    _text = GT.translate(content)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(out_dir,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        c=_text.translatedText</span><br><span class="line">        <span class="comment"># 还原tag</span></span><br><span class="line">        c=c.replace(<span class="string">'stitle&gt;'</span>, <span class="string">'title&gt;'</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;span translate="no"&gt;'</span>, <span class="string">''</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;/span&gt;&lt;/pubDate&gt;'</span>, <span class="string">'&lt;/pubDate&gt;'</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        f.write(c)</span><br><span class="line">        <span class="comment">#f.write(content)</span></span><br><span class="line">    print(<span class="string">"GT: "</span>+ url +<span class="string">" &gt; "</span>+ out_dir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(args)==<span class="number">1</span>:</span><br><span class="line">    tran()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    tran(args[<span class="number">1</span>],args[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tran_nature</span><span class="params">(url=<span class="string">"http://rss.acast.com/nature"</span>,out_dir=BASE+<span class="string">"nature_rss.xml"</span>)</span>:</span></span><br><span class="line">    GT = Translate()</span><br><span class="line">    </span><br><span class="line">    html_doc=request.urlopen(url).read().decode(<span class="string">'utf8'</span>)</span><br><span class="line">    soup = BeautifulSoup(html_doc)</span><br><span class="line"></span><br><span class="line">    items=soup.find_all(<span class="string">'item'</span>)</span><br><span class="line">    <span class="comment"># nature post内容太多，谷歌api翻译不了，去掉一些</span></span><br><span class="line">    <span class="keyword">for</span> idx,e <span class="keyword">in</span> enumerate(items):</span><br><span class="line">        <span class="keyword">if</span> idx &gt;<span class="number">8</span>:</span><br><span class="line">                e.decompose()</span><br><span class="line">    </span><br><span class="line">    content= str(soup)</span><br><span class="line">    content=content.replace(<span class="string">'title&gt;'</span>, <span class="string">'stitle&gt;'</span>)</span><br><span class="line">    content=content.replace( <span class="string">'&lt;pubdate&gt;'</span>,<span class="string">'&lt;pubDate&gt;&lt;span translate="no"&gt;'</span>)</span><br><span class="line">    content=content.replace( <span class="string">'&lt;/pubdate&gt;'</span>,<span class="string">'&lt;/span&gt;&lt;/pubdate&gt;'</span>)</span><br><span class="line">    <span class="comment">#print(content)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    _text = GT.translate(content)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(out_dir,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        c=_text.translatedText</span><br><span class="line">        c=c.replace(<span class="string">'stitle&gt;'</span>, <span class="string">'title&gt;'</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;span translate="no"&gt;'</span>, <span class="string">''</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;/span&gt;&lt;/pubdate&gt;'</span>, <span class="string">'&lt;/pubDate&gt;'</span>) <span class="comment"># 对于ttrss需要为pubDate才会识别正确</span></span><br><span class="line">        c=c.replace(<span class="string">'&amp;gt'</span>,<span class="string">'&gt;'</span>) <span class="comment"># &amp;gt 会影响识别</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        f.write(c)</span><br><span class="line">        <span class="comment">#f.write(content)</span></span><br><span class="line">    print(<span class="string">"GT: "</span>+ url +<span class="string">" &gt; "</span>+ out_dir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tran_nature()</span><br></pre></td></tr></table></figure>
<h3 id="定时任务"><a class="header-anchor" href="#定时任务">¶</a>定时任务</h3>
<blockquote>
<p>注意激活一下miniconda3 这个命令<code>source /home/xxx/miniconda3/bin/activate</code></p>
</blockquote>
<p>放到 <code>/etc/cron.daily/</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">source</span> /home/xxx/miniconda3/bin/activate</span><br><span class="line">python /home/xxx/txxx.py</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2>
<ul>
<li><a href="https://blog.csdn.net/wokuailewozihao/article/details/82021709" target="_blank" rel="noopener">利用Google翻译实现网站国际化——js插件</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>rss</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>本地安装rss</title>
    <url>/public/2022/04/16/rss_local_install/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>在 “<a href="https://zhuanlan.zhihu.com/p/149452085" target="_blank" rel="noopener">二零年RSS杂谈</a>”中说到，我想建立一种信息的获取系统，免受广告和推荐算法的困扰。</p>
<p>我希望其的功能包括：</p>
<ul>
<li>多终端 Web、PC、 mobile的同步</li>
<li>全文获取能力</li>
<li>可自定义过滤规则</li>
<li>RSS源自定义</li>
</ul>
<p>方案：</p>
<ul>
<li>RSS源 rsshub</li>
<li>RSS服务  ttrss</li>
<li>RSS电脑手机软件：Android的Readably、Feedme，mac的reeder等等。windows上我暂时没有发现，我用的是ttrss的web界面。</li>
</ul>
<a id="more"></a>
<p>rsshub 是由 DIYgod 开发的开源RSS源生成工具，RSShub原始的网站可能不稳定，所以我选择了自己搭建。</p>
<p>ttrss 是一个rss源管理配置的工具，可获取全文，可自定义过滤规则。</p>
<p>本教程我们将完成在window电脑通过docker安装，ttrss与全文插件、rsshub的过程。</p>
<p>服务器的成本还是有点小贵的，我们可以在本地搭建整个服务，即利用docker安装这些服务，开机的时候记得启动这些服务。
不爽点：</p>
<ul>
<li>需要后台开启docker服务，使得其自动更新信息</li>
<li>没有公网ip的情况下，无法全网连接服务</li>
</ul>
<h2 id="最终ttrss界面"><a class="header-anchor" href="#最终ttrss界面">¶</a>最终ttrss界面</h2>
<p>在这里我已经添加一些rss源了。</p>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626135803804.png" alt="image-20200626135803804"></p>
<h2 id="docker-windows安装"><a class="header-anchor" href="#docker-windows安装">¶</a>docker windows安装</h2>
<p>从<a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">docker 官网</a> 下载windows版本安装。完成后，在图标区会有一个鲸鱼船。</p>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626141604658.png" alt="image-20200626141604658"></p>
<p>我们使用docker-compose 来进行下一步 网站服务的安装。将下面的资料保存到s<code> docker-compose.yml</code> 然后利用docker-compose方法安装。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">service.rsshub:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">diygod/rsshub</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rsshub</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"1200:1200"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rsshub_data:/app/lib</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">service.rss:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangqiru/ttrss:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ttrss</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8118</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SELF_URL_PATH=http://127.0.0.1:8118/</span> <span class="comment"># please change to your own domain</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_HOST=database.postgres</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PORT=5432</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_NAME=ttrss</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_USER=postgres</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PASS=ttrss</span> <span class="comment"># please change the password</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ENABLE_PLUGINS=auth_internal,fever</span> <span class="comment"># auth_internal is required. Plugins enabled here will be enabled for all users as system plugins</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FEED_LOG_QUIET=true</span></span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">'sh /wait-for.sh $$DB_HOST:$$DB_PORT -- php /configure-db.php &amp;&amp; exec s6-svscan /etc/s6/'</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">database.postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_PASSWORD=ttrss</span> <span class="comment"># please change the password</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgres_data:/var/lib/postgresql/data</span> <span class="comment"># persist postgres data to ~/postgres/data/ on the host</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">service.mercury:</span> <span class="comment"># set Mercury Parser API endpoint to `service.mercury:3000` on TTRSS plugin setting page</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangqiru/mercury-parser-api:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mercury</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">postgres_data:</span></span><br><span class="line">  <span class="attr">rsshub_data:</span></span><br></pre></td></tr></table></figure>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626140114783.png" alt="image-20200626140114783"></p>
<p>在地址栏输入<code>cmd</code>，我们就可以打开cmd界面了，然后运行<code>docker-compose up -d</code> ，就可以自动安装全部内容了。</p>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626134626593.png" alt="image-20200626134626593"></p>
<p>在地址栏输入<code>cmd</code> 然后回车，我们就能进入cmd界面，然后使用docker-compose，进行安装，网速好的话，安装很快。</p>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626140147402.png" alt="image-20200626140147402"></p>
<p>安装完毕我们就可以使用了，下面是其资源占用情况。</p>
<table>
<thead>
<tr>
<th></th>
<th>内容</th>
<th>占用内存空间（M）</th>
</tr>
</thead>
<tbody>
<tr>
<td>mercury</td>
<td>全文获取ttrss插件</td>
<td>66.8</td>
</tr>
<tr>
<td>postgres</td>
<td>ttrss数据库</td>
<td>6.8</td>
</tr>
<tr>
<td>ttrss</td>
<td>ttrss工具</td>
<td>30.2</td>
</tr>
<tr>
<td>rsshub</td>
<td>rsshub各种b站源等等</td>
<td>142.4</td>
</tr>
<tr>
<td></td>
<td></td>
<td>246.2</td>
</tr>
</tbody>
</table>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626140407183.png" alt="image-20200626140407183"></p>
<p>打开 <a href="http://127.0.0.1:8118/" target="_blank" rel="noopener">http://127.0.0.1:8118/</a></p>
<p>默认账户：admin 密码：password，请第一时间更改。</p>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626143320968.png" alt="image-20200626143320968"></p>
<h2 id="在chrome安装-rsshub-radar"><a class="header-anchor" href="#在chrome安装-rsshub-radar">¶</a>在chrome安装 rsshub radar</h2>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626144233385.png" alt="image-20200626144233385"></p>
<p>并设置到本机的rsshub地址，ttrss地址，如上。</p>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626144330350.png" alt="image-20200626144330350"></p>
<p>打开bilibili up主的主页就能订阅了，订阅到ttrss。</p>
<p>这里有问题。需要解决。</p>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626145153354.png" alt="image-20200626145153354"></p>
<p>本次安装教程到此结束，下期我们介绍全文获取功能，手机app的联动，即ttrss的设置问题</p>
]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
      <tags>
        <tag>rss</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>二零年RSS杂谈</title>
    <url>/public/2022/01/14/rss_talk2020/</url>
    <content><![CDATA[<p>2020年了，笔者还是使用RSS的原始人。RSS，Really Simple Syndication是一种信息聚合工具。在5G时代信息即将大爆炸之前，我来谈谈rss的杂七杂八吧。我们来打个赌，你不会看完这篇文章。</p>
<a id="more"></a>
<p>软件的交互设计有很多心理学理论的应用。比如微信、QQ的三级页面设计，一般经过3次点击就能到达功能或设置。这符合认知原理，人认知记忆能力一般为3-5个的组合。日常生活中要记电话号码，可以3-4-4这样记。软件交互中还有利用人的习惯奖励机制的提醒红点的设计，吸引你去点击，获取红点消失的奖励。对我来说，较难控制住不受这些设计的影响。在《习惯的力量》一书了解到，直接逃离这些环境可有效解决控制不住的问题。比如工作的时候，把手机关进柜子，工作1个小时，然后再回复信息，当然重要电话还是要立即接的。</p>
<p>铺天盖地的广告，马路上，电视中，手机里，PC页面充斥着各种广告等等。大多数人可能养成了自动过滤的广告的习惯，然而我的情况是一直在用去广告的插件，并没有养成自动忽略广告的习惯。可怜兮兮，难道只有我是有广告洁癖的嘛？广告有点浪费生命。</p>
<p>我饱受广告的困扰。web的去广告方法，我可使用某款chrome插件可以将web界面上的小红点，推荐信息模块全部屏蔽掉的。哪里不看点哪里，贼方便。</p>
<p>移动端的广告去掉太难了，我一生气卸载了知乎 b站等等应用，终于有了一个清爽的手机。</p>
<p>那我还是想获取一些新的内容，根据二八定律，是有20%的网络资料包含了80%的信息，也就是干货，也可能被我这种操作忽略掉了，那一套RSS应用体系应运而生。</p>
<p>谈谈推荐算法，知乎推荐的都是啥呀，程序员都懂的，把我一个屌丝的形象勾勒的这么明显。于是我回答问题，人在美国，刚下飞机，年薪百万，老婆在旁？</p>
<p>很多人会说，RSS一定会获取到有用的信息吗，这取决于信息源的可靠程度。也就是需要你自己去选择，由于它是不含推荐算法的，就不会根据你选择的，再给你推荐一些可能是非常有用的。</p>
<p>再谈谈知识焦虑，每天觉得有大量知识需要吸收。大家都明白mark了也并不会看的，但还是mark很多，但你并不会有时间或者精力去看。既然不会看，那就不mark了，用到啥学啥，或许是个不错的策略。那RSS的即时性还是不错的，最好能当天把信息清理一下，star一些当前重要的东西，然后一周整理一下，像阮一峰老师。吸收完，把它输出出去，与人交流，给人讲明白，能够记得更深。（费曼学习法，把自己当成老师）。</p>
<p>让我们再回到RSS，RSS是个淘汰的东西，和微信的公众号的形式有点像。然后倒霉的我又在微信的公众号上难以自拔，常常花很多时间在这上面。推荐算法厉害呀，就是让你看得爽。自我节制太难，那就改变环境。于是，我去掉了很多公众号，保留一些本地生活工作的公众号，微信上专注与朋友们侃大山。</p>
<p>还有一点难受是，各个平台，相互串在一起，在这个地方看了，在其他地方又换了一个马甲它继续晃悠在眼前。信息源在多平台发布，然后信息重叠。</p>
<p>看来all in one 势在必行，RSS被谷歌放弃后，很多网站傲娇地不提供RSS服务了，毕竟流量至上，钱要赚的，我一直想做一个这种爬的工具，但我不希望有大量使用爬，也就是我们还是要尊重网站的盈利以及持续发展的，这也是仅仅方便个人的信息处理，优化你的自动信息的处理，再也不用一个个打开网站，然后看信息看广告，还要被推荐不重用的信息。这也算我个人的想法。人在于折腾，于是我开始折腾ttrss rsshub等开源软件。</p>
<p>自由软件的好处，在于自由定制，参与发展，利益化会尽量变慢或者没有，方便的同时并不忘隐私保护。</p>
<p>我想说的是，<strong>技术应当给人们带来自由和发展，而非接管人们的注意力，浪费宝贵的时间。</strong></p>
<p>写在5G信息大爆发前，与大家共同反思与成长。</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>RSS</tag>
      </tags>
  </entry>
  <entry>
    <title>rss统计 基于ttrss的PostgresQL数据库</title>
    <url>/public/2022/05/08/rss_ttrss_statics/</url>
    <content><![CDATA[<p><strong>前言</strong>
统计ttrss的使用数据。</p>
<ul>
<li>月度mark文件分析 OK</li>
</ul>
<p>TODO：</p>
<ul>
<li>全年阅读报告 doing</li>
</ul>
<a id="more"></a>
<h2 id="按月保存mark的内容"><a class="header-anchor" href="#按月保存mark的内容">¶</a>按月保存mark的内容</h2>
<p>账号 密码 和你docker文件里面的一致。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按月来保存</span></span><br><span class="line"><span class="keyword">import</span> html2text</span><br><span class="line"><span class="comment"># psycopg2 head</span></span><br><span class="line"><span class="keyword">import</span> psycopg2</span><br><span class="line"><span class="comment"># pip3 install psycopg2-binary</span></span><br><span class="line"><span class="comment"># ref:https://blog.csdn.net/Haiqiang1995/article/details/89069791</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_from_dataset</span><span class="params">(cmd_sql)</span>:</span></span><br><span class="line">    conn = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># read database configuration</span></span><br><span class="line">        params = &#123;</span><br><span class="line">        <span class="string">'host'</span>: <span class="string">"?????"</span>,</span><br><span class="line">        <span class="string">'user'</span>: <span class="string">"????"</span>,</span><br><span class="line">        <span class="string">'password'</span>: <span class="string">"????"</span>,</span><br><span class="line">        <span class="string">'dbname'</span>: <span class="string">"ttrss"</span>,</span><br><span class="line">        'port': ??00</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># connect to the PostgresQL database</span></span><br><span class="line">        conn = psycopg2.connect(**params)</span><br><span class="line">        <span class="comment"># create a new cursor object</span></span><br><span class="line">        cur = conn.cursor()</span><br><span class="line">        <span class="comment"># execute the SELECT statement</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        print(cmd_sql)</span><br><span class="line">        cur.execute(cmd_sql)</span><br><span class="line"></span><br><span class="line">        blob = cur.fetchall()</span><br><span class="line">        <span class="comment"># blob = cur.fetchone()</span></span><br><span class="line">        <span class="comment">#open(path_to_dir + str(blob[0]) + '.jpg', 'wb').write(blob[1])</span></span><br><span class="line">        <span class="comment"># close the communication with the PostgresQL database</span></span><br><span class="line">        cur.close()</span><br><span class="line">    <span class="keyword">except</span> (Exception, psycopg2.DatabaseError) <span class="keyword">as</span> error:</span><br><span class="line">        print(error)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> conn <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            conn.close()</span><br><span class="line">    print(<span class="string">"get_from_dataset success"</span>)</span><br><span class="line">    <span class="keyword">return</span> blob</span><br><span class="line"></span><br><span class="line">_s=<span class="string">"ref_id,feed_id,last_read,last_marked"</span></span><br><span class="line">cmd_sql=<span class="string">"SELECT %s  FROM public.ttrss_user_entries Where marked=TRUE AND last_marked BETWEEN '2022-04-01' And '2022-5-01'"</span> % _s</span><br><span class="line"><span class="comment"># 可以自己改日期</span></span><br><span class="line"></span><br><span class="line">g_content=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> _e <span class="keyword">in</span> sorted(get_from_dataset(cmd_sql),key=<span class="keyword">lambda</span> x:x[<span class="number">3</span>]):</span><br><span class="line">    [ref_id,feed_id,last_read,last_marked] = _e</span><br><span class="line">    _s=<span class="string">"id,title,link,updated,content"</span></span><br><span class="line">    cmd_sql=<span class="string">"SELECT %s FROM public.ttrss_entries WHERE id = %s"</span> % (_s,ref_id)</span><br><span class="line">    [id,title,link,updated,content] =get_from_dataset(cmd_sql)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    g_content += <span class="string">"# [%s](%s)\n"</span>%(title,link)</span><br><span class="line">    g_content +=<span class="string">"pubdata:%s\n"</span>%str(updated)</span><br><span class="line">    g_content +=<span class="string">"markdate:%s\n"</span>%str(last_marked)</span><br><span class="line">    g_content+=html2text.html2text(content)</span><br><span class="line">    </span><br><span class="line">    g_content+=<span class="string">"\n\n"</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">D=<span class="string">"C:\\Users\\talen\\Desktop\\"</span></span><br><span class="line"><span class="keyword">with</span> open(D+<span class="string">"cc.md"</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(g_content)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>rss</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>博客模版</title>
    <url>/public/2019/07/25/template/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>前言主要说明文章的写作意图，概要介绍文中涉及的背景、主要内容、与其他文章关系等。对于长文，这个部分可以写摘要。</p>
<p>本文为Hexo博客模版文件，以Markdown语言书写。<a href="#%E9%99%84%EF%BC%9Amarkdown%E8%AF%AD%E6%B3%95">模版markdown语法</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言一般放到主页，可利用 &lt;!-- more --&gt; 隔断。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="构思与起草"><a class="header-anchor" href="#构思与起草">¶</a>构思与起草</h2>
<ul>
<li>对文章的阅读群体、写作意图和反馈（Audience Intention Response AIR）要有一个清楚的认识。照顾沟通对象的需要、你的意图（信息）以及希望的反馈。</li>
<li>在思维导图上，放上你需要的关键名词，然后依次在它基础上添加动词，在加上形容词。最后以一定顺序组织你将要阐述的信息。比如重要性排序，对比优势劣势，方案的不同层面，时间上逻辑上的因果性等等。</li>
</ul>
<h2 id="主体内容"><a class="header-anchor" href="#主体内容">¶</a>主体内容</h2>
<p>文章的主要内容，包括你对跟进过程或发现成果的描述，以数据、事实证据以及其他的信息支撑主要内容。在你的论说中，你应该把对客观事实的描述和写作者对事情的主管阐述区分开来。</p>
<p>当你在报告中对一个观点进行陈述的时候，你需要记住以下几点：</p>
<ul>
<li>清晰的呈现事实</li>
<li>有逻辑地提出论据</li>
<li>引用相关的语录、简明易懂的事实和例子来支持你的论点</li>
<li>给出支持或反对该行为的理由</li>
<li>始终围绕主要观点进行讨论</li>
<li>处理好重要的假设关系</li>
<li>区分说明（具体阐述）和论证（有理有据）</li>
</ul>
<h2 id="写作检查"><a class="header-anchor" href="#写作检查">¶</a>写作检查</h2>
<p>主体内容完成后，要进行写作检查。</p>
<ul>
<li>保证信息的准确性，时间地点等信息的准确。</li>
<li>确保语法规范性</li>
<li>段落写作
<ul>
<li>主题句，核心思想</li>
<li>使用关联词，但勿滥
<ul>
<li>表示转折：虽然，尽管，但是，相反的是，另一方面</li>
<li>对已阐述观点的强调：此外，与此同时，除此以外，再补充一点</li>
<li>阐述结果：结果是，相应的结果是，因此</li>
</ul>
</li>
<li>简单的句子 15-25</li>
</ul>
</li>
<li>精心选择词语
<ul>
<li>同一个意思，换一下说法</li>
<li>少用名词，多用动词。我们想用名词表达意思，采用动名组合，或者一个意群搭配上动词会更有力。</li>
<li>多用主动动词，少用被动动词</li>
</ul>
</li>
<li>核对标点符号，逗号，与分号。英文的话，检查一下拼写</li>
<li>注意行为的语气</li>
<li>保持连贯性，使用一种统一的方式表达。</li>
</ul>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>一个清晰的总结应该概括全部论点。</p>
<h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2>
<ul>
<li>逻辑清楚，达情切意<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。准备看一些基础的逻辑学。</li>
<li>写完要读两遍，修改错别字，标点，语序连接等等。</li>
<li>修改可以反着读，正着读对熟悉的材料会有一种连贯性忽略掉错误或者不顺的地方。</li>
</ul>
<h2 id="附：markdown语法"><a class="header-anchor" href="#附：markdown语法">¶</a>附：markdown语法</h2>
<h3 id="head"><a class="header-anchor" href="#head">¶</a>head</h3>
<p>文件head，设置标题、日期、分类、标签、评论、版权、是否使用公式，如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 模版文件</span><br><span class="line">date: 2019-07-25 12:00:00</span><br><span class="line">updated: 2019-07-25 12:00:00</span><br><span class="line">categories:</span><br><span class="line">  - 博客搭建</span><br><span class="line">  - 模版文件</span><br><span class="line">tags:</span><br><span class="line">  - Writing</span><br><span class="line">comments: true</span><br><span class="line">copyright: true</span><br><span class="line">math: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="图"><a class="header-anchor" href="#图">¶</a>图</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 使用标准markdown</span><br><span class="line">![GDP](http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用html</span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png"</span> <span class="attr">width</span>=<span class="string">"60%"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 图1 2019年国内生产总值及其增速度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 白色图片用table提供辨识度</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png"</span> <span class="attr">width</span>=<span class="string">"60%"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span> 图1 2019年国内生产总值及其增速度<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这两行代码生成下面的图和标题。</p>
<center><img src="http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png" width="60%">
</center>
<p>图 1 展示的是2015-2019年的GDP和增长速度<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，直方图数据反应国内生产总值在2015-2019年度均平稳增长。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png"</span>&gt;</span>图1     <span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">center</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png"</span>&gt;</span>图2 <span class="tag">&lt;/<span class="name">center</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<table><tr>
<td><center><img src="http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png">图1     </center></td>
<td><center><img src="http://www.stats.gov.cn/tjsj/zxfb/202002/W020200228491461098230_r75.png">图2 </center></td>
</tr></table>
<h3 id="表"><a class="header-anchor" href="#表">¶</a>表</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div align=&apos;center&apos;&gt; 表1 2018年年末人口数及其构成&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">| 指标       | 年末数（万人） | 比重（%） |</span><br><span class="line">| ---------- | -------------- | --------- |</span><br><span class="line">| 全国总人口 | 139538         | 100.0     |</span><br><span class="line">| 其中：城镇 | 83137          | 59.58     |</span><br><span class="line">| 乡村       | 56401          | 40.42     |</span><br></pre></td></tr></table></figure>
<p>这两行代码生成下面的表和标题。</p>
<div align="center">表1 2018年年末人口数及其构成</div>
<table>
<thead>
<tr>
<th>指标</th>
<th>年末数（万人）</th>
<th>比重（%）</th>
</tr>
</thead>
<tbody>
<tr>
<td>全国总人口</td>
<td>139538</td>
<td>100.0</td>
</tr>
<tr>
<td>城镇</td>
<td>83137</td>
<td>59.58</td>
</tr>
<tr>
<td>乡村</td>
<td>56401</td>
<td>40.42</td>
</tr>
</tbody>
</table>
<p>从表1得出2018年年末，城镇人口占总人口的59.58%，乡村人口占总人口的40.42%，城镇人口已大比例超过乡村人口。</p>
<h3 id="公式"><a class="header-anchor" href="#公式">¶</a>公式</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">f=w_1 x_1 + w_2 x_2</span><br><span class="line">\tag&#123;1&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>在Markdown中可用Tex代码渲染数学公式，渲染效果为公式（1）。如图2，Tex公式可以在<a href="http://latex.codecogs.com/eqneditor/editor.php" target="_blank" rel="noopener">Latex编辑器网站</a> 可视化编写
$$
f=w_1 x_1 + w_2 x_2
\tag{1}
$$</p>
<center><img src="https://img-blog.csdnimg.cn/20200425095309901.png" width="60%">
<div> 图2 Latex在线编辑器</div>
</center>
<h3 id="定理证明"><a class="header-anchor" href="#定理证明">¶</a>定理证明</h3>
<p><strong>定理 3.1</strong> 如果时域混合场积分方程是时域电场积分方程与时域磁场积分方程的线性组合……</p>
<p><strong>证明：</strong></p>
<p>首先，由于 ……</p>
<p>……</p>
<p>根据 ……，结论得证。                        ■</p>
<h3 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h3>
<p>参考的分类：</p>
<ul>
<li>链接直接在原文中给出。</li>
<li>引用他人文章中的段落或者意识给出引用的链接。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">**参考**</span><br><span class="line"></span><br><span class="line">[^statics_report_2019]: 国家统计局 [2019年国民经济和社会发展统计公报](http://www.stats.gov.cn/tjsj/zxfb/202002/t20200228_1728913.html) 2020-02-28</span><br><span class="line"></span><br><span class="line">[^hetang]: 朱自清《荷塘清韵》北京大学出版社  2010-1</span><br></pre></td></tr></table></figure>
<h3 id="添加iframes"><a class="header-anchor" href="#添加iframes">¶</a>添加iframes</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &#123;&#125;替换为视频id，同时去掉&#123;&#125; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 小破站 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"https://player.bilibili.com/player.html?bvid=&#123;&#125;"</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"430"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 腾讯视频 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://v.qq.com/iframe/player.html?vid=&#123;&#125;"</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"430"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 优酷视频 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">src</span>=<span class="string">'https://player.youku.com/embed/&#123;&#125;'</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"430"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- PDF --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">src</span>=<span class="string">'https://arxiv.org/pdf/1406.2661.pdf'</span> <span class="attr">width</span>=<span class="string">"800"</span> <span class="attr">height</span>=<span class="string">"450"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span>  <span class="attr">src</span>=<span class="string">'https://www.sohu.com/a/287817933_100118081'</span> <span class="attr">width</span>=<span class="string">"800"</span> <span class="attr">height</span>=<span class="string">"450"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<iframe src="https://player.bilibili.com/player.html?bvid=BV1Wb411v7WN" width="640" height="430">
</iframe>
<iframe src="https://v.qq.com/txp/iframe/player.html?vid=u0951gpf8u2" width="640" height="430"></iframe>
<p>TODO:
markdown 空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>参考</strong></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>朱自清《荷塘清韵》北京大学出版社  2010-1 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>国家统计局 <a href="http://www.stats.gov.cn/tjsj/zxfb/202002/t20200228_1728913.html" target="_blank" rel="noopener">2019年国民经济和社会发展统计公报</a> 2020-02-28 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>博客模版</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】在 C/C++ 程序中打印当前函数调用栈</title>
    <url>/public/2021/08/25/c_debug/</url>
    <content><![CDATA[<p><strong>背景</strong></p>
<p>2011 年 6 月 11 日 <a href="http://www.wuzesheng.com/?author=2" title="由 小武哥 发布" target="_blank" rel="noopener">小武哥</a></p>
<p>前几天帮同事跟踪的一个程序莫名退出，没有 core dump(当然 ulimit 是打开的) 的问题。我们知道，正常情况下，如果程序因为某种异常条件退出的话，应该会产生 core dump，而如果程序正常退出的话，应该是直接或者间接的调用了 exit() 相关的函数。基于这个事实，我想到了这样一个办法，在程序开始时，通过系统提供的 atexit()，向系统注册一个回调函数，在程序调用 exit() 退出的时候，这个回调函数就会被调用，然后我们在回调函数中打印出当前的函数调用栈，由此便可以知道 exit() 是在哪里调用，从而上述问题便迎刃而解了。上述方法用来解决类似问题是非常行之有效的。在上面，我提到了在 “回调函数中打印出当前的函数调用栈”，相信细心的朋友应该注意到这个了，本文的主要内容就是详细介绍，如何在程序中打印中当前的函数调用栈。</p>
<a id="more"></a>
<p>我之前写过一篇题目为《<a href="http://www.wuzesheng.com/?p=1123" target="_blank" rel="noopener">介绍几个关于 C/C++ 程序调试的函数</a>》的文章，看到这里，请读者朋友先看一下前面这篇，因为本文是以前面这篇文章为基础的。我正是用了 backtrace() 和 backtrace_symbols() 这两个函数实现的，下面是一个简单的例子，通过这个例子我们来介绍具体的方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo .h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio .h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib .h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stacktrace</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stackstrace begin:\n"</span>);</span><br><span class="line">    print_stacktrace();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun1();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stacktrace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">void</span> * <span class="built_in">array</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> stack_num = backtrace(<span class="built_in">array</span>, size);</span><br><span class="line">    <span class="keyword">char</span> ** stacktrace = backtrace_symbols(<span class="built_in">array</span>, stack_num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stack_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, stacktrace[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(stacktrace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（说明：下面的介绍采用的环境是 ubuntu 11.04, x86_64, gcc-4.5.2）</p>
<ol>
<li>
<p>通过下面的方式编译运行：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ gcc test.cc -o test1</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ ./test1</span><br><span class="line">stackstrace begin:</span><br><span class="line">./test1() [0x400645]</span><br><span class="line">./test1() [0x400607]</span><br><span class="line">./test1() [0x400612]</span><br><span class="line">./test1() [0x40061d]</span><br><span class="line">./test1() [0x4005ed]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xff) [0x7f5c59a91eff]</span><br><span class="line">./test1() [0x400529]</span><br></pre></td></tr></table></figure>
<p>从上面的运行结果中，我们的确看到了函数的调用栈，但是都是 16 进制的地址，会有点小小的不爽。当然我们可以通过反汇编得到每个地址对应的函数，但这个还是有点麻烦了。不急，且听我慢慢道来，看第 2 步。</p>
</li>
<li>
<p>通过下面的方式编译运行：</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ gcc test.cc -rdynamic -o test2</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ ./test2</span><br><span class="line">stackstrace begin:</span><br><span class="line">./test2(_Z16print_stacktracev+0x26) [0x4008e5]</span><br><span class="line">./test2(_Z4fun1v+0x13) [0x4008a7]</span><br><span class="line">./test2(_Z4fun2v+0x9) [0x4008b2]</span><br><span class="line">./test2(_Z4fun3v+0x9) [0x4008bd]</span><br><span class="line">./test2(main+0x9) [0x40088d]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xff) [0x7f9370186eff]</span><br><span class="line">./test2() [0x4007c9]</span><br></pre></td></tr></table></figure>
<p>这下终于可以看到函数的名字了，对比一下 2 和 1 的编译过程，2 比 1 多了一个 <strong>- rdynamic</strong> 的选项，让我们来看看这个选项是干什么的 (来自 gcc mannual 的说明):</p>
<pre><code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-rdynamic</span><br><span class="line">		Pass the flag -export-dynamic to the ELF linker, on targets that support it. This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. This option is needed for some uses of "dlopen" or to allow obtaining backtraces from within a program.</span><br></pre></td></tr></table></figure>
</code></pre>
<p>从上面的说明可以看出，它的主要作用是让链接器把所有的符号都加入到动态符号表中，这下明白了吧。不过这里还有一个问题，这里的函数名都是 mangle 过的，需要 demangle 才能看到原始的函数。关于 c++ 的 mangle/demangle 机制，不了解的朋友可以在搜索引擎上搜一下，我这里就不多就介绍了。这里介绍如何用命令来 demangle，通过 c++filt 命令便可以:</p>
<pre><code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ c++filt &lt; &lt;&lt; "_Z16print_stacktracev"</span><br><span class="line">print_stacktrace()</span><br></pre></td></tr></table></figure>
</code></pre>
<p>写到这里，大部分工作就 ok 了。不过不知道大家有没有想过这样一个问题，同一个函数可以在代码中多个地方调用，如果我们只是知道函数，而不知道在哪里调用的，有时候还是不够方便，bingo，这个也是有办法的，可以通过 address2line 命令来完成，我们用第 2 步中编译出来的 test2 来做实验 (address2line 的 - f 选项可以打出函数名, -C 选项也可以 demangle)：</p>
<pre><code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ addr2line -a 0x4008a7 -e test2 -f</span><br><span class="line">0x00000000004008a7</span><br><span class="line">_Z4fun1v</span><br><span class="line">??:0</span><br></pre></td></tr></table></figure>
</code></pre>
<p>Oh no，怎么打出来的位置信息是乱码呢？不急，且看我们的第 3 步。</p>
<ol start="3">
<li>
<p>通过下面的方式编译运行：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ gcc test.cc -rdynamic -g -o test3</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ ./test3</span><br><span class="line">stackstrace begin:</span><br><span class="line">./test3(_Z16print_stacktracev+0x26) [0x4008e5]</span><br><span class="line">./test3(_Z4fun1v+0x13) [0x4008a7]</span><br><span class="line">./test3(_Z4fun2v+0x9) [0x4008b2]</span><br><span class="line">./test3(_Z4fun3v+0x9) [0x4008bd]</span><br><span class="line">./test3(main+0x9) [0x40088d]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xff) [0x7fa9558c1eff]</span><br><span class="line">./test3() [0x4007c9]</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ addr2line -a 0x4008a7 -e test3 -f -C</span><br><span class="line">0x00000000004008a7</span><br><span class="line">fun1()</span><br><span class="line">/home/wuzesheng/work/test/test.cc:20</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>看上面的结果，我们不仅得到了调用栈，而且可以得到每个函数的名字，以及被调用的位置，大功告成。在这里需要说明一下的是，第 3 步比第 2 步多了一个 - g 选项，-g 选项的主要作用是生成调试信息，位置信息就属于调试信息的范畴，经常用 gdb 的朋友相信不会对这个选项感到陌生。</p>
<h3 id="在-C-C-程序里打印调用栈信息"><a class="header-anchor" href="#在-C-C-程序里打印调用栈信息">¶</a>在 C/C++ 程序里打印调用栈信息</h3>
<p>我们知道，GDB 的 backtrace 命令可以查看堆栈信息。但很多时候，GDB 根本用不上。比如说，在线上环境中可能没有 GDB，即使有，也不太可能让我们直接在上面调试。如果能让程序自己输出调用栈，那是最好不过了。本文介绍和调用椎栈相关的几个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">    backtrace, backtrace_symbols, backtrace_symbols_fd - support <span class="keyword">for</span> application self-debugging</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">void</span> **buffer, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">char</span> **<span class="title">backtrace_symbols</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">const</span> *buffer, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">backtrace_symbols_fd</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">const</span> *buffer, <span class="keyword">int</span> size, <span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>以上内容源自这几个函数的 man 手册。</p>
<p>先简单介绍一下这几个函数的功能：
<strong>backtrace</strong>：获取当前的调用栈信息，结果存储在 buffer 中，返回值为栈的深度，参数 size 限制栈的最大深度，即最大取 size 步的栈信息。
<strong>backtrace_symbols</strong>：把 backtrace 获取的栈信息转化为字符串，以字符指针数组的形式返回，参数 size 限定转换的深度，一般用 backtrace 调用的返回值。
<strong>backtrace_symbols_fd</strong>：它的功能和 backtrace_symbols 差不多，只不过它不把转换结果返回给调用方，而是写入 fd 指定的文件描述符。</p>
<p>Man 手册里，给出了一个简单的实例，我们看一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  SIZE 100 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, nptrs;</span><br><span class="line">    <span class="keyword">void</span> *buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span> **strings;</span><br><span class="line">    nptrs = backtrace(buffer, SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"backtrace() returned %d addresses\n"</span>, nptrs);</span><br><span class="line">      </span><br><span class="line"> <span class="comment">/* The call backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)  </span></span><br><span class="line"><span class="comment">  *  would produce similar output to the following: */</span></span><br><span class="line">        strings = backtrace_symbols(buffer, nptrs);</span><br><span class="line">    <span class="keyword">if</span> (strings == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"backtrace_symbols"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nptrs; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strings[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(strings);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* "static" means don't export the symbol... */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myfunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myfunc3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> ncalls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ncalls &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        myfunc(ncalls - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        myfunc2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     </span><br><span class="line"> 	<span class="keyword">if</span>  (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s num-calls\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);  </span><br><span class="line">    &#125;</span><br><span class="line">    myfunc(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cc prog.c -o prog</span></span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./prog 0</span></span><br><span class="line">backtrace() returned 6 addresses</span><br><span class="line">./prog() [0x80485a3]</span><br><span class="line">./prog() [0x8048630]</span><br><span class="line">./prog() [0x8048653]</span><br><span class="line">./prog() [0x80486a7]</span><br></pre></td></tr></table></figure>
<p>这样，是输出了调用栈，不过只是以十六进制输出函数地址而已，可读性很差。仔细看下 man 手册，原来很简单，编译时加上个参数：</p>
<p>重新编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cc -rdynamic  prog.c -o prog</span></span><br></pre></td></tr></table></figure>
<p>通过 gcc 手册，我们可以也解下参数的说明:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-rdynamic</span><br><span class="line">        Pass the flag -export-dynamic to the ELF linker, on targets that support it. This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. This option is needed for some uses of "dlopen" or to allow obtaining backtraces from within a program.</span><br></pre></td></tr></table></figure>
<p>再执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./prog 0</span></span><br><span class="line">backtrace() returned 6 addresses</span><br><span class="line">./prog(myfunc3+0x1f) [0x8048763]</span><br><span class="line">./prog() [0x80487f0]</span><br><span class="line">./prog(myfunc+0x21) [0x8048813]</span><br><span class="line">./prog(main+0x52) [0x8048867]</span><br><span class="line">/lib/libc.so.6(__libc_start_main+0xe6) [0xaf9cc6]</span><br><span class="line">./prog() [0x80486b1]</span><br></pre></td></tr></table></figure>
<p>这回，可以看到函数名了。是不是很酷呢？把它封装到你的调试代码中吧。</p>
<hr>
<p><strong>原地址</strong></p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>地表最强大的还有这 14 位程序员</title>
    <url>/public/2020/04/09/cs_fonters/</url>
    <content><![CDATA[<p>原标题：除了 Linus，地表最强大的还有这 14 位程序员，速来膜拜！</p>
<p>导语：IT world 曾经做过一次调查，这个世界上最强大的 15 位程序员，到底是？</p>
<blockquote>
<p>文 / IT world</p>
</blockquote>
<blockquote>
<p>译 / 优达菌</p>
<p>转自 / 优达学城 2018</p>
<p>原文地址 <a href="https://www.sohu.com/a/223302790_700886" target="_blank" rel="noopener">https://www.sohu.com/a/223302790_700886</a></p>
</blockquote>
<p>当和技术基友谈论起 “谁是世界上最顶级的程序员” 的话题时，总是分分钟能引发骂战，优秀的程序员太多了，要评出最优秀的，貌似真的不容易。</p>
<p>IT world 曾经就做过一次调查，当说到谁是世界上健在且最顶级的程序员时，这 15 个人的名字总是能浮现出来，是公认的还是有争议的，是真 · 大神还是伪 · 大神？一起来看看吧~</p>
<img src="/public/2020/04/09/cs_fonters/3e28c4606b644378b652dc9c3716da02.jpeg" style="zoom:33%;">
<a id="more"></a>
<h2 id="Margaret-Hamilton"><a class="header-anchor" href="#Margaret-Hamilton">¶</a>Margaret Hamilton</h2>
<img src="/public/2020/04/09/cs_fonters/264f0ac3e2254ea8b1f91eac42632e1c.jpeg" style="zoom:33%;">
<p>作为 15 位上榜者中唯一女性，玛格丽特被誉为是 “<strong>阿波罗飞行控制软件背后的大脑</strong>”。</p>
<p>作为查尔斯 · 斯塔克 · 德雷珀实验室（Charles Stark Draper Laboratory）软件工程部的老大，她组建了一个团队，负责设计和制造阿波罗舰载飞行控制器软件和空间实验室。</p>
<p>基于这段经历，她开发了通用系统语言（Universal Systems Language）和开发先于事实（ Development Before the Fact）的范例，首先提出异步软件、优先调度和高可信度的软件设计理念。“软件工程（ software engineering）” 这个名字，公认是由她首先发明的。</p>
<p>1986 年，玛格丽特获得了奥古斯塔 · 埃达 · 洛夫莱斯奖，2003 年获得 NASA 卓越太空行动奖。</p>
<p><strong>世人评价：</strong></p>
<p>“她发明了测试，很大程度上规范了美国的计算机工程” —— ford_beeblebrox</p>
<p>“在她之前，计算机编程只是个数学分支。然而这个宇宙空间的飞行控制系统，清晰地将编程引入到一个截然不同的领域。” —— Dan Allen</p>
<p>“... 她发明了‘软件工程’这个词，并作出了最好的示范。” —— David Hamilton</p>
<h2 id="Donald-Knuth"><a class="header-anchor" href="#Donald-Knuth">¶</a>Donald Knuth</h2>
<img src="/public/2020/04/09/cs_fonters/e964fa2bfe7d4e0784b4d1dcc84dd883.jpeg" style="zoom:33%;">
<p>唐纳德 · 克努斯的中文名叫 “高德纳”，几乎是中国程序员永远的偶像之一。他最主要的成就，<strong>就是《计算机编程艺术》的作者。</strong></p>
<p>高德纳写出了计算机编程领域的红宝书，发明了 Tex 数字排版系统，获得了无数的荣耀。1971 年，他获得了第一届葛丽丝 · 穆雷 · 霍普奖（Grace Murray Hopper Award） 奖。1974 年获得了图灵奖，当时他才 36 岁....1979 年又获得了美国国家科学奖章，95 年解锁 IEEE 约翰 · 冯 · 诺依曼奖章，98 年，他入选为计算机历史博物馆名人堂的成员之一。</p>
<p><strong>世人评价：</strong></p>
<p>“... 《计算机编程艺术》这本书，估计是有史以来关于计算机编程最牛逼的贡献。”—— 匿名</p>
<p>“他发明的 TeX ，是我所用过的唯一一个几乎没有 bug 的计算机软件，真让人心悦诚服”—— Jaap Weel</p>
<p>“如果你要问我的话，他简直是前无古人后无来者！” —— Mitch Rees-Jones</p>
<h2 id="Ken-Thompson"><a class="header-anchor" href="#Ken-Thompson">¶</a>Ken Thompson</h2>
<img src="/public/2020/04/09/cs_fonters/71e925e1580c419fbae8df0829706e92.jpeg" style="zoom:33%;">
<p><strong>作为 “Unix 之父”，肯 · 汤普森足够在这个榜单占据一席之地。</strong></p>
<p>他与丹尼斯 · 里奇（Dennis Ritchie）共同创造了 Unix 操作系统。此外，他还发明了 B 语言、UTF-8 字符编码规范、ed 文本编辑器，同时也是 Go 语言的共同开发者之一。</p>
<p>肯 · 汤普森获奖无数，1983 年他获得图灵奖，1994 年获得 IEEE 计算机先锋奖，1998 年获颁美国国家科技奖章。在 1997 年入选成为计算机历史博物馆名人堂的一员。</p>
<p><strong>世人评论：</strong></p>
<p>“... 他可能是有史以来最具成就的程序员了。Unix 内核，Unix 工具，国际象棋程序世界冠军 Belle，Plan 9，Go 语言，无人可比” —— Pete Prokopowicz</p>
<p>“他所做出的贡献影响深刻，而且经得住时间的考验，时至今日，我们还在享受着他的智慧成果。” —— Jan Jannink</p>
<h2 id="Richard-Stallman"><a class="header-anchor" href="#Richard-Stallman">¶</a>Richard Stallman</h2>
<img src="/public/2020/04/09/cs_fonters/efe61b0807d541e3b1c3e8c77210d977.jpeg" style="zoom:33%;">
<p><strong>作为 Emacs 和 GCC 的缔造者，是他最大的成就之一。</strong></p>
<p>理查德是 GNU 项目的创立者，为其开发了很多核心工具，如 Emacs、GCC、GDB 和 GNU Make 等等。他还创办了自由软件基金会。1990 年荣获葛丽丝 · 穆雷 · 霍普奖，1998 年获得 EFF 先锋奖.</p>
<p><strong>世人评论：</strong></p>
<p>“他在编程上的造诣和思想，形成了一整套计算机编程的亚文化。” —— Dan Dunay</p>
<p>“我并不百分百认同他，但不可否认，他的确是足够载入史册的伟大的程序员。” —— Marko Poutiainen</p>
<p>“假设 Linux 写出来的时候，如果没有 GNU 工程的前期工作会怎么样。多亏了他！” —— John Burnette</p>
<h2 id="Anders-Hejlsberg"><a class="header-anchor" href="#Anders-Hejlsberg">¶</a>Anders Hejlsberg</h2>
<img src="/public/2020/04/09/cs_fonters/a1a41004e6af4e9390d7a6aa0b85acf6.jpeg" style="zoom:33%;">
<p>身为 <strong>Turbo Pascal 的缔造者兼 C# 之父</strong>，安德斯也是非常牛逼的！Turbo Pascl 可谓是历史上最受欢迎的编译器之一，也是首个集成开发环境（IDE）。他还主导开发了 Turbo Pascal 的继任者 Delphi ，他还是 C# 的首席架构师。</p>
<p>2001 年，他荣获了 Dr. Dobb 的杰出编程奖</p>
<p>生平： Turbo Pascal 的原作者，是最流行的 Pascal 编译器和第一个集成开发环境。而后，领导了 Turbo Pascal 的继任者 Delphi 的构建。C# 的主要设计师和架构师。2001 年荣获 Dr. Dobb’s 杂志颁发的 “杰出编程奖”。</p>
<p><strong>世人评论：</strong></p>
<p>“他用汇编语言写了 Pascal 编译器，支持当时 PC 端的两种主流操作系统（DOS 和 CP/M）。用它来编译链接程序并运行的时间，从几分钟减少到了几秒钟。” —— Steve Wood</p>
<h2 id="Doug-Cutting"><a class="header-anchor" href="#Doug-Cutting">¶</a>Doug Cutting</h2>
<img src="/public/2020/04/09/cs_fonters/239b715dcfaf4c4e9800dbdbd68009b2.jpeg" style="zoom:33%;">
<p>康婷开发了 Lucene 搜索引擎、 网络爬虫 Nutch 和分布式大型数据处理工具 Hadoop。此外，他还是一位坚定而热情的开源支持者（Lucene、Nutch 以及 Hadoop 都是开源的）。他还担任过前 Apache 软件基金的理事。</p>
<p><strong>世人评论：</strong></p>
<p>“... 他写出了杰出的搜索引擎框架（Lucene/solr），为世界开启大数据之门（Hadoop）。” —— Rajesh Rao</p>
<h2 id="Sanjay-Ghemawat"><a class="header-anchor" href="#Sanjay-Ghemawat">¶</a><strong>Sanjay Ghemawat</strong></h2>
<img src="/public/2020/04/09/cs_fonters/b9ba05338ce64e1e893af0cb86e8af6e.jpeg" style="zoom:33%;">
<p>这位谷歌核心架构师，参与设计和实现了一些谷歌大型分布式系统的功能，包括 MapReduce、BigTable、Spanner 和谷歌文件系统。还编写了 Unix 的 ical 日历系统。</p>
<p>他于 2009 年入选美国国家工程院。2012 年荣获 ACM 计算机科学奖。</p>
<p><strong>世人评论：</strong></p>
<p>“Jeff Dean 的左膀右臂。” —— Ahmet Alp Balkan</p>
<h2 id="Jeff-Dean"><a class="header-anchor" href="#Jeff-Dean">¶</a>Jeff Dean</h2>
<img src="/public/2020/04/09/cs_fonters/a2e2f5bed1484e2ea60d7e84f1a9c5de.jpeg" style="zoom:33%;">
<p>身为谷歌搜索索引的大脑，他参与设计和实现了许多谷歌大型分布式系统的功能，包括网页爬虫，索引搜索，AdSense，MapReduce，BigTable 和 Spanner。</p>
<p>2009 年，杰夫获得美国国家工程院奖。2012 年荣获 ACM SIGOPS 马克 · 维瑟奖和 ACM 计算机科学奖。</p>
<p><strong>世人评论：</strong></p>
<p>“... 他在数据挖掘领域（GFS、MapReduce、BigTable）上取得了重大突破。” —— Natu Lauchande</p>
<h2 id="Linus-Torvalds"><a class="header-anchor" href="#Linus-Torvalds">¶</a>Linus Torvalds</h2>
<img src="/public/2020/04/09/cs_fonters/5bc1912d08ad47b3be77809a49a6d532.jpeg" style="zoom:33%;">
<p>他是 Linux 的缔造者，创建了 Linux 内核与开源的版本控制系统 Git。</p>
<p>1998 年，他获得了 EFF 先锋奖，2000 年荣获英国电脑学会授予的洛夫莱斯勋章，2012 年的千禧技术奖，2014 年 IEEE 计算机学会授予的计算机先锋奖。他同样入选了 2008 年的计算机历史博物馆名人堂。</p>
<p><strong>世人评论：</strong></p>
<p>“他只花了几年，就写出了 Linux 内核，而 GNU Hurd（一个 GNU 开发的内核项目）历经 25 年，却还是一个 demo。” —— Erich Ficker</p>
<p>“他是程序员的程序员。” —— Dan Allen</p>
<h2 id="John-Carmack"><a class="header-anchor" href="#John-Carmack">¶</a>John Carmack</h2>
<img src="/public/2020/04/09/cs_fonters/939e4ce41e844230a7481f54271d6969.jpeg" style="zoom:33%;">
<p>他是 《毁灭战士》Doom 之父， ID Software 的联合创始人，开发了一系列极具影响力的 FPS 游戏，比如《德军总部 3D》（Wolfenstein 3D）、《毁灭战士》（Doom）和《雷神之锤》（Quake）等。</p>
<p>他还是计算机图形技术领域的先锋，在图形学上多次取得重要突破：包括自适应性图块刷新（adaptive tile refresh），二叉空间分割（BSP），以及表面缓存技术等等。</p>
<p>他在 2001 年入选交互式艺术与科学学院名人堂，并在 2007 年和 2008 年两次获得艾美奖工程和技术类奖项，并于 2010 年获得游戏开发者选择终身成就奖。</p>
<p><strong>世人评价：</strong></p>
<p>“他写第一个渲染引擎的时候不到 20 岁。真是个天才。” —— Alex Dolinsky</p>
<p>“... 德军总部 3D、毁灭战士还有雷神之锤，这些革命性的游戏，影响了一代游戏设计师。” —— dniblock</p>
<p>“给他一个周末，他可以写出任何东西....” —— Greg Naughton</p>
<p>“他是编程界的莫扎特...” —— Chris Morris</p>
<h2 id="Fabrice-Bellard"><a class="header-anchor" href="#Fabrice-Bellard">¶</a>Fabrice Bellard</h2>
<img src="/public/2020/04/09/cs_fonters/75c0a9b71a5c4209ae5bceeab7a5d7f9.jpeg" style="zoom:33%;">
<p>他是 QEMU 之父，是众多著名开源软件的作者，包括硬件模拟和虚拟化的平台 QEMU，处理多媒体数据的 FFmpeg，还有 Tiny C 编译器和 LZEXE，这是一个执行文件压缩的软件。</p>
<p>他是 2000 年和 2001 年 C 语言混乱代码大赛的冠军，2011 年 荣获 Google-O'Reilly 开源奖。此外，他还解锁了计算圆周率小数点后位数最多的世界纪录成就。</p>
<p><strong>世人评价：</strong></p>
<p>“我觉得他的工作实在是太伟大了。” —— raphinou</p>
<p>“他简直是世界上最高产的程序员...” —— Pavan Yara</p>
<h2 id="Jon-Skeet"><a class="header-anchor" href="#Jon-Skeet">¶</a>Jon Skeet</h2>
<img src="/public/2020/04/09/cs_fonters/35fc5db1746e495da75a89f408d92e3e.jpeg" style="zoom:33%;">
<p>“他根本不需要调试器，他盯下代码，bug 便会羞愧地原形毕露。” 这是世人对他的评价，他作为 Stack Overflow 传说级贡献者，保持着有史以来在 Stack Overflow 上最高的声誉，要知道，他平均每月解答高达 390 个问题！！！</p>
<p>此外，他还是 Google 工程师，《C# in Depth》的作者。</p>
<p>“如果他的代码没有通过编译，那么编译器应该道歉。” —— Dan Dyer</p>
<p>“他根本不需要什么编程规范，他的代码本身就是编程规范。” —— 匿名</p>
<h2 id="Adam-D-Angelo"><a class="header-anchor" href="#Adam-D-Angelo">¶</a>Adam D'Angelo</h2>
<img src="/public/2020/04/09/cs_fonters/8cb005da7eb146e9a32b8ed72c07012d.jpeg" style="zoom:33%;">
<p>他是” 海外知乎 “—— Quora 的创始人之一，他最早是 Facebook 工程师时，为其搭建了 News Feeds 的基础功能，成为了 Facebook 的 CTO 和 工程 VP。后面离职创办了现在的 Quora 。</p>
<p>他的经历很传奇，2001 年以还是一名高中生的他，在美国计算机奥林匹克竞赛排名上第八位。在 2004 年 ACM 国际大学生编程大赛获得银牌。2005 年闯入了 Topcoder 大学生算法编程挑战赛的决赛。</p>
<p>他是马克 · 扎克伯格的所谓的 6 个人之一（不懂请 Google）</p>
<p><strong>世人评论：</strong></p>
<p>“这是一位万能的程序员。” —— 匿名</p>
<h2 id="Petr-Mitrechev"><a class="header-anchor" href="#Petr-Mitrechev">¶</a><strong>Petr Mitrechev</strong></h2>
<img src="/public/2020/04/09/cs_fonters/a526c7c7edc04910bed60b68bb36990f.jpeg" style="zoom:33%;">
<p>他被誉为 <strong>“有史以来最具竞赛能力的程序员”</strong>，的确，看看他的履历就知道了：2000 年和 2002 年，他在国际信息学奥林匹克竞赛中两次获得金牌。2006 年，赢得 Google 代码挑战赛和 TopCoder 公开算法大赛冠军。他还是两次 Facebook 黑客杯的冠军。</p>
<p><strong>世人评价：</strong></p>
<p>“他简直是竞技程序员的偶像，即使是在我们印度” —— Kavish Dwivedi</p>
<h2 id="Gennady-Korotkevich"><a class="header-anchor" href="#Gennady-Korotkevich">¶</a><strong>Gennady Korotkevich</strong></h2>
<img src="/public/2020/04/09/cs_fonters/75da2050fc004f0d84956dc62fdd4dae.jpeg" style="zoom:33%;">
<p>榜单最后一位，是位竞技编程小神童，他是国际信息学奥林匹克竞赛的历史中，年纪最小参赛者（11 岁），并且 6 次获得金牌 (2007~2012)。2013 年，他在 ACM 国际大学生编程大赛获胜，同时还是 2014 Facebook 黑客杯的获胜者。</p>
<p>写这篇文章的时候，他在 Codeforces 榜排名第一 （ID：Tourist）、TopCoder 榜也是第一。</p>
<p><strong>世人评价：</strong></p>
<p>“当之无愧的编程神童！” —— Prateek Joshi</p>
<p><strong>大神级别的程序员太多了！并不是一篇文章就能说明白道清楚，如果你还有推荐的大神，欢迎在本文评论中和大家分享下。</strong></p>
<p>— 完 —</p>
]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>人物</tag>
      </tags>
  </entry>
  <entry>
    <title>选择困难者的福音？层次分析法</title>
    <url>/public/2021/04/02/math_AHP/</url>
    <content><![CDATA[<p><strong>摘要</strong></p>
<p>日常生活中，我们面临很多的选择，选择工作offer，选择买哪个牌子的手机，选择哪个地方旅行等等。这些选择难以定量的衡量，有很多不确定性。内心小纠结，我选择了这个，万一那个好呢，怎么办？请看层次分析法。</p>
<p>层次分析法(Analytic Hierarchy Process，简称 AHP)是对一些较为复杂、较为模糊的问题作出决策的简易方法，它特别适用于那些难于完全定量分析的问题。它是美国运筹学家 T. L. Saaty 教授于上世纪 70 年代初期提出的一种简便、灵活而又实用的多准则决策方法。</p>
<p>运用层次分析法建模，大体上可按下面四个步骤进行</p>
<ul>
<li>建立递阶层次结构模型</li>
<li>构造出各层次中的所有判断矩阵</li>
<li>层次单排序及一致性检验</li>
<li>层次总排序及一致性检验。（一般不用）</li>
</ul>
<a id="more"></a>
<p>让我们从offer大佬的例子开始吧！</p>
<p>举个栗子，今年有位大学生，有三个offer，C1 C2 C3。</p>
<p>第一步，建立层次模型。</p>
<ul>
<li>目标层A：找工作的目标，自己满意程度。
<ul>
<li>这个程度怎么计算呢？比如工作1。</li>
</ul>
</li>
<li>准则层B：研究课题、发展前途、待遇、同事情况、地理位置、单位名气等等。
<ul>
<li>尽量列全一点，不需要排列重要顺序。</li>
<li>小于等于9个，后面要两两拍脑袋给出相对的重要层度，给多了不得把脑袋拍疼了。</li>
<li>也可以有子准则层，比如待遇中的放假、工作环境等等，列出也小于9个。</li>
</ul>
</li>
<li>方案层C：就是我们的offer</li>
</ul>
<img src="/public/2021/04/02/math_AHP/image-20200406145535585.png" alt="image-20200406145535585" style="zoom:50%;">
<h2 id="构造-A-B-之间判断矩阵"><a class="header-anchor" href="#构造-A-B-之间判断矩阵">¶</a>构造 A B 之间判断矩阵</h2>
<p>准则层B与目标A之间的关系。为了求出准则层中(B1-6) 对目标的重要层度的排序。比如对于该生工作满意度第一重要是待遇，然后是地点，其实该生自己也很模糊。就是固定A，然后求B中准则，对A重要性的排序。</p>
<h3 id="我们怎么对B中的准则们的重要排序呢？"><a class="header-anchor" href="#我们怎么对B中的准则们的重要排序呢？">¶</a>我们怎么对B中的准则们的重要排序呢？</h3>
<p>直接给每一个准则，0-1的评分，然后排序。经常会想，给完分之后，这个不合理呀要不我再给哪个准则加加分。所以这样的方法常常会因考虑不周全、顾此失彼而使决策者提出与他实际认为的重要性程度不相一致的数据。</p>
<p>我们可以将这个过程细化，我就比较两个准则对于目标的重要性，然后通过下面的矩阵方法，求出优先顺序。</p>
<p>还能通过一个一致性检验，来检验在你评分的过程中，有没有自相矛盾的地方，当然这种方法允许一些自相矛盾。反正评分的时候尊从内心拍脑袋就对了。</p>
<p>所以我们拿出一个B1 与 B2 对于目标的重要，想一想然后给出B2/B1，填入下面的表格中的(2,1)的位置。</p>
<p>整个矩阵i,j 与j，i 是取倒数的关系，所以只要做一半。</p>
<p>在找工作的目标下，准则i与j相对的重要性表示，B2/B1 的值。采用9个标度。而相比不重要刻度取倒数就可以了</p>
<table>
<thead>
<tr>
<th>准则i比j的比较</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>相同重要</td>
<td></td>
<td>比较重要</td>
<td></td>
<td>明显重要</td>
<td></td>
<td>强烈重要</td>
<td></td>
<td>极端重要</td>
</tr>
</tbody>
</table>
<p>最后的两两相对重要表格</p>
<img src="/public/2021/04/02/math_AHP/image-20200406145640316.png" alt="image-20200406145640316" style="zoom:50%;">
<p>对角线对称的两个数互为倒数，即 $$a_{ji}=\frac{1}{a_{ij}}$$  B1/B2 不就是和 B2/B1互为倒数嘛</p>
<p>从心理学观点来看，分级太多会超越人们的判断能力，既增加了作判断的难度， 又容易因此而提供虚假数据。Saaty 等人还用实验方法比较了在各种不同标度下人们判断结果的正确性，实验结果也表明，采用 1~9 标度最为合适。</p>
<p>判断矩阵的一致性指标步骤：</p>
<ul>
<li>1）计算一致性指标 CI 。$$CI=\frac{ \lambda_{max}-n}{n-1}$$</li>
<li>2）查表，平均随机一致性指标 RI。</li>
</ul>
<table>
<thead>
<tr>
<th>n</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>RI</td>
<td>0</td>
<td>0</td>
<td>0.58</td>
<td>0.90</td>
<td>1.12</td>
<td>1.24</td>
<td>1.32</td>
<td>1.41</td>
<td>1.45</td>
</tr>
</tbody>
</table>
<blockquote>
<p><em>RI</em> 的值是这样得到的，用随机方法构造500个样本矩阵:随机地从1~9及其倒数中抽取数字构造正互反矩阵，求得最大特征根的平均值 $$\bar \lambda_{max}$$ 并定义$$RI=\frac{\bar \lambda_{max}-n}{n-1}$$</p>
</blockquote>
<ul>
<li>3）计算一致性比例CR。 $$CR=\frac{CI}{RI}$$，当$$CR&lt;0.10$$ 时，认为判断矩阵的一致性是可以接受的，否则应对判断矩阵作适当修正。</li>
</ul>
<p>如果一个矩阵满足上面的条件，那么它最大特征值对应的特征向量就可以认为是每个维度的重要性权重。</p>
<h2 id="构造-B-C-之间判断矩阵"><a class="header-anchor" href="#构造-B-C-之间判断矩阵">¶</a>构造 B C 之间判断矩阵</h2>
<p>相同的方法，在同一B准则下，考虑不同工作的优先顺序。求工作排序的方法，和上面一样。</p>
<img src="/public/2021/04/02/math_AHP/image-20200406162644137.png" alt="image-20200406162644137" style="zoom:50%;">
<p>python代码<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AHP</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, criteria, b)</span>:</span></span><br><span class="line">        self.RI = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.58</span>, <span class="number">0.9</span>, <span class="number">1.12</span>, <span class="number">1.24</span>, <span class="number">1.32</span>, <span class="number">1.41</span>, <span class="number">1.45</span>, <span class="number">1.49</span>)</span><br><span class="line">        self.criteria = criteria</span><br><span class="line">        self.b = b</span><br><span class="line">        self.num_criteria = criteria.shape[<span class="number">0</span>]</span><br><span class="line">        self.num_project = b[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cal_weights</span><span class="params">(self, input_matrix)</span>:</span></span><br><span class="line">        input_matrix = np.array(input_matrix)</span><br><span class="line">        n, n1 = input_matrix.shape</span><br><span class="line">        <span class="keyword">assert</span> n == n1, <span class="string">'不是一个方阵'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> np.abs(input_matrix[i, j] * input_matrix[j, i] - <span class="number">1</span>) &gt; <span class="number">1e-7</span>:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(<span class="string">'不是反互对称矩阵'</span>)</span><br><span class="line"></span><br><span class="line">        eigenvalues, eigenvectors = np.linalg.eig(input_matrix)</span><br><span class="line"></span><br><span class="line">        max_idx = np.argmax(eigenvalues)</span><br><span class="line">        max_eigen = eigenvalues[max_idx].real</span><br><span class="line">        eigen = eigenvectors[:, max_idx].real</span><br><span class="line">        eigen = eigen / eigen.sum()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">9</span>:</span><br><span class="line">            CR = <span class="literal">None</span></span><br><span class="line">            warnings.warn(<span class="string">'无法判断一致性'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            CI = (max_eigen - n) / (n - <span class="number">1</span>)</span><br><span class="line">            CR = CI / self.RI[n]</span><br><span class="line">        <span class="keyword">return</span> max_eigen, CR, eigen</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        max_eigen, CR, criteria_eigen = self.cal_weights(self.criteria)</span><br><span class="line">        print(<span class="string">'准则层：最大特征值&#123;:&lt;5f&#125;,CR=&#123;:&lt;5f&#125;,检验&#123;&#125;通过'</span>.format(max_eigen, CR, <span class="string">''</span> <span class="keyword">if</span> CR &lt; <span class="number">0.1</span> <span class="keyword">else</span> <span class="string">'不'</span>))</span><br><span class="line">        print(<span class="string">'准则层权重=&#123;&#125;\n'</span>.format(criteria_eigen))</span><br><span class="line"></span><br><span class="line">        max_eigen_list, CR_list, eigen_list = [], [], []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.b:</span><br><span class="line">            max_eigen, CR, eigen = self.cal_weights(i)</span><br><span class="line">            max_eigen_list.append(max_eigen)</span><br><span class="line">            CR_list.append(CR)</span><br><span class="line">            eigen_list.append(eigen)</span><br><span class="line"></span><br><span class="line">        pd_print = pd.DataFrame(eigen_list,</span><br><span class="line">                                index=[<span class="string">'准则'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num_criteria)],</span><br><span class="line">                                columns=[<span class="string">'方案'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num_project)],</span><br><span class="line">                                )</span><br><span class="line">        pd_print.loc[:, <span class="string">'最大特征值'</span>] = max_eigen_list</span><br><span class="line">        pd_print.loc[:, <span class="string">'CR'</span>] = CR_list</span><br><span class="line">        pd_print.loc[:, <span class="string">'一致性检验'</span>] = pd_print.loc[:, <span class="string">'CR'</span>] &lt; <span class="number">0.1</span></span><br><span class="line">        print(<span class="string">'方案层'</span>)</span><br><span class="line">        print(pd_print)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 目标层</span></span><br><span class="line">        obj = np.dot(criteria_eigen.reshape(<span class="number">1</span>, <span class="number">-1</span>), np.array(eigen_list))</span><br><span class="line">        print(<span class="string">'\n目标层'</span>, obj)</span><br><span class="line">        print(<span class="string">'最优选择是方案&#123;&#125;'</span>.format(np.argmax(obj)))</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 准则重要性矩阵</span></span><br><span class="line">    criteria = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">7</span>, <span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span> / <span class="number">3</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">5</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">5</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对每个准则，方案优劣排序</span></span><br><span class="line">    b1 = np.array([[<span class="number">1</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span> / <span class="number">8</span>], [<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">3</span>], [<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>]])</span><br><span class="line">    b2 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span> / <span class="number">5</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">    b3 = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span>]])</span><br><span class="line">    b4 = np.array([[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">    b5 = np.array([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span> / <span class="number">2</span>], [<span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">4</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    b = [b1, b2, b3, b4, b5]</span><br><span class="line">    a = AHP(criteria, b).run()</span><br></pre></td></tr></table></figure>
<h2 id="层次分析法与控制变量法"><a class="header-anchor" href="#层次分析法与控制变量法">¶</a>层次分析法与控制变量法</h2>
<p>我们的任务是选择工作，最后使得我们满意，直接选择我们当然一头雾水。所以我们设立一些准则，然后对这些准则对于目标的重要性排序。</p>
<p>这又有点像概率图模型，只是赋权的方法，是相互比较的方法。</p>
<h2 id="选择困难者的福音？"><a class="header-anchor" href="#选择困难者的福音？">¶</a>选择困难者的福音？</h2>
<p>层次分析法对人们的思维过程进行了加工整理，提出了一套系统分析问题的方法，为科学管理和决策提供了较有说服力的依据。</p>
<p>在应用层次分析法研究问题时，遇到的主要困难有两个:
(1) 如何根据实际情况抽象出较为贴切的层次结构;
(2) 如何将某些定性的量作比较接近实际定量化处理。</p>
<p>层次分析法的其局限性<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：
(1) 它在很大程度上依赖于人们的经验，主观因素的影响很大，它至多只能排除思维过程中的严重非一致性，却无法排除决策者个人可能存在的严重片面性。
(2) 比较、 判断过程较为粗糙，不能用于精度要求较高的决策问题。</p>
<p>所以，AHP 至多只能算是一种半定量(或定性与定量结合)的方法。
本文仅供参考，不负法律责任，哈哈。</p>
<p>参考</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>幼鹰me 知乎 <a href="https://zhuanlan.zhihu.com/p/101505929" target="_blank" rel="noopener">层次分析法原理与Python实现</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>司守奎《数学建模算法与程序》第八章 层次分析法 P167 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>层次分析法</tag>
      </tags>
  </entry>
  <entry>
    <title>RSS跟踪github文件更新+某管子更新</title>
    <url>/public/2021/07/24/rss_github_file/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>好久没有更新博客了。RSS这种形式的信息获取方式，似乎又流行起来。</p>
<a id="more"></a>
<h2 id="github文件更新"><a class="header-anchor" href="#github文件更新">¶</a>github文件更新</h2>
<p>github上面有很多不错的资源。我的流程是：github readme文件更新-&gt;svn下载对应文件-&gt;生成rss文件。</p>
<p>这里为什么要这么复杂，因为github仓库更新多了好多不需要的rss信息，而且github文件下载比较慢。</p>
<p>最后效果，获取《经济学人》和《纽约客》的更新～</p>
<p><img src="/public/2021/07/24/rss_github_file/rss_result.png" alt="image-20210724005152399"></p>
<h3 id="下载脚本"><a class="header-anchor" href="#下载脚本">¶</a>下载脚本</h3>
<p>解析readme中的地址，自动下载，并生成rss源。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># /etc/cron.hour </span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> rfeed <span class="keyword">import</span> * <span class="comment"># 为生成rss.xml的库</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line">URL=<span class="string">"https://raw.githubusercontent.com/hehonghui/the-economist-ebooks/master/README.md"</span></span><br><span class="line">BASE_URL=<span class="string">"http://your_vps_host/download/"</span></span><br><span class="line"></span><br><span class="line">SVN_BASE_URL=<span class="string">"https://github.com/hehonghui/the-economist-ebooks/trunk/"</span></span><br><span class="line"></span><br><span class="line">s=<span class="string">"""</span></span><br><span class="line"><span class="string">* [经济学人 - 周刊, 点击这里下载最新一期](01_economist/te_2021.02.27) , 每周五十一点更新</span></span><br><span class="line"><span class="string">* [纽约客 - 周刊, 点击这里下载最新一期](02_new_yorker/2021.03.01) , 每周六上午更新</span></span><br><span class="line"><span class="string">* [卫报 - 每周两期](09_guardian/), 每周三、周日更新</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">s = request.urlopen(URL).read().decode(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">res= re.findall(<span class="string">r"\[.+\]\((0.+)\)"</span>,s)[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># generate xml</span></span><br><span class="line">res_list=[]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">	res_list+=sorted(glob(item.split(<span class="string">'/'</span>)[<span class="number">0</span>]+<span class="string">"/*"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">item_list=[]</span><br><span class="line">print(item_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> res_list:</span><br><span class="line">    _one = Item(</span><br><span class="line">			title = item[<span class="number">3</span>:],</span><br><span class="line">        link = BASE_URL+item,</span><br><span class="line">		description = <span class="string">'pdf etc. &lt;a href="%s"&gt;link&lt;/a&gt; '</span>% (BASE_URL+item),</span><br><span class="line">        author = <span class="string">"hehonghui"</span>,</span><br><span class="line">        guid = Guid(BASE_URL+item),</span><br><span class="line">        pubDate = datetime.datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>)) <span class="comment"># year, month, date, hh, mm, ss</span></span><br><span class="line">    item_list+=[_one]</span><br><span class="line"></span><br><span class="line">feed = Feed(</span><br><span class="line">        title = <span class="string">"经济学人+纽约客更新"</span>,</span><br><span class="line">        link = <span class="string">"https://www.xxxxx.biz/atom/updated.xml"</span>,</span><br><span class="line">        description = <span class="string">"更新经济学人，纽约客"</span>,</span><br><span class="line">        language = <span class="string">"en-US"</span>,</span><br><span class="line">        lastBuildDate = datetime.datetime.now(),</span><br><span class="line">        items = item_list)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_file</span><span class="params">(file_name, contents)</span>:</span></span><br><span class="line">    fh = open(file_name, <span class="string">'w'</span>)</span><br><span class="line">    fh.write(contents)</span><br><span class="line">    fh.close()</span><br><span class="line"></span><br><span class="line">save_to_file(<span class="string">'test.xml'</span>, feed.rss())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># start downing </span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> res_list:</span><br><span class="line">	    print(<span class="string">"downing %s"</span>%item)</span><br><span class="line">	    os.popen(<span class="string">"svn checkout %s %s"</span>%(SVN_BASE_URL+item,item))</span><br><span class="line"></span><br><span class="line">    _now=sorted(glob(item.split(<span class="string">'/'</span>)[<span class="number">0</span>]+<span class="string">"/*"</span>))</span><br><span class="line">    print(_now)</span><br><span class="line">    <span class="keyword">if</span> len(_now)&gt;=<span class="number">5</span>: <span class="comment"># 最多5个，免得服务器下载过多。</span></span><br><span class="line">        <span class="keyword">for</span> _d <span class="keyword">in</span> _now[:<span class="number">-5</span>]:</span><br><span class="line">            os.popen(<span class="string">"rm -rf %s"</span>%_d)</span><br></pre></td></tr></table></figure>
<p>在linux亦可使用<a href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html" target="_blank" rel="noopener">crontab</a>定时启动下载任务。在 <code>/etc/cron.hourly/</code> 设置即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">date &gt;&gt; test.log</span><br><span class="line">python3 down_ecomic.py &gt;&gt;test.log</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<h2 id="下载某管音频，自动转成mp3格式"><a class="header-anchor" href="#下载某管音频，自动转成mp3格式">¶</a>下载某管音频，自动转成mp3格式</h2>
<p>某管自带rss的，所以只要用feedparser解析一下，然后调用youtube_dl下载一哈。
各种码包自行安装，哈。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2020-04-18</span></span><br><span class="line"><span class="comment"># /etc/cron.hour # https://www.runoob.com/w3cnote/linux-crontab-tasks.html</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> rfeed <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line">URL=<span class="string">"https://www.youtube.com/feeds/videos.xml?channel_id=UCFhp6N5z8W9Ann2eyHAzbbA"</span></span><br><span class="line">rss = feedparser.parse(URL)</span><br><span class="line">entries=rss[<span class="string">'entries'</span>][:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">BASE_URL=<span class="string">"http://xxxxx/down_youtube/"</span></span><br><span class="line"></span><br><span class="line">item_list=[]</span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> entries:</span><br><span class="line">    print(entry[<span class="string">'title'</span>])</span><br><span class="line">    print(entry[<span class="string">'published'</span>])</span><br><span class="line">    print(entry[<span class="string">'link'</span>])</span><br><span class="line">    <span class="comment">#print(entry['summary'])</span></span><br><span class="line">    new_link=BASE_URL+<span class="string">"book_audios/%s.mp3"</span>%entry[<span class="string">'yt_videoid'</span>]</span><br><span class="line">    _one = Item(</span><br><span class="line">			title = entry[<span class="string">'title'</span>],</span><br><span class="line">        link = new_link,</span><br><span class="line">		description = <span class="string">'audio: &lt;a href="%s"&gt;mp3&lt;/a&gt; %s'</span>% (new_link,entry[<span class="string">'summary'</span>]),</span><br><span class="line">        author = <span class="string">"Youtube"</span>,</span><br><span class="line">        guid = Guid(new_link),</span><br><span class="line">        pubDate = datetime.datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>)) <span class="comment"># year, month, date, hh, mm, ss</span></span><br><span class="line">    item_list+=[_one]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">feed = Feed(</span><br><span class="line">        title = <span class="string">"知乎读书会更新"</span>,</span><br><span class="line">        link = <span class="string">"https://www.xxxxx.biz/atom/updated.xml"</span>,</span><br><span class="line">        description = <span class="string">"更新Youtube知乎读书会"</span>,</span><br><span class="line">        language = <span class="string">"en-US"</span>,</span><br><span class="line">        lastBuildDate = datetime.datetime.now(),</span><br><span class="line">        items = item_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_file</span><span class="params">(file_name, contents)</span>:</span></span><br><span class="line">    fh = open(file_name, <span class="string">'w'</span>)</span><br><span class="line">    fh.write(contents)</span><br><span class="line">    fh.close()</span><br><span class="line"></span><br><span class="line">save_to_file(<span class="string">'audio.xml'</span>, feed.rss())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> rename</span><br><span class="line"><span class="keyword">import</span> youtube_dl</span><br><span class="line"></span><br><span class="line"><span class="comment"># start downing </span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">"book_audios/"</span>):</span><br><span class="line">    os.makedirs(<span class="string">"book_audios/"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">audio_download</span><span class="params">(youtube_url)</span>:</span></span><br><span class="line">    <span class="comment"># 定义某些下载参数</span></span><br><span class="line">    ydl_opts = &#123;</span><br><span class="line">        <span class="string">'format'</span>: <span class="string">'bestaudio/best'</span>,</span><br><span class="line">     <span class="comment">#   'download_archive': 'downloaded_songs.txt',</span></span><br><span class="line">        <span class="string">'outtmpl'</span>: <span class="string">'book_audios/%(id)s.%(ext)s'</span>,</span><br><span class="line">        <span class="string">'postprocessors'</span>: [&#123;</span><br><span class="line">            <span class="string">'key'</span>: <span class="string">'FFmpegExtractAudio'</span>,</span><br><span class="line">            <span class="string">'preferredcodec'</span>: <span class="string">'mp3'</span>,</span><br><span class="line">            <span class="string">'preferredquality'</span>: <span class="string">'192'</span>,</span><br><span class="line">            &#125;],</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> youtube_dl.YoutubeDL(ydl_opts) <span class="keyword">as</span> ydl:</span><br><span class="line">        ydl.download([youtube_url])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#download('https://www.youtube.com/watch?v=JElpSrsmbTU')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> entries:</span><br><span class="line">    <span class="keyword">if</span> entry[<span class="string">'yt_videoid'</span>]+<span class="string">'.mp3'</span> <span class="keyword">not</span> <span class="keyword">in</span> os.listdir(<span class="string">'book_audios'</span>):</span><br><span class="line">        print(<span class="string">"downing %s, %s"</span>%(entry[<span class="string">'title'</span>], entry[<span class="string">'link'</span>]))</span><br><span class="line">        audio_download(entry[<span class="string">'link'</span>])</span><br><span class="line">   </span><br><span class="line">    _now=sorted(glob(<span class="string">"book_audios/*"</span>),key=os.path.getctime)</span><br><span class="line">    print(_now)</span><br><span class="line">    <span class="keyword">if</span> len(_now)&gt;=<span class="number">6</span>: <span class="comment"># 多余删除</span></span><br><span class="line">        <span class="keyword">for</span> _d <span class="keyword">in</span> _now[:<span class="number">-5</span>]:</span><br><span class="line">            os.popen(<span class="string">"rm -rf %s"</span>%_d)</span><br></pre></td></tr></table></figure>
<h2 id="下载某管视频"><a class="header-anchor" href="#下载某管视频">¶</a>下载某管视频</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2020-04-18</span></span><br><span class="line"><span class="comment"># /etc/cron.hour # https://www.runoob.com/w3cnote/linux-crontab-tasks.html</span></span><br><span class="line"><span class="comment"># pip install feedparser youtube_dl</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> rfeed <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> rename</span><br><span class="line"><span class="keyword">import</span> youtube_dl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_file</span><span class="params">(file_name, contents)</span>:</span></span><br><span class="line">    fh = open(file_name, <span class="string">'w'</span>)</span><br><span class="line">    fh.write(contents)</span><br><span class="line">    fh.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">audio_download</span><span class="params">(youtube_url, file_root, only_audio=False)</span>:</span></span><br><span class="line">    <span class="comment"># 定义某些下载参数</span></span><br><span class="line">    ydl_opts = &#123;</span><br><span class="line">        <span class="string">'format'</span>: <span class="string">'best'</span>,</span><br><span class="line">        <span class="string">'outtmpl'</span>: file_root+<span class="string">'/%(id)s.%(ext)s'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment"># 定义某些下载参数</span></span><br><span class="line">    ydl_opts_a = &#123;</span><br><span class="line">        <span class="string">'format'</span>: <span class="string">'bestaudio/best'</span>,</span><br><span class="line">     <span class="comment">#   'download_archive': 'downloaded_songs.txt',</span></span><br><span class="line">        <span class="string">'outtmpl'</span>: file_root+<span class="string">'/%(id)s.%(ext)s'</span>,</span><br><span class="line">        <span class="string">'postprocessors'</span>: [&#123;</span><br><span class="line">            <span class="string">'key'</span>: <span class="string">'FFmpegExtractAudio'</span>,</span><br><span class="line">            <span class="string">'preferredcodec'</span>: <span class="string">'mp3'</span>,</span><br><span class="line">            <span class="string">'preferredquality'</span>: <span class="string">'192'</span>,</span><br><span class="line">            &#125;],</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> only_audio:</span><br><span class="line">        ydl_opts = ydl_opts_a</span><br><span class="line">    <span class="keyword">with</span> youtube_dl.YoutubeDL(ydl_opts) <span class="keyword">as</span> ydl:</span><br><span class="line">        ydl.download([youtube_url])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YoutubeDowner</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, yurl, burl, file_root, feed_title, only_audio=False)</span>:</span></span><br><span class="line">        self.yurl = yurl</span><br><span class="line">        self.burl = burl</span><br><span class="line">        self.file_root = file_root</span><br><span class="line">        self.feed_title = feed_title</span><br><span class="line">        self.feed_des = feed_title</span><br><span class="line">        self.only_audio = only_audio</span><br><span class="line">        self.type_name = <span class="string">"mp4"</span></span><br><span class="line">        <span class="keyword">if</span> only_audio:</span><br><span class="line">            self.type_name = <span class="string">"mp3"</span></span><br><span class="line"></span><br><span class="line">        rss = feedparser.parse(yurl)</span><br><span class="line">        self.entries = rss[<span class="string">'entries'</span>][:<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_root):</span><br><span class="line">            os.makedirs(file_root)</span><br><span class="line">        self.generate_xml()</span><br><span class="line"></span><br><span class="line">        self.down()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_xml</span><span class="params">(self)</span>:</span></span><br><span class="line">        item_list = []</span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> self.entries:</span><br><span class="line">            print(entry[<span class="string">'title'</span>],entry[<span class="string">'published'</span>],entry[<span class="string">'link'</span>])</span><br><span class="line">           <span class="comment"># print(entry['summary'])</span></span><br><span class="line">            date_s = entry[<span class="string">'published'</span>].split(<span class="string">'T'</span>)[<span class="number">0</span>].split(<span class="string">'-'</span>)</span><br><span class="line">            dates = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> date_s]</span><br><span class="line">            <span class="comment"># print(dates)</span></span><br><span class="line">            new_link = self.burl + <span class="string">"/%s.%s"</span> % (entry[<span class="string">'yt_videoid'</span>],self.type_name) <span class="comment"># 下载的实际地址</span></span><br><span class="line">            print(<span class="string">'%s: &lt;a href="%s"&gt;%s&lt;/a&gt; &lt;pre&gt;%s&lt;/pre&gt;'</span> % (self.type_name,new_link,self.type_name,entry[<span class="string">'summary'</span>]))</span><br><span class="line">            _one = Item(</span><br><span class="line">                    title = entry[<span class="string">'title'</span>],</span><br><span class="line">                link = new_link,</span><br><span class="line">                description = <span class="string">'%s: &lt;a href="%s"&gt;%s&lt;/a&gt; &lt;pre&gt;%s&lt;/pre&gt;'</span> % (self.type_name,new_link,self.type_name,entry[<span class="string">'summary'</span>]),</span><br><span class="line">                author = <span class="string">"Youtube"</span>,</span><br><span class="line">                guid = Guid(new_link),</span><br><span class="line">                pubDate = datetime.datetime(dates[<span class="number">0</span>], dates[<span class="number">1</span>], dates[<span class="number">2</span>], <span class="number">6</span>, <span class="number">0</span>)) <span class="comment"># year, month, date, hh, mm, ss</span></span><br><span class="line">            item_list+=[_one]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        feed = Feed(</span><br><span class="line">                title = self.feed_title,</span><br><span class="line">                link = <span class="string">"https://www.xxxxx.biz/atom/updated.xml"</span>,</span><br><span class="line">                description = self.feed_des,</span><br><span class="line">                language = <span class="string">"en-US"</span>,</span><br><span class="line">                lastBuildDate = datetime.datetime.now(),</span><br><span class="line">                items = item_list)</span><br><span class="line"></span><br><span class="line">        save_to_file(<span class="string">'%s.xml'</span> % self.file_root, feed.rss())</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">down</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> self.entries:</span><br><span class="line">            <span class="keyword">if</span> entry[<span class="string">'yt_videoid'</span>]+<span class="string">'.'</span>+self.type_name <span class="keyword">not</span> <span class="keyword">in</span> os.listdir(self.file_root):</span><br><span class="line">                print(<span class="string">"downing %s, %s"</span>%(entry[<span class="string">'title'</span>], entry[<span class="string">'link'</span>]))</span><br><span class="line">                audio_download(entry[<span class="string">'link'</span>], self.file_root, self.only_audio)</span><br><span class="line">    </span><br><span class="line">        _now = sorted(glob(self.file_root + <span class="string">"/*"</span>),key=os.path.getctime)</span><br><span class="line">        print(_now)</span><br><span class="line">        <span class="keyword">if</span> len(_now)&gt;=<span class="number">6</span>: <span class="comment"># 多余删除</span></span><br><span class="line">            <span class="keyword">for</span> _d <span class="keyword">in</span> _now[:<span class="number">-5</span>]:</span><br><span class="line">                os.popen(<span class="string">"rm -rf %s"</span>%_d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># url_rss = "https://www.youtube.com/feeds/videos.xml?channel_id=UCSs4A6HYKmHA2MG_0z-F0xw"</span></span><br><span class="line"><span class="comment"># url_base="http://xxxxx/"</span></span><br><span class="line"><span class="comment"># root="rss2"</span></span><br><span class="line"><span class="comment"># title="李永乐老师"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># YoutubeDowner(url_rss, url_base, root, title)</span></span><br></pre></td></tr></table></figure>
<p>最后效果如下：</p>
<p><img src="/public/2021/07/24/rss_github_file/20220511-00-35-57.png" alt></p>
<p>祝大家使用愉快！</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>RSS</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】window软件运行时间</title>
    <url>/public/2022/04/15/soft_run_time/</url>
    <content><![CDATA[<h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2>
<p>对关注性能的程序开发人员而言，一个好的计时部件既是益友，也是良师。计时器既可以作为程序组件帮助程序员精确的控制程序进程，又是一件有力的调试武器，在有经验的程序员手里可以尽快的确定程序的性能瓶颈，或者对不同的算法作出有说服力的性能比较。</p>
<a id="more"></a>
<p>在Windows平台下，常用的计时器有两种，一种是<code>timeGetTime</code>多媒体计时器，它可以提供毫秒级的计时。但这个精度对很多应用场合而言还是太粗糙了。另一种是<code>QueryPerformanceCount</code>计数器，随系统的不同可以提供微秒级的计数。对于实时图形处理、多媒体数据流处理、或者实时系统构造的程序员，善用<code>QueryPerformanceCount/QueryPerformanceFrequency</code>是一项基本功。</p>
<p>本文要介绍的，是另一种直接利用<code>Pentium CPU</code>内部时间戳进行计时的高精度计时手段。以下讨论主要得益于<code>《Windows图形编程》</code>一书，第15页－17页，有兴趣的读者可以直接参考该书。关于RDTSC指令的详细讨论，可以参考Intel产品手册。本文仅仅作抛砖之用。</p>
<p>在 <code>Intel Pentium</code>以上级别的CPU中，有一个称为“时间戳（Time   Stamp）”的部件，它以64位无符号整型数的格式，记录了自CPU上电以来所经过的时钟周期数。由于目前的CPU主频都非常高，因此这个部件可以达到纳秒级的计时精度。这个精确性是上述两种方法所无法比拟的。</p>
<p>在Pentium以上的CPU中，提供了一条机器指令RDTSC（Read Time   Stamp Counter）来读取这个时间戳的数字，并将其保存在EDX:EAX寄存器对中。由于<code>EDX:EAX</code>寄存器对恰好是Win32平台下C++语言保存函数返回值的寄存器，所以我们可以把这条指令看成是一个普通的函数调用。像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline   unsigned   __int64   GetCycleCount()   </span><br><span class="line">&#123;   </span><br><span class="line">  __asm   RDTSC   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是不行，因为RDTSC不被C++的内嵌汇编器直接支持，所以我们要用_emit伪指令直接嵌入该指令的机器码形式<code>0X0F</code>、<code>0X31</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  inline   unsigned   __int64   GetCycleCount()   </span><br><span class="line">  &#123;   </span><br><span class="line">    __asm   _emit   0x0F   </span><br><span class="line">    __asm   _emit   0x31   </span><br><span class="line">  &#125;   </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">以后在需要计数器的场合，可以像使用普通的Win32   API一样，调用两次GetCycleCount函数，比较两个返回值的差，像这样：</span><br></pre></td></tr></table></figure>
<p>unsigned   long   t;<br>
t   =   (unsigned   long)GetCycleCount();<br>
//Do   Something   time-intensive   ...<br>
t   -=   (unsigned   long)GetCycleCount();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">`《Windows图形编程》`第15页编写了一个类，把这个计数器封装起来。有兴趣的读者可以去参考那个类的代码。作者为了更精确的定时，做了一点小小的改进，把执行`RDTSC`指令的时间，通过连续两次调用`GetCycleCount`函数计算出来并保存了起来，以后每次计时结束后，都从实际得到的计数中减掉这一小段时间，以得到更准确的计时数字。但我个人觉得这一点点改进意义不大。在我的机器上实测，这条指令大概花掉了几十到100多个周期，在`Celeron 800MHz`的机器上，这不过是十分之一微秒的时间。对大多数应用来说，这点时间完全可以忽略不计；而对那些确实要精确到纳秒数量级的应用来说，这个补偿也过于粗糙了。   </span><br><span class="line">    </span><br><span class="line">  这个方法的优点是：   </span><br><span class="line">    </span><br><span class="line">  1. 高精度。可以直接达到纳秒级的计时精度（在1GHz的CPU上每个时钟周期就是一纳秒），这是其他计时方法所难以企及的。   </span><br><span class="line">    </span><br><span class="line">  2. 成本低。`timeGetTime`函数需要链接多媒体库 `winmm.lib`，`QueryPerformance*`函数根据MSDN的说明，需要硬件的支持（虽然我还没有见过不支持的机器）和KERNEL库的支持，所以二者都只能在Windows平台下使用（关于DOS平台下的高精度计时问题，可以参考`《图形程序开发人员指南》`，里面有关于控制定时器8253的详细说明）。但`RDTSC`指令是一条CPU指令，凡是i386平台下Pentium以上的机器均支持，甚至没有平台的限制（我相信i386版本UNIX和Linux下这个方法同样适用，但没有条件试验），而且函数调用的开销是最小的。   </span><br><span class="line">    </span><br><span class="line">  3. 具有和CPU主频直接对应的速率关系。一个计数相当于1/(CPU主频Hz数)秒，这样只要知道了CPU的主频，可以直接计算出时间。这和   `QueryPerformanceCount`不同，后者需要通过`QueryPerformanceFrequency`获取当前计数器每秒的计数次数才能换算成时间。   </span><br><span class="line">    </span><br><span class="line">  这个方法的缺点是：   </span><br><span class="line">    </span><br><span class="line">  1. 现有的C/C++编译器多数不直接支持使用RDTSC指令，需要用直接嵌入机器码的方式编程，比较麻烦。   </span><br><span class="line">    </span><br><span class="line">  2. 数据抖动比较厉害。其实对任何计量手段而言，精度和稳定性永远是一对矛盾。如果用低精度的`timeGetTime`来计时，基本上每次计时的结果都是相同的；而`RDTSC`指令每次结果都不一样，经常有几百甚至上千的差距。这是这种方法高精度本身固有的矛盾。   </span><br><span class="line">    </span><br><span class="line">  关于这个方法计时的最大长度，我们可以简单的用下列公式计算：</span><br></pre></td></tr></table></figure>
<p>自CPU上电以来的秒数   =   RDTSC读出的周期数   /   CPU主频速率（Hz）</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">64位无符号整数所能表达的最大数字是`1.8×10^19`，在我的`Celeron   800`上可以计时大约700年（书中说可以在200MHz的Pentium上计时117年，这个数字不知道是怎么得出来的，与我的计算有出入）。无论如何，我们大可不必关心溢出的问题。   </span><br><span class="line">    </span><br><span class="line">下面是几个小例子，简要比较了三种计时方法的用法与精度   </span><br><span class="line"> ```c</span><br><span class="line">//Timer1.cpp   使用了RDTSC指令的Timer类//KTimer类的定义可以参见《Windows图形编程》P15   </span><br><span class="line">//编译行：CL Timer1.cpp   /link   USER32.lib   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">#include   &quot;KTimer.h&quot;   </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  unsigned   t;   </span><br><span class="line">  KTimer   timer;   </span><br><span class="line">  timer.Start();   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  t   =   timer.Stop();   </span><br><span class="line">  printf(&quot;Lasting   Time:   %d\n&quot;,t);   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">//Timer2.cpp   使用了timeGetTime函数   </span><br><span class="line">//需包含&lt;mmsys.h&gt;，但由于Windows头文件错综复杂的关系   </span><br><span class="line">//简单包含&lt;windows.h&gt;比较偷懒：）   </span><br><span class="line">//编译行：CL   timer2.cpp   /link   winmm.lib     </span><br><span class="line">#include   &lt;windows.h&gt;   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">  </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  DWORD   t1,   t2;   </span><br><span class="line">  t1   =   timeGetTime();   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  t2   =   timeGetTime();   </span><br><span class="line">  printf(&quot;Begin   Time:   %u\n&quot;,   t1);   </span><br><span class="line">  printf(&quot;End   Time:   %u\n&quot;,   t2);   </span><br><span class="line">  printf(&quot;Lasting   Time:   %u\n&quot;,(t2-t1));   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">//Timer3.cpp   使用了QueryPerformanceCounter函数   </span><br><span class="line">//编译行：CL   timer3.cpp   /link   KERNEl32.lib   </span><br><span class="line">#include   &lt;windows.h&gt;   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">  </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  LARGE_INTEGER   t1,   t2,   tc;   </span><br><span class="line">  QueryPerformanceFrequency(&amp;tc);   </span><br><span class="line">  printf(&quot;Frequency:   %u\n&quot;,   tc.QuadPart);   </span><br><span class="line">  QueryPerformanceCounter(&amp;t1);   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  QueryPerformanceCounter(&amp;t2);   </span><br><span class="line">  printf(&quot;Begin   Time:   %u\n&quot;,   t1.QuadPart);   </span><br><span class="line">  printf(&quot;End   Time:   %u\n&quot;,   t2.QuadPart);   </span><br><span class="line">  printf(&quot;Lasting   Time:   %u\n&quot;,(   t2.QuadPart-   t1.QuadPart));   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">////////////////////////////////////////////////   </span><br><span class="line">//以上三个示例程序都是测试1秒钟休眠所耗费的时间   </span><br><span class="line">//测试环境：Celeron   800MHz   /   256M   SDRAM       </span><br><span class="line">//         Windows   2000   Professional   SP2   </span><br><span class="line">//         Microsoft   Visual   C++   6.0   SP5   </span><br><span class="line">////////////////////////////////////////////////</span><br></pre></td></tr></table></figure>
<p>以下是Timer1的运行结果，使用的是高精度的<code>RDTSC</code>指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lasting   Time:   804586872</span><br></pre></td></tr></table></figure>
<p>以下是Timer2的运行结果，使用的是最粗糙的<code>timeGetTime API</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Begin   Time:   20254254   </span><br><span class="line">End   Time:   20255255   </span><br><span class="line">Lasting   Time:   1001</span><br></pre></td></tr></table></figure>
<p>以下是Timer3的运行结果，使用的是<code>QueryPerformanceCount API</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Frequency:   3579545   </span><br><span class="line">Begin   Time:   3804729124   </span><br><span class="line">End   Time:   3808298836   </span><br><span class="line">Lasting   Time:   3569712</span><br></pre></td></tr></table></figure>
<p>古人说，触类旁通。从一本介绍图形编程的书上得到一个如此有用的实时处理知识，我感到非常高兴。有美不敢自专，希望大家和我一样喜欢这个轻便有效的计时器。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>软件运行</tag>
      </tags>
  </entry>
  <entry>
    <title>Why Software Should Not Have Owners</title>
    <url>/public/2018/05/11/why_gnu/</url>
    <content><![CDATA[<p><a href="http://www.gnu.org/philosophy/why-free.html" target="_blank" rel="noopener">Why Software Should Not Have Owners</a>
为什么软件不应有主人
作者︰<a href="https://www.stallman.org/" target="_blank" rel="noopener">Richard Stallman</a></p>
<a id="more"></a>
<p>数字资讯科技令大众更容易复制和变更资料。然而不是所有人都希望这样。版权制度容许软件有「主人」。他们主要目的在于从公众夺取软件的潜在利益。他们希望独占这些软件的复制、更改权利。</p>
<p>版权制度随著印刷技术而发展——印刷是一种大量制作副本的技术。版权很适合这项技术，因为它只限制了大规模的复制。它并没有剥夺图书读者的自由。一般读者没有印刷机，他们只能用笔墨抄写作品，所以很少有读者因此而被控告。</p>
<p>数字科技比印刷机更灵活：当信息呈数字形式时，你能很容易把它跟别人分享。这种情况不太配合故有的版权制度，所以现在有越来越多日益严厉的措施用来加强软件版权。看看这些软件出版商协会（Software Publishers Association, SPA）的四种惯常说法：</p>
<ul>
<li>大肆宣传违反版权法去帮助朋友是错误的。</li>
<li>诱使大家告发违返规定的同事和同僚。</li>
<li>如果警察协助突击搜查公司和学校，那里的人们必须证明自己没有非法复制。</li>
<li>因软件出版商协会提出要求，美国政府起诉一些如麻省理工学院的 David LaMacchia的人，不是因为他非法软复制件，而只是因为破解复制工具，从而不能对用户非法复制进行检查。</li>
</ul>
<p>这些惯常说法和前苏联曾用过的做法相似，在每一台影印机前都有一个守卫，以防止那些未经许可复印，同时个人只有秘密地复制信息，并像「秘密出版物」一样在手头传播。不同的是，苏联管制信息是政治原因，而美国则是为了经济利益。无论动机如何，我们都受到影响。不管什么原因，任何人企图阻止信息共享，都导致了相同的后果和同样的不便。</p>
<p>软件所有者用各种理由来控制我们如何使用资讯的权利︰</p>
<ul>
<li>
<p>中伤
软件所有者使用「盗窃」、「剽窃」这类带有污蔑的词语，或者「知识产权」、「损害」之类专业的术语，向公众暗示他们是合理的——其实，他们是将软件和真实物件混为一谈。
我们对「拿取别人的物件」的概念 ，并不能直接套用在复制这件事，然而软件所有者却迫使我们必须接受他们的想法。</p>
</li>
<li>
<p>凭空夸大
软件所有者声称当用户复制他们的程序时，他们受到「伤害」或「经济损失」。但复制并不会对软件所有者造成直接的影响，也没有伤害到任何人。只有在使用复制者不愿意给软件所有者付费时，软件所有者才会受损失。
很明显大多数这样的人不愿意购买这些程序，但是软件所有者会假定所有人都会购买，并以此来计算他们的「损失」。客气点说这就是夸大了专有软件的价值。</p>
</li>
<li>
<p>法律
软件所有者经常引用当今的法律和苛刻的刑罚来威胁我们。这暗示现今的法律反映了一个不容置疑的道德观念，同时怂恿我们视这些刑罚为正常及不能推卸。
这些说词面对严谨的思维是站不住脚的，这做法只是打算利用了人的惯性思维。
显然法律是不能决定错对的。美国人都应该知道，五十年代的黑人在许多州份坐在巴士前座是违法的；但只有种族主义者才会说他们是错误的。</p>
</li>
<li>
<p>自然权利
软件作者常常声称与自己编写的程序有一种特殊联系，因此他们宣称对这个程序的渴望和兴趣是高于世上任何人。（通常是公司持有软件版权，而不是作者，但是我们预期忽略这个差异。)
对那些打算把「作者高于一切」推崇为一种道德的人，本人作为一个著名的软件开发者，只能说这是废话。
但一般人有两个原因对自然权利的说法产生共鸣。
第一个原因是将软件与现实事物过分地类比。当我做意大利面时，如果其他人也要吃，我一定会反感，因为那样的话，我就吃不上了。他的行为对我造成的损失，正如他得到的利益一样。我们中仅有一人可以吃意大利面，问题是谁来吃？我们两者之间最小的分歧也足以打破道德上的平衡。
问题是︰你会否因为运行或修改一个我写的程序而直接影响到你，而对我只会产生一点间接影响？你是否复制我的软件给你的朋友，而对你们的影响远比对我的还要大？我不应有这样的权利去叫你不要这么做。任何人都不该有。
这第二个原因就是，人们被告知作者的自然权利是社会约定俗成的准则。
历史证明，相反的一方才是正确的。当年起草美国宪法时坚决驳回了关于作者自然权利的提议。这就是为什么宪法只是允许版权体系，而并不强制要求；所以说版权体制一定是临时的。宪法也说明版权体制的目的是促进发展，而不是奖励作者。版权确实给作者和出版社带来了更多收益，但这本来只是一种激励他们的手段而已。
事实是我们的社会建立了削弱公众自然权利的版权制度。然而版权只有用于公益事业才是正当的。</p>
</li>
<li>
<p>经济
软件应该有主人的最终辩解理由是，这会提高软件产量。
这个论据至少比以上的更切合主题。它立足于一个合理目标——满足软件用户的需求。以经验看来，人们因为满意的回报而生产更多，是很容易理解的。
但是这个关于经济的论据有瑕疵：它基于这样一个假设，区别仅仅是我们要付多少钱的问题。它假设无论软件是否有其所有者，「软件产品」都是我们想要的。
由于这个假设合乎我们处理真实物件的经验，所以人们很乐意接受。假设你付费与否都能得到一份一样的三明治，这样你付的费用就是唯一的分别。不管你是否购买，三明治有相同的味道和相同的营养，但你只能吃一次。不管你是否从所有者手中得到三明治，它都不能直接影响到你的金钱以外的任何事情。
对任何真实物件，这都是正确的︰不管它是否有主人都不会直接影响它的本质和用途。
如果程序有了主人，这将大大影响它的本质，和你对它的用途。不同之处不仅仅是钱的问题。软件该有主人的体制鼓励软件主人生产，但不一定是社会真正需要的。它导致的道德低落影响我们所有人。
社会需要什么？社会需要对公民真实可用的信息──例如，人们可以解读、修补、使用和改进的程序，而不只是操作。但是软件主人往往会给我们一个不能研究和修改的黑盒子。</p>
</li>
</ul>
<p>社会也需要自由。当程序有了主人，用户就失去了控制他们部分生活的自由。</p>
<p>总之社会需要鼓励公民们自主合作的精神。当软件主人告诉我们用这种自然的方式帮助旁人是剽窃行为时，那他们就是玷污我们的人格。</p>
<p>这正是我们提倡自由软件 事关自由，而并非价格的原因。</p>
<p>支持所有者的经济论据是错误的，但是经济问题确实存在。一些人出于荣誉、认同和博爱，而编写了有用的软件，但是如果我们希望有更多的软件，就需要筹集资金。</p>
<p>自由软件开发者自从八十年代尝试过许多寻求财源的方法，稍有小成。我们不需要让任何人致富，典型的收入，足以吸引人做很多比编程少满足感的工作。</p>
<p>多年以来，我一直靠改进自己编写的自由软件为生，直到获得研究经费。每次改进我都会添加到标準发佈版本，使得大众受益。客户为我付费，这样我就会优先完成他们需求，自己的变成次要。</p>
<p>一些自由软件开发者通过支援服务赚钱。1994年，Cygnus 有近50个员工，估计有大约百分之十五的员工从事自由软件开发︰对一间软件公司而言，这是个了不起的比例。</p>
<p>九十年代，Intel、Motorola、Texas Instruments 和 Analog Devices 等公司联合赞助持续发展的GNU C语言编译器。现在大部份开发GCC的人工作还是受薪的开发者完成的。GNU的Ada语言编译器受美国空军赞助，之后成立专属公司延续过个项目。</p>
<p>自由软件运动的规模还是很小，但是靠听众支持的美国电台的例子说明，不用强迫每个用户付费也可以支撑一个巨大的活动。</p>
<p>今天如果你发现用了专有软件。如果你的朋友问你复制一份，拒绝是不对的。合作比版权更重要。私下传播也不能建立健康的社会。人应当自豪的向往开放而正直的生活，这就意味著应该对专有软件说「不」。</p>
<p>你应该能与其他软件使用者开放、自由地合作，能够学习软件如何运作，并教导学生，能够在软件出问题时请中意的程序员修复它。</p>
<p><strong>欢迎来到自由软件的世界。</strong></p>
<p><strong>参考</strong>
<a href="http://www.gnu.org/philosophy/why-free.html" target="_blank" rel="noopener">http://www.gnu.org/philosophy/why-free.html</a></p>
]]></content>
      <categories>
        <category>技术阅读</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>gnu</tag>
        <tag>linux</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系列</title>
    <url>/public/2019/07/23/AI/ML_summary/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>路漫漫其修远兮，吾将上下而求索。2013年，大二接触人工智能课，讲逻辑推理，专家系统等等，神经网络只是一部分，打开当时老师的ppt，还能看到BP等算法。接着在2015年，上了模式识别课程，有一些启发式算法，KNN K-means等算法，同时神经网络也已经有了 GoogLeNet 等深层网络，热门的GAN网络也在2014年被提出。后面，机遇巧合，本科毕业时选了人工智能的坑，直到3年后的现在算是明白了一点。接下来的三年的目标还是<a href="https://talengu.github.io/public/2018/10/01/AI/how_algorithm_engineer/">【成为一名优秀的算法工程师】</a>。</p>
<p>回望入坑 <strong>机器学习</strong>，没有系统地整理过相关知识。于是想着手整理一份自己笔记系列。本文为序。</p>
<blockquote>
<p>雄关漫道真如铁，而今迈步从头越。</p>
</blockquote>
<p><img src="/public/2019/07/23/AI/ML_summary/1564034058070.png" alt="1564034058070"></p>
<div align="center"> 图1 机器学习知识框架</div>
如图1 所示，整个系列将由五个部分组成。
<a id="more"></a>
<h2 id="一、机器学习基础"><a class="header-anchor" href="#一、机器学习基础">¶</a>一、机器学习基础</h2>
<h2 id="二、监督学习"><a class="header-anchor" href="#二、监督学习">¶</a>二、监督学习</h2>
<img src="/public/2019/07/23/AI/ML_summary/1564034419203.png" alt="1564034419203" style="zoom:67%;">
<div align="center"> 图 监督学习</div>
<h2 id="三、无监督学习"><a class="header-anchor" href="#三、无监督学习">¶</a>三、无监督学习</h2>
<img src="/public/2019/07/23/AI/ML_summary/1564034460034.png" alt="1564034460034" style="zoom:67%;">
<div align="center"> 图 无监督学习</div>
<h2 id="四、学习理论"><a class="header-anchor" href="#四、学习理论">¶</a>四、学习理论</h2>
<img src="/public/2019/07/23/AI/ML_summary/xuexililun.png" alt="xuexililun" style="zoom:67%;">
<div align="center"> 图 学习理论</div>
<h3 id="4-1-正则化"><a class="header-anchor" href="#4-1-正则化">¶</a>4.1 <a href="regulation_baysian.md">正则化</a></h3>
<h2 id="五、强化学习"><a class="header-anchor" href="#五、强化学习">¶</a>五、强化学习</h2>
<h2 id="六、参考与规划"><a class="header-anchor" href="#六、参考与规划">¶</a>六、参考与规划</h2>
<p><strong>目标</strong>
通过阅读以上基本书，打牢自己的理论基础。</p>
<p><strong>书籍</strong></p>
<ul>
<li>PRML Bishop</li>
<li>机器学习 周志华</li>
<li>统计学习 李航</li>
<li>深度学习 Goodfellow</li>
<li>模式识别 张学工</li>
</ul>
<p><strong>课程</strong></p>
<p><a href="https://www.bilibili.com/video/av70839977" target="_blank" rel="noopener">https://www.bilibili.com/video/av70839977</a></p>
<p><strong>博客编写</strong></p>
<ul>
<li>前言介绍，包括作者，背景，原始paper，和以上基本书的对应章节。</li>
<li>原理阐述，算法步骤写出。</li>
<li>案例分析</li>
<li>利用python写出代码，先用scilearn写。</li>
<li>总结，预告。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>DSP滤波程序</title>
    <url>/public/2015/06/14/dsp/dsp_filter/</url>
    <content><![CDATA[<p><strong>前言</strong>
通过matlab对数字信号进行滤波器的设计后，我们要将设计好的参数放到嵌入式系统中进行滤波。本文就是一个滤波程序。</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="comment">//z变换转成差分方程然后迭代</span></span><br><span class="line"><span class="comment">//Talen @UESTC 2015.6.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">float</span> *x,<span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="comment">//取后第1-n个</span></span><br><span class="line"><span class="function"><span class="keyword">float</span>* <span class="title">aminusone</span><span class="params">(<span class="keyword">float</span>* a,<span class="keyword">int</span> ar)</span></span>;</span><br><span class="line"><span class="comment">//差分中间值</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">gtcet</span><span class="params">(<span class="keyword">float</span> *t,<span class="keyword">float</span> *x,<span class="keyword">int</span> xr,<span class="keyword">int</span> s,<span class="keyword">int</span> d)</span></span>;</span><br><span class="line"><span class="comment">//主要滤波函数</span></span><br><span class="line"><span class="function"><span class="keyword">float</span>* <span class="title">gfilter</span><span class="params">(<span class="keyword">float</span> *b,<span class="keyword">int</span> br,<span class="keyword">float</span> *a,<span class="keyword">int</span> ar,<span class="keyword">float</span> *x,<span class="keyword">int</span> xr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">float</span> *x,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">"%9.3f "</span>,x[i]);</span><br><span class="line">    <span class="keyword">if</span>((i%<span class="number">7</span>)==<span class="number">6</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span>* <span class="title">aminusone</span><span class="params">(<span class="keyword">float</span>* a,<span class="keyword">int</span> ar)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span>* am = (<span class="keyword">float</span> *)<span class="built_in">malloc</span>((ar<span class="number">-1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ar<span class="number">-1</span>;i++)</span><br><span class="line">        am[i]=a[i+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> am;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">gtcet</span><span class="params">(<span class="keyword">float</span> *t,<span class="keyword">float</span> *x,<span class="keyword">int</span> xr,<span class="keyword">int</span> s,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//x[]数据源 r数据源长度 s开始点(0开始) d数据长度</span></span></span><br><span class="line"><span class="function">    <span class="comment">//t可以是a[] b[] 长度与d一样</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span>* w = (<span class="keyword">float</span> *)<span class="built_in">malloc</span>(d * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=s-i;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=<span class="number">0</span>&amp;&amp;temp&lt;xr)</span><br><span class="line">            w[i]=x[temp];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            w[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//核心语句</span></span><br><span class="line">        sum=sum+w[i]*t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span>* <span class="title">gfilter</span><span class="params">(<span class="keyword">float</span> *b,<span class="keyword">int</span> br,<span class="keyword">float</span> *a,<span class="keyword">int</span> ar,<span class="keyword">float</span> *x,<span class="keyword">int</span> xr)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//b a x br b的长度 ar a的长度 xr数据长度</span></span></span><br><span class="line"><span class="function">    <span class="comment">//use本程序定义的gtcet()和aminusone()</span></span></span><br><span class="line"><span class="function">    <span class="comment">//输入数据，b，a，x得出滤波后的y</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span>* y = (<span class="keyword">float</span> *)<span class="built_in">malloc</span>(xr* <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ti=<span class="number">0</span>;ti&lt;xr;ti++)</span><br><span class="line">        y[ti]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xr;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//最核心语句，此处迭代</span></span><br><span class="line">        y[i]=gtcet(b,x,xr,i,br)-gtcet(aminusone(a,ar),y,xr,i<span class="number">-1</span>,ar<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//input 源数据 可修改</span></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="keyword">float</span> x[<span class="number">120</span>]=&#123;<span class="number">-4</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">-4</span>, <span class="number">-6</span>, <span class="number">-4</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-6</span>, <span class="number">-6</span>, <span class="number">-4</span>, <span class="number">-4</span>,\</span><br><span class="line">        <span class="number">-6</span>, <span class="number">-6</span>, <span class="number">-2</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">-16</span>, <span class="number">-38</span>, <span class="number">-60</span>, <span class="number">-84</span>,\</span><br><span class="line">        <span class="number">-90</span>, <span class="number">-66</span>, <span class="number">-32</span>, <span class="number">-4</span>, <span class="number">2</span>, <span class="number">-4</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">6</span>,\</span><br><span class="line">        <span class="number">6</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-2</span>,\</span><br><span class="line">        <span class="number">-2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-2</span>, <span class="number">0</span>,\</span><br><span class="line">        <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-2</span>,\</span><br><span class="line">        <span class="number">-4</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-4</span>, <span class="number">-4</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-6</span>, <span class="number">-6</span>,\</span><br><span class="line">        <span class="number">-4</span>, <span class="number">-4</span>, <span class="number">8</span>, <span class="number">-10</span>, <span class="number">-8</span>, <span class="number">-6</span>, <span class="number">-6</span>, <span class="number">-8</span>, <span class="number">-12</span>, <span class="number">-10</span>,\</span><br><span class="line">        <span class="number">-8</span>, <span class="number">-8</span>, <span class="number">-10</span>, <span class="number">-12</span>, <span class="number">-10</span>, <span class="number">-8</span>, <span class="number">-8</span>, <span class="number">-10</span>, <span class="number">-10</span>,\</span><br><span class="line">        <span class="number">-8</span>, <span class="number">-6</span>, <span class="number">-6</span>, <span class="number">-8</span>, <span class="number">-8</span>, <span class="number">-4</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-4</span>, <span class="number">-4</span>,\</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">-4</span>&#125;;</span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">    <span class="keyword">float</span> b[<span class="number">7</span>]=&#123; <span class="number">0.0007</span>,<span class="number">0.0044</span>,<span class="number">0.0111</span>,<span class="number">0.0148</span>,<span class="number">0.0111</span>,<span class="number">0.0044</span>,<span class="number">0.0007</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> a[<span class="number">7</span>]=&#123; <span class="number">1.0000</span>,<span class="number">-3.1836</span>,<span class="number">4.6222</span>,<span class="number">-3.7795</span>,<span class="number">1.8136</span>,<span class="number">-0.4800</span>,<span class="number">0.0544</span>&#125;;</span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//不要修改</span></span><br><span class="line">    <span class="keyword">int</span> xr=<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">    <span class="keyword">int</span> br=<span class="keyword">sizeof</span>(b)/<span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">    <span class="keyword">int</span> ar=<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">    <span class="comment">//output 滤波后数据</span></span><br><span class="line">    <span class="keyword">float</span> *y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"参数b：\n"</span>);print(b,br);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"参数a：\n"</span>);print(a,ar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"原数据：\n"</span>);print(x,xr);</span><br><span class="line"></span><br><span class="line">    y=gfilter(b,br,a,ar,x,xr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"滤波后数据：\n"</span>);print(y,xr);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数字信号处理</category>
      </categories>
      <tags>
        <tag>滤波器</tag>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>终端中bash、vim、tmux等的配置</title>
    <url>/public/2018/07/12/linux/bash_bashrc/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>使用终端有一段时间了，现在主力的平台是Ubuntu16.04，本文对bash、vim、tmux配置的一些记录。</p>
<a id="more"></a>
<p>在<code>cd ~</code>下建立talen_bashrc文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> HOME_BASHRC=xxxx/talen_bashrc</span><br><span class="line"> alias vimbashrc='vim $HOME_BASHRC &amp;&amp; source $HOME_BASHRC'</span><br><span class="line"><span class="meta">#</span><span class="bash"> files</span></span><br><span class="line"> alias countfiles='echo "total num: " &amp;&amp; ls | wc -l &amp;&amp; du -sh'</span><br><span class="line"> alias ll='ls -htrlF --time-style="+%H:%M %Y/%m/%d"'</span><br><span class="line"> alias dum='du -a -d 1 -m |sort -nr'</span><br><span class="line"> alias dug='df -h /dev/sdbxxx &amp;&amp; du -BG -d 1 --time |sort -nr'</span><br><span class="line"></span><br><span class="line"> alias pi='pip install -i https://pypi.tuna.tsinghua.edu.cn/simple'</span><br><span class="line"> alias gpuwatch='watch -n 1 nvidia-smi'</span><br><span class="line"></span><br><span class="line"> alias gitm='git commit -m'</span><br><span class="line"> alias gits='git status -s'</span><br><span class="line"></span><br><span class="line"> export PYTHONPATH=$PYTHONPATH:xxxxxxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> vimrc</span></span><br><span class="line"> export MYVIMRC=xxxx/.vim/.vimrc</span><br><span class="line"> export VIMINIT="let &amp;rtp='xxxx/.vim,' . &amp;rtp</span><br><span class="line"> so $MYVIMRC"</span><br></pre></td></tr></table></figure>
<p>python环境使用的是anaconda（或者minicoonda）添加激活环境。
在<code>~/.bashrc</code>中加入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias talen='source xxx/talen_bashrc &amp;&amp; source activate xxx/envs'</span><br><span class="line">alias utalen='source deactivate'</span><br></pre></td></tr></table></figure>
<p>github <a href="https://github.com/talengu/vim/blob/master/bashrc" target="_blank" rel="noopener">bashrc</a></p>
<p>其他的vimrc配置见我的github项目<a href="https://github.com/talengu/vim" target="_blank" rel="noopener">vimrc</a></p>
<h2 id="跳转命令-z"><a class="header-anchor" href="#跳转命令-z">¶</a>跳转命令 z</h2>
<p><a href="https://github.com/rupa/z/blob/master/z.sh" target="_blank" rel="noopener">z.sh</a>
终端效率提升：自动路径切换
<a href="https://zhuanlan.zhihu.com/p/50548459" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50548459</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Bashrc</tag>
        <tag>Vimrc</tag>
        <tag>Tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu引导修复</title>
    <url>/public/2017/06/14/linux/boot_recovery/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>本文记录修复ubuntu引导，并修改ubuntu盘的大小过程。
参考：<a href="http://www.cnblogs.com/jloveu/p/Ubuntu-partition-expansion-record.html" target="_blank" rel="noopener">http://www.cnblogs.com/jloveu/p/Ubuntu-partition-expansion-record.html</a>
工具：Ubuntu 的live U盘，带有gparted分区工具，和grub修复工具</p>
<a id="more"></a>
<h2 id="修复启动"><a class="header-anchor" href="#修复启动">¶</a>修复启动</h2>
<p>对于使用gpt的格式的硬盘，ubuntu不要用uefi来安装。gpt还要生成一个bootgios的分区，很重要。</p>
<p>执行以下命令（以root身份）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /tmp/mydir</span><br><span class="line">mount /dev/sda8 /tmp/mydir  (注：其中的`/dev/sda8`为我的`/`分区标识，根据自己情况修改为自己的`/`分区标识)</span><br><span class="line">mount /dev/sda11 /tmp/mydir/boot  (注：同上，`/dev/sda11`为`/boot`分区标识)</span><br><span class="line">mount --bind /dev /tmp/mydir/dev</span><br><span class="line">mount --bind /proc /tmp/mydir/proc</span><br><span class="line">mount --bind /sys /tmp/mydir/sys</span><br><span class="line">chroot /tmp/mydir  (此步可能输出一些信息，可以无视)</span><br><span class="line">grub-install /dev/sda  (注：其中的`/dev/sda`为`/`分区所在硬盘的标识)</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<h2 id="修改Ubuntu多系统的默认启动顺序"><a class="header-anchor" href="#修改Ubuntu多系统的默认启动顺序">¶</a>修改Ubuntu多系统的默认启动顺序</h2>
<p><a href="http://jingyan.baidu.com/article/f71d60379e16021ab641d1ab.html" target="_blank" rel="noopener">link</a><br>
打开该配置文件&quot;/etc/default/grub&quot;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/default/grub</span><br><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure>
<p>其中的“GRUB_DEFAULT=0”为设置默认启动项。系统启动菜单Windows10的启动项在第5项，修改为4（GRUB启动项是从0开始的）。<br>
<img src="/public/2017/06/14/linux/boot_recovery/boot_file.png" alt="GRUB修改"></p>
<h2 id="去除多余GRUB启动项（直接）"><a class="header-anchor" href="#去除多余GRUB启动项（直接）">¶</a>去除多余GRUB启动项（直接）</h2>
<p><a href="https://zhidao.baidu.com/question/472571337.html" target="_blank" rel="noopener">link</a><br>
注释掉“/boot/grub/grub.cfg”中对应</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gedit /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
<h2 id="Ubuntu下如何修复Grub引导"><a class="header-anchor" href="#Ubuntu下如何修复Grub引导">¶</a>Ubuntu下如何修复Grub引导</h2>
<p><a href="https://mp.weixin.qq.com/s/NDZPPA-0FhqSzRndQOhNEw" target="_blank" rel="noopener">link</a></p>
<p>本文以 Ubuntu Live CD 修复 Grub 引导为例，已在 /dev/sda3 安装 Fedora。</p>
<p>首先制作 Ubuntu 启动 USB</p>
<p>复制代码代码如下：
　　<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　　sudo dd if=ubuntu-13.10-desktop-amd64.iso of=/dev/sdb </span><br><span class="line">　　#/dev/sdb 为 USB 盘符</span><br></pre></td></tr></table></figure></p>
<p>1.使用启动 USB 进入 Ubuntu 试用环境</p>
<p>2.查看硬盘分区状况，获取 Linux 系统安装分区编号
　　代码如下：</p>
<p>sudo fdisk -l</p>
<p>查看输出结果，然后根据文件类型和分区大小来判定 Linux 系统安装在哪块硬盘和安装的分区。我的电脑是在 /dev/sda3 安装了 Fedora。</p>
<p>或者，打开 Gparted 图形化工具来查看分区信息也可以。</p>
<p>挂载 Fedora 安装分区</p>
<p><strong>3.已知 Fedora 安装在了 /dev/sda3 上，所以我们可以用下面命令来挂载 Fedora 安装分区。你需要将 /dev/sda3 换成自己的 Linux 安装分区。</strong></p>
<p>代码如下：</p>
<p>sudo mount /dev/sda3 /mnt</p>
<p><strong>4.挂载其他所需的目录（使用 --bind）</strong></p>
<p>代码如下：</p>
<p>sudo mount --bind /dev /mnt/dev</p>
<p>sudo mount --bind /proc /mnt/proc</p>
<p>sudo mount --bind /sys /mnt/sys</p>
<p><strong>5.Chroot 到硬盘上的 Linux 系统</strong></p>
<p>代码如下：</p>
<p>sudo chroot /mnt</p>
<p><strong>6.安装&amp;更新 Grub</strong></p>
<p>代码如下：</p>
<p>grub2-install /dev/sda</p>
<p>grub2-mkconfig -o /boot/grub2/grub.cfg</p>
<p><strong>7.Grub 已经修复成功，我们还需要退出 chroot 环境、卸载已经挂载的设备与目录：</strong></p>
<p>代码如下：</p>
<p>exit 退出 chroot 环境</p>
<p>sudo umount /mnt/dev</p>
<p>sudo umount /mnt/proc</p>
<p>sudo umount /mnt/sys</p>
<p>sudo umount /mnt</p>
<p><strong>8.重启！</strong></p>
<p>上面就是使用Ubuntu LiveCD修复grub的方法介绍了，如果你在使用双系统安装windows中出现Grub引导错误，不妨使用该方法进行修复吧。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>BootRecovery</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」tcpdump是在哪儿抓到的包？</title>
    <url>/public/2022/07/01/linux/how_tcpdump/</url>
    <content><![CDATA[<blockquote>
<p>原文地址 <a href="https://cloud.tencent.com/developer/article/1879646" target="_blank" rel="noopener">cloud.tencent.com</a></p>
</blockquote>
<blockquote>
<p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对...</p>
</blockquote>
<p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对这个问题，我进行了一番学习探究。</p>
<p>先说结论：通过 PF_PACKET 这个特殊的套接字协议，直接接收来自链路层的帧。数据包<strong>并非没有</strong>进入内核，而是在进入内核后直接跳过了内核中三层 / 四层的协议栈，直达套接字接口，被应用层的 tcpdump 所使用。实际上，在网卡驱动程序通知内核接受到数据帧的时候，数据包就已经进入了内核处理流程。具体的区别，可以见下图。</p>
<p><img src="/public/2022/07/01/linux/how_tcpdump/1620.png" alt></p>
<p>内核网络协议栈示意图</p>
<a id="more"></a>
<p>先来看看，普通的套接字的收包路径在内核中是怎么样。</p>
<p>以最常见的以太网网卡，当网卡接口接收到了一个帧，那么接受者知道它一定包含了一个 Ethernet 报头。封包在协议栈向上传递过程中，一定会在报头中包含一个字段，指出下一阶段的处理应该使用哪一个协议。 以太网卡拥有特定的 MAC 地址，在监听数据帧的时候，当看到帧的目的 MAC 地址与自己的地址或者链路层广播地址（FF:FF:FF:FF:FF:FF）相匹配，就会通过 DMA 把该帧读取到内存中的 ring buffer。</p>
<p>当一个数据帧被写入到内存后，将产生一个硬件中断请求，以通知 CPU 收到了数据包。操作系统为了减少硬中断产生的次数，会采用一个软中断 (softirq) 唤醒 NAPI 子系统。这样会产生一个单独的线程，调用网卡驱动注册的 poll 方法收包，同时禁止网卡产生新的硬中断，这样的效果便是一次中断可以接收多个包。一旦软终端代码判断有 softirq 处于 pending 状态，便会调用软终端处理函数 net_rx_action。</p>
<p>中断处理函数会在处理循环中调用 NAPI poll 来接收数据包。poll 方法会分配一个 sk_buff 数据结构（include/linux/skbuff.h），表示该数据包的内核视图。然后将数据从缓冲区提取到新建的 sk_buff 中，并对其中的 protocol 字段做初始化，该字段用以识别特定的协议。之后这个字段会被 netif_receive_skb 内核函数查询，用来确定该执行哪个函数来处理三层的封包。字段涉及协议的值都列在了 include/uapi/linux/if_ether.h 中，名字形如 ETH_P_XXX，比如 ip 协议为 ETH_P_IP。而有一种特殊情况，单一封包可以传递给多个处理函数，这就是 tcpdump 等网络嗅探应用会用到的 ETH_P_ALL。</p>
<p>软终端处理循环的最后是通过 netif_receive_skb 函数将将数据交给 TCP/IP 协议栈的。它会从数据包包头中取出协议信息，然后遍历注册在这个协议上的回调函数列表。这里的列表值得一提，分别是 ptype_all 和 ptype_base。他们是 hash table 数据结构，分别对应通用数据包（ETH_P_ALL 类型）和特定协议的数据包（ETH_P_XXX 类型），其中存放着指向对应协议处理函数的指针，当收到该类型的数据包时便调用对应的处理函数。</p>
<p>因此，以 IP 数据包为例，当 ETH_P_IP 类型数据包出队后，软中断处理程序 net_rx_action 最终会在 ptype_base 列表中找到 IP 协议的处理函数 ip_rcv() 并调用它，完成数据包向上提交到协议栈。这里略过 IP 协议栈的处理过程，简而言之，在经过 IP 数据包完整性校验、Netfilter 子系统（iptables 的底层实现）、路由子系统等等一些列流程之后，开始准备送往高层协议。这里的处理和 net_rx_action 很相似，从 IP 数据包头部提取出协议类型后，通过名为 inet_protos 的哈希来寻找高层协议的处理函数，每个高层协议都对应一个处理函数，型如 tcp_v4_rcv(), udp_rcv() 等。</p>
<p>四层协议以较为简单的 UDP 为例，udp_rcv 会对 udp 包进行合法性校验，然后查找是否有愿意接收此数据包的套接字，如果找到，__udp_queue_rcv_skb 会将包放到 socket 的接收队列。最后，所有在这个 socket 上等待数据的进程都会收到通过 sk_data_ready 函数处理的通知。</p>
<p>以上是一个数据包穿越协议栈到达 socket 的简要过程，实际的内核处理过程会复杂的多，这里只是做简要的描述。以引入本文的主角：PF_PACKET 协议数据包在内核中的处理路径。</p>
<p>当创建 PF_PACKET 套接字时，与协议相关的数据包类型将被同时注册进 ptype_all 和 ptype_base，接受函数为 packet_rcb()。此时，net_rx_action 函数会拦截所有进入机器的包，并同样通过 netif_receive_skb 函数遍历 ptype_all 后，传递给 PF_PACKET 接受函数。值得一提的是，tcpdump 依赖的 libpcap 库并非使用原始套接字 + recvfrom 的方式收包，而是在内核空间分配一块内核缓冲区，然后用户空间调用 mmap 系统调用映射到用户空间。</p>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<p><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/" target="_blank" rel="noopener">Monitoring and Tuning the Linux Networking Stack: Receiving Data</a></p>
<p><a href="https://www.linuxjournal.com/article/4852" target="_blank" rel="noopener">Inside the Linux Packet Filter</a></p>
<p><a href="https://km.woa.com/group/17746/articles/show/%E5%9B%BE%E8%A7%A3linux%20tcpdump" target="_blank" rel="noopener">图解 linux tcpdump</a></p>
<p>《深入理解 Linux 网络技术内幕》</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>tcpdump</tag>
      </tags>
  </entry>
  <entry>
    <title>linux代理的使用</title>
    <url>/public/2018/07/24/linux/linux_proxy/</url>
    <content><![CDATA[<p><strong>前言</strong>
最近要下载一个在youtube上的数据库，用来训练神经网络。走国内通道下载比较慢。于是，我使用了vps代理方式下载，速度取决于你的机器连接vps的网速。本文的主要内容有，实现shadowsocks 代理 ，tsocks 代理工具使用，可组合使用的一些下载工具如wget 和axel等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 举个栗子</span></span><br><span class="line">$ tsocks wget -c https://www.dropbox.com/s/minpyv59crdifk9/datasets.zip</span><br></pre></td></tr></table></figure>
<p>嗯嗯，这个速度还不错！</p>
<p><img src="/public/2018/07/24/linux/linux_proxy/1565246896718.png" alt="1565246896718"></p>
<p><strong>声明</strong>：本文以科学研究为目的，请勿滥用。</p>
<a id="more"></a>
<h2 id="1-Shadowsocks"><a class="header-anchor" href="#1-Shadowsocks">¶</a>1 Shadowsocks</h2>
<p><strong>Shadowsocks</strong>是一个轻量级socks5代理工具。在linux平台，我们可使用 python 提供的包管理工具 pip <strong>安装 Shadowsocks</strong> ，如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pip 安装 Shadowsocks</span></span><br><span class="line">$ pip install shadowsocks</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br></pre></td></tr></table></figure>
<p>pip安装完之后，可能要重启终端，我们就有ssserver和sslocal小工具了。下面配置server或者client。一般，server配置在国外的vps上，client配置在本地国内机器上。</p>
<p>PS：其他平台安装 参考 shadowsocks官方 <a href="https://github.com/shadowsocks/shadowsocks/tree/master#install" target="_blank" rel="noopener">install</a></p>
<h3 id="1-1-配置-Shadowsocks-server"><a class="header-anchor" href="#1-1-配置-Shadowsocks-server">¶</a>1.1 配置 Shadowsocks server</h3>
<p>按下面的三步走，即可。</p>
<ul>
<li>
<p>通过ssh连接到（Virtual Private Server）vps上，或者本地打开终端。</p>
</li>
<li>
<p>新建一个<strong>server_shadowsocks.json</strong>文件，内容如下：</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">443</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"密码"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行<code>ssserver -c server_shadowsocks.json</code></li>
</ul>
<p>说一点: 由于我们的下载任务是临时的，开个screen（终端复用工具）放在后台。当然你也可以设置为开机自启动，这里不再赘述。</p>
<h3 id="1-2-配置-Shadowsocks-client"><a class="header-anchor" href="#1-2-配置-Shadowsocks-client">¶</a>1.2 配置 Shadowsocks client</h3>
<ul>
<li>
<p>通过ssh连接到机器上，或者本地打开终端。</p>
</li>
<li>
<p>新建文件 <strong>client_shadowsocks.json</strong></p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">"server"</span>:<span class="string">"服务器ip或域名"</span>,</span><br><span class="line">        <span class="attr">"server_port"</span>:<span class="number">443</span>,</span><br><span class="line">        <span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">        <span class="attr">"local_port"</span>:<span class="number">1280</span>,</span><br><span class="line">        <span class="attr">"password"</span>:<span class="string">"密码"</span>,</span><br><span class="line">        <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">        <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">        <span class="attr">"fast_open"</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"workers"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行<code>sslocal -c client_shadowsocks.json</code>。</li>
</ul>
<p>说一点：推荐使用screen方式放在后台。当然也可以使用-d 参数放在后台运行。
<code>sslocal -c client_shadowsocks.json -d start</code></p>
<h2 id="2-tsocks"><a class="header-anchor" href="#2-tsocks">¶</a>2 tsocks</h2>
<p>有些linux工具可能没有proxy的代理功能，或者不支持sock5代理，而用tsocks可以很好的解决这些问题。<strong>tsocks</strong> 是个终端代理工具，可以直接连接shadowsocks提供socks 5代理端口，有点类似于proxychains。</p>
<p>下面简单介绍下安装与使用：</p>
<ul>
<li>安装<strong>tsocks</strong>
<ul>
<li>linux安装tsocks 命令：<code>apt install tsocks</code></li>
<li>mac 安装参考 <a href="https://github.com/Anakros/homebrew-tsocks" target="_blank" rel="noopener">homebrew-tsocks</a></li>
</ul>
</li>
<li><strong>开启上面Shadowsocks的client</strong>放在后台。</li>
<li>修改tsocks 配置文件，在<code>/etc/tsocks.conf</code>  文件的最后添加：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local = 192.168.1.0/255.255.255.0</span><br><span class="line">server = 127.0.0.1</span><br><span class="line">server_type = 5</span><br><span class="line">server_port = 1080</span><br></pre></td></tr></table></figure>
<h2 id="3-Demo：代理使用"><a class="header-anchor" href="#3-Demo：代理使用">¶</a>3 Demo：代理使用</h2>
<h3 id="3-1-使用-tsocks"><a class="header-anchor" href="#3-1-使用-tsocks">¶</a>3.1 使用 tsocks</h3>
<p>在所需代理的命令前加个tsocks就行，如：
<code>tsocks wget -c xxxx</code>,<code>tsocks axel -n 10 -av xxxx</code>,<code>tsocks curl xxx</code></p>
<h3 id="3-2-使用-youtube-dl"><a class="header-anchor" href="#3-2-使用-youtube-dl">¶</a>3.2 使用 youtube-dl</h3>
<p>youtube-dl是批量下载youtube视频的好工具。youtube-dl 可以指定 proxy，<strong>可以不使用tsocks</strong>。</p>
<ul>
<li>安装youtube-dl</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install --upgrade youtube-dl</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>使用举个例子</p>
<ul>
<li>下载youtube视频</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL=https://www.youtube.com/playlist?list=PLLbeS1kM6teJqdFzw1ICHfa4a1y0hg8Ax</span><br><span class="line">./youtube-dl --proxy socks5://127.0.0.1:1280 $&#123;URL&#125;</span><br><span class="line"># 在 client_shadowsocks.json 的 local_port 设置为1280，这儿也为1280</span><br></pre></td></tr></table></figure>
<ul>
<li>下载里面的mp3</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">youtube-dl -x --audio-format mp3 https://www.youtube.com/watch?v=xpVfcZ0ZcFM</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>youtube-dl 中待解决的问题？</strong>
想只下载一个视频中的一部分，不用下载整个视频，太费vps流量了。暂未找到解决办法，我找到的一个跟问题很相似的issue，有朋友会整的，望告诉一下。<a href="https://github.com/rg3/youtube-dl/issues/4821" target="_blank" rel="noopener">is it possible to download only desired time interval?</a></p>
<h3 id="3-3-使用-axel"><a class="header-anchor" href="#3-3-使用-axel">¶</a>3.3 使用 axel</h3>
<p>axel多线程下载。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tsocks axel -n 3 -a https://www.dropbox.com/s/minpyv59crdifk9/datasets.zip</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-n 3 : 3个线程下载</span><br><span class="line">-a   : 有个进度条</span><br></pre></td></tr></table></figure>
<p>其他方式：下载脚本 <a href="http://axel-bash.sh" target="_blank" rel="noopener">axel-bash.sh</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh -e  </span></span><br><span class="line"><span class="comment"># usage:  ./axel-batch.sh the-download-url.list  </span></span><br><span class="line">cat <span class="variable">$1</span> | <span class="keyword">while</span> <span class="built_in">read</span> LINE  </span><br><span class="line"><span class="keyword">do</span>  </span><br><span class="line">	<span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$LINE</span>"</span> ]; <span class="keyword">then</span>  </span><br><span class="line">	axel -n 3 -a `<span class="built_in">echo</span> <span class="variable">$LINE</span>`  </span><br><span class="line">	<span class="keyword">fi</span>  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>linux</tag>
        <tag>proxy代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu的优化与设置</title>
    <url>/public/2017/05/22/linux/ubuntu/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>本文整理了一下我在使用ubuntu过程中的一些小技巧。
推荐一个好的Ubuntu教程.<a href="http://www.cnblogs.com/dutlei/archive/2012/11/20/2778327.html" target="_blank" rel="noopener">原文链接</a></p>
<p>Linux有很多分支，Ubuntu的使用安装比较方便.Ubuntu 16.04 LTS</p>
<a id="more"></a>
<h2 id="1-个性化"><a class="header-anchor" href="#1-个性化">¶</a>1 个性化</h2>
<h3 id="窗口颜色设置浅绿色"><a class="header-anchor" href="#窗口颜色设置浅绿色">¶</a>窗口颜色设置浅绿色</h3>
<p>窗口编程浅绿色  <a href="http://jingyan.baidu.com/article/ff42efa9195eb8c19e2202ec.html" target="_blank" rel="noopener">link</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/share/themes/Ambiance/gtk-3.0</span><br><span class="line">sudo gedit gtk-main.css</span><br></pre></td></tr></table></figure>
<p>编辑该文件,将base_color <code>#ffffff</code>修改成 <code>#CCE8CF</code>
对应RGB  48,19,36</p>
<h2 id="2-常用环境"><a class="header-anchor" href="#2-常用环境">¶</a>2  常用环境</h2>
<h3 id="安装jdk"><a class="header-anchor" href="#安装jdk">¶</a>安装jdk</h3>
<p>打开文件 <code>vim ~/.bashrc</code>，在文件后面添加下面几行，其中<code>JAVA_HOME</code>根据自己的java安装位置修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add java path</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/java/jdk1.7</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>别忘了，<code>source ~/.bashrc</code>激活环境</p>
<h2 id="3-安装软件"><a class="header-anchor" href="#3-安装软件">¶</a>3 安装软件</h2>
<h3 id="在线软件安装"><a class="header-anchor" href="#在线软件安装">¶</a>在线软件安装</h3>
<p><strong>源列表地址修改(可选)</strong>，如果选用靠近的源速度会比较快，但是可能不是最新的软件。现在好像ubuntu china的官方节点速度还不错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份源列表地址</span></span><br><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup</span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p><strong>在线安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新源</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包search</span></span><br><span class="line">apt-cache search xxx</span><br></pre></td></tr></table></figure>
<h3 id="deb本地软件安装"><a class="header-anchor" href="#deb本地软件安装">¶</a>deb本地软件安装</h3>
<p><strong>安装软件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装deb包命令</span></span><br><span class="line">dpkg -i *.deb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果缺少依赖执行</span></span><br><span class="line">apt-get -f install</span><br></pre></td></tr></table></figure>
<h2 id="4-常用软件"><a class="header-anchor" href="#4-常用软件">¶</a>4 常用软件</h2>
<h3 id="mpv播放器"><a class="header-anchor" href="#mpv播放器">¶</a>mpv播放器</h3>
<h3 id="有道字典"><a class="header-anchor" href="#有道字典">¶</a>有道字典</h3>
<p>有道字典 需要修改一下才能使用。 <a href="http://www.w2bc.com/article/227083" target="_blank" rel="noopener">link</a></p>
<h3 id="atom"><a class="header-anchor" href="#atom">¶</a>atom</h3>
<p>高分屏字体大小，Settings-&gt;Themes-&gt;your stylesheet</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">atom-pane</span> &#123;</span><br><span class="line">     <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.command-palette</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="图标设置"><a class="header-anchor" href="#图标设置">¶</a>图标设置</h3>
<p>对于一些绿化软件来说没有图标，我们可以手动创建一个图标。
在/usr/share/applications目录下创建eclipse启动器配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/share/applications</span><br><span class="line">vim eclipse.desktop</span><br></pre></td></tr></table></figure>
<p>编辑eclipse.desktop并保存。简单的配置示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env xdg-open</span></span><br><span class="line"></span><br><span class="line">[Desktop Entry]</span><br><span class="line">Version=22.0</span><br><span class="line">Name=eclipse</span><br><span class="line">Exec=/home/gtc/Android/adt-bundle-linux/eclipse/eclipse</span><br><span class="line">Terminal=false</span><br><span class="line">Icon=/home/gtc/Android/adt-bundle-linux/eclipse/icon.xpm</span><br><span class="line">Type=Application</span><br><span class="line">Categories=Development</span><br></pre></td></tr></table></figure>
<h2 id="5-其他优化"><a class="header-anchor" href="#5-其他优化">¶</a>5 其他优化</h2>
<h3 id="关闭错误报告"><a class="header-anchor" href="#关闭错误报告">¶</a>关闭错误报告</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭烦人的错误报告</span></span><br><span class="line">sudo gedit /etc/default/apport</span><br></pre></td></tr></table></figure>
<h3 id="CPU-100-占用"><a class="header-anchor" href="#CPU-100-占用">¶</a>CPU 100%占用</h3>
<p>gvfsd-smb-browse CPU 100%占用
我没有修改，它就自己停了，可以在mointer里中止这个进程
地址
<a href="http://tieba.baidu.com/p/4505730863" target="_blank" rel="noopener">http://tieba.baidu.com/p/4505730863</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/lib/gvfs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将gvfsd-smb-brows权限改成744，取消普通用户的执行权限，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也挺有意思，暂时没引发别的问题</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么正好经过这个空隙？</title>
    <url>/public/2017/05/05/math/math_q1/</url>
    <content><![CDATA[<p><strong>前言</strong>
偶然看到的一个问题，如图1，为什么正好经过这个空隙？我们用空间解析几何来解一下吧。</p>
<p><img src="/public/2017/05/05/math/math_q1/math_q1_show.gif" alt="动图"></p>
<div align="center"> 图1 为什么会经过这个空隙？</div>
<a id="more"></a>
<p><strong>解答</strong></p>
<p>如图2，建立空间直角坐标系$xyz$，原点记为 $O$ ， $P$  点为水平杆与斜杆的交点， $Q$ 点为垂直杆与水平杆的交点， 将斜杆标记为 $L$ 。</p>
<p><img src="/public/2017/05/05/math/math_q1/v2-80ac80b8031d5782412f4f4ef4e22a1a_b.jpeg" alt="img"></p>
<div align="center"> 图2 建立空间直角坐标系</div>
<p>设 $OQ=q$  ， $QP=r$  。$Q$ 点坐标为 $(0, 0, q)$  。</p>
<p>设水平杆  $QP$  绕  $z$   轴以  $\omega, rad/s$  的角速度旋转，并设从开始旋转到现在的时长为 $t$  秒， 则  $P$  点坐标为 $(r\cos{\omega t}, r\sin{\omega t}, q)$  。</p>
<p>由 $Q$、$P$ 两点坐标得：</p>
<p>$$
\overrightarrow{OQ}=(0, 0, q) \qquad \overrightarrow{QP}=(r\cos{\omega t}, r\sin{\omega t}, 0) \tag{1}
$$</p>
<p>设 $L$ 的方向向量 $\overrightarrow{S}=(a, b, c) $，由 $L$ 的方向向量 $\overrightarrow{S}$ 和 $P$ 点得，得斜杆  $L$  代表的直线方程：
$$
\frac{x-r\cos{\omega t}}{a}=\frac{y-r\sin{\omega t}}{b}=\frac{z-q}{c} \tag{2}
$$</p>
<p>我们知道 $\overrightarrow{QP}$ 与斜杆 $L$ 垂直，假设 $\overrightarrow{OQ}$ 与斜杆 $L$ 成固定角 $ \theta$ ，得：
$$
\begin{cases} 0=\overrightarrow{QP} \cdot \overrightarrow{S} \ \cos{\theta}=\frac{\overrightarrow{OQ} \cdot \overrightarrow{S}}{\left|\overrightarrow{OQ}\right| \left| \overrightarrow{S}\right|} \end{cases} \tag{3}
$$</p>
<p>把 $\overrightarrow{QP}$， $\overrightarrow{S}$， $\overrightarrow{OQ}$ 代入 式(3)，得
$$
\begin{cases}  \frac{a}{b}=\frac{-\sin{\omega t}}{\cos{\omega t}} \ c^{2}(\tan{\theta})^{2}=a^{2}+b^{2}  \end{cases} \tag{4}
$$</p>
<p>式（4）中第2条等式两边除以 $b^2$ ，再化简得：
$$
\frac{c^{2}}{b^{2}}=\frac{1}{(\tan{\theta})^{2}(\cos{\omega t})^{2}} \tag{5}
$$</p>
<p>求直线组 $L$ 与 $xoz$ 平面相交的图形，即回答这个缝隙的形状为什么是图1 中这样的曲线。我们令 $y=0$ ，代入直线公式(2) 得：
$$
\frac{x-r\cos{\omega t}}{a}=\frac{-r\sin{\omega t}}{b} =\frac{z-q}{c} \tag{6}
$$
由式（4）（5）（6）得到方程组（7）。
$$
\begin{cases} \frac{a}{b}=\frac{-\sin{\omega t}}{\cos{\omega t}}\  \frac{x-r\cos{\omega t}}{a}=\frac{-r\sin{\omega t}}{b} \  \frac{c^2}{b^2}=\frac{1}{(\tan{\theta})^{2}(\cos{\omega t})^{2}}\  \frac{-r\sin{\omega t}}{b} =\frac{z-q}{c}  \end{cases}  \tag{7}
$$</p>
<p>由式（7）中上面两个等式，消去a，b得：
$$
\frac{-\sin{\omega t}}{\cos{\omega t}}=\frac{x-r\cos{\omega t}}{-r\sin{\omega t}}=\frac{a}{b} \tag{8}
$$
$$
x \cos{\omega t}=r   \tag{9}
$$</p>
<p>由式（7）中下面两个等式，消去b，c得：
$$
\frac{1}{(\tan{\theta})^2(\cos{\omega t})^2}
= \frac{(z-q)^2}{(-r\sin{\omega t})^2}
=\frac{c^2}{b^2} \tag{10}
$$</p>
<p>$$
\frac{(-r\sin{\omega t})^2}{(\tan{\theta})^2(\cos{\omega t})^2}
= {(z-q)}^2 \tag{11}
$$</p>
<p>由利用式（9），可消去式（11）中的 $(\sin{\omega t})^{2}$  和 $(\cos{\omega t})^{2}$  得：
$$
x^{2}-(\tan{\theta})^{2}(z-q)^{2}=r^{2} \tag{12}
$$
易知，为双曲线方程，所以在  xoz 平面相交得图形为双曲线。 ■</p>
<hr>
<p>欢迎观众老爷们评论回复，一键三连。
更多有趣问题，欢迎关注投稿 <a href="https://zhuanlan.zhihu.com/shuxuemanyou" target="_blank" rel="noopener">知乎小成 - 数学漫游专栏</a>，
我们聚焦生活中的数与形的小小问题们。
转载请注明出处，谢谢！</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>数学</tag>
        <tag>空间解析几何</tag>
      </tags>
  </entry>
  <entry>
    <title>正则化【一】机器学习中的正则化</title>
    <url>/public/2019/07/17/AI/regulation_baysian/</url>
    <content><![CDATA[<p><strong>前言</strong>
本<strong>正则化系列</strong>文章我们将讨论<strong>正则化技术在机器学习和深度学习的应用</strong>。本文为该系列的第一篇，主要介绍<strong>机器学习正则化的概念，原理和应用实例</strong>。</p>
<p><a href="https://en.wikipedia.org/wiki/Regularization_(mathematics)" target="_blank" rel="noopener">正则化</a> 技术广泛应用在机器学习和深度学习算法中，本质作用是<strong>防止过拟合、提高模型泛化能力</strong>。其中过拟合的简单理解就是训练的算法模型太过复杂，模型过分考虑了当前样本的结构。</p>
<p>在早期的机器学习领域一般只是将范数惩罚叫做正则化技术，而在深度学习领域认为，能够显著减少方差，而不过度增加偏差的策略都可以认为是正则化技术。故<strong>推广的正则化技术</strong>还有：扩增样本集、早停止、Dropout、集成学习、多任务学习、对抗训练、参数共享等。(具体见“花书 第七章 <a href="http://www.deeplearningbook.org/contents/regularization.html" target="_blank" rel="noopener">Regularization for Deep Learning</a>”），关于<strong>深度学习正则化</strong>会在下一篇正则化文章中重点分析。</p>
<p>转载自：<a href="https://blog.csdn.net/BigData_Mining/article/details/81631249" target="_blank" rel="noopener">https://blog.csdn.net/BigData_Mining/article/details/81631249</a></p>
<a id="more"></a>
<h2 id="1-多角度看机器学习正则化"><a class="header-anchor" href="#1-多角度看机器学习正则化">¶</a>1. 多角度看机器学习正则化</h2>
<p><strong>机器学习领域正则化</strong>可以从以下三个角度进行理解：</p>
<p><strong>(1)</strong> <strong>正则化等价于结构风险最小化，其是通过在经验风险项后加上表示模型复杂度的正则化项或惩罚项，达到选择经验风险和模型复杂度都较小的模型目的</strong>。</p>
<p>​	<strong>经验风险</strong>：机器学习中的风险是指模型与真实解之间的误差的积累，经验风险是指使用训练出来的模型进行预测或者分类，存在多大的误差，可以简单理解为训练误差，经验风险最小化即为训练误差最小。</p>
<p>​	<strong>结构风险</strong>：结构风险定义为经验风险与置信风险(置信是指可信程度)的和，置信风险越大，模型推广能力越差。可以简单认为结构风险是经验风险后面多加了一项表示模型复杂度的函数项，从而可以同时控制模型训练误差和测试误差，结构风险最小化即为在保证模型分类精度(经验风险)的同时，降低模型复杂度，提高泛化能力。</p>
<p>​	<strong>公式表达</strong>
$$
R(f)=\frac{1}{n}\sum_{i=1}^{n}L(y_i,f(x_i)) + \lambda \Omega (f)
\tag{1}
$$
​		其中，$R(f)$表示结构风险，$L(y_i,f(x_i))$表示第 $i$ 个样本的经验风险，$\Omega(f)$是表征模型复杂度的正则项，$\lambda$ 是正则化参数。根据奥姆剃刀定律，“如无必要，勿增实体”，即认为相对简单的模型泛化能力更好。而模型泛化能力强、泛化误差小，即表示模型推广能力强，通俗理解就是在训练集中训练得到的优秀模型能够很好的适用于实际测试数据，而不仅仅是减少训练误差或者测试误差。泛化误差定义如下：
$$
E={Bias}^2(X) + {Var}(X) +{Noise}
\tag{2}
$$
​		其中，$E$ 表示泛化误差，${Bias}$ 代表偏差，${Var}$ 代表方差， ${Noise}$ 代表噪声。</p>
<p>​	<strong>关系图</strong></p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/1563350068097.png" alt="1563350068097"></p>
<div align="center"> Fig 1. 泛化误差与偏差和方差的关系</div>
​		从 Fig 1 可以看出，随着训练程度加深，模型复杂度会增加，偏差减少，方差增大，而泛化误差呈现U型变化。对于一个“好的系统”通常要求误差小，正则化的作用即为适当的控制模型复杂度，从而使得**泛化误差曲线**取最小值。
<p><strong>(2)</strong> <strong>正则化等价于带约束的目标函数中的约束项</strong></p>
<p>以平方误差损失和L2范数为例，优化问题的数学模型如下：
$$
J(\theta)=\sum_{i=1}^{n}(y_i-\theta^Tx_i)^2
\tag{3}
$$
$$
{s.t.}{|| \theta ||}_2^2 \leq C\<br>
\tag{4}
$$</p>
<p>针对上述约束条件的优化问题，采用拉格朗日乘积算子法可以转化为无约束化问题，即
$$
J(\theta)=\sum_{i=1}^{n}(y_i-w^Tx_i)^2 + \lambda({|| \theta ||}_2^2-C)
\tag{5}
$$</p>
<p>由于参数 $C$ 为常数，可以忽略，故上述公式和标准的正则化 公式完全一致。</p>
<p><strong>(3)</strong> <strong>从贝叶斯角度考虑</strong></p>
<p>正则项等价于引入参数的模型先验概率，可以简单理解为对最大似然估计引入先验概率，从而转化为最大后验估计，其中的先验概率即对于正则项（这部分内容后面详细讲解）。</p>
<h2 id="2-基本概念"><a class="header-anchor" href="#2-基本概念">¶</a>2 基本概念</h2>
<p>正则化也可以成为规则化、权重衰减技术，不同的领域叫法不一样，数学上常用范数实现，例如L1和L2范数，统计学领域叫做惩罚项、罚因子。</p>
<p>下面给出范数的数学公式，方便以后分析：</p>
<p>​	(1) $p$ 范数：
$$
Lp=(\sum_{i=1}^{n}{|| x_i ||}^p)^{\frac{1}{p}}
\tag{6}
$$
​	(2) $L0$ 范数：0 范数表示向量中非零元素的个数（即为其稀疏度）</p>
<p>​	(3) $L1$ 范数：即向量元素绝对值之和，$p$ 范数取1，即为1范数
$$
{||x||}_1=\sum^n_1 {|| x_i || }
\tag{7}
$$</p>
<p>​	(4) $L2$ 范数：即向量元素绝对值的平方和再开发，也称欧几里得距离，$p$ 范数取2，即为2范数
$$
{||x||}_{2}=\sqrt{\sum^{n}_1|| x_i ||^2}
\tag{8}
$$</p>
<p>​	(5) $\infty $ 范数：即所有向量元素的绝对值中的最大值，$p$ 范数取 $\infty $，即为 $\infty $ 范数
$$
{||x  ||}_{\infty }=\underset{i}{\max}{\left | x_i \right |}
\tag{9}
$$</p>
<p>​	(6) $-\infty $ 范数：即所有向量元素绝对值中的最小值，$p$ 范数取$-\infty $，即为 $-\infty $ 范数
$$
{||x  ||}_{-\infty }=\underset{i}{\min}{\left | x_i \right |}
\tag{10}
$$
<strong>图形描述</strong></p>
<p>​		从 Fig 2、Fig 3 图可以看出：q(p)越小，曲线越贴近坐标轴，q(p)越大，曲线越远离坐标轴，并且棱角越明显，当q(p)取0时候，是完全和坐标轴贴合，当q(p)取无穷的时候，呈现正方体形状。同时也可以看出，采用不同的范数作为正则项，会得到完全不同的算法模型结果，故而对于不同要求的模型，应该采用不同的范数作为正则项。</p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/1563354053269.png" alt="1563354053269"></p>
<div align="center"> Fig 2. 向量长度为2维的范数约束</div>
![1563354456894](regulation_baysian/1563354456894.png)
<div align="center"> Fig 3. 向量长度为3维的范数约束</div>
## 3 深度理解
<p>​		为了更好的理解正则化技术原理，下面从4个方面进行深度分析，希望对大家理解有帮助。</p>
<h3 id="3-1-简单数值假设分析法"><a class="header-anchor" href="#3-1-简单数值假设分析法">¶</a>3.1 简单数值假设分析法</h3>
<p>​		此处以L2范数讲解，下面的各图形来自吴恩达的机器学习课程。</p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/image-20190619002115576.png" alt="image-20190619002115576"></p>
<div align="center"> Fig 4. 不同参数下的曲线拟合结果</div>
​		左边的曲线拟合是欠拟合，中间的曲线拟合是刚好合适，右边的曲线拟合是过拟合。对于右边的拟合曲线，有
$$
h_{\theta}(x)={\theta}_0+{\theta}_0 x_1 +{\theta}_2 x_2^2 +{\theta}_3 x_3^3 +{\theta}_4 x_4^4
\tag{11}
$$
​		从上式可以看出，由于$\theta_3$和$\theta_4$对应了高阶，导致拟合曲线是4阶曲线，出现了过拟合。正则化的目的为适当缩减$\theta_3$和$\theta_4$的值，例如都为0.0001，则上述曲线本质上等价与
$$
h_{\theta}(x)={\theta}_0 + {\theta}_1 x_1 +{\theta}_2 x_2^2
\tag{12}
$$
​		也就是变成了中间的刚好合适的拟合曲线。对于$\theta_3$ 和$\theta_4$增加 L2 正则项后的代价函数表达式为：
$$
J(\theta)= \underset{\theta}{\min}\frac{1}{n}\sum_{i=1}^{n}((h_{\theta}(x_i)-y_i)+1000{\theta}_3^2 + 1000 {\theta}_4^2)
\tag{13}
$$
​		从上式可以看出，$\theta_3^2$ 和 $\theta_4^2$ 均大于 0，其乘上了1000，要 $J(\theta)$ 是最小，则会迫使模型学习到的$\theta_3$ 和 $\theta_4$ 会非常小，因为只有在$\theta_3$ 和 $\theta_4$ 会非常小的情况下整个代价函数值才会取的较小值。在实际开发中，是对所有参数进行正则化，为了使代价函数尽可能的小，所有的参数 $\theta$ 的值（不包括 $\theta_0$）都会在一定程度上减小，但是减小程度会不一样，从而实现了权重衰减、简化模型复杂度的作用。
<h3 id="3-2-图形分析法"><a class="header-anchor" href="#3-2-图形分析法">¶</a>3.2 图形分析法</h3>
<p>​		此处采用L1和L2范数讲解：
<strong>(1) L2 范数正则</strong>
$$
J(\beta)=\sum_{i=1}^{n}(y_i-{\beta}^T x_i)^2 + \lambda {|| {\beta} ||}_2^2
\tag{14}
$$
<img src="/public/2019/07/17/AI/regulation_baysian/1563366078400.png" alt="1563366078400"></p>
<div align="center"> Fig 5. L2 范数与代价函数的寻优图示</div>
​		在 Fig 5 中，蓝色的圆形空间表示 L2 范数空间，设为 $\beta_1^2 + \beta_2^2 = r^2$，可以看出，当 $r$ 从 0 逐渐增大时候，该圆形也逐渐增大，红色的线表示原始代价函数解空间即 $\sum_{i=1}^{n}(y_i-\beta^T x_i)^2$，此处为了方便绘图，设参数只有2维。红色圆环上的任何一点都表示一个可行解即代表一组$\beta_1$、$\beta_2$，其中任何一个红色圆环上面的$\beta_1$，$\beta_2$对应的代价函数值一样（可以简单理解为等值线），$\hat{\beta}$ 代表最佳解空间。
<h2 id="4-贝叶斯角度分析"><a class="header-anchor" href="#4-贝叶斯角度分析">¶</a>4. 贝叶斯角度分析</h2>
<p>​		以L1和L2范数为例，所得结论可以推广到P范数中，首先需要知道：整个最优化问题从贝叶斯观点来看是一种贝叶斯最大后验估计，其中正则化项对应后验估计中的先验信息，损失函数对应后验估计中的似然函数，两者的乘积即对应贝叶斯最大后验估计的形式。针对L1和L2范数还有结论：<strong>L2 范数相当于给模型参数设置一个协方差为1/alpha的零均值高斯先验分布，L1 范数相当于给模型参数 设置一个参数为1/alpha 拉普拉斯先验分布</strong>。</p>
<p>​		为了讲清楚上述结论，需要具备几点前置知识点：(1) 高斯分布和拉普拉斯分布的定义和形状；(2) 贝叶斯定理；(3) 最大似然估计；(4) 最大后验估计。下面我对这4个知识点进行解释。</p>
<p><strong>(1)</strong> <strong>高斯分布和拉普拉斯分布</strong></p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0.png" alt="0?wx_fmt=png"></p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610163845194.png" alt="0?wx_fmt=png"></p>
<p><strong>(2)</strong> <strong>最大似然估计</strong></p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610163845276.png" alt="0?wx_fmt=png"></p>
<p>​		如果上述公式不能理解，请各位读者去复习一下大学课程《概率论与数理统计》中的参数估计章节，为了更方便理解，下面举一个例子：假设我要统计出整个大学内所有同学的身高分布情况，设全校一共20000人，数量庞大，所有人都去问一遍不太靠谱，所以我打算采用抽样方法来估计，假设我已经知道身高分布服从高斯分布，但是我不知道高斯分布中的均值和方差参数，现在我打算采用最大似然估计方法来确定这两个参数。首先需要明确，全校20000即为总体X，我随机从各个班抽取10名同学，假设一共抽了2000个同学，那么2000同学就构成了样本空间，由于每个样本的概率密度函数已知，则很容易写出似然函数，对数求导即可求解参数。</p>
<p><strong>(3)</strong> <strong>最大后验估计</strong></p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610163845259.png" alt="0?wx_fmt=png"></p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610163845297.png" alt="0?wx_fmt=png"></p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610163845289.png" alt="0?wx_fmt=png"></p>
<h2 id="5-例子"><a class="header-anchor" href="#5-例子">¶</a>5. 例子</h2>
<h3 id="5-1-逻辑回归"><a class="header-anchor" href="#5-1-逻辑回归">¶</a>5.1 逻辑回归</h3>
<p>​		二分类逻辑回归使用Sigmoid作为决策函数进行分类，该函数可以将任意的输入映射到[0,1]区间，当预测结果小于0.5，则表示负类，当预测结果大于0.5.则表示正类，其模型本质是求最大似然估计，具体求解似然函数通常使用梯度下降法，而前面说过：最大似然估计法没有考虑训练集以外的因素，很容易造成过拟合，故而逻辑回归一般采用L2范数进行正则化操作，Sigmoid函数定义和图形如下：</p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0.jpeg" alt="0?wx_fmt=png"></p>
<h3 id="5-2-岭回归-Ridge-Regression"><a class="header-anchor" href="#5-2-岭回归-Ridge-Regression">¶</a>5.2 岭回归(Ridge Regression)</h3>
<p>​		岭回归本质上是针对线性回归问题引入了L2范数正则，通过缩减回归系数避免过拟合问题，最先用来处理特征数多于样本数的情况(高维小样本问题)，现在也用于在估计中加人偏差，从而得到更好的估计，加了正则化后的代价函数如下：</p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610174921016.png" alt="0?wx_fmt=png"></p>
<h3 id="5-3-Lasso-回归"><a class="header-anchor" href="#5-3-Lasso-回归">¶</a>5.3 Lasso 回归</h3>
<p>​		拉索回归(lasso回归)本质上是针对线性回归问题引入了L1范数正则，通过缩减回归系数避免过拟合问题，其不同于L2范数，其可以将某些系数缩减为0即所谓的具备稀疏性(稀疏性的好处是简化计算、容易理解模型、减少存储空间、不容易出现过拟合等等)，加了正则化后的代价函数如下：</p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610174920968.png" alt="0?wx_fmt=png"></p>
<p>​		其中，参数函数和岭回归中相同。L1范数罚有一个问题：由于|X|函数在0处不可导，故而直接使用最小二乘法、梯度下降法等方法均失效，但是由于其为第一类间断点中的可去间断点，可以通过补充该点的定义解决，通常，对于线性回归中的lasso回归可以采用近似的前向逐步回归替代。</p>
<h3 id="5-4-SVM"><a class="header-anchor" href="#5-4-SVM">¶</a>5.4 SVM</h3>
<p>​		支持向量机SVM优化目的为寻找一个超平面，使得正负样本能够以最大间隔分离开，从而得到更好的泛化性能，其通过引入核函数来将低维线性不可分的样本映射到高维空间从而线性可分，通过引入惩罚参数C(类似于正则化参数)来对错分样本进行惩罚，从而减少模型复杂度，提高泛化能力，其优化目标如下：</p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610174921029.png" alt="0?wx_fmt=png"></p>
<p>​		大家如果不知道上面公式的推导，不用紧张，对于本次内容不是重点，只需要关注后面正则项部分，惩罚参数C作用和正则化参数作用一致，只是反相关而已。需要明白以下结论：</p>
<p>​		<strong>(1)</strong> C越大，正则化参数越小，表示对分错样本的惩罚程度越大，正则化作用越小，偏差越小，方差越大，越容易出现过拟合(通俗理解，原本将低维空间映射到5维空间正好线性可分，但是由于惩罚过于严重，任何一个样本分错了都不可原谅，结果系统只能不断提高维数来拟合样本，假设为10维，最终导致映射维数过高，出现过拟合样本现象，数学上称为VC维较大)；</p>
<p>​		<strong>(2)</strong> C越小，正则化参数越大，表示对分错样本的惩罚程度越小，正则化作用越大，偏差越大，方差越小，越容易出现欠拟合(通俗理解，原本将低维空间映射到5维空间正好线性可分，但是由于惩罚过小，分错了好多样本都可以理解，比较随意，结果系统也采用简化版来拟合样本，假设为3维，最终导致映射维数过低，出现欠拟合样本现象，数学上称为VC维较小)。</p>
<h2 id="6-总结"><a class="header-anchor" href="#6-总结">¶</a>6. 总结</h2>
<p>根本目的本质：防止过拟合，提高模型泛化能力。</p>
<p>正则化技术分类：
<strong>狭义上</strong>（不同地方叫法不同）</p>
<ul>
<li>在早期的机器学习领域一般只是将范数惩罚叫做正则化技术</li>
<li>规则化、权重衰减</li>
<li>从贝叶斯角度考虑，正则项等价于引入参数的模型先验概率</li>
</ul>
<p><strong>广义上</strong>：
能够显著减少方差，而不过度增加偏差的策略都可以认为是正则化技术，推广的正则化技术还有：扩增样本集、早停止、Dropout、集成学习、多任务学习、对抗训练、参数共享等。</p>
<h2 id="Reference"><a class="header-anchor" href="#Reference">¶</a>Reference</h2>
<p><a href="https://blog.csdn.net/BigData_Mining/article/details/81631249" target="_blank" rel="noopener">正则化总结的比较好比较全面的文章</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>正则化</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter notebook的配置</title>
    <url>/public/2017/07/03/linux/jupyter_notebook/</url>
    <content><![CDATA[<p><strong>前言</strong>
本文介绍jupyter notebook的安装配置过程和实用技巧。
<a href="https://jupyter.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">jupyter.readthedocs教程</a></p>
<a id="more"></a>
<h2 id="1-安装与配置"><a class="header-anchor" href="#1-安装与配置">¶</a>1 安装与配置</h2>
<h3 id="1-1-安装-jupyter"><a class="header-anchor" href="#1-1-安装-jupyter">¶</a>1.1 安装 jupyter</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install jupyter</span><br><span class="line"><span class="comment"># pip install jupyter -y</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-修改配置文件"><a class="header-anchor" href="#1-2-修改配置文件">¶</a>1.2 修改配置文件</h3>
<ul>
<li>生成配置文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br><span class="line">vim ~/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure>
<ul>
<li>修改配置文件内容</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.ip = <span class="string">'0.0.0.0'</span></span><br><span class="line">c.NotebookApp.port = <span class="number">8018</span></span><br><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">c.NotebookApp.password = <span class="string">u'sha1:bcd259ccf...your hashed password here'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip: 利用ipython 生成密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; In [1]: from IPython.lib import passwd</span><br><span class="line">&gt; In [2]: passwd()</span><br><span class="line">&gt;   Enter password:</span><br><span class="line">&gt;   Verify password:</span><br><span class="line">&gt;   Out[2]: &apos;sha1:67xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&apos;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我选用的是password密码登陆jupyter的方案，其他的密码登陆方案见 <a href="https://zhuanlan.zhihu.com/p/23110830" target="_blank" rel="noopener">link</a></p>
<h3 id="1-3-安装插件管理"><a class="header-anchor" href="#1-3-安装插件管理">¶</a>1.3 安装插件管理</h3>
<p>jupyter_contrib_nbextensions 为 jupyter notebook 扩展插件管理器，下面简称nbextensions。</p>
<p>nbextensions的github <a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" target="_blank" rel="noopener">repo</a>
nbextensions的教程<a href="https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/" target="_blank" rel="noopener">nbextensions_manual_readthedocs</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用conda安装</span></span><br><span class="line">conda install jupyter</span><br><span class="line">conda install -c conda-forge jupyter_contrib_nbextensions</span><br><span class="line"></span><br><span class="line"><span class="comment"># pip安装</span></span><br><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使能</span></span><br><span class="line">jupyter contrib nbextension install</span><br></pre></td></tr></table></figure>
<p>我启用的一些插件</p>
<table>
<thead>
<tr>
<th>plugins</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Table of Contents (2)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Freeze</td>
<td>比较好的一个插件，可以用来冻住cell</td>
<td></td>
</tr>
<tr>
<td>nbTranslate</td>
<td>这个插件利用Google翻译cell很好用</td>
<td><a href="https://github.com/jfbercher/jupyter_nbTranslate/blob/master/languages.js" target="_blank" rel="noopener">support languages</a></td>
</tr>
<tr>
<td>ExecuteTime</td>
<td>显示执行时间</td>
<td></td>
</tr>
<tr>
<td>Ruler</td>
<td>代码标尺</td>
<td></td>
</tr>
<tr>
<td>Autopep8</td>
<td>代码美化</td>
<td></td>
</tr>
<tr>
<td>Scratchpad</td>
<td>代码测试</td>
<td></td>
</tr>
</tbody>
</table>
<p>其他花样的配置</p>
<p><a href="https://zhuanlan.zhihu.com/p/74950682" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/74950682</a></p>
<h3 id="1-4-conda环境的设置"><a class="header-anchor" href="#1-4-conda环境的设置">¶</a>1.4 conda环境的设置</h3>
<p>jupyter使用Anaconda miniconda环境需要安装的组件。
[conda repo][<a href="https://repo.anaconda.com" target="_blank" rel="noopener">https://repo.anaconda.com</a>]</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建虚拟环境</span></span><br><span class="line">conda create -n env_name python=3.6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> conda虚拟核组件 切换kernel</span></span><br><span class="line">conda install nb_conda_kernels</span><br></pre></td></tr></table></figure>
<h3 id="1-5-解决界面中英文混杂"><a class="header-anchor" href="#1-5-解决界面中英文混杂">¶</a>1.5 解决界面中英文混杂</h3>
<img src="/public/2017/07/03/linux/jupyter_notebook/image-20200413125705473.png" alt="image-20200413125705473" style="zoom:50%;">
<p>如图，jupyter 界面中中英文混杂，解决方法为将界面文字中文切换成英文。</p>
<p>原理：让jupyter就找不到他的中文配置文件夹。</p>
<p>找到notebook的汉化文件夹的路径，比如<code>~/miniconda3/lib/python3.6/site-packages/notebook/i18n/zh_CN</code>。将其重命名如加个下划线作为后缀<code>zh_CN_old</code>，重启jupyter就行了。</p>
<p>为了方便，我作了个脚本自动找<code>notebook/i18n/zh_CN</code>位置并改名此文件夹，如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> distutils.sysconfig <span class="keyword">import</span> get_python_lib</span><br><span class="line"><span class="comment"># 获取site-package包的位置</span></span><br><span class="line">path_zh=get_python_lib()+<span class="string">'/notebook/i18n/zh_CN'</span></span><br><span class="line">path_zh_old=get_python_lib()+<span class="string">'/notebook/i18n/zh_CN_old'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 notebook/i18n/zh_CN 改为 notebook/i18n/zh_CN_old</span></span><br><span class="line">shutil.move(path_zh,path_zh_old)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回中文</span></span><br><span class="line"><span class="comment"># shutil.move(path_zh_old,path_zh)</span></span><br></pre></td></tr></table></figure>
<p>重启jupyter就行了, 这样jupyter就找不到这个中文配置，返回中文改回去就行了<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<h2 id="2-使用的技巧"><a class="header-anchor" href="#2-使用的技巧">¶</a>2 使用的技巧</h2>
<h3 id="2-1-快捷键"><a class="header-anchor" href="#2-1-快捷键">¶</a>2.1 快捷键</h3>
<hr>
<table>
<thead>
<tr>
<th>在非激活状态即是蓝颜色的边框</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>insert cell above</td>
</tr>
<tr>
<td>B</td>
<td>insert cell below</td>
</tr>
<tr>
<td>H</td>
<td>查看帮助</td>
</tr>
<tr>
<td>⌃↩(ctrl + enter)</td>
<td>run selected cells</td>
</tr>
</tbody>
</table>
<h3 id="2-2-显示图片-视频-音频"><a class="header-anchor" href="#2-2-显示图片-视频-音频">¶</a>2.2 显示图片 视频 音频</h3>
<p>主要是画图、显示视频和音频的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 图片</span></span><br><span class="line">%%HTML</span><br><span class="line">&lt;img src=<span class="string">"xxx.jpg"</span>  alt=<span class="string">"title"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频</span></span><br><span class="line">%%HTML</span><br><span class="line">&lt;video width=<span class="string">"330"</span> height=<span class="string">"150"</span> controls&gt;</span><br><span class="line">&lt;source src=<span class="string">"out_all.mp4"</span> type=<span class="string">"video/mp4"</span>&gt;</span><br><span class="line">&lt;/video&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语音</span></span><br><span class="line">%%HTML</span><br><span class="line">&lt;audio src=<span class="string">"out.wav"</span> controls=<span class="string">"controls"</span>&gt;</span><br><span class="line">Your browser does <span class="keyword">not</span> support the audio element.</span><br><span class="line">&lt;/audio&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># html t是html的字符串</span></span><br><span class="line"><span class="keyword">from</span> IPython.core.display <span class="keyword">import</span> HTML</span><br><span class="line">HTML(str(t))</span><br></pre></td></tr></table></figure>
<h3 id="2-3-其他技巧"><a class="header-anchor" href="#2-3-其他技巧">¶</a>2.3 其他技巧</h3>
<h4 id="修复视频文件"><a class="header-anchor" href="#修复视频文件">¶</a>修复视频文件</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix_use_ffmpeg</span><span class="params">(in_name, out_name,message=<span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(out_name):</span><br><span class="line">    os.remove(out_name)</span><br><span class="line">    cmd = <span class="string">'ffmpeg -i %s %s'</span> % (in_name, out_name)</span><br><span class="line">    log_lines = os.popen(cmd).readlines()</span><br><span class="line">    print(message,<span class="string">"ok"</span>)</span><br></pre></td></tr></table></figure>
<h4 id="加载自己的模块文件"><a class="header-anchor" href="#加载自己的模块文件">¶</a>加载自己的模块文件</h4>
<p>出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果你修改了你的模块，需要重启解释器；或者，如果你就是想交互式的测试这么一个模块，可以用 imp.reload() 重新加载，例如 <code>import imp; imp.reload(modulename)</code></p>
<h4 id="导出pdf支持中文"><a class="header-anchor" href="#导出pdf支持中文">¶</a>导出pdf支持中文</h4>
<p>Jupyter Notebook 输出PDF中文支持 <a href="https://www.jianshu.com/p/c3f660188766" target="_blank" rel="noopener">link</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/lib/python3.6/site-packages/nbconvert/templates/latex</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在里面的模版中添加，前提是安装好了texlive</span></span><br><span class="line">% add</span><br><span class="line">\usepackage&#123;ctex&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ipynb2pdf"><a class="header-anchor" href="#ipynb2pdf">¶</a>ipynb2pdf</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Current version of Jupyter doesn't support pdf exporting when it comes to</span></span><br><span class="line"><span class="string">russian language in the document. To fix this, current script has born.</span></span><br><span class="line"><span class="string">It requires nbconvert as long as jupyter to be installed.</span></span><br><span class="line"><span class="string">Author:     Sergey Ivanychev</span></span><br><span class="line"><span class="string">Email:      sergeyivanychev@gmail.com</span></span><br><span class="line"><span class="string">Revision:   1</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">FORMAT = <span class="string">".ipynb"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">TODO:   What if user has ___o.tex in current folder?</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">TEMP_TEX = <span class="string">"___o.tex"</span></span><br><span class="line">TEMP_FOLDER = <span class="string">"/tmp"</span></span><br><span class="line">TRASH_EXTENSIONS = [<span class="string">".aux"</span>, <span class="string">".out"</span>, <span class="string">".log"</span>]</span><br><span class="line">OLD1 = <span class="string">r"\usepackage[utf8x]&#123;inputenc&#125;"</span></span><br><span class="line">NEW1 = <span class="string">r"""</span></span><br><span class="line"><span class="string">    \usepackage[utf8x]&#123;inputenc&#125;</span></span><br><span class="line"><span class="string">    \usepackage&#123;ctex&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">REPLACE = [(OLD1, NEW1)]</span><br><span class="line">HELP = <span class="string">"""</span></span><br><span class="line"><span class="string">This script is aimed at correctly converting .ipynb to .pdf files.</span></span><br><span class="line"><span class="string">You may use it via</span></span><br><span class="line"><span class="string"># ipynb2pdf Solution.ipynb</span></span><br><span class="line"><span class="string">To get .pdf in the same directory</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_args</span><span class="params">(argv)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> (len(argv) &gt; <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">"Please, type .ipynb filename as argument"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> (len(argv) == <span class="number">1</span>):</span><br><span class="line">        print(HELP)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    script, filename = argv</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_ipynb(filename):</span><br><span class="line">        print(<span class="string">"Please, type .ipynb filename as argument"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_extention</span><span class="params">(string, extention)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Removes argumented extention from the end of the string</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> extention[<span class="number">0</span>] != <span class="string">'.'</span>:</span><br><span class="line">        extention = <span class="string">"."</span> + extention</span><br><span class="line">    <span class="keyword">if</span> string.endswith(extention):</span><br><span class="line">        string = string[<span class="number">0</span>:-len(extention)]</span><br><span class="line">    <span class="keyword">return</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_ipynb</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> filename.endswith(<span class="string">".ipynb"</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tex2pdf</span><span class="params">(filename, desired_name)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Converts filename (which is tex document) to desired_name (which is pdf)</span></span><br><span class="line"><span class="string">    leaving no trash in current folder</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    base = remove_extention(filename, <span class="string">"tex"</span>)</span><br><span class="line">    output = base + <span class="string">".pdf"</span></span><br><span class="line">    ret = subprocess.call(<span class="string">"xelatex %s"</span> % filename , </span><br><span class="line">                                        shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">for</span> ext <span class="keyword">in</span> TRASH_EXTENSIONS:</span><br><span class="line">        os.unlink(base + ext)</span><br><span class="line">    os.rename(output, desired_name)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> check_args(argv) == <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    script, filename = argv</span><br><span class="line">    ret = subprocess.call(<span class="string">"jupyter nbconvert %s --to latex --output %s"</span> %</span><br><span class="line">                                            (filename, TEMP_TEX), shell=<span class="literal">True</span>,</span><br><span class="line">                                            stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>):</span><br><span class="line">        print(<span class="string">"ret = %d"</span> % ret)</span><br><span class="line">        os.unlink(TEMP_TEX)</span><br><span class="line">        print(<span class="string">"Converting to LaTeX failed. Return code: %d"</span> % ret)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    tex_file = open(TEMP_TEX, <span class="string">"r"</span>)</span><br><span class="line">    tex = tex_file.read()</span><br><span class="line">    <span class="keyword">for</span> old, new <span class="keyword">in</span> REPLACE:</span><br><span class="line">        tex = tex.replace(old, new)</span><br><span class="line">    tex_file.close()</span><br><span class="line">    os.unlink(TEMP_TEX)</span><br><span class="line">    tex_file = open(TEMP_TEX, <span class="string">"w+"</span>)</span><br><span class="line">    tex_file.write(tex)</span><br><span class="line">    tex_file.close()</span><br><span class="line">    ret = tex2pdf(TEMP_TEX, remove_extention(filename, <span class="string">".ipynb"</span>) + <span class="string">".pdf"</span>)</span><br><span class="line">    tex_file.close()</span><br><span class="line">    os.unlink(TEMP_TEX)</span><br><span class="line">    print(remove_extention(filename, <span class="string">".ipynb"</span>) + <span class="string">".pdf - DONE"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    exit(main(sys.argv))</span><br></pre></td></tr></table></figure>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://www.zhihu.com/question/302814218/answer/1029684239" target="_blank" rel="noopener">https://www.zhihu.com/question/302814218/answer/1029684239</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>jupyter</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Python</tag>
        <tag>笔记应用</tag>
      </tags>
  </entry>
  <entry>
    <title>红楼梦与我</title>
    <url>/public/2017/05/14/readings/hongloumeng/</url>
    <content><![CDATA[<p>红楼梦是我国四大名著之一，主要内容是贾府的兴衰和宝黛的悲剧爱情。电视剧红楼梦2010版，我是从八月开始看的，看完到现在，也有小一个月了。在网上大家对这版电视剧褒贬不一。与我来说，我是喜欢这部剧的，不能说拍得很好，但这部剧却勾起了我读书与写字的兴趣。于是乎，做了一篇随笔，以记录我的一些感触。</p>
<a id="more"></a>
<p>我记得最早是小学，我们还是顾着打玻璃珠和丢沙包的年纪，学校旁边的小书店里，也都是七龙珠，哆啦A梦，柯南的小人书，老师们讲到四大名著，顺带提了下红楼梦，其他没印象了。我们学习最多的是中文的拼音和书写，作文都是打油，日记也闹了不少笑话。后来上初中，有一次寒假附加作业是阅读红楼梦，我虽毫无兴趣，但还是硬着头皮，去新华书店，试看红楼梦。120章的红楼，厚得连看下去的勇气也没有。略看了几下，最后，做了一个红楼梦不好看的论断，也就放在那边了。那时有老版的红楼梦电视剧播映，打开电视偶尔会遇见，但是立马换台，央视的西游记与情深深雨蒙蒙，湖南电视台的还珠格格，也是欣赏了好几遍。再者，有动画片谁有兴趣去看这些什么破剧，关于书本，最多也就是看看汤姆索亚历险记。</p>
<p>再后来，去启中读书，学习上比较紧张，再加上理科班的非文学氛围，对这些文学的东西更不感冒。尽管偶尔也会入耳一些其中的人物，比如林妹妹，刘姥姥，也是不用大脑耳朵直接过滤。当时，大伙是杂志，读者，青年文摘读得比较多，班上一本，全班查阅，杂志文章篇幅较小，读起很顺很舒服。期间，与红楼的唯一一次接触是，高中教科书上有刘姥姥进大观园的章节，翻了一遍，当时，感叹人物好多，理不出人物关系，完全放弃看完红楼的欲望。以为姥姥是贾府的姥姥，猩猩然想着以后可以说看过一段红楼，红楼也比较贵不如多买几本读者，积累作文素材。不知什么时候，班上网络小说之风随着mp4和智能手机的普及而吹起，我也用MP4刷完了一两部网络小说，感觉都是一个套路，主角都是绝处逢生，越来越无敌，也就不敢兴趣了。</p>
<p>再然后，我上大学，藏书400百万册的成电图书馆，也并没有引起我读文学类的欲望，大学四年借的专业工具类书比较多，想来也是浪费资源。在一个工科高校，文学方面的课程几乎没有，虽说有个大学语文的选修课，俨然不感兴趣。大学里，再一次看到有人在看红楼梦电视剧，也是大二的时候的人工智能课上，也是闲得无聊。再后来，大四时，手机上自带一个蜻蜓网络电台应用，无聊点开蒋勋老师评述的红楼梦音频，红学大师讲到他与红楼梦的相遇，同时，他介绍的红楼基本背景和人物，通俗易懂，一下子引起我的兴趣。他说红楼梦写的都是15、6岁人的故事，15、16岁就可以读了。回想我15、16岁，基本没看什么名著。要说四大名著，我也就看了三国和水浒的少年版。上次回家，看美剧，老妈突然蹦出句，不能光看英文也应当看看我们老祖宗的文化。</p>
<p>现在得空，就这样抱着惭愧和一丝尝试我看起了2010版红楼梦。在这我得承认，我是个演员控。不得不说，三大主演都很不错。</p>
<p>50集过后，原来红楼讲得是这个，并表示有兴趣去读读名著了。原来有这么多原来。</p>
<ul>
<li>
<p>人物家族命运令人感慨。作者写出超越那个时代的朦胧的爱情与不得不提的丧心病狂的全部悲剧，果然是个失意文人的作品。 可叹停机德，堪怜咏絮才。宝钗落落大方德才兼备，黛玉因情而伤而痛去世，宝玉虽与宝钗结婚，最后离家成道去。精于人情世故,，胸有城府的王熙凤，平日的爽朗笑声终究悲剧，贾府里多么好的领导，最后也人情冷暖，不免为其伤心。刘姥姥，其实是个成功的投机分子，但也是朴实善良的“穷亲戚”，最后救了巧儿。十二金钗各有个的悲剧，正如宝玉在虚幻仙境里警幻仙姑给的设定。原来故事一开始就把结局告诉了读者。</p>
</li>
<li>
<p>体验古代贵族文化。里面还有个诗社的组织，古人的结社，好有雅致，也会给人起“绰号”。除此以外还有击鼓传花，有时主题是讲笑话有时对诗。猜灯谜，中秋赏月，生日宴会等等。</p>
</li>
<li>
<p>语言魅力。打秋风，这是形容刘姥姥找找贾府接济用的。恼，生气，或者使生气。不同人的称谓，宝兄弟，宝二爷，宝姐姐或者好姐姐，林妹妹或者好妹妹。</p>
</li>
<li>
<p>情节回味无穷。刘姥姥进大观园，是贾母和姥姥差不多年纪想和她聊聊，邀请她的。乡村来打秋风的刘姥姥像是在参观皇宫。在后面时期  ，家族里一次比一次捉襟见肘的聚会，可以看见这些家族的衰落。中国的各种人情世故体现在这里面。四个大家族，一个小社会。</p>
</li>
</ul>
<p>以上是我的一点点感悟。</p>
<p>只是，我与红楼梦，还差80章书页，希望还能有计划地读完。</p>
<p>2016年于成电</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>故事</tag>
        <tag>《红楼梦》</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】《中华古籍资源库》中国国家图书馆</title>
    <url>/public/2021/12/16/readings/zhonghuaguji/</url>
    <content><![CDATA[<p><strong>简介</strong></p>
<p>“中华古籍资源库”是“中华古籍保护计划”的重要成果。2016年9月28日，“中华古籍资源库”正式开通运行，陆续发布国家图书馆藏善本和普通古籍、法国国家图书馆藏敦煌遗书、天津图书馆藏普通古籍、日本永青文库捐赠汉籍、云南省图书馆善本古籍、芷兰斋藏稿抄校本等古籍影像资源，总量超过3.3万部。</p>
<p>《中华古籍资源库》！！！<br>
网址：<a href="http://www.nlc.cn/pcab/zy/zhgj_zyk/" target="_blank" rel="noopener">http://www.nlc.cn/pcab/zy/zhgj_zyk/</a><br>
查询：<a href="http://read.nlc.cn/thematDataSearch/toGujiIndex" target="_blank" rel="noopener">http://read.nlc.cn/thematDataSearch/toGujiIndex</a></p>
<img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216225907506.png" alt="image-20211216225907506" style="zoom:30%;">
<a id="more"></a>
<p>比如：《九章算数》的古籍</p>
<img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216231340351.png" alt="image-20211216231340351" style="zoom:30%;">
<img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216231141739.png" alt="image-20211216231141739" style="zoom:30%;">
<p>比如：卷第九的勾股</p>
<img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216232009068.png" alt="image-20211216232009068" style="zoom:50%;">
<ul>
<li>
<p>数字古籍
国家图书馆收藏古籍15万部，其中善本古籍直接继承了南宋缉熙殿、元翰林国史院、明文渊阁、清内阁大库等皇家珍藏，以及明清以来许多私人藏书家的毕生所聚。宋元旧椠、明清精刻琳琅满目。通过全彩影像数字化和缩微胶卷转化影像方式建设，从2016年9月28日起陆续在线发布，目前已发布馆藏古籍2万余部，国家图书馆超过三分之二的善本古籍实现了在线阅览。</p>
</li>
<li>
<p>数字方志
地方志文献为我国所特有，也是国家图书馆独具特色的馆藏之一，所存文献数量与品质极高。该数据库以国家图书馆藏地方志文献建设，主要包括为清代（含清代）以前的方志资源6529种。</p>
</li>
<li>
<p>赵城金藏
《赵城金藏》被誉为国家图书馆四大镇馆之宝之一。《赵城金藏》是在金代刻的一部大藏，因为它藏在赵城县（今属山西洪洞县）广胜寺，所以后人将它定名为《赵城金藏》。全藏约七千卷左右，六千多万字，现存四千余卷。2017年12月28日，国家图书馆《赵城金藏》1281件正式发布。</p>
</li>
<li>
<p>宋人文集
国家图书馆精选所藏宋人文集善本二百七十五部，首选宋元刊本，次及明清精抄精刻，或经名家校勘题跋之本，通过缩微胶卷还原数字影像，并辅以详细书目建成本全文影像数据库，目前已发布275部，免费呈献公众利用。</p>
</li>
<li>
<p>碑帖菁华
以国家图书馆藏有的历代甲骨、青铜器、石刻等类拓片二十三万余件为基础建设的数据库，内容涉及历史、地理、政治、经济、军事、民族、民俗、文学、艺术、科技、建筑等方面。2019年11月12日又新增发布2595种馆藏明清碑刻拓片数字资源，现有元数据2.5万余条，影像3.1万余幅。</p>
</li>
<li>
<p>甲骨世界
被誉为二十世纪四大文献发现之一的甲骨文，集文献性、文物性、收藏性于一身，是研究我国商朝晚期不可多得的珍贵史料，该库包括甲骨实物元数据2964条，影像5932幅；甲骨拓片元数据2975条，影像3177幅。</p>
</li>
<li>
<p>西夏文献
以国家图书馆保存的西夏、元代孤本及各种西夏的珍贵实物资料为基础建设的数据库。包括西夏文献书目数据124条，原件影像近5000拍。</p>
</li>
<li>
<p>西夏论著
包括西夏研究论文篇名数据1200余条。</p>
</li>
<li>
<p>年画撷英
国家图书馆收藏了杨柳青、朱仙镇等地制作的4000余幅年画作品，从中精选出一部分制作了该库，并为每种年画编写了内容说明，重点介绍了该年画的故事梗概、历史背景、制作特色和相关知识。目前发布元数据及影像302组。</p>
</li>
<li>
<p>前尘旧影
该资源库收录了国家图书馆收藏的新旧照片3074组，真实生动地记录了过去的社会事件、历史人物、城乡面貌、名胜古迹和建筑服饰等，人们可从中解读出不同历史时期特定事物的形象特征和真实信息，具有十分重要的历史价值。</p>
</li>
<li>
<p>敦煌遗珍
国际敦煌项目（IDP）建设的数据库，发布来自敦煌和丝绸之路上的写本、绘画、纺织品及器物的信息和图片，其中包括国家图书馆藏敦煌写卷影像18万余拍。</p>
</li>
<li>
<p>徽州善本家谱
徽州善本家谱印刷资料数据库是中国国家图书馆与法国远东学院的合作项目，收录了中国国家图书馆藏善本古籍中徽州家谱243种286部，配有书影5437幅。</p>
</li>
<li>
<p>中华医药典籍资源库（测试版）
图书馆收藏的文献典籍是整理研究的基础资料，为使读者能够通过互联网检索、利用中医文献资源，国家图书馆（国家古籍保护中心）将逐步建设中华医药典藏资源库，目前首批对221种中医古籍影像进行发布测试。</p>
</li>
<li>
<p>云南图书馆古籍
云南省图书馆将该馆古籍数字资源共139种727册提供给国家图书馆（国家古籍保护中心），这批资源均是云南省图书馆所藏珍贵的、有代表性的古籍文献，特别是明代云南丽江木氏土司家族著述，更是明代少数民族汉文著述的代表。该批资源于2019年11月12日正式在线发布。</p>
</li>
<li>
<p>天津图书馆古籍
为进一步丰富古籍数字资源品种和版本，满足广大读者使用需求，2014年底，天津图书馆向国家图书馆（国家古籍保护中心）提供总量约5,800余种300万拍明清古籍数字资源，该批资源经加工后，于2018年9月28日、2019年1月28日分两批发布。</p>
</li>
<li>
<p>上海图书馆家谱
上海图书馆现藏有家谱近3万余种30余万册共计365个姓氏，收藏的家谱覆盖全国27个省、自治区及直辖市，是国内外收藏中国家谱原件最多的公藏机构，有着“全球中国家谱第一藏”之美誉。国家图书馆与上海图书馆合作，征集该馆所藏明清家谱资源2200余种，在国图网站发布使用。</p>
</li>
<li>
<p>中华古籍善本联合书目
中华古籍善本国际联合书目系统是由中文善本书国际联合目录项目发展而来的新数据库，著录了三十余家海内外图书馆所藏古籍善本，数据达2万多条，并配有1.4万余幅书影。</p>
</li>
<li>
<p>东文研汉籍影像库
东京大学东洋文化研究所收藏有大量中国古籍，其中包括东方文化学院东京研究所的旧藏以及大木幹一、长泽规矩也、仓石武四郎等各具特色的个人收藏。2009年11月，东洋文化研究所将所藏中文古籍4000余种，以数字化方式无偿提供给中国国家图书馆，在国图网站上面向读者提供服务。</p>
</li>
<li>
<p>哈佛大学善本特藏
哈佛大学哈佛燕京图书馆藏中文善本古籍特藏，以其质量之高、数量之大著称于世。为了方便海内外学人便捷地利用这些资料进行研究，同时以数字化形式保存这些中华古籍精品，2009年国家图书馆与哈佛大学哈佛燕京图书达成协议，对哈佛燕京图书馆所藏中文善本和齐如山专藏进行数字化。目前在线发布经部和史部善本数字资源741部，另有齐如山戏曲小说专藏204种。</p>
</li>
<li>
<p>法藏敦煌遗书
2015年，在法国国家图书馆与中国国家图书馆达成合作意向，由法国国家图书馆向中国国家图书馆赠送馆藏全部敦煌遗书高清数字资源。在双方共同努力下，实现了这批敦煌遗书的数字化回归，并于2018年3月5日正式在线发布，共计5300余号3.1万余拍。</p>
</li>
<li>
<p>中华寻根网
中华寻根网是国家图书馆与澳门基金会开展的文化合作项目，是以提供姓氏源流和家谱资源服务为核心、方便海内外华人寻根问祖活动的网络平台。“中华寻根网”目前提供500多个姓氏源流、2000多部家谱和6000种其他文献的阅览，以及自建家谱，交流联谊的互动服务。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>资源</tag>
        <tag>古籍</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows笔记本开共享wifi</title>
    <url>/public/2015/04/14/shells/share_win_wifi/</url>
    <content><![CDATA[<p><strong>前言</strong>
网上有很多用笔记本设置无线热点的批处理，我中和了一下。复制下面代码到记事本，改后缀为bat就行了。其中，mssid和mkey可自定义</p>
<a id="more"></a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@echo off</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set mssid=GOODGOOD</span><br><span class="line">::网络名字</span><br><span class="line">set mkey=123456789</span><br><span class="line">::大于八位密码</span><br><span class="line"></span><br><span class="line">echo ***********************************************</span><br><span class="line">echo              打开承载网络  1</span><br><span class="line">echo              关闭承载网络  2</span><br><span class="line">echo              承载网络信息  3</span><br><span class="line">echo              设置网络信息  set</span><br><span class="line">echo              退出          e</span><br><span class="line">echo        （网络名字、密码可在源文件中改）</span><br><span class="line">echo           （请以管理员身份打开!!!）</span><br><span class="line">echo ***********************************************</span><br><span class="line">:start</span><br><span class="line">set /p var=请选择:</span><br><span class="line">if %var%==1 netsh wlan start hostednetwork &amp;&amp; echo 网络名字:%mssid% 密码:%mkey% &amp;&amp; GOTO start</span><br><span class="line">if %var%==2 netsh wlan stop hostednetwork &amp;&amp; GOTO start</span><br><span class="line">if %var%==3 netsh wlan show hostednetwork &amp;&amp; echo 网络名字:%mssid% 密码:%mkey% &amp;&amp; GOTO start</span><br><span class="line">if %var%==set netsh wlan set hostednetwork mode=allow ssid=%mssid% key=%mkey% &amp;&amp; echo 网络名字:%mssid% 密码:%mkey% &amp;&amp; GOTO start</span><br><span class="line">if %var%==e pause</span><br></pre></td></tr></table></figure>
<h2 id="播放声音"><a class="header-anchor" href="#播放声音">¶</a>播放声音</h2>
<p>保存为<code>播放声音.vbs</code>,可以播放声音</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CreateObject(&quot;SAPI.SpVoice&quot;).Speak &quot;hello world&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>常用脚本</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Windows脚本</tag>
        <tag>共享wifi</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>srt中英文合并python脚本</title>
    <url>/public/2016/04/14/shells/youtube_src_combine/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>从Youtube上看只有中文或英文分开的字幕，下载好视频，想要中英文字幕。可从 <a href="http://mo.dbxdb.com/Yang/setting.html" target="_blank" rel="noopener">Getting Youtube subtitles</a> 获取中或英文字幕，然后将其合并，即成中英文双字幕。下面是python脚本。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">本脚本完成了中英文srt合并的功能</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">srt2lis</span><span class="params">(name)</span>:</span></span><br><span class="line">    lines = open(<span class="string">'srt/'</span>+name, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>).readlines()</span><br><span class="line">    lis = []</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> i, line <span class="keyword">in</span> enumerate(lines):</span><br><span class="line">        <span class="comment"># 以\n 结尾的一个时间点</span></span><br><span class="line">        <span class="keyword">if</span> line == <span class="string">'\n'</span>:</span><br><span class="line">            lis.append(tmp)</span><br><span class="line">            tmp = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(line)</span><br><span class="line">    <span class="keyword">return</span> lis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hebing</span><span class="params">(name_zh)</span>:</span></span><br><span class="line">    name_en = name_zh[:<span class="number">-7</span>] + <span class="string">'.srt'</span></span><br><span class="line">    out_name=<span class="string">'out/'</span>+name_en</span><br><span class="line">    f=open(out_name,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    lis_en=srt2lis(name_en)</span><br><span class="line">    lis_zh=srt2lis(name_zh)</span><br><span class="line">    <span class="keyword">for</span> i,item <span class="keyword">in</span> enumerate(lis_en):</span><br><span class="line">        print(item[<span class="number">0</span>])</span><br><span class="line">        f.write(item[<span class="number">0</span>])</span><br><span class="line">        f.write(item[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lis_zh[i][<span class="number">2</span>:]:</span><br><span class="line">            f.write(line)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> item[<span class="number">2</span>:]:</span><br><span class="line">            f.write(line)</span><br><span class="line">        f.write(<span class="string">'\n'</span>)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flis=os.listdir(<span class="string">'srt/'</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'out'</span>):</span><br><span class="line">    os.mkdir(<span class="string">'out'</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> flis:</span><br><span class="line">    print(name)</span><br><span class="line">    <span class="keyword">if</span> name[<span class="number">-6</span>:<span class="number">-4</span>]==<span class="string">'zh'</span>:</span><br><span class="line">        hebing(name)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>常用脚本</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>python</tag>
        <tag>YouTube字幕合并</tag>
        <tag>src</tag>
      </tags>
  </entry>
  <entry>
    <title>这哈儿是重庆</title>
    <url>/public/2019/04/25/trips/chongqing/</url>
    <content><![CDATA[<p>重庆，旅游纪实。20190422 - 20190424</p>
<a id="more"></a>
<h2 id="四月二十二"><a class="header-anchor" href="#四月二十二">¶</a>四月二十二</h2>
<img src="/public/2019/04/25/trips/chongqing/tiankongzhicheng.jpg" alt="tiankongzhicheng" width="50%">
<div align="center"> <b>天空之城旅店的临江阳台</b></div>
<p>今天刚来到重庆。前天查天气说是多云，但是来这之后，天气极好。早上9点从成都出发，12点左右到达重庆北站，然后做地铁10号线倒到6号线的小什坊。在解放广场附近，中午吃了个碗杂面很不错，对于我来说有点辣，说是重庆排行第五的小面。</p>
<p>下午就准备午休一哈，今早上很早起来要赶到成都的市中心乘火车。在江边，也是在洪崖洞旁边，找了一家叫做天空之城的青年旅舍。晚上走在千厮大桥上，脚感受着下面的地铁穿过抖动。从青年旅馆房间里面刚好可以看到江边的夜景，管理人是个可爱的老人家。里面的床单是没有铺上的，得自己铺，老人家解释免得被认为不好，你也可以自己带睡袋。老人家在铁路上工作，与他聊了很久，谈到他在铁路站工作的经历，当然还有很多打理旅舍时的故事。</p>
<h2 id="四月二十三"><a class="header-anchor" href="#四月二十三">¶</a>四月二十三</h2>
<img src="/public/2019/04/25/trips/chongqing/guojiang1.jpeg" alt="guojiang1" width="50%">
<div align="center"> <b>排队2小时，乘过江索道</b></div>
<img src="/public/2019/04/25/trips/chongqing/goujiang2.jpeg" alt="goujiang2" width="50%">
<div align="center"> <b>过江索道，晃晃悠悠在路上</b></div>
<p>早上起来，去楼下买了个早餐，有八宝粥和一个米团（块），那个团米上面加了两个半枣。吃完早饭，阳光正照进那个青年公寓。四月底，节气谷雨过后，算还不是很热，在那个临江的阳台晒了会儿阳光。然后很困，大概是吃饱的缘故，我又回去睡了一个回笼觉。下午出发去白公馆，搭的是轻轨2号线，到大坪换到去烈士墓的地铁上，轻轨是一路沿江跑的，欣赏着嘉陵江的美景，羡慕着重庆人的立体公交系统。嘉陵江水比较清澈，也见到有人在游泳。过会儿就经过网红景点李子坝，轻轨穿房而过。白公馆旁边是四川外国语大学，没有去逛，直接去了白公馆，香山别墅，然后去了渣滓洞，白公馆的地势比较陡，台阶比较多，旁边是歌乐山。</p>
<img src="/public/2019/04/25/trips/chongqing/eling.jpg" alt="eling" width="50%">
<div align="center"> <b>鹅岭公园有个塔，从塔上望去</b></div>
<p>接着到了鹅岭公园，可直接做地铁鹅岭站，进门处分左右路线，我选了左转，然后绕了一大圈到了那个塔，其实可以右转沿着汽车的道往上到那个塔。到了塔顶，可以看到面向朝天门方向，左边是嘉陵江，右边是长江，然后各种大桥，轻轨地铁尽收眼底。吹着微风，站在那个塔上，可见重庆各种摩天大楼，然后就是更远处的山。离开鹅岭公园后，继续搭地铁去了上新街站，下车后往南岸区走，南岸发展比较慢，可以看到明显和渝中区的不同，路边找了一家店，选了几个小菜，吃了个晚饭。晚饭后，去了南山一棵树，人很多，夜景倒是很漂亮，有水有山，两水相交，滋润了这个大都市，今天的行程不错。</p>
<img src="/public/2019/04/25/trips/chongqing/yejing.jpg" alt="yejing" width="50%">
<div align="center"> <b>南山一棵松</b></div>
<h2 id="四月二十四"><a class="header-anchor" href="#四月二十四">¶</a>四月二十四</h2>
<img src="/public/2019/04/25/trips/chongqing/caotianmen.jpg" alt="caotianmen" width="50%">
<div align="center"> <b>朝天门码头，水清黄分明</b></div>
<p>今天也是懒懒起床，吃了个早饭，豆浆是放在那种果冻的包装袋里。今天差不多，就准备看看朝天门，然后回成都。去朝天门还是比较奇怪，随着百度地图导航走，到了一个商城里面，从地面进去是商城的8楼，下了电梯，走了一个商品批发的地方，然后向朝天门赶，今天太阳超级满足，比较热。岸边停了好多游船。到了朝天门，水分了两个颜色，黄的长江，清的嘉陵江。休息一刻，搭了公交车，沿着长江岸跑，居然到了李子坝，然后地铁转到重庆北火车站，这一趟重庆算是画上了一个句号。</p>
<p>【转载请联系 博主。】</p>
]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>重庆</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>希腊罗马神话</title>
    <url>/public/2018/11/05/readings/Gods_stories/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>在我电的图书馆的还书柜子里面偶然所得，一本叫《希腊罗马神话对英语语言文化的影响》吕海平 著 江苏大学初版社，然后莫名的想研究一下，发现挺不错的。</p>
<a id="more"></a>
<p>古希腊罗马的神的关系还是比较乱的，尤其是jupiter 或者zeus的奥林匹斯神系。从上古的神系，总共有三代。</p>
<p>网上有个人（<a href="http://www.veritablehokum.com/" target="_blank" rel="noopener">Korwin Briggs</a>）做的关系图很不错。</p>
<p>TODO:后面我也会对其进行整理，以后给大家分享。</p>
<p><img src="http://www.veritablehokum.com/wp-content/uploads/2018/08/Roman-God-Family-Tree.jpg" alt></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>希腊罗马神话</tag>
        <tag>语言文化</tag>
      </tags>
  </entry>
  <entry>
    <title>个人主页搭建</title>
    <url>/public/2016/12/22/build_blog/</url>
    <content><![CDATA[<p><strong>前言</strong>
本文主要内容为博客搭建的记录与分享，我采用了Hexo博客框架，NexT主题和Gitment评论系统。本文中记录了我博客的安装流程和使用过程中的改进细节。</p>
<p>对Next主题版本的一些说明：我使用的是<code>version: 5.1.0</code>。而使用新版本的NexT v6 主题的同学，有些功能如gitment已经实现，可以直接使用V6。此V6版本对于图片的使用可能会出现问题。仅需看看我下面的2.2小节。</p>
<p>有时间我会将我修改后的hexo Next theme 基于<code>version: 5.1.0</code>主题，给个独立的git仓，放到github 上。</p>
<blockquote>
<p>小技巧：在文章中可以使用<code>&lt;!-- more --&gt;</code>手动进行截断，more上面部分将被放到主页上显示。此为Hexo 提供的方式。</p>
</blockquote>
<p>下面就是用<code>&lt;!-- more --&gt;</code>截断的～～</p>
<a id="more"></a>
<p>在看安装教程的时候，发现怎么要涉及这么多东西，请大家不要担心，一步步来。同时也不用在意会不会nodejs，框架这些东西，人家已经帮我们把东西都写好了，我们做的就是改改配置文件，最多改改里面swig的模版的一些代码。最后，望大家见谅的是，我对js不太熟，有些地方不是很清楚。欢迎大家在下面评论，或者在github上开issue，共同讨论。</p>
<h2 id="1-安装"><a class="header-anchor" href="#1-安装">¶</a>1. 安装</h2>
<h3 id="1-1-简易安装使用"><a class="header-anchor" href="#1-1-简易安装使用">¶</a>1.1 简易安装使用</h3>
<p>使用新版本的NexT v6 主题即可，有些功能如gitment已经实现。对于图片的使用可能会出现问题。仅需看看我下面的2.2小节。我使用的是<code>version: 5.1.0</code>。</p>
<h3 id="1-2-从头安装"><a class="header-anchor" href="#1-2-从头安装">¶</a>1.2 从头安装</h3>
<ul>
<li>安装 nodejs，从nodejs 官网下载安装包 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">download page</a></li>
<li>安装git客户端 <a href="https://git-scm.com/" target="_blank" rel="noopener">git</a></li>
<li>安装Hexo <code>npm install -g hexo-cli</code>
<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo 中文安装文档</a>
<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo中文网站</a></li>
<li>安装NexT ，NexT是一个比较火的主题。
按官网教程NexT安装即可，官网安装和配置教程比较美滋滋。
<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a>
NexT Github  <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a>
另外，NexT开发者的博客（最近Next 变成组织了，祝贺）<a href="http://notes.iissnan.com" target="_blank" rel="noopener">http://notes.iissnan.com</a></li>
</ul>
<blockquote>
<p><strong>Ubuntu安装记录</strong></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for Ubuntu16.04</span></span><br><span class="line">$ sudo apt install npm nodejs-legacy</span><br><span class="line">$ sudo npm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>ok，安装完的目录结构。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── node_modules  <span class="comment"># nodejs的目录</span></span><br><span class="line">├── public        <span class="comment"># 输出网站目录</span></span><br><span class="line">├── scaffolds     <span class="comment"># hexo 的一些预设模版</span></span><br><span class="line">├── <span class="built_in">source</span>        <span class="comment"># 独立submodule</span></span><br><span class="line">├── themes        <span class="comment"># 主题 里面也有主题的配置文件不要与项目的配置文件搞混</span></span><br><span class="line">├── README.md</span><br><span class="line">├── _config.yml   <span class="comment"># 整个项目配置文件</span></span><br><span class="line">├── db.json</span><br><span class="line">├── index.html。  <span class="comment"># 用于跳转到public下</span></span><br><span class="line">└── package.json</span><br><span class="line"></span><br><span class="line">5 directories, 5 files</span><br></pre></td></tr></table></figure>
<p>我对博客项目的安排是这样的，总共有两个github项目，一个放素材，一个用hexo框架生成html文件。
在上面的文件目录只能够，将source 文件夹作为一个submodule 用 <a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" target="_blank" rel="noopener">git submodule</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于我来说</span></span><br><span class="line">$ <span class="built_in">cd</span> path/to/your/github.io/project</span><br><span class="line">$ git submodule add https://github.com/talengu/blog_source <span class="built_in">source</span></span><br></pre></td></tr></table></figure>
<p>在生成html，下面操作都在 <code>path/to/your/github.io/project</code>，hexo找不到node_modules</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># clone 项目</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/talengu/talengu.github.io</span><br><span class="line">$ git submodule init</span><br><span class="line">$ git submodule update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到最新的submodule</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">source</span></span><br><span class="line">$ git merge origin/master</span><br><span class="line">$ git submodule update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行npm按照，由于已经生成它会按照package.json文件自动安装</span></span><br><span class="line"><span class="comment"># 没有npm的话 安装 https://nodejs.org/en/download/</span></span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<h2 id="2-配置"><a class="header-anchor" href="#2-配置">¶</a>2. 配置</h2>
<p>对于在NexT主页上介绍的配置我就不写了，请参考http://theme-next.iissnan.com/getting-started.html  。</p>
<img src="/public/2016/12/22/build_blog/image-20181112002650646.png" alt="image-20181112002650646" width="50%">
<p>下面主要对重要的和我自己修改的部分说明没有的进行配置，值得注意的是我的NexT版本是<code>version: 5.1.0</code>。</p>
<h3 id="2-1-NexT官网的设置"><a class="header-anchor" href="#2-1-NexT官网的设置">¶</a>2.1 NexT官网的设置</h3>
<p><strong>MathJax</strong></p>
<p>编辑 <code>主题配置文件</code>， 将 <code>mathjax</code> 下的 <code>enable</code> 设定为 <code>true</code> 即可。 <code>cdn</code> 用于指定 MathJax 的脚本地址，默认是 MathJax 官方提供的 CDN 地址。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure>
<p>下面测试
<code>$\frac{d}{dx}c^n=nx^{n-1}$</code> $\frac{d}{dx}c^n=nx^{n-1}$</p>
<p><strong>Local Search</strong> (推荐)<br>
本地内容搜索引擎。</p>
<ul>
<li>
<p>安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：</p>
<p><code>npm install hexo-generator-searchdb --save</code></p>
</li>
<li>
<p>编辑 站点配置文件，新增以下内容到任意位置：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">   <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">   <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">   <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">   <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编辑 <code>主题配置文件</code>，启用本地搜索功能：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  	<span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-markdown图片"><a class="header-anchor" href="#2-2-markdown图片">¶</a>2.2 markdown图片</h3>
<p>网上的图片链接可以直接使用，下面对本地图片使用进行配置。</p>
<p><strong>使用</strong></p>
<p>安装插件<code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p>
<p>在 <code>主题配置文件</code>（不是next的_config.yml）中设置<code>permalink: :year/:month/:day/:title/</code>，设置 <code>post_asset_folder: true</code>，这主要将文件拷贝到/public文件夹。其中permalink很关键，只能这样设置。</p>
<blockquote>
<p>图片必须放到和md文件名字一样的同名字文件夹。
如使用Typora软件写md的话，设置一下image保存路径即可，如下。</p>
<img src="/public/2016/12/22/build_blog/typora_image.png" alt="typora_image" width="50%">
</blockquote>
<h3 id="2-3-代码复制"><a class="header-anchor" href="#2-3-代码复制">¶</a>2.3 代码复制</h3>
<p>为了提高博客代码块的用户体验，仅仅代码高亮还不行，最好还能一键复制代码。故此文将讲述 Hexo NexT 主题博客的代码块复制功能配置。转 <a href="https://www.jianshu.com/p/3e9d614c1e77" target="_blank" rel="noopener">Hexo NexT 代码块复制功能</a></p>
<h4 id="2-3-1-下载-clipboard-js"><a class="header-anchor" href="#2-3-1-下载-clipboard-js">¶</a>2.3.1 下载 clipboard.js</h4>
<p>三方插件 clipboardjs ，相关介绍和兼容性<a href="https://clipboardjs.com/" target="_blank" rel="noopener">它主页</a>或 <a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">github</a> 上看。</p>
<p><strong>下载地址：</strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.js" target="_blank" rel="noopener">clipboard.js</a></li>
<li><a href="https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.min.js" target="_blank" rel="noopener">clipboard.min.js</a> <strong>推荐</strong></li>
</ul>
<p>保存文件<code>clipboard.js / clipboard.min.js</code> ，目录如下：
<code>.\themes\next\source\js\src</code></p>
<h4 id="2-3-2-clipboardjs-使用"><a class="header-anchor" href="#2-3-2-clipboardjs-使用">¶</a>2.3.2 clipboardjs 使用</h4>
<p>也是在<code>.\themes\next\source\js\src</code>目录下，创建<code>clipboard-use.js</code>，文件内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*页面载入完成后，创建复制按钮*/</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params">e, t, a</span>) </span>&#123; </span><br><span class="line">  <span class="comment">/* code */</span></span><br><span class="line">  <span class="keyword">var</span> initCopyCode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copyHtml = <span class="string">''</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'</span>;</span><br><span class="line">    copyHtml += <span class="string">'  &lt;i class="fa fa-globe"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;/button&gt;'</span>;</span><br><span class="line">    $(<span class="string">".highlight .code pre"</span>).before(copyHtml);</span><br><span class="line">    <span class="keyword">new</span> ClipboardJS(<span class="string">'.btn-copy'</span>, &#123;</span><br><span class="line">        target: <span class="function"><span class="keyword">function</span>(<span class="params">trigger</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> trigger.nextElementSibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  initCopyCode();</span><br><span class="line">&#125;(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>
<p>在<code>.\themes\next\source\css\_custom\custom.styl</code>样式文件中添加下面代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//代码块复制按钮</span><br><span class="line"><span class="selector-class">.highlight</span>&#123;</span><br><span class="line">  //方便copy代码按钮（btn-copy）的定位</span><br><span class="line">  <span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-copy</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(#fcfcfc,#eee);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d5d5d5</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-moz-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-ms-user-select</span>: none;</span><br><span class="line">    <span class="attribute">user-select</span>: none;</span><br><span class="line">    <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">-webkit-transition</span>: opacity .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">-o-transition</span>: opacity .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">transition</span>: opacity .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-copy</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.highlight</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.btn-copy</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-引用"><a class="header-anchor" href="#2-3-3-引用">¶</a>2.3.3 引用</h4>
<p>在<code>.\themes\next\layout\_layout.swig</code>文件中，添加引用（注：在 swig 末尾或 body 结束标签（<code>&lt;/body&gt;</code>）之前添加）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 代码块复制功能 --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clipboard.min.js&quot;&gt;&lt;/script&gt;  </span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clipboard-use.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>想看效果的可以去<a href="https://talengu.github.io/public/2016/12/22/build_blog/">我博客</a>看，截图如下:</p>
<img src="/public/2016/12/22/build_blog/image-20181112004401227.png" alt="image-20181112004401227" width="50%">
<blockquote>
<p>熟悉的也可以将<code>clipboard.min.js</code>和<code>clipboard-use.js</code>合并为一个文件，再在<code>.\themes\next\layout\_layout.swig</code>文件中使用。当然<code>clipboard.min.js</code>也可以直接用三方 cdn 的方式引入也行。</p>
</blockquote>
<h3 id="2-4-Gitment-评论功能"><a class="header-anchor" href="#2-4-Gitment-评论功能">¶</a>2.4 Gitment 评论功能</h3>
<p>集成 giment 评论系统的过程。gitment 把评论放到 github 的 issues 系统里，评论支持 md，比较适合程序员.</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装gitment</span><br><span class="line">$ npm install gitment --save</span><br></pre></td></tr></table></figure>
<h4 id="2-4-1-注册-OAuth-Application"><a class="header-anchor" href="#2-4-1-注册-OAuth-Application">¶</a>2.4.1 注册 OAuth Application</h4>
<p>点击 <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a> 注册，注意<code>Authorization callback URL</code>填自己的网站 url <code>https://xxxx.github.io/</code>. 记下 <strong>Client ID</strong> 和 <strong>Client Secret</strong>.</p>
<blockquote>
<p>在新版本NexT v6里面已经支持gitment了所以你只要在github上注册一下 OAuth Application ，填上<strong>Client ID</strong> 和 <strong>Client Secret</strong>.即可</p>
</blockquote>
<h4 id="2-4-2-修改themes-next-config-yml"><a class="header-anchor" href="#2-4-2-修改themes-next-config-yml">¶</a>2.4.2 修改<code>themes/next/_config.yml</code></h4>
<p>在其中添加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Gitment</span><br><span class="line"># Introduction: https://imsun.net/posts/gitment-introduction/</span><br><span class="line">gitment:</span><br><span class="line">  enable: true</span><br><span class="line">  githubID: yourid</span><br><span class="line">  repo: yourrepo</span><br><span class="line">  ClientID: yourid</span><br><span class="line">  ClientSecret: yoursecret</span><br><span class="line">  lazy: true</span><br></pre></td></tr></table></figure>
<p><strong>注意: 格式要正确，该空格的一定要空格。所有的 yourXXX 都换成自己的.</strong></p>
<p>在主题的<code>en.yml</code>增加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitmentbutton: Show comments from Gitment</span><br></pre></td></tr></table></figure>
<p><code>zh-Hans.yml</code>增加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitmentbutton: 显示 Gitment 评论</span><br></pre></td></tr></table></figure>
<h4 id="2-4-3-修改主题layout-partials-comments-swig"><a class="header-anchor" href="#2-4-3-修改主题layout-partials-comments-swig">¶</a>2.4.3 修改主题<code>layout/_partials/comments.swig</code></h4>
<p>找到这个文件里的这两行:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"vcomments"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面是最后一个<code>elseif</code>分支，在下面加一个<code>elseif</code>分支:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.gitment.enable %&#125;</span><br><span class="line">   &#123;% if theme.gitment.lazy %&#125;</span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"ShowGitment()"</span> <span class="attr">id</span>=<span class="string">"gitment-display-button"</span>&gt;</span>&#123;&#123;  __('gitmentbutton') &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitment-container"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   &#123;% else %&#125;</span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitment-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>加完之后下面的内容是原来的，保持不变:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-4-增加gitment-swig"><a class="header-anchor" href="#2-4-4-增加gitment-swig">¶</a>2.4.4 增加<code>gitment.swig</code></h4>
<p>在主题下<code>layout/_third-party/comments/</code>目录下中添加文件<code>gitment.swig</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.gitment.enable %&#125;</span><br><span class="line">   &#123;% set owner = theme.gitment.githubID %&#125;</span><br><span class="line">   &#123;% set repo = theme.gitment.repo %&#125;</span><br><span class="line">   &#123;% set cid = theme.gitment.ClientID %&#125;</span><br><span class="line">   &#123;% set cs = theme.gitment.ClientSecret %&#125;</span><br><span class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://imsun.github.io/gitment/style/default.css"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://imsun.github.io/gitment/dist/gitment.browser.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   &#123;% if not theme.gitment.lazy %&#125;</span><br><span class="line">       <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">           <span class="keyword">var</span> gitment = <span class="keyword">new</span> Gitment(&#123;</span></span><br><span class="line"><span class="javascript">               id: <span class="built_in">window</span>.location.pathname, </span></span><br><span class="line"><span class="javascript">               owner: <span class="string">'&#123;&#123;owner&#125;&#125;'</span>,</span></span><br><span class="line"><span class="javascript">               repo: <span class="string">'&#123;&#123;repo&#125;&#125;'</span>,</span></span><br><span class="line">               oauth: &#123;</span><br><span class="line"><span class="javascript">                   client_id: <span class="string">'&#123;&#123;cid&#125;&#125;'</span>,</span></span><br><span class="line"><span class="javascript">                   client_secret: <span class="string">'&#123;&#123;cs&#125;&#125;'</span>,</span></span><br><span class="line">               &#125;&#125;);</span><br><span class="line"><span class="javascript">           gitment.render(<span class="string">'gitment-container'</span>);</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   &#123;% else %&#125;</span><br><span class="line">       <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">           <span class="function"><span class="keyword">function</span> <span class="title">ShowGitment</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">               <span class="built_in">document</span>.getElementById(<span class="string">"gitment-display-button"</span>).style.display = <span class="string">"none"</span>;</span></span><br><span class="line"><span class="javascript">               <span class="built_in">document</span>.getElementById(<span class="string">"gitment-container"</span>).style.display = <span class="string">"block"</span>;</span></span><br><span class="line"><span class="javascript">               <span class="keyword">var</span> gitment = <span class="keyword">new</span> Gitment(&#123;</span></span><br><span class="line"><span class="javascript">                   id: <span class="built_in">document</span>.location.href, </span></span><br><span class="line"><span class="javascript">                   owner: <span class="string">'&#123;&#123;owner&#125;&#125;'</span>,</span></span><br><span class="line"><span class="javascript">                   repo: <span class="string">'&#123;&#123;repo&#125;&#125;'</span>,</span></span><br><span class="line">                   oauth: &#123;</span><br><span class="line"><span class="javascript">                       client_id: <span class="string">'&#123;&#123;cid&#125;&#125;'</span>,</span></span><br><span class="line"><span class="javascript">                       client_secret: <span class="string">'&#123;&#123;cs&#125;&#125;'</span>,</span></span><br><span class="line">                   &#125;&#125;);</span><br><span class="line"><span class="javascript">               gitment.render(<span class="string">'gitment-container'</span>);</span></span><br><span class="line">           &#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>然后在主题下<code>layout/_third-party/comments/index.swig</code>文件中引入 gitment.swig 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &apos;gitment.swig&apos; %&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-5-添加gitment-styl"><a class="header-anchor" href="#2-4-5-添加gitment-styl">¶</a>2.4.5 添加<code>gitment.styl</code></h4>
<p>在主题下<code>source/css/_common/components/third-party/</code>目录下添加<code>gitment.styl</code>文件，设置 button 的样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#gitment-display-button</span>&#123;</span><br><span class="line">     <span class="attribute">display</span>: inline-block;</span><br><span class="line">     <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">     <span class="attribute">color</span>: <span class="number">#0a9caf</span>;</span><br><span class="line">     <span class="attribute">cursor</span>: pointer;</span><br><span class="line">     <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">     <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#0a9caf</span>;</span><br><span class="line">     <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-id">#gitment-display-button</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">     <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">     <span class="attribute">background</span>: <span class="number">#0a9caf</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>然后在主题下<code>source/css/_common/components/third-party/third-party.styl</code>文件中引入相应的 CSS 样式即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &quot;gitment&quot;;</span><br></pre></td></tr></table></figure>
<p>这样就 ok 了！</p>
<h4 id="2-4-6-易错点"><a class="header-anchor" href="#2-4-6-易错点">¶</a>2.4.6 易错点</h4>
<ol>
<li>修改<code>themes/next/_config.yml</code>这个文件时，格式要正确。另外，repo 是你要想创建 issues 的仓库，完全可以跟博文所放的仓库不一个。id 就写自己的 github 用户名就可以，这个用户名跟 repo 必须匹配。</li>
<li>gitment 可能不支持链接地址里有中文，所以安装 gitment 前一定要参考<a href="http://yangq.me/post/19acb239.html" target="_blank" rel="noopener">前文</a>把链接持久化搞成全是英文的。</li>
<li>同一篇文章需要<a href="https://github.com/imsun/gitment/issues/68" target="_blank" rel="noopener">初始化 comment 两次的问题</a>，是因为 <a href="http://xxx.com/post/ab9bb85a.html" target="_blank" rel="noopener">http://xxx.com/post/ab9bb85a.html</a> 和点击<strong>阅读全文</strong>进去的链接 <a href="http://yangq.me/post/ab9bb85a.html#more" target="_blank" rel="noopener">http://xxx.com/post/ab9bb85a.html#more</a> 对 issues 来说是不同的，所以创建两次。解决方法就是<code>gitment.swig</code>里 id 弄成<code>window.location.pathname</code>而不是<code>document.location.href</code>。</li>
<li>初始化评论后，可以到 github 里自己放 issues 的仓库查看 issues 是否创建成功，有时候浏览器可能会有缓存依然提示你初始化评论。一般过个两分钟就显示正常了。</li>
</ol>
<h4 id="2-4-7-参考文档"><a class="header-anchor" href="#2-4-7-参考文档">¶</a>2.4.7 参考文档</h4>
<ol>
<li><a href="http://www.jianshu.com/p/10134c474991" target="_blank" rel="noopener">主要参考文档</a></li>
<li><a href="https://meesong.github.io/StaticBlog/2017/NexT+Gitment/" target="_blank" rel="noopener">一种相对简略的配置方式</a></li>
<li><a href="https://github.com/imsun/gitment/issues" target="_blank" rel="noopener">作者 issue</a></li>
</ol>
<h3 id="2-x-gittalk-评论系统"><a class="header-anchor" href="#2-x-gittalk-评论系统">¶</a>2.x gittalk 评论系统</h3>
<p><a href="https://iochen.com/2018/01/06/use-gitalk-in-hexo/" target="_blank" rel="noopener">https://iochen.com/2018/01/06/use-gitalk-in-hexo/</a></p>
<p>403 error:<br>
<a href="https://zhuanlan.zhihu.com/p/350735142" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/350735142</a></p>
<p>申请个人worker
<a href="https://dash.cloudflare.com/" target="_blank" rel="noopener">https://dash.cloudflare.com/</a></p>
<h3 id="2-x-glup加速"><a class="header-anchor" href="#2-x-glup加速">¶</a>2.x glup加速</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --global gulp</span><br><span class="line">npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean  gulp-imagemin --save</span><br></pre></td></tr></table></figure>
<p>使用Gulp压缩Hexo博客静态资源, 加快响应速度
<a href="https://blog.csdn.net/cpohui/article/details/98525437" target="_blank" rel="noopener">https://blog.csdn.net/cpohui/article/details/98525437</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 设置 淘宝镜像源</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">// 查看 使用的 镜像源</span><br><span class="line">npm config get registry</span><br><span class="line"></span><br><span class="line">// 安装 淘宝镜像源</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<h3 id="字体大小"><a class="header-anchor" href="#字体大小">¶</a>字体大小</h3>
<p>Hexo 你的博客之修改字体大小
<a href="https://www.jianshu.com/p/02fbd409988c" target="_blank" rel="noopener">https://www.jianshu.com/p/02fbd409988c</a></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">themes/next/source/css/_variables</span><br></pre></td></tr></table></figure>
<p><a href="https://zenreal.github.io/posts/44730/" target="_blank" rel="noopener">页面美化</a></p>
<h3 id="2-x-利用-Github-Actions-自动部署-Hexo-博客"><a class="header-anchor" href="#2-x-利用-Github-Actions-自动部署-Hexo-博客">¶</a>2.x 利用 Github Actions 自动部署 Hexo 博客</h3>
<p>生成RSA密码对，部署到任务仓。
<a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/" target="_blank" rel="noopener">https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/</a></p>
<h3 id="2-5-copyright文字添加"><a class="header-anchor" href="#2-5-copyright文字添加">¶</a>2.5 copyright文字添加</h3>
<p><strong>效果</strong> 可以在md文件里面控制是否使用这个组建。</p>
<img src="/public/2016/12/22/build_blog/copyright.png" alt="copyright" title="copyright 效果" width="50%">
<p><strong>使用</strong></p>
<p>在md文件中的front-head部分，设置 <code>copyright:true</code>如下面。
设置next/_config.yml 文件，中设置<code>post_copyright</code> 的选项 <code>enable</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 个人主页搭建</span><br><span class="line">date: 2016-12-22 12:39:04</span><br><span class="line">categories:</span><br><span class="line">  - 博客搭建</span><br><span class="line">tags:</span><br><span class="line">  - Hexo</span><br><span class="line">comments: true</span><br><span class="line">copyright: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong> 对原next的改变</p>
<p>对于一些原创的文本可以设置版权的声明，这个是next自带的，我进行了修改。next的_config.yml 文件，中设置<code>post_copyright</code> 的选项，启用它会对所有的页面添加，我多加了一个page的copyright使能判断。
对<code>next/layout/_macro/post-copyright.swig</code>修改。下面为修改后的文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.post_copyright.enable %&#125;</span><br><span class="line">&#123;% if page.copyright %&#125; <span class="comment">&lt;!-- 加上page md文件头部使能--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"post-copyright"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"post-copyright-author"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; __('post.copyright.author') + __('symbol.colon') &#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">      &#123;&#123; config.author &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"post-copyright-link"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; __('post.copyright.link') + __('symbol.colon') &#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- url的修正，可能要根据你的情况修改--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; config.url &#125;&#125;&#123;&#123; config.root &#125;&#125;&#123;&#123; post.path &#125;&#125;"</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; post.title &#125;&#125;"</span>&gt;</span>&#123;&#123; config.url &#125;&#125;&#123;&#123; config.root &#125;&#125;&#123;&#123; post.path &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"post-copyright-license"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; __('post.copyright.license_title') + __('symbol.colon') &#125;&#125; <span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">      &#123;&#123; __('post.copyright.license_content', theme.post_copyright.license_url, theme.post_copyright.license) &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-RSS-可选"><a class="header-anchor" href="#2-6-RSS-可选">¶</a>2.6 RSS (可选)</h3>
<p>对一些网站的feed 的订阅 如rss，使用来进行订阅网站的rss，现在一些网站已经没有rss服务，google也停掉了google rss reader的项目，所以看你的喜好。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装hexo-generator-feed</span></span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line"><span class="comment"># 在_config.yml 启用feed</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips: 由于我博客在public文件夹下，导致hexo-generator-feed生成的地址不对。
在node_modules/hexo-generator-feed/lib/generator.js` 第35行下面添加一行:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">url += <span class="string">'public/'</span></span><br></pre></td></tr></table></figure>
<p>可用此脚本替换 <code>sed -i &quot;36c url += 'public/';&quot; node_modules/hexo-generator-feed/lib/generator.js  </code></p>
<p>note: mac中手动修改，sed指令<a href="https://blog.csdn.net/bertie_Jnn/article/details/51219670" target="_blank" rel="noopener">不一样</a></p>
<h3 id="2-7-添加-fork-me-github"><a class="header-anchor" href="#2-7-添加-fork-me-github">¶</a>2.7 添加 fork me github</h3>
<p>效果</p>
<img src="/public/2016/12/22/build_blog/image-20181122020200453.png" alt="image-20181122020200453" width="50%">
<p>在<a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="noopener">GitHub Ribbons</a>或<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">GitHub Corners</a>选择一款你喜欢的挂饰。比如下面的 github corners 在<code>your-url</code>填上你的 url 。</p>
<img src="/public/2016/12/22/build_blog/image-20181122020427248.png" alt="image-20181122020427248" width="50%">
<p>将刚刚复制的挂饰代码，添加到<code>themes/next/layout/_layout.swig</code>文件中，添加位置，放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下方如下图。</p>
<img src="/public/2016/12/22/build_blog/image-20181122021516212.png" alt="image-20181122021516212" width="50%">
<h3 id="2-8-添加注脚"><a class="header-anchor" href="#2-8-添加注脚">¶</a>2.8 添加注脚</h3>
<p>hexo-renderer-markdown-it插件，<a href="https://www.dazhuanlan.com/2019/11/22/5dd6faa42d279/" target="_blank" rel="noopener">参考</a></p>
<p>首先卸载原来的markdown渲染插件（我这里原来是marked，这是Hexo提供的默认渲染插件），然后把hexo-renderer-markdown-it装上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure>
<p>然后在根目录下的<code>_config.yml</code>中进行相应的配置。<a href="https://github.com/hexojs/hexo-renderer-markdown-it/wiki/Simple-Configuration" target="_blank" rel="noopener">简单的配置方法</a>只包括设置markdown格式，这里就不详述了。<a href="https://github.com/hexojs/hexo-renderer-markdown-it/wiki/Advanced-Configuration" target="_blank" rel="noopener">高级的配置方法</a>中包含很多可选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span><br><span class="line">markdown:</span><br><span class="line">  # 渲染设置</span><br><span class="line">  render:</span><br><span class="line">    # 置为true时，html内容保持不变；置为false时，html内容将被转义成普通字符串</span><br><span class="line">    html: true</span><br><span class="line">    # 是否生成与XHTML完全兼容的标签（虽然我不懂是什么意思）</span><br><span class="line">    xhtmlOut: false</span><br><span class="line">    # 置为true时，每个换行符都被渲染成一个&lt;br&gt;（即Hexo的默认表现）；置为false时，只有空行才会被渲染为&lt;br&gt;（GFM的默认表现）</span><br><span class="line">    breaks: true</span><br><span class="line">    # 是否自动识别链接并把它渲染成链接</span><br><span class="line">    linkify: true</span><br><span class="line">    # 是否自动识别印刷格式（意思是把(c)渲染为©这样的）</span><br><span class="line">    typographer: true</span><br><span class="line">    # 如果typographer被设置为true，则该选项用于设置将dumb quotes（&quot;&quot;）自动替换为smart quotes</span><br><span class="line">    quotes: &apos;“”‘’&apos;</span><br><span class="line">  # 设置所需插件</span><br><span class="line">  plugins:</span><br><span class="line">    - markdown-it-abbr</span><br><span class="line">    - markdown-it-footnote</span><br><span class="line">    - markdown-it-ins</span><br><span class="line">    - markdown-it-sub</span><br><span class="line">    - markdown-it-sup</span><br><span class="line">  # 锚点设置（因为我没有尝试相关内容，所以就不翻译相关说明了）</span><br><span class="line">  anchors:</span><br><span class="line">    level: 2</span><br><span class="line">    collisionSuffix: &apos;v&apos;</span><br><span class="line">    permalink: true</span><br><span class="line">    permalinkClass: header-anchor</span><br><span class="line">    permalinkSymbol: ¶</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ref https://www.dazhuanlan.com/2019/11/22/5dd6faa42d279/</span><br><span class="line">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span><br><span class="line">markdown:</span><br><span class="line">  # 渲染设置</span><br><span class="line">  render:</span><br><span class="line">    # 置为true时，html内容保持不变；置为false时，html内容将被转义成普通字符串</span><br><span class="line">    html: true</span><br><span class="line">    # 是否生成与XHTML完全兼容的标签（虽然我不懂是什么意思）</span><br><span class="line">    xhtmlOut: false</span><br><span class="line">    # 置为true时，每个换行符都被渲染成一个&lt;br&gt;（即Hexo的默认表现）；置为false时，只有空行才会被渲染为&lt;br&gt;（GFM的默认表现）</span><br><span class="line">    breaks: true</span><br><span class="line">    # 是否自动识别链接并把它渲染成链接</span><br><span class="line">    linkify: true</span><br><span class="line">    # 是否自动识别印刷格式（意思是把(c)渲染为©这样的）</span><br><span class="line">    typographer: true</span><br><span class="line">    # 如果typographer被设置为true，则该选项用于设置将dumb quotes（&quot;&quot;）自动替换为smart quotes</span><br><span class="line">    quotes: &apos;“”‘’&apos;</span><br><span class="line">  # 设置所需插件</span><br><span class="line">  plugins:</span><br><span class="line">    - markdown-it-abbr</span><br><span class="line">    - markdown-it-footnote</span><br><span class="line">    - markdown-it-ins</span><br><span class="line">    - markdown-it-sub</span><br><span class="line">    - markdown-it-sup</span><br><span class="line">  # 锚点设置（因为我没有尝试相关内容，所以就不翻译相关说明了）</span><br><span class="line">  # anchors:</span><br><span class="line">  #   level: 2</span><br><span class="line">  #   collisionSuffix: &apos;v&apos;</span><br><span class="line">  #   permalink: true</span><br><span class="line">  #   permalinkClass: header-anchor</span><br><span class="line">  #   permalinkSymbol: ¶</span><br><span class="line">  anchors:</span><br><span class="line">    # Minimum level for ID creation. (Ex. h2 to h6)</span><br><span class="line">    level: 2</span><br><span class="line">    # A suffix that is prepended to the number given if the ID is repeated.</span><br><span class="line">    collisionSuffix: &apos;&apos;           </span><br><span class="line">    # If `true`, creates an anchor tag with a permalink besides the heading.</span><br><span class="line">    permalink: true              </span><br><span class="line">    # Class used for the permalink anchor tag.</span><br><span class="line">    permalinkClass: header-anchor</span><br><span class="line">    # Set to &apos;right&apos; to add permalink after heading</span><br><span class="line">    permalinkSide: &apos;left&apos;</span><br><span class="line">    # The symbol used to make the permalink</span><br><span class="line">    permalinkSymbol: ¶</span><br><span class="line">    # Transform anchor to (1) lower case; (2) upper case</span><br><span class="line">    case: 0</span><br><span class="line">    # Replace space with a character</span><br><span class="line">    separator: &apos;-&apos;</span><br></pre></td></tr></table></figure>
<h2 id="添加运行时间"><a class="header-anchor" href="#添加运行时间">¶</a>添加运行时间</h2>
<p><a href="https://blog.csdn.net/jieruis/article/details/104024884?utm_source=app&amp;app_version=4.21.0" target="_blank" rel="noopener">https://blog.csdn.net/jieruis/article/details/104024884?utm_source=app&amp;app_version=4.21.0</a></p>
<h2 id="使用Github-Action-自动布置"><a class="header-anchor" href="#使用Github-Action-自动布置">¶</a>使用Github Action 自动布置</h2>
<p>ruanyifeng</p>
<p><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https://github.com/组织或个人/仓库</span><br><span class="line">/workflows/执行Action的Name注意转码/badge.svg)</span><br></pre></td></tr></table></figure>
<p>编译过程图标
<a href="https://lindexi.oschina.io/post/Github-%E6%B7%BB%E5%8A%A0-Action-%E7%BC%96%E8%AF%91%E5%9B%BE%E6%A0%87.html" target="_blank" rel="noopener">https://lindexi.oschina.io/post/Github-添加-Action-编译图标.html</a></p>
<p>自动部署</p>
<p>ref: <a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/" target="_blank" rel="noopener">https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/</a></p>
<h2 id="TODO"><a class="header-anchor" href="#TODO">¶</a>TODO:</h2>
<p>这个TODO中放的是，我接下来对博客搭建这个项目，要做的事。平台的debug，内容的设计等等。</p>
<ul>
<li>
<p>[ ] 续写这篇博客，后面根据内容多少看要不要拆分这个博客。</p>
</li>
<li>
<p>[ ] 永久化连接 permalink
​	这permalink 和本地图片的拷贝复制有关不好改，下面是可能的方法，由于现在的评论还比较少，后面改进。
​	<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">https://github.com/rozbo/hexo-abbrlink</a>
​	<a href="https://github.com/EqualMa/hexo-plugin-permalink-pathed-title" target="_blank" rel="noopener">https://github.com/EqualMa/hexo-plugin-permalink-pathed-title</a></p>
</li>
<li>
<p>[ ] gitment object ProgressEvent #170
​	gitment 出现问题 作者好像放弃了，所以网上有一些解决方案，(gitment issue #170)(<a href="https://github.com/imsun/gitment/issues/170" target="_blank" rel="noopener">https://github.com/imsun/gitment/issues/170</a>)</p>
<p>​	临时使用<code>https://www.wenjunjiang.win/js/gitment.js</code> 这个gitment.js</p>
</li>
<li>
<p>[ ] 编写规范 得写一个博客的编写规范。分类、标签的使用，图片的使用，公式的使用等等</p>
</li>
</ul>
<h2 id="博客编写规范"><a class="header-anchor" href="#博客编写规范">¶</a>博客编写规范</h2>
<ul>
<li>github上有项目图片就从项目中链接过来，比如头像就是我github的头像</li>
<li>重要的图片存在本项目中</li>
<li>Typora的使用</li>
</ul>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<p><a href="https://www.jianshu.com/p/9f0e90cc32c2" target="_blank" rel="noopener">Hexo-NexT配置超炫网页效果</a> 好多新奇玩意儿～</p>
<p><a href="https://blog.csdn.net/yanzi1225627/article/details/77890414" target="_blank" rel="noopener">Hexo gitment</a></p>
<p>原文地址</p>
<p>图标网站
<a href="https://icons8.com/icon/new-icons/all" target="_blank" rel="noopener">icon8 web</a> 比较舒服
<a href="http://fontawesome.io" target="_blank" rel="noopener">http://fontawesome.io</a> 标准风格
<a href="https://www.easyicon.net/" target="_blank" rel="noopener">https://www.easyicon.net/</a> 国内的图标</p>
<p>【正在补充修改内容中～】</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>爱立信的百年沉浮</title>
    <url>/public/2022/04/01/history_ericsson/</url>
    <content><![CDATA[<blockquote>
<p>文章来源：<br>
鲜枣课堂（ID：xzclasscom）<br>
<a href="https://mp.weixin.qq.com/s?__biz=MjM5NTY1MjY0MQ==&amp;mid=2650814278&amp;idx=1&amp;sn=26083fed8d8dd76340e063fd42a59dea" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<p>19 世纪中叶，电报业务在欧洲大陆逐渐开始普及。</p>
<p>1853 年，北欧小国瑞典动用 “海盗基金”（不是海盗的钱，是政府用来打海盗的钱），架设了自己的第一条电报线路，从首都斯德哥尔摩到乌普萨拉。</p>
<p>为了确保负责这条线路的正常运营，瑞典政府还成立了自己的第一家电报公司，名字叫 Televerket。</p>
<p>当时，Televerket 公司急需大量的电报硬件设备。于是，乌普萨拉电报局的局长，<strong>安东 · 亨里克 · 奥勒</strong>（Anton Henric Öller），决定创办一家公司，为 Televerket 生产、修理和改进电报机。</p>
<p>不久后，这家电气设备维修公司正式成立，名字叫奥勒公司（Öller &amp; Co）。</p>
<p><img src="/public/2022/04/01/history_ericsson/640.png" alt></p>
<center><div>安东 · 亨里克 · 奥勒，瑞典电信业的先驱</div></center>
<p>奥勒公司名义上是一家公司，但实际上就是一个手工作坊，规模很小，只能靠 Televerket 公司的资助才能维持生存。</p>
<p>在奥勒公司的员工中，有一个勤奋的小伙子，当时专门负责维修电报设备以及其它机械设备。他的名字，叫做<strong>拉什 · 玛格纳斯 · 爱立信</strong>（Lars Magnus Ericsson）。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-16487839499382.png" alt></p>
<center><div> 拉什 · 玛格纳斯 · 爱立信</div></center>
<a id="more"></a>
<p>拉什 · 爱立信 1846 年 5 月 5 日出生于瑞典中部瓦姆兰省的一个小农场里。他的家庭条件贫困，自己在 9 个兄弟姐妹中排行第六。</p>
<p>11 岁时，由于父亲病逝，他不得不外出工作，养家糊口。这期间，他当过矿工，修过铁路，还在铁匠铺做了很长时间的学徒。</p>
<p>1867 年，拉什 · 爱立信终于攒够了路费，来到他梦寐以求的瑞典首都——斯德哥尔摩。经过一周的试用后，他成功加入了奥勒公司，成为一名修理工。</p>
<p>尽管这份工作的工资微薄，拉什 · 爱立信仍然感到十分满足。他后来回忆说：“（这份工作）足以满足我的需求，让我庆幸地看到生活比以往任何时候都更加光明，我心中第一次感受到了生活的快乐。”</p>
<p>工作之余，拉什 · 爱立信努力学习数学、材料技术、工程制图，以及德语和英语。在公司老板奥勒先生的推荐下，1873 年和 1875 年，拉什 · 爱立信先后两次获得瑞典政府的官方资助，前往德国和瑞士进行游学和实习。</p>
<p>这期间，拉什 · 爱立信来到了德国柏林的西门子公司（Siemens &amp; Halske），学到了很多电报工程技术知识，也接触到一些先进的机床设备。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-16487839554904.jpeg" alt></p>
<center><div> 拉什 · 爱立信在西门子公司时绘制的图纸，相当精妙</div></center>
<p>游学结束之后，拉什 · 爱立信返回瑞典。此时的他，已经具备了非常丰富的专业知识，有能力开创属于自己的事业。</p>
<p>1876 年 4 月，拉什 · 爱立信拒绝了奥勒公司升职加薪的提议，在斯德哥尔摩皇后街 15 号一个普通建筑的小厨房里，创建了 <strong>L.M.Ericsson</strong> 公司。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-16487839586856.png" alt></p>
<center><div> 爱立信公司最初的商标</div></center>
<center><div>MEK.WERKSTAD 的意思是 “机械作坊”</div></center>
<center><div> STOCKHOLM 就是瑞典首都 “斯德哥尔摩”</div></center>
<p>当时的 L.M.Ericsson 公司，其实就是一个作坊修理铺。启动资金 1000 克朗，是借来的。小厨房不到 13 平方米，是租来的。仅有的一套工作设备，是一架脚踏式机床。</p>
<p>公司的全部员工，除了拉什 · 爱立信本人之外，只有一名临时雇佣的 12 岁男孩。</p>
<p>不久后，拉什 · 爱立信在奥勒公司的前同事卡尔 · 乔汗 · 安德森（Carl Johan Andersson）加入了他的新公司，成为合伙人。</p>
<p>公司创立之后，主要业务是维修各种机械设备、电报机以及电器仪表。他们接到的第一单生意，是维修用于火警的一只机械指示器，收费 2 克朗。</p>
<p>没过多久，拉什 · 爱立信凭借自己的才华和经验，制造出了一些不错的产品，例如用于铁路系统的拨号电报仪器，以及小型社区的防火电报系统。</p>
<p>这些产品，逐渐赢得了铁路、消防等部门用户的认可，带来了源源不断的订单。</p>
<h2 id="█-涉足电话业务，规模迅速扩张"><a class="header-anchor" href="#█-涉足电话业务，规模迅速扩张">¶</a>█  涉足电话业务，规模迅速扩张</h2>
<p>爱立信公司成立的同一年（1876 年），美国的亚历山大 · 贝尔申请并获得了电话的发明专利，从而将人类带入了电话时代。</p>
<p>1877 年，电话被引入瑞典。拉什 · 爱立信第一时间去买了一对，并进行了拆解研究。</p>
<p>后来，很多用户将损坏的电话机送到拉什 · 爱立信这里维修，使得他对电话机内部结构有了更深入的了解。</p>
<p>凭借敏锐的商业嗅觉，拉什 · 爱立信意识到电话背后的巨大商机。于是，他决定研制自己的电话机型号。</p>
<p>1878 年底，拉什 · 爱立信在妻子<strong>希尔达 · 爱立信</strong>（Hilda Ericsson）的帮助下，成功研制出第一台电话机产品。这款产品性能出色，价格远低于对手，受到了用户的欢迎。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-16487981603198.jpeg" alt></p>
<center><div>拉什 · 爱立信的妻子（左），对他帮助极大</div></center>
<p>后来，拉什 · 爱立信又推出了自己的墙式电话机，再次获得畅销。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879816421310.png" alt></p>
<center><div>爱立信的墙式电话机</div></center>
<p>1880 年，拉什 · 爱立信和他的公司迎来了一次重大的机遇。</p>
<p>当时，美国贝尔公司在斯德哥尔摩、哥德堡、马尔默、松兹瓦尔和索德港建造了一个电话网络。如果任由贝尔公司发展下去，他们将垄断整个瑞典的电话市场。</p>
<p>于是，拉什 · 爱立信决定与贝尔公司进行正面竞争。不久后，L.M.Ericsson 公司成功击败对手，先后中标了耶夫勒市和挪威卑尔根市的本地电话系统合同。</p>
<p>拉什 · 爱立信的胜利，极大地增强了瑞典人民的信心。事实证明，瑞典的工艺和技术，完全可以与世界最领先的公司相媲美。</p>
<p>1883 年，拉什 · 爱立信遇到了自己创业早期最重要的合作伙伴兼客户，<strong>亨里克 · 托勒 · 塞德格伦</strong>（Henrik Thore Cedergren）。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879816726712.jpeg" alt></p>
<center><div>亨里克 · 托勒 · 塞德格伦</div></center>
<p>亨里克 · 塞德格伦原本是一个珠宝商人。作为瑞典最早的电话机用户之一，他非常看好电话的发展潜力。但是，他认为贝尔公司的收费太过昂贵，阻碍了电话业务的普及。</p>
<p>于是，1883 年 2 月，他成立了一家名为 Stockholms Allmänna Telefonaktiebolag（斯德哥尔摩公共电话公司，以下简称 SAT 公司）的独立瑞典电话公司，旨在为公众提供廉价的电话连接服务。</p>
<p>起初，拉什 · 爱立信并不看好亨里克 · 塞德格伦和他的公司，因为他们完全没有电话网络方面的经验。后来，亨里克 · 塞德格伦凭借自己的热情，打动了拉什 · 爱立信，说服他支持自己的事业。</p>
<p>1883 年，L.M.Ericsson 公司和 SAT 公司就电话供应签订了一项供货合同，全面负责 SAT 的电话及相关设备。那一年，L.M.Ericsson 公司完成了 SAT 订购的 1000 部电话机和 22 套电话交换设备的交付。</p>
<p>此后，L.M.Ericsson 公司进入了发展的快车道。</p>
<p>1884 年，公司建造完成了自己的第一家大规模工厂。1885 年，生产了第一部手持送受话筒。1887 年，签订了当时的最大的合同，为 SAT 在斯德哥尔摩开办的电话局提供设备。这个电话局，是当时欧洲最大的电话局。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879816988314.png" alt></p>
<center><div>当时的 SAT 公司电话塔</div></center>
<p>1890 年，L.M.Ericsson 公司的员工人数上升到 153 人。1896 年，L.M.Ericsson 公司改制为有限责任公司，股份资本为 100 万克朗。这一年的 6 月 1 日，爱立信公司累计生产电话超过十万部。</p>
<p>此后的爱立信，开始全面开拓海外市场。</p>
<p>1897 年，爱立信在俄罗斯圣彼得堡开办工厂，组装电话机。1902 年，爱立信在纽约开设办事处。1903 年，爱立信与英国国家电话公司联合组建英国爱立信制造有限公司。</p>
<p>后来，爱立信陆续进入了挪威、丹麦、芬兰、澳大利亚、新西兰、南非、墨西哥、法国、匈牙利、奥地利等国家，成为一家全球性的电信设备公司。</p>
<p>1900 年，正当爱立信公司高速发展的时候，创始人拉什 · 爱立信决定辞去总经理职务。次年，他又辞任董事长，并逐步出售他持有的爱立信公司的股票（1905 年全部卖完）。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879817266816.png" alt></p>
<center><div>拉什 · 爱立信</div></center>
<p>1926 年 12 月 17 日，拉什 · 爱立信逝世，安葬在距离斯德哥尔摩不远的博基尔卡。按照他的遗嘱，墓地没有立石碑。</p>
<p>1946 年，拉什 · 爱立信百年诞辰之际，他的家乡为他立了一座石碑，上面刻着——<strong>“瑞典电话工业见证了他的成就”</strong>。</p>
<h2 id="█-遭遇股权危机，险些沦落敌手"><a class="header-anchor" href="#█-遭遇股权危机，险些沦落敌手">¶</a>█  遭遇股权危机，险些沦落敌手</h2>
<p>1914 年，第一次世界大战爆发，爱立信的海外市场受到重创。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879817662718.png" alt></p>
<center><div>瑞典地处波罗的海，战争导致出海口被封，爱立信的设备根本运不出去。</div></center>
<p>1917 年，俄国十月革命爆发，新成立的布尔什维克政府将爱立信在俄国的工厂和业务全部国有化，夺取了价值约 2000 万瑞典克朗的资产，使得爱立信公司雪上加霜。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879818274520.jpeg" alt></p>
<center><div>被夺走的工厂，后来被改名为 “红色黎明”</div></center>
<p>1918 年，为了度过经营危机，L.M.Ericsson 与 SAT 公司正式合并，成为 <strong>Allmänna Telefonaktiebolaget LM Ericsson</strong> 公司。</p>
<p>合并之后的新公司，得到了瑞典政府支付的约 5000 万克朗电话网络运营费用，大大缓解了经营压力。</p>
<p>不久后，新公司迎来了一个更大的危机，关于<strong>控制权</strong>的危机。</p>
<p>当时的情况是这样的：1909 年，SAT 公司创始人亨里克 · 塞德格伦去世时，将公司所有权转移给了一个基金会和他的家人。后来，SAT 公司与 L.M.Ericsson 公司合并，基金会和亨里克 · 塞德格伦的家人继而拥有了新公司的大部分控制权。</p>
<p>再后来，一战期间的巨额经营亏损，使得他们面临巨大的经济压力，于是，他们将爱立信公司的股权卖给了<strong>卡尔 · 弗雷德里克 · 温克兰茨</strong>（Karl Henrik Wincrantz）。</p>
<p>温克兰茨是谁？温克兰茨原本是 SAT 公司旗下斯德哥尔摩电信的总裁，1925 年，他被任命为爱立信公司的总裁。</p>
<p>为了巩固自己的权力，温克兰茨一直在努力增加自己的持股比例。</p>
<p>1928 年，在温克兰茨的推动下，爱立信公司开始发行 “A” 和“B”股。其中，“B”股只有 “A” 股千分之一的投票权。</p>
<p>温克兰茨希望通过持有少数 “A” 股来控制公司。同时，他主导发行了大量的 “B” 股，筹措公司发展所需的资金。这一时期，公司更名为 Telefon AB LM Ericsson。</p>
<p>温克兰茨增持股票肯定需要资金，但自己并没有这么多资金。于是，他找到了国际金融家<strong>伊瓦尔 · 克鲁格</strong>（Ivar Kreuger）。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879818656822.jpeg" alt></p>
<center><div>伊瓦尔 · 克鲁格</div></center>
<p>伊瓦尔 · 克鲁格帮助温克兰茨控制了爱立信公司。后来，克鲁格与温克兰茨闹翻，干脆赶走了温克兰茨，委任了自己的亲信担任爱立信公司的总裁。</p>
<p>克鲁格是一个做火柴生意起家的商人，非常精明，也非常不靠谱。为了从资本市场骗取资金，他长期谎报自己的资产规模和旗下企业的盈利能力。</p>
<p>1931 年，经济大萧条愈演愈烈，克鲁格资金断链。为了偿还债务，他找到了 ITT 的主席，索申尼斯 · 奔尼（Sosthenes Behn），把自己的爱立信股票以 1100 万美元的价格出售给 ITT。</p>
<p>ITT 是什么公司？美国国际电话电报公司，爱立信最大的竞争对手。这一举动，相当于把爱立信的控制权拱手交给了死对头。</p>
<p>1932 年 3 月，克鲁格自杀身亡。此时，ITT 拥有爱立信三分之一的股份。</p>
<p>事情被揭露之后，瑞典举国哗然。自己的民族企业，竟然被对手完全控制，这是无法接受的事情。</p>
<p>不过好在瑞典法律规定，禁止外国利益在瑞典公司中行使多数表决权，导致 ITT 公司没有办法完全控制爱立信公司。</p>
<p>后来，瑞典三大银行——斯堪的纳维亚银行、斯德哥尔摩恩斯基尔达银行和瑞典商业银行——迅速采取行动，拯救爱立信。他们与 ITT 进行谈判，逐渐增加了对爱立信公司的控股，夺回了控制权。</p>
<p>当时，负责牵头拯救行动的是瓦伦堡家族的<strong>小马库斯 · 瓦伦堡</strong>（Marcus Wallenberg Jr），斯德哥尔摩恩斯基尔达银行就属于他的瓦伦堡家族。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879819009724.jpeg" alt></p>
<center><div>小马库斯 · 瓦伦堡</div></center>
<p>后来，经过数十年的漫长周旋，一直到 1960 年，小马库斯 · 瓦伦堡才完全收回了 ITT 所持有的爱立信公司股份。爱立信公司也由此彻底摆脱了伊瓦尔 · 克鲁格事件的阴影。</p>
<h2 id="█-专注技术研发，成功反超对手"><a class="header-anchor" href="#█-专注技术研发，成功反超对手">¶</a>█  专注技术研发，成功反超对手</h2>
<p>二战时期，爱立信的业务再度因为出海口问题遭受重创。它的很多国外资产都被战争摧毁，销售额也大幅下降。</p>
<p>这期间，爱立信不得不临时转行，进行军工生产，为军队制造电话、飞机仪表、机枪和弹药等，维持生存。</p>
<p>二战结束后，全球电话市场需求激增，爱立信公司的业务也逐渐开始复苏。</p>
<p>1960 年，爱立信开始业务聚焦，砍掉了电信业务之外的无关业务，专注通信设备的研发。</p>
<p>当时，爱立信启动了一种名为 AKE 的商用电子交换系统的研发。到了 60 年代末，爱立信意识到，AKE 系统已经跟不上时代，它的速度太慢而且价格过于昂贵。</p>
<p>因为技术和产品的落后，爱立信在市场竞争中屡次输给自己的对手——ITT、GTE 和西门子等。</p>
<p>1969 年底，爱立信在一个大额合同上再次输给了 ITT。这次失败，迫使爱立信管理层下定决心，与瑞典电报公司 Televerket 联手，共同开发有竞争力的新型产品。</p>
<p>于是，1970 年 4 月，爱立信与 Televerket 正式签署协议，成立一家名为 <strong>Ellemtel Utvecklings AB</strong> 的联合研发公司。该公司的主要任务，就是开发一种先进的自动化数字电话交换系统，名为 <strong>AX 系统</strong>。</p>
<p>1976 年，经过不懈努力，Ellemtel 公司成功研发出世界上首台全数字交换机——<strong>AXE 交换机</strong>。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879819313226.png" alt></p>
<center><div>AXE 是爱立信历史上最重要和最成功的产品</div></center>
<p>AXE 是一个划时代的产品。它采用模块化的软硬件设计方式，易于制造和测试，也易于维修。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879819539828.png" alt></p>
<center><div>AXE 设备</div></center>
<p>因为技术上非常领先，在推出的两年时间里，AXE 几乎赢得了所有主要的国际电信合同。领导 AXE 开发团队的年轻工程师 Björn Svedberg，1977 年直接被任命为公司总裁。</p>
<p>AXE 成功商用后，Ellemtel 完成了自己的使命，逐步将研究成果移交给了爱立信和 Televerket。后来，Televerket 将自己的 Ellemtel 股份出售给爱立信，Ellemtel 也因此被完全整合到爱立信中。</p>
<h2 id="█-移动通信浪潮，百年名企沉浮"><a class="header-anchor" href="#█-移动通信浪潮，百年名企沉浮">¶</a>█ 移动通信浪潮，百年名企沉浮</h2>
<p>20 世纪 80 年代初，爱立信的数字交换技术继续在行业保持领先。</p>
<p>这一时期，因为沉迷于自己的 AXE 系统，爱立信错过了移动通信技术崛起的第一波浪潮。等到对手纷纷有所成就后，爱立信公司才反应过来，赶紧调整自身的战略方向，转战蜂窝移动通信市场。</p>
<p>1981 年 9 月，爱立信在沙特阿拉伯建设完成了世界第一个投入商业运营的 NMT 网络（比瑞典自己还早了 1 个月）。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879819790330.jpeg" alt></p>
<center><div>项目签约现场</div></center>
<p>1988 年，爱立信决定继续聚焦核心业务。这一年，它以 2.17 亿美元的价格，将自己的计算机和终端业务出售给了芬兰公司诺基亚。</p>
<p>与此同时，爱立信最主要的竞争对手，美国 AT&amp;T 公司，因为垄断被美国政府强行拆分。爱立信从中受益，很快占据了全球 40% 的移动系统市场。</p>
<p>后来，到了 2G 时代。欧洲基于 NMT 推出了 GSM，爱立信也及时地推出了自己的产品。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879820007232.png" alt></p>
<center><div>爱立信的 2G GSM 原型机</div></center>
<p>这期间，爱立信保持了连续 10 年<strong>年均 35% 以上</strong>的惊人增长，成为了世界上最大的电话及蜂窝移动通信设备商之一。</p>
<p>1995 年，爱立信的收入达到 76.1 亿瑞典克朗。1996 年，爱立信全球研发工程师达到 18000 名。1997 年，爱立信在世界移动市场上的份额达到 40%，拥有大约 5400 万用户。</p>
<p>1998 年，<strong>斯温 · 克里斯特 · 尼尔森</strong>（Sven-Christer Nilsson）当选为爱立信公司的 CEO。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879820245334.png" alt></p>
<center><div>斯温 · 克里斯特 · 尼尔森</div></center>
<p>在他的领导下，爱立信进行了重大的组织架构调整。</p>
<p>他将公司业务分为三个板块，分别是网络运营商部门、消费品部门（包括手机业务）和企业解决方案部门。（是不是有点眼熟？）</p>
<p>除了重组之外，尼尔森还宣布了 11000 人的裁员计划。</p>
<p>1999 年，爱立信与高通公司解决了为期两年的 CDMA 技术专利官司。作为和解的一部分，爱立信收购了高通的无线基础设施业务。</p>
<p>这一年，爱立信的手机业务在与诺基亚的竞争中落后，导致市场份额从 15.1% 下降到 10.5%。当时，爱立信 70% 的收入来自基础设施销售，而 21% 来自手机销售。</p>
<p>1999 年 7 月，因为业务重组失败，尼尔森被迫辞职。</p>
<p>进入 21 世纪，爱立信的霉运没有结束。2000 年，因为产品质量问题以及工厂发生的火灾意外，爱立信亏损 240 亿瑞典克朗。</p>
<p>2001 年，爱立信宣布将其手机的生产外包给<strong>伟创力</strong>国际有限公司，自己则集中力量于手机的技术研发、设计以及市场推广。同时，爱立信大幅裁剪了消费品部门的员工人数。</p>
<p>同年 10 月，爱立信与日本索尼公司分别出资 50%，组建了<strong>索尼爱立信移动通信公司</strong>，专门生产手机产品。对于这家公司，相信大家都比较熟悉。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879820498536.jpeg" alt></p>
<p>2002 年，在全球金融危机的持续影响下，爱立信再次遭受巨额亏损。</p>
<p>面对亏损，爱立信一方面推出了降低运营成本、提高效率的 “成本控制计划”；另一方面，调整市场战略，将公司的核心业务做了全面的优化与整合，出售了一些非核心业务。</p>
<p>2002 年 6 月，爱立信以 4 亿美元的价格，将自己的微电子部门卖给了<strong>英飞凌</strong>科技股份公司（当时是西门子的子公司）。</p>
<p>2003 年，随着全球通信产业回暖，加上之前的一系列战略调整显露成效，爱立信宣告结束亏损，恢复盈利。</p>
<p>复苏后的爱立信，在全球 3G 市场上表现突出，拥有 40% 的 3G WCDMA 市场份额，是当之无愧的全球第一设备商。</p>
<h2 id="█-遭遇中国对手，迎来严峻挑战"><a class="header-anchor" href="#█-遭遇中国对手，迎来严峻挑战">¶</a>█ 遭遇中国对手，迎来严峻挑战</h2>
<p>爱立信与中国的历史渊源已超过百年。早在 1892 年，爱立信就接到了来自中国的订单（2000 个电话机），并为中国供货。1906 年，中国代表团还前往斯德哥尔摩，参观了爱立信总部。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879820869638.png" alt></p>
<center><div>当时的会面场景</div></center>
<p>一个多世纪以来，爱立信在中国电信发展史上贡献了多个 “第一”。</p>
<p>中国第一部人工交换机（1900 年）和第一部自动交换机（1924 年），就是来自爱立信。1987 年中国第一套移动电话系统在广州开通，设备也是来自爱立信。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879821103340.jpeg" alt></p>
<center><div>中国第一套移动电话系统</div></center>
<p><img src="/public/2022/04/01/history_ericsson/640-164879821453442.png" alt></p>
<center><div>改革开放后，国内也引进了 AXE（1985 年照片）</div></center>
<p>爱立信一直非常重视中国市场，不仅成立了合资公司和独资公司，还在中国设立了爱立信学院和研究院。</p>
<p>不过，拉什 · 爱立信当年卖电话到这个国家的时候，一定不会想到，一百多年后，这个国家会走出来两个名不见经传的小公司，把他开创的通信霸业给搅得鸡犬不宁。</p>
<p>这两个小公司，当然就是华为和中兴。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879821693844.jpeg" alt></p>
<p>在这两家公司的挑战和冲击下，爱立信公司在 21 世纪的市场份额不断下滑，CEO 频繁更换。那些年，伴随爱立信的坏消息总是一个接着一个，不是出售业务，就是裁员。</p>
<p>2013 年，华为全年销售收入正式超过爱立信，爱立信被迫将全球第一的位置拱手相让。</p>
<p>2016 年，爱立信计划关闭瑞典境内的所有工厂，结束在瑞典制造产品 140 年的历史。</p>
<p>2017 年，爱立信净亏损 44.76 亿美元，全年裁员达到 1.7 万人。</p>
<h2 id="█-外部环境变化，业绩迅速复苏"><a class="header-anchor" href="#█-外部环境变化，业绩迅速复苏">¶</a>█ 外部环境变化，业绩迅速复苏</h2>
<p>2018 年之后，爱立信的形势有了明显的好转，原因包括多个方面。</p>
<p>首先，就是 5G 市场增长带来的商业机会。</p>
<p>爱立信非常重视 5G，投入了大量的资源进行研发。2014 年，爱立信就发布了全球首台 5G 移动终端原型。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879822068446.jpeg" alt></p>
<p>2016 年，爱立信发布了一款号称 “全球首个 5G NR 无线设备” 的 5G 基站——AIR 6468。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879822338648.jpeg" alt></p>
<p>2017 年 2 月，爱立信推出了自己的 5G 平台。2018 年 1 月，爱立信发布了首个 5G 小基站 “5G Radio Dot”，吸引了行业的广泛关注。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879822621150.png" alt></p>
<center><div>5G NR DOT 点系统</div></center>
<p>除了 5G 之外，另一个帮助爱立信业绩复苏的主要原因，是微妙变化的外部环境。</p>
<p>正如大家所知道的，中美贸易摩擦，美国对中国通信设备商进行强力打压，多个国家宣布 “禁用” 华为和中兴。于是，欧美国家的设备商就有了难得的市场机会。</p>
<p>综合种种因素，爱立信的业绩迅速转好，扭亏为盈，股价攀升。</p>
<p>2020 年，爱立信全年净销售额达到 2324 亿瑞典克朗（约合 278 亿美元），同比上涨 2%；净利润 176 亿瑞典克郎（约合 21 亿美元），相比 2019 年，翻了近十倍。</p>
<h2 id="█-结语"><a class="header-anchor" href="#█-结语">¶</a>█  结语</h2>
<p>爱立信，是通信行业历史最悠久的企业之一（准确来说，是 145 年的历史）。</p>
<p>在很长的一段时间里，它都是世界排名第一的通信设备制造商。爱立信的很多技术创新，改变了通信行业的发展走向。很多经典的通信产品和知名的通信项目，都是出于这家企业。</p>
<p>在一百年的发展过程中，爱立信有过辉煌，也有过挫折，但是它仍然屹立不倒，在世界通信第一阵营中牢牢占据自己的位置。这充分说明，这家企业有着自己的技术积累和文化底蕴，有属于自己的 “韧性”。</p>
<p>如今，5G 的竞争还在继续，百年老店爱立信的奋斗之路也在继续。面对变幻莫测的市场环境，爱立信究竟会走向何方呢？它还会续写另一段百年辉煌吗？</p>
<p>（全文完）</p>
<p><strong>参考文献：</strong></p>
<p>1、<a href="https://www.ericsson.com/en/about-us/history/company" target="_blank" rel="noopener">https://www.ericsson.com/en/about-us/history/company</a></p>
<p>2、<a href="https://en.wikipedia.org/wiki/Ericsson" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Ericsson</a></p>
<p>3、《改变世界》，2009 年出版</p>
<p>4、<a href="https://ethw.org/Lars_Magnus_Ericsson" target="_blank" rel="noopener">https://ethw.org/Lars_Magnus_Ericsson</a></p>
<p>5、<a href="https://www.company-histories.com/Telefonaktiebolaget-LM-Ericsson-Company-History.html" target="_blank" rel="noopener">https://www.company-histories.com/Telefonaktiebolaget-LM-Ericsson-Company-History.html</a></p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879825241752.gif" alt></p>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title>[译] Face Detection – OpenCV, Dlib and Deep Learning ( C++ / Python )</title>
    <url>/public/2018/11/12/cv/FaceDetectionComparison/</url>
    <content><![CDATA[<p><strong>前言</strong>
本文为翻译文章。原文地址 <a href="https://www.learnopencv.com/face-detection-opencv-dlib-and-deep-learning-c-python/" target="_blank" rel="noopener">https://www.learnopencv.com/face-detection-opencv-dlib-and-deep-learning-c-python/</a></p>
<p>在这篇文章中，作者讨论使用了OpenCV或Dlib的多种人脸检测的代码，并给出性能分析。作者使用的 Face Detector 包括以下四个，后面分别给出 c++ 和 python 实现。</p>
<ol>
<li>OpenCV 的 Haar Cascade Face Detector</li>
<li>OpenCV 的 Deep Learning based Face Detector</li>
<li>Dlib 的 HoG Face Detector</li>
<li>Dlib 的 Deep Learning based Face Detector</li>
</ol>
<p>作者限于篇幅没有对对理论进行深入解读，只讨论框架的使用，同时分享一些应用上的选择权衡的经验。</p>
<p>结论：在多数场景中，我们提前不知道图片大小，因此 选用 OpenCV – DNN 相当快也很精确，甚至对于小人脸也不错，各种人脸角度也可以。选用这个在大多情况下是最优的。</p>
<p><a href="https://github.com/spmallick/learnopencv/tree/master/FaceDetectionComparison" target="_blank" rel="noopener">code FaceDetectionComparison</a> 说明：为了使文章显得简洁一些，在文中只提供关键的代码片段。在github项目中详细代码，包括每个方法独立的代码和整合在一起的cpp和py文件（<a href="http://run-all.py" target="_blank" rel="noopener">run-all.py</a> 和 run-all.cpp），同时里面也有运行代码所使用的人脸检测模型。</p>
<a id="more"></a>
<center><iframe width="100%" height="360" frameborder="0" src="http://v.qq.com/iframe/player.html?vid=k07615vrzj8&tiny=0&auto=0" allowfullscreen></iframe></center>
> 实验的图片尺寸是  image size 300×300
<h2 id="1-OpenCV-Haar"><a class="header-anchor" href="#1-OpenCV-Haar">¶</a>1. OpenCV-Haar</h2>
<p>在2001年，Viola 和 Jones提出Haar Cascade 特征为基础的 Face Detector，在以后的多年内都是最优的人脸检测算法。以他们的算法为基础人们做了很多改进。OpenCV提供了很多Haar特征的模型算法，更多的Haar特征模型 <strong><a href="https://github.com/opencv/opencv/tree/master/data/haarcascades" target="_blank" rel="noopener">here</a></strong></p>
<h3 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h3>
<h4 id="Python"><a class="header-anchor" href="#Python">¶</a>Python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">faceCascade = cv2.CascadeClassifier(<span class="string">'./haarcascade_frontalface_default.xml'</span>)</span><br><span class="line">faces = faceCascade.detectMultiScale(frameGray)</span><br><span class="line"><span class="keyword">for</span> face <span class="keyword">in</span> faces:</span><br><span class="line">    x1, y1, w, h = face</span><br><span class="line">    x2 = x1 + w</span><br><span class="line">    y2 = y1 + h</span><br></pre></td></tr></table></figure>
<h4 id="C"><a class="header-anchor" href="#C">¶</a>C++</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">faceCascadePath = <span class="string">"./haarcascade_frontalface_default.xml"</span>;</span><br><span class="line">faceCascade.load( faceCascadePath )</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Rect&gt; faces;</span><br><span class="line">faceCascade.detectMultiScale(frameGray, faces);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; faces.size(); i++ )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> x1 = faces[i].x;</span><br><span class="line">  <span class="keyword">int</span> y1 = faces[i].y;</span><br><span class="line">  <span class="keyword">int</span> x2 = faces[i].x + faces[i].width;</span><br><span class="line">  <span class="keyword">int</span> y2 = faces[i].y + faces[i].height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对图片灰度变化（grayscale）后，再应用 haar cascade 特征，输出是脸的list。list中每个item有四个element 分别为 top-left corner的(x, y) 、检测出来脸的大小(width, height) 。</p>
<h3 id="优点"><a class="header-anchor" href="#优点">¶</a>优点</h3>
<ol>
<li>在CPU上几乎是实时的（real-time）</li>
<li>简单的框架 （Simple Architecture）</li>
<li>能检测不同大小的脸 （different scales）</li>
</ol>
<h3 id="缺点"><a class="header-anchor" href="#缺点">¶</a>缺点</h3>
<ol>
<li>主要缺点是有很多错误的预测（False predictions），会多预测出人脸。</li>
<li>人脸非正面效果不好 （non-frontal）</li>
<li>人脸遮挡效果不好 （under occlusion）</li>
</ol>
<h2 id="2-OpenCV-DNN"><a class="header-anchor" href="#2-OpenCV-DNN">¶</a>2. OpenCV-DNN</h2>
<p>在 OpenCV 3.3 中引入这个方法。DNN模型使用SSD **<a href="https://arxiv.org/abs/1512.02325" target="_blank" rel="noopener">Single-Shot-Multibox detector</a>**框架和  ResNet-10 特征提取网络（backbone）。这个模型喂的数据是从网上采集的，但是训练的源代码没有公开。OpenCV提供了2个模型文件。</p>
<ol>
<li>Float 16 位版本模型，使用原始的 caffe 训练  (5.4 MB)</li>
<li>8 bit quantized 版本模型，使用 Tensorflow 训练 (2.7 MB)</li>
</ol>
<p>代码 <a href="https://github.com/spmallick/learnopencv/tree/master/FaceDetectionComparison" target="_blank" rel="noopener">FaceDetectionComparison</a>  里面放了这两个模型文件。</p>
<h3 id="代码-2"><a class="header-anchor" href="#代码-2">¶</a>代码</h3>
<h4 id="Python-2"><a class="header-anchor" href="#Python-2">¶</a>Python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DNN = <span class="string">"TF"</span></span><br><span class="line"><span class="keyword">if</span> DNN == <span class="string">"CAFFE"</span>:</span><br><span class="line">    modelFile = <span class="string">"res10_300x300_ssd_iter_140000_fp16.caffemodel"</span></span><br><span class="line">    configFile = <span class="string">"deploy.prototxt"</span></span><br><span class="line">    net = cv2.dnn.readNetFromCaffe(configFile, modelFile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    modelFile = <span class="string">"opencv_face_detector_uint8.pb"</span></span><br><span class="line">    configFile = <span class="string">"opencv_face_detector.pbtxt"</span></span><br><span class="line">    net = cv2.dnn.readNetFromTensorflow(modelFile, configFile)</span><br></pre></td></tr></table></figure>
<h4 id="C-2"><a class="header-anchor" href="#C-2">¶</a>C++</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> caffeConfigFile = <span class="string">"./deploy.prototxt"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> caffeWeightFile = <span class="string">"./res10_300x300_ssd_iter_140000_fp16.caffemodel"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> tensorflowConfigFile = <span class="string">"./opencv_face_detector.pbtxt"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> tensorflowWeightFile = <span class="string">"./opencv_face_detector_uint8.pb"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> CAFFE</span></span><br><span class="line"></span><br><span class="line">  Net net = cv::dnn::readNetFromCaffe(caffeConfigFile, caffeWeightFile);</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  Net net = cv::dnn::readNetFromTensorflow(tensorflowWeightFile, tensorflowConfigFile);</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>caffe 和 Tensorflow 框架加载模型的代码。使用 Float 16 的 Caffe 模型，需要 caffemodel 和 prototxt 文件。使用 8 bit quantized 的 Tensorflow 模型，需要 Tensorflow 配置文件和模型。</p>
<h4 id="Python-3"><a class="header-anchor" href="#Python-3">¶</a>Python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blob = cv2.dnn.blobFromImage(frameOpencvDnn, <span class="number">1.0</span>, (<span class="number">300</span>, <span class="number">300</span>), [<span class="number">104</span>, <span class="number">117</span>, <span class="number">123</span>], <span class="literal">False</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">net.setInput(blob)</span><br><span class="line">detections = net.forward()</span><br><span class="line">bboxes = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(detections.shape[<span class="number">2</span>]):</span><br><span class="line">    confidence = detections[<span class="number">0</span>, <span class="number">0</span>, i, <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> confidence &gt; conf_threshold:</span><br><span class="line">        x1 = int(detections[<span class="number">0</span>, <span class="number">0</span>, i, <span class="number">3</span>] * frameWidth)</span><br><span class="line">        y1 = int(detections[<span class="number">0</span>, <span class="number">0</span>, i, <span class="number">4</span>] * frameHeight)</span><br><span class="line">        x2 = int(detections[<span class="number">0</span>, <span class="number">0</span>, i, <span class="number">5</span>] * frameWidth)</span><br><span class="line">        y2 = int(detections[<span class="number">0</span>, <span class="number">0</span>, i, <span class="number">6</span>] * frameHeight)</span><br></pre></td></tr></table></figure>
<h4 id="C-3"><a class="header-anchor" href="#C-3">¶</a>C++</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAFFE</span></span><br><span class="line">cv::Mat inputBlob = cv::dnn::blobFromImage(frameOpenCVDNN, inScaleFactor, cv::Size(inWidth, inHeight), meanVal, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">cv::Mat inputBlob = cv::dnn::blobFromImage(frameOpenCVDNN, inScaleFactor, cv::Size(inWidth, inHeight), meanVal, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">net.setInput(inputBlob, <span class="string">"data"</span>);</span><br><span class="line">cv::Mat detection = net.forward(<span class="string">"detection_out"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">cv::Mat <span class="title">detectionMat</span><span class="params">(detection.size[<span class="number">2</span>], detection.size[<span class="number">3</span>], CV_32F, detection.ptr&lt;<span class="keyword">float</span>&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; detectionMat.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">float</span> confidence = detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (confidence &gt; confidenceThreshold)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">int</span> x1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">3</span>) * frameWidth);</span><br><span class="line">         <span class="keyword">int</span> y1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">4</span>) * frameHeight);</span><br><span class="line">         <span class="keyword">int</span> x2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">5</span>) * frameWidth);</span><br><span class="line">         <span class="keyword">int</span> y2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">6</span>) * frameHeight);</span><br><span class="line"></span><br><span class="line">        cv::rectangle(frameOpenCVDNN, cv::Point(x1, y1), cv::Point(x2, y2), cv::Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码里面，图像转为blob输入进network里，利用前向传播函数forward()，得到一个4-D matrix。 #TODO :这里不是很理解，代码跑起来看一下？？？</p>
<ul>
<li>The 3rd dimension iterates over the detected faces. (i is the iterator over the number of faces)</li>
<li>The fourth dimension contains information about the bounding box and score for each face. For example, detections[0,0,0,2] gives the confidence score for the first face, and detections[0,0,0,3:6] give the bounding box.</li>
</ul>
<p>The output coordinates of the bounding box are normalized between [0,1]. Thus the coordinates should be multiplied by the height and width of the original image to get the correct bounding box on the image.</p>
<h3 id="优点（merits）"><a class="header-anchor" href="#优点（merits）">¶</a>优点（merits）</h3>
<ol>
<li>在本文四个方法中最精确（Most accurate）</li>
<li>可以在CPU上实时运行（real-time）</li>
<li>人脸不同方向效果不错（上下左右，侧脸等）up, down, left, right, side-face etc</li>
<li>人脸不同大小效果不错哦（various scales, big and tiny OK）</li>
</ol>
<p>OpenCV的这个DNN方法克服了 Haar cascade 方法的不足，同时精度也不比它差。暂时没有发现这个方法其他有不足地方，除了比后面的 Dlib HoG 方法速度慢一点以外。</p>
<p>作者建议，在使用OpenCV时，比Haar方法，可以优先考虑DNN方法。</p>
<h2 id="3-Dlib-HoG"><a class="header-anchor" href="#3-Dlib-HoG">¶</a>3. Dlib-HoG</h2>
<p>HoG 人脸检测方法被广泛的使用，基于 HoG 特征和 SVM 分类。作者还写了一篇 HoG 的博客 <a href="https://www.learnopencv.com/histogram-of-oriented-gradients/" target="_blank" rel="noopener">post</a>。模型有5个 HOG filters 滤波器（ front looking, left looking, right looking, front looking but rotated left, and a front looking but rotated right），模型直接放在了头文件里面 <strong><a href="https://github.com/davisking/dlib/blob/master/dlib/image_processing/frontal_face_detector.h" target="_blank" rel="noopener">header file</a></strong>。</p>
<p>训练模型的数据库，来自LFW dataset，由 Davis King (Dlib的作者) 手工标记 （manually annotated）共2825张。需要的话，数据库从这里可以下载 <strong><a href="http://dlib.net/files/data/dlib_face_detector_training_data.tar.gz" target="_blank" rel="noopener">dlib_face_detector_training_data.tar.gz</a></strong>.</p>
<h3 id="代码-3"><a class="header-anchor" href="#代码-3">¶</a>代码</h3>
<h4 id="Python-4"><a class="header-anchor" href="#Python-4">¶</a>Python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hogFaceDetector = dlib.get_frontal_face_detector()</span><br><span class="line">faceRects = hogFaceDetector(frameDlibHogSmall, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> faceRect <span class="keyword">in</span> faceRects:</span><br><span class="line">    x1 = faceRect.left()</span><br><span class="line">    y1 = faceRect.top()</span><br><span class="line">    x2 = faceRect.right()</span><br><span class="line">    y2 = faceRect.bottom()</span><br></pre></td></tr></table></figure>
<h4 id="C-4"><a class="header-anchor" href="#C-4">¶</a>C++</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">frontal_face_detector hogFaceDetector = get_frontal_face_detector();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert OpenCV image format to Dlib's image format</span></span><br><span class="line"><span class="function">cv_image&lt;bgr_pixel&gt; <span class="title">dlibIm</span><span class="params">(frameDlibHogSmall)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect faces in the image</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dlib::rectangle&gt; faceRects = hogFaceDetector(dlibIm);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; faceRects.size(); i++ )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> x1 = faceRects[i].left();</span><br><span class="line">  <span class="keyword">int</span> y1 = faceRects[i].top();</span><br><span class="line">  <span class="keyword">int</span> x2 = faceRects[i].right();</span><br><span class="line">  <span class="keyword">int</span> y2 = faceRects[i].bottom();</span><br><span class="line">  cv::rectangle(frameDlibHog, Point(x1, y1), Point(x2, y2), Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), (<span class="keyword">int</span>)(frameHeight/<span class="number">150.0</span>), <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，首先加载 face detector，然后将图像输入给 detector 。其中第二个参数代表，想要上采样图片的倍数（times of upscale）。你给的数字越大，小脸检测出的概率越大。但是upscaling 会在计算上花费可观的时间（ substantial impact on the computation speed）。输出是脸的list， 框框对角的坐标（diagonal corners）。</p>
<h3 id="优点-2"><a class="header-anchor" href="#优点-2">¶</a>优点</h3>
<ol>
<li>在cpu上最快的方法（在四个方法中）</li>
<li>对正面和轻微非正面的方法效果很不错</li>
<li>模型比较少对于其他三个的文件来说</li>
<li>轻微遮挡下可以检测</li>
</ol>
<p>大概以上，这个方法多数情况可以工作，除了下面的情况。</p>
<h3 id="缺点-2"><a class="header-anchor" href="#缺点-2">¶</a>缺点</h3>
<ol>
<li>主要缺点对小人脸不识别。由于训练在最小 80×80 的数据集上，要确保你的使用环境，不然的话你要自己再训练一下小人脸。</li>
<li>人脸框经常去掉了人额头一部分，有时脸颊一部分。
（part of forehead and even part of chin sometimes）</li>
<li>在明显的遮挡情况下效果不好</li>
<li>在测量和极端不正面的脸情况不工作，像向上看，和向下看的情况。</li>
</ol>
<h2 id="4-Dlib-CNN"><a class="header-anchor" href="#4-Dlib-CNN">¶</a>4. Dlib-CNN</h2>
<p>这个模型使用了**<a href="https://arxiv.org/pdf/1502.00046.pdf" target="_blank" rel="noopener">Maximum-Margin Object Detector (MMOD)</a>** 加CNN的特征的方法。训练过程相当简单，也不需要大量的数据去训练一个新的 object detector。更多的训练套路，在这个网站上 <strong><a href="http://blog.dlib.net/2016/10/easily-create-high-quality-object.html" target="_blank" rel="noopener">website</a></strong>.</p>
<p>使用的模型可以从 <strong><a href="https://github.com/davisking/dlib-models" target="_blank" rel="noopener">dlib-models repository</a></strong> 下载。</p>
<p>训练使用的数据库是dlib的作者 Davis King 手工标的，7220张从  ImageNet, PASCAL VOC, VGG, WIDER, Face Scrub等数据库里面挑的。这个数据库可以下载到。<a href="http://dlib.net/files/data/dlib_face_detection_dataset-2016-09-30.tar.gz" target="_blank" rel="noopener"><strong>dlib_face_detection_dataset-2016-09-30.tar.gz</strong></a></p>
<h3 id="代码-4"><a class="header-anchor" href="#代码-4">¶</a>代码</h3>
<h4 id="Python-5"><a class="header-anchor" href="#Python-5">¶</a>Python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dnnFaceDetector = dlib.cnn_face_detection_model_v1(<span class="string">"./mmod_human_face_detector.dat"</span>)</span><br><span class="line">faceRects = dnnFaceDetector(frameDlibHogSmall, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> faceRect <span class="keyword">in</span> faceRects:</span><br><span class="line">    x1 = faceRect.rect.left()</span><br><span class="line">    y1 = faceRect.rect.top()</span><br><span class="line">    x2 = faceRect.rect.right()</span><br><span class="line">    y2 = faceRect.rect.bottom()</span><br></pre></td></tr></table></figure>
<h4 id="C-5"><a class="header-anchor" href="#C-5">¶</a>C++</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">String mmodModelPath = <span class="string">"./mmod_human_face_detector.dat"</span>;</span><br><span class="line">net_type mmodFaceDetector;</span><br><span class="line">deserialize(mmodModelPath) &gt;&gt; mmodFaceDetector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert OpenCV image format to Dlib's image format</span></span><br><span class="line"><span class="function">cv_image&lt;bgr_pixel&gt; <span class="title">dlibIm</span><span class="params">(frameDlibMmodSmall)</span></span>;</span><br><span class="line">matrix&lt;rgb_pixel&gt; dlibMatrix;</span><br><span class="line">assign_image(dlibMatrix, dlibIm);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect faces in the image</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dlib::mmod_rect&gt; faceRects = mmodFaceDetector(dlibMatrix);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; faceRects.size(); i++ )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> x1 = faceRects[i].rect.left();</span><br><span class="line">  <span class="keyword">int</span> y1 = faceRects[i].rect.top();</span><br><span class="line">  <span class="keyword">int</span> x2 = faceRects[i].rect.right();</span><br><span class="line">  <span class="keyword">int</span> y2 = faceRects[i].rect.bottom();</span><br><span class="line">  cv::rectangle(frameDlibMmod, Point(x1, y1), Point(x2, y2), Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), (<span class="keyword">int</span>)(frameHeight/<span class="number">150.0</span>), <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码和  HoG detector 差不多，除了下载的 CNN face detection 的模型文件。</p>
<h3 id="优点-3"><a class="header-anchor" href="#优点-3">¶</a>优点</h3>
<ol>
<li>不同的脸朝向效果不错 （face orientations）</li>
<li>遮挡比较稳定 （occlusion）</li>
<li>在GPU上很快</li>
<li>训练模型过程很简单</li>
</ol>
<h3 id="缺点-3"><a class="header-anchor" href="#缺点-3">¶</a>缺点</h3>
<ol>
<li>CPU上很慢</li>
<li>脸大小于 80×80  检测不出，因为模型在小脸训练的。所以要考虑你应用的具体场景脸的大小，当然也可以对小脸数据库再训练一下。</li>
<li>人脸框 bounding box 甚至比 HoG detector 还小。</li>
</ol>
<h2 id="5-精度比较"><a class="header-anchor" href="#5-精度比较">¶</a>5. 精度比较</h2>
<p>（Accuracy Comparison）</p>
<p>作者评估这四个模型使用的是 FDDB 数据库，其中评估OpenCV-DNN 脚本为 <a href="https://github.com/opencv/opencv/blob/master/modules/dnn/misc/face_detector_accuracy.py" target="_blank" rel="noopener">OpenCV face_detector_accuracy.py</a>.</p>
<p>作者发现奇怪的结果。Dlib 的结果比 Haar OpenCV还要低，然而实际从图片上效果比较好。下图是这四个方法的精度得分（ Precision scores）。</p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/face-detection-coco-comparison.jpg" alt></p>
<p>指标说明（Metric）：
AP_50 = Precision when overlap between Ground Truth and predicted bounding box is at least 50% (IoU = 50%)
AP_75 = Precision when overlap between Ground Truth and predicted bounding box is at least 75% (IoU = 75%)
AP_Small = Average Precision for small size faces (Average of IoU = 50% to 95%)
AP_medium = Average Precision for medium size faces (Average of IoU = 50% to 95%)
AP_Large = Average Precision for large size faces (Average of IoU = 50% to 95%)
mAP = Average precision across different IoU (Average of IoU = 50% to 95%)</p>
<p><strong>作者最近的发现评估过程对 Dlib 不够公平，科学。</strong></p>
<h3 id="5-1-评估过程出错了，分析的二个原因！"><a class="header-anchor" href="#5-1-评估过程出错了，分析的二个原因！">¶</a>5.1. 评估过程出错了，分析的二个原因！</h3>
<p>根据我们的分析，Dlib拿到低的精度的原因如下：
<strong>第一个主要原因是训练dlib的是标准数据库没有加标签（annotations）</strong>。数据库图片是由dlib作者自己切的，因此可以发现同样是人脸检测的框，同OpenCV 中的两个方法 OpenCV-Haar 或者 OpenCV-DNN 相比，dlib的方法会裁掉额头一部分或者脸颊一部分（forehead chin）。下面的图中可以看到。</p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-acc-result1-e1539872861105.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-acc-result2-e1539872827875.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-acc-result3-e1539872783684.jpg" alt></p>
<p>这个问题可以导致 在上个柱状图中 dlib 分数会低。AP_X 代表着  X% 预测框和真实框交叠的面积占合起来面积的比率。dlib 的 AP_75 的得分为0，尽管有在 AP_75 比 Haar 还高。这个就意味着：<strong>Dlib 模型可以预测更多的人脸比 Haar 特征，但是dlib的框的 AP_75 得分比较低</strong>。</p>
<p><strong>第二个原因是 dlib 不能检测小的人脸，进一步拉低了得分。</strong></p>
<p><strong>因此，比较 OpenCV 和 Dlib 精确性的一个相对合理的指标是 AP_50 （或者可以使用小于50%的指标，我们只是设阈值用来计算人头的个数）</strong> 以上分析大家使用 Dlib 的时候注意一下。</p>
<h2 id="6-速度比较"><a class="header-anchor" href="#6-速度比较">¶</a>6. 速度比较</h2>
<p>Speed Comparison</p>
<p>我们使用 300x300 图像做的对比实验。Dlib 的 MMOD 模型可以利用上GPU，但是OpenCV方法对 NVIDIA GPUs 支持还没有。所以我们评估对比这些方法在CPU上，但我们也给出 GPU 版本 MMOD 结果。</p>
<p>(这段话以后写论文的时候可以用到，保留:cat:) We used a 300×300 image for the comparison of the methods. The MMOD detector can be run on a GPU, but the support for NVIDIA GPUs in OpenCV is still not there. So, we evaluate the methods on CPU only and also report result for MMOD on GPU as well as CPU.</p>
<h3 id="硬件的配置"><a class="header-anchor" href="#硬件的配置">¶</a>硬件的配置</h3>
<p>Processor : Intel Core i7 6850K – 6 Core
RAM : 32 GB
GPU : NVIDIA GTX 1080 Ti with 11 GB RAM
OS : Linux 16.04 LTS
Programming Language : Python</p>
<p>我们跑了10次，每次对图片进行10000趟测试得总时间，然后对这10次取平均。下面的柱状图是结果。We run each method 10000 times on the given image and take 10 such iterations and average the time taken. Given below are the results.</p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/face-detection-speed-comparison.jpg" alt></p>
<p>从图中可以看到，对于 300x300 的图片，除了 MMOD。MMOD 在GPU上还是很快的，CPU上就是渣渣了。As you can see that for the image of this size, all the methods perform in real-time, except MMOD. MMOD detector is very fast on a GPU but is very slow on a CPU.</p>
<p>以上的结果在不同电脑硬软件环境下可能不一样。</p>
<h2 id="7-多种情况讨论"><a class="header-anchor" href="#7-多种情况讨论">¶</a>7. 多种情况讨论</h2>
<p>除了速度和精度外，我们在选择哪个模型来使用还有一些因素可以考虑。在这节中，将考虑这些情况下的选择。主要为人脸大小变化、非正脸、遮挡。</p>
<h3 id="7-1-人脸大小变化"><a class="header-anchor" href="#7-1-人脸大小变化">¶</a>7.1. 人脸大小变化</h3>
<p>Detection across scale</p>
<p>下面有一个例子视频，这位帅哥在做一个前后的健身动作，使得脸部区域变大变小。可以看到OpenCV DNN 检测出了所有的脸，而 Dlib 的方法只有在大于某个 size 的时候才被检测出来。</p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/face-detection-scale-comparison.gif" alt></p>
<p>我们测试后，脸大于 70×70 才能被 dlib检测出。正如在前面说到的，对小人脸检测是dlib方法的一个大的缺点。我们也可以将图片上采样，但这样的话速度的话相对于 OpenCV-DNN 就太慢了。</p>
<p>It can be seen that dlib based methods are able to detect faces of size upto ~(70×70) after which they fail to detect. As we discussed earlier, I think this is the major drawback of Dlib based methods. Since it is not possible to know the size of the face before-hand in most cases. We can get rid of this problem by upscaling the image, but then the speed advantage of dlib as compared to OpenCV-DNN goes away.</p>
<h3 id="7-2-非正脸"><a class="header-anchor" href="#7-2-非正脸">¶</a>7.2. 非正脸</h3>
<p>Non-frontal Face</p>
<p>对于非正脸的测试，我们选用了 looking towards right, left, up, down。为了对 dlib 公平，我们选择了face 大于 80×80 的图片。下面是一些例子。</p>
<p>Non-frontal can be looking towards right, left, up, down. Again, to be fair with dlib, we make sure the face size is more than 80×80. Given below are some examples.</p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result7.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result6.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result5.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result4.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result2.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result1.jpg" alt></p>
<p>和预期的一样，OpenCV Haar 方法完全败了。Dlib HoG能检测出 left 或 right looking faces，但是精度不如那些DNN方法。</p>
<p>As expected, Haar based detector fails totally. HoG based detector does detect faces for left or right looking faces (since it was trained on them) but not as accurately as the DNN based detectors of OpenCV and Dlib.</p>
<h3 id="7-3-遮挡"><a class="header-anchor" href="#7-3-遮挡">¶</a>7.3. 遮挡</h3>
<p>Occlusion</p>
<p>接下来看一下遮挡的情况。Let us see how well the methods perform under occlusion.</p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-occlusion-result1.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-occlusion-result2.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-occlusion-result3.jpg" alt></p>
<p>再一次看到，DNN方法比其他方法更优，OpenCV-DNN 比  Dlib-MMOD 还好一点。这是因为CNN 特征 比 HoG or Haar 更加鲁棒，稳定。</p>
<p>Again, the DNN methods outperform the other two, with OpenCV-DNN slightly better than Dlib-MMOD. This is mainly because the CNN features are much more robust than HoG or Haar features.</p>
<h2 id="8-总结"><a class="header-anchor" href="#8-总结">¶</a>8. 总结</h2>
<p>我们讨论了每个方法的优缺点。个人建议使用 OpenCV-DNN 和 Dlib-HoG 在应用和设备成本权衡中。以下我们的建议：</p>
<p>We had discussed the pros and cons of each method in the respective sections. I recommend to try both OpenCV-DNN and HoG methods for your application and decide accordingly. We share some tips to get started.</p>
<h3 id="8-1-大多数的情况"><a class="header-anchor" href="#8-1-大多数的情况">¶</a>8.1 大多数的情况</h3>
<p>General Case</p>
<p>在多数场景中，我们提前不知道图片大小，因此 选用 OpenCV – DNN 相当快也很精确，甚至对于小人脸也不错，各种人脸角度也可以。选用这个在大多情况下是最优的。</p>
<p>In most applications, we won’t know the size of the face in the image before-hand. Thus, it is better to use OpenCV – DNN method as it is pretty fast and very accurate, even for small sized faces. It also detects faces at various angles. We recommend to use OpenCV-DNN in most</p>
<h3 id="8-2-大小中等或大一点图片"><a class="header-anchor" href="#8-2-大小中等或大一点图片">¶</a>8.2 大小中等或大一点图片</h3>
<p>For medium to large image sizes</p>
<p>Dlib HoG 在 cpu上是最快的一个方法。但是它不能检测出 face size (&lt; 70x70) 的图片。所以你得清楚使用的场景，比如自拍的话就可以。如果能使用GPU的话 dlib-MMOD 是一个最好的选择，因为它支持GPU，跑得也比较快，也能适应人脸的角度变化。</p>
<p>Dlib HoG is the fastest method on CPU. But it does not detect small sized faces (&lt; 70x70). So, if you know that your application will not be dealing with very small sized faces ( for example a selfie app ), then HoG based Face detector is a better option. Also, If you can use a GPU, then MMOD face detector is the best option as it is very fast on GPU and also provides detection at various angles.</p>
<h3 id="8-3-高分辨率图像"><a class="header-anchor" href="#8-3-高分辨率图像">¶</a>8.3 高分辨率图像</h3>
<p>High resolution images</p>
<p>对于这些方法来说，高分辨图像都有点难度，计算时间比较长。可能采用的方法是resize图像 （ scale down the image），HoG / MMOD方法可能就识别不出了，但是可以使用 OpenCV-DNN 尝试一下。我认为也可以将图片分割开再识别呀，嘻嘻。</p>
<p>Since feeding high resolution images is not possible to these algorithms (for computation speed), HoG / MMOD detectors might fail when you scale down the image. On the other hand, OpenCV-DNN method can be used for these since it detects small faces.</p>
<p>有任何建议，欢迎在下面评论。
Have any other suggestions? Please mention in the comments and we’ll update the post with them!</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<p><a href="https://github.com/opencv/opencv/blob/master/modules/dnn/misc/face_detector_accuracy.py" target="_blank" rel="noopener">FDDB Comparison code</a>
<a href="http://blog.dlib.net/2016/10/easily-create-high-quality-object.html" target="_blank" rel="noopener">Dlib Blog</a>
<a href="http://dlib.net/cnn_face_detector.py.html" target="_blank" rel="noopener">dlib mmod python example</a>
<a href="http://dlib.net/dnn_mmod_face_detection_ex.cpp.html" target="_blank" rel="noopener">dlib mmod cpp example</a>
<a href="https://github.com/opencv/opencv/tree/master/samples/dnn/face_detector" target="_blank" rel="noopener">OpenCV DNN Face detector</a>
<a href="https://docs.opencv.org/3.4/d7/d8b/tutorial_py_face_detection.html" target="_blank" rel="noopener">Haar Based Face Detector</a></p>
<h2 id="TODOS"><a class="header-anchor" href="#TODOS">¶</a>TODOS</h2>
<p>文章作者是 <a href="https://www.learnopencv.com/author/vikas/" target="_blank" rel="noopener">VIKAS GUPTA</a></p>
<p>来，看看这个是站长大佬的图片，是不是很熟悉？膜拜一哈。</p>
<p><img src="https://secure.gravatar.com/avatar/708995cd13fb5756f6bc418aecb23b78?s=250&amp;d=mm&amp;r=g" alt="blog_author"></p>
<p>我订阅后文章后，作者发的邮件内容，并没有给文章页的代码。</p>
<ul>
<li><a href="https://www.learnopencv.com/wp-content/uploads/2015/05/Computer-Vision-Resources.pdf" target="_blank" rel="noopener">给的Computer-Vision-Resources.pdf</a></li>
<li><a href="https://github.com/spmallick/dlib" target="_blank" rel="noopener">作者的Dlib fork</a></li>
</ul>
<p><strong>重要资源</strong></p>
<ul>
<li>
<p>作者博客 <a href="https://www.learnopencv.com/" target="_blank" rel="noopener">link</a></p>
</li>
<li>
<p>作者的所有代码拿走不谢 <a href="https://github.com/spmallick/learnopencv" target="_blank" rel="noopener">link</a></p>
</li>
<li>
<p>[x] 翻译</p>
</li>
<li>
<p>[ ] 代码运行</p>
</li>
<li>
<p>[ ] 根据该作者的博客继续翻译，学习，向大佬致敬。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>转载</category>
        <category>cv</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>Face Detection</tag>
        <tag>Dlib</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」Linux内核数据包bridge上转发流程</title>
    <url>/public/2022/07/06/linux/linux_bridge_forward/</url>
    <content><![CDATA[<blockquote>
<p>原文地址 <a href="https://blog.csdn.net/hhhhhyyyyy8/article/details/102133863" target="_blank" rel="noopener">blog.csdn.net</a>
@hhhhhyyyyy8 @4.15.1</p>
</blockquote>
<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>linux 内核源代码变动怎么这么大，handle_bridge 函数居然没有了，本来接着准备以 3.9.1 分析的，但发现和后面的又变了，还是以 4.15.1 现在电脑上用的版本分析吧。</p>
<p><strong>linux kernel：4.15.1</strong></p>
<p>先看三张图片</p>
<p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76153027" target="_blank" rel="noopener">IMG skb桥转发蓝图</a>
<img src="/public/2022/07/06/linux/linux_bridge_forward/20191005153149853.jpg" alt></p>
<p><a href="https://blog.csdn.net/u012247418/article/details/90137663" target="_blank" rel="noopener">IMG linux TCP/IP L2层数据包接收流程</a>
<img src="/public/2022/07/06/linux/linux_bridge_forward/t_70.png" alt></p>
<p><a href="https://www.cnblogs.com/xuanxuanBOSS/p/11424290.html" target="_blank" rel="noopener">IMG 浅析ebtables的概念和一些基本应用</a>
<img src="/public/2022/07/06/linux/linux_bridge_forward/netfilter.png" alt></p>
<blockquote>
<p>tips: linux 内核版本不一样，流程函数会发生细微改变。</p>
</blockquote>
<a id="more"></a>
<h2 id="1-br-handle-frame"><a class="header-anchor" href="#1-br-handle-frame">¶</a>1. br_handle_frame()</h2>
<p>作用：</p>
<ol>
<li>
<p>对于需要转发的报文，调用 <code>NF_BR_PRE_ROUTING</code> 处钩子函数，结束后，进入 <code>br_handle_frame_finish()</code> 函数；</p>
</li>
<li>
<p>对于 STP 报文，调用 <code>NF_BR_LOCAL_IN</code> 处钩子函数，结束后，进入 <code>br_handle_local_finish()</code> 函数，在 <code>br_handle_local_finish()</code> 函数中会调用 <code>br_pass_frame_up()</code> 函数。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return NULL if skb is handled</span></span><br><span class="line"><span class="comment"> * note: already called with rcu_read_lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">rx_handler_result_t</span> <span class="title">br_handle_frame</span><span class="params">(struct sk_buff **pskb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> = *<span class="title">pskb</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line">	<span class="keyword">br_should_route_hook_t</span> *rhook;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*如果是环回地址，直接返回RX_HANDLER_PASS*/</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(skb-&gt;pkt_type == PACKET_LOOPBACK))</span><br><span class="line">		<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*判断源MAC地址是否是有效的地址，不是直接丢弃，源MAC地址不能是多播地址和全0地址*/</span></span><br><span class="line">	<span class="keyword">if</span> (!is_valid_ether_addr(eth_hdr(skb)-&gt;h_source))</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	<span class="comment">/*判断是否是共享数据包，若是则clone该数据包；若clone时分配内存出错，返回NULL*/</span></span><br><span class="line">	skb = skb_share_check(skb, GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*获取dev对应的网桥端口*/</span></span><br><span class="line">	p = br_port_get_rcu(skb-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; BR_VLAN_TUNNEL) &#123;</span><br><span class="line">		<span class="keyword">if</span> (br_handle_ingress_vlan_tunnel(skb, p,</span><br><span class="line">						  nbp_vlan_group_rcu(p)))</span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*特殊MAC地址处理*/</span></span><br><span class="line">	<span class="comment">//如果目的mac地址是本地链路地址link local reserved addr (01:80:c2:00:00:0X) STP报文</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(is_link_local_ether_addr(dest))) &#123;</span><br><span class="line">		u16 fwd_mask = p-&gt;br-&gt;group_fwd_mask_required;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * See IEEE 802.1D Table 7-10 Reserved addresses</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Assignment		 		Value</span></span><br><span class="line"><span class="comment">		 * Bridge Group Address		01-80-C2-00-00-00</span></span><br><span class="line"><span class="comment">		 * (MAC Control) 802.3		01-80-C2-00-00-01</span></span><br><span class="line"><span class="comment">		 * (Link Aggregation) 802.3	01-80-C2-00-00-02</span></span><br><span class="line"><span class="comment">		 * 802.1X PAE address		01-80-C2-00-00-03</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 802.1AB LLDP 		01-80-C2-00-00-0E</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Others reserved for future standardization</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		fwd_mask |= p-&gt;group_fwd_mask;</span><br><span class="line">		<span class="keyword">switch</span> (dest[<span class="number">5</span>]) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x00</span>:	<span class="comment">/* Bridge Group Address */</span></span><br><span class="line">			<span class="comment">/* If STP is turned off,</span></span><br><span class="line"><span class="comment">			   then must forward to keep loop detection */</span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;br-&gt;stp_enabled == BR_NO_STP ||</span><br><span class="line">			    fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line">				<span class="keyword">goto</span> forward;</span><br><span class="line">			*pskb = skb;</span><br><span class="line">			__br_handle_local_finish(skb);</span><br><span class="line">			<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x01</span>:	<span class="comment">/* IEEE MAC (Pause) */</span></span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x0E</span>:	<span class="comment">/* 802.1AB LLDP */</span></span><br><span class="line">			fwd_mask |= p-&gt;br-&gt;group_fwd_mask;</span><br><span class="line">			<span class="keyword">if</span> (fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line">				<span class="keyword">goto</span> forward;</span><br><span class="line">			*pskb = skb;</span><br><span class="line">			__br_handle_local_finish(skb);</span><br><span class="line">			<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">/* Allow selective forwarding for most other protocols */</span></span><br><span class="line">			fwd_mask |= p-&gt;br-&gt;group_fwd_mask;</span><br><span class="line">			<span class="keyword">if</span> (fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line">				<span class="keyword">goto</span> forward;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/* Deliver packet to local host only */</span></span><br><span class="line">		<span class="comment">/*调用NF_BR_LOCAL_IN处钩子函数，结束后，进入br_handle_local_finish函数*/</span></span><br><span class="line">		NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, dev_net(skb-&gt;dev),</span><br><span class="line">			<span class="literal">NULL</span>, skb, skb-&gt;dev, <span class="literal">NULL</span>, br_handle_local_finish);</span><br><span class="line">		<span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">forward:</span><br><span class="line">	<span class="keyword">switch</span> (p-&gt;state) &#123;</span><br><span class="line">	<span class="comment">//网桥端口处于转发状态</span></span><br><span class="line">	<span class="keyword">case</span> BR_STATE_FORWARDING:</span><br><span class="line">		rhook = rcu_dereference(br_should_route_hook);</span><br><span class="line">		<span class="keyword">if</span> (rhook) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((*rhook)(skb)) &#123;</span><br><span class="line">				*pskb = skb;</span><br><span class="line">				<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line">			&#125;</span><br><span class="line">			dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* fall through */</span></span><br><span class="line">	<span class="comment">/*网桥端口处于学习状态，处于转发状态也会执行下面的代码，因为上面的case没有break。*/</span></span><br><span class="line">	<span class="keyword">case</span> BR_STATE_LEARNING:</span><br><span class="line">	<span class="comment">/*数据包目的MAC为网桥的Mac，发往本地的数据包*/</span></span><br><span class="line">		<span class="keyword">if</span> (ether_addr_equal(p-&gt;br-&gt;dev-&gt;dev_addr, dest))</span><br><span class="line">			skb-&gt;pkt_type = PACKET_HOST;</span><br><span class="line">		<span class="comment">/*调用NF_BR_PRE_ROUTING处钩子函数，结束后进入br_handle_frame_finish函数*/</span></span><br><span class="line">		NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,</span><br><span class="line">			dev_net(skb-&gt;dev), <span class="literal">NULL</span>, skb, skb-&gt;dev, <span class="literal">NULL</span>,</span><br><span class="line">			br_handle_frame_finish);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">drop:</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关函数</p>
<h3 id="rx-handler-result-t-枚举类型"><a class="header-anchor" href="#rx-handler-result-t-枚举类型">¶</a><code>rx_handler_result_t</code> 枚举类型</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> rx_handler_result &#123;</span><br><span class="line">	RX_HANDLER_CONSUMED,</span><br><span class="line">	RX_HANDLER_ANOTHER,</span><br><span class="line">	RX_HANDLER_EXACT,</span><br><span class="line">	RX_HANDLER_PASS,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> rx_handler_result <span class="keyword">rx_handler_result_t</span>;</span><br></pre></td></tr></table></figure>
<h3 id="is-valid-ether-addr"><a class="header-anchor" href="#is-valid-ether-addr">¶</a><code>is_valid_ether_addr()</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * is_valid_ether_addr - Determine if the given Ethernet address is valid</span></span><br><span class="line"><span class="comment"> * @addr: Pointer to a six-byte array containing the Ethernet address</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not</span></span><br><span class="line"><span class="comment"> * a multicast address, and is not FF:FF:FF:FF:FF:FF.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return true if the address is valid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Please note: addr must be aligned to u16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_valid_ether_addr</span><span class="params">(<span class="keyword">const</span> u8 *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to</span></span><br><span class="line"><span class="comment">	 * explicitly check for it here. */</span></span><br><span class="line">	<span class="keyword">return</span> !is_multicast_ether_addr(addr) &amp;&amp; !is_zero_ether_addr(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="br-handle-local-finish"><a class="header-anchor" href="#br-handle-local-finish">¶</a><code>br_handle_local_finish()</code></h3>
<p><code>br_handle_local_finish()</code> 函数中调用 <code>br_pass_fame_up()</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/* note: already called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">br_handle_local_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span> = <span class="title">br_port_get_rcu</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line"> </span><br><span class="line">	__br_handle_local_finish(skb);</span><br><span class="line"> </span><br><span class="line">	BR_INPUT_SKB_CB(skb)-&gt;brdev = p-&gt;br-&gt;dev;</span><br><span class="line">	br_pass_frame_up(skb);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-br-handle-frame-finish"><a class="header-anchor" href="#2-br-handle-frame-finish">¶</a>2. br_handle_frame_finish()</h2>
<p>作用：</p>
<p>网桥设备是否处于混杂模式，如果是，则会发一份到本地进行处理</p>
<p>如果是广播包，则会进行广播洪泛，并会发一份到本地处理</p>
<p>如果是组播包，则根据组播表进行组播转发，并发一份数数包到本地处理</p>
<p>如果是单播包，发往本地的单播包则送到本地处理，在 fdb 表中可以找到转发表项的单播包则进行转发，未知单播包在广播域内进行洪泛</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="comment">/* note: already called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_handle_frame_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span> = <span class="title">br_port_get_rcu</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line">	<span class="keyword">enum</span> br_pkt_type pkt_type = BR_PKT_UNICAST;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_fdb_entry</span> *<span class="title">dst</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_mdb_entry</span> *<span class="title">mdst</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> local_rcv, mcast_hit = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *dest;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span>;</span></span><br><span class="line">	u16 vid = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*如果网桥端口不存在或者网桥端口状态为BR_STATE_DISABLED，则丢弃*/</span></span><br><span class="line">	<span class="keyword">if</span> (!p || p-&gt;state == BR_STATE_DISABLED)</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	<span class="comment">/*判断是否允许进入桥内，如果没有开启VLAN则所有数据包都可以进入，</span></span><br><span class="line"><span class="comment">	如果开启了VLAN,则根据VLAN相应的规则，从桥上进行数据包转发。*/</span></span><br><span class="line">	<span class="keyword">if</span> (!br_allowed_ingress(p-&gt;br, nbp_vlan_group_rcu(p), skb, &amp;vid))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line">	nbp_switchdev_frame_mark(p, skb);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* insert into forwarding database after filtering to avoid spoofing */</span></span><br><span class="line">	br = p-&gt;br;</span><br><span class="line">	<span class="comment">/*如果网桥端口标志有BR_LEARNING,则更新fdb表。</span></span><br><span class="line"><span class="comment">    一般新建网桥端口p-&gt;flags=BR_LEARNING| BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD*/</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; BR_LEARNING)</span><br><span class="line">		br_fdb_update(br, p, eth_hdr(skb)-&gt;h_source, vid, <span class="literal">false</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发往本地数据包标记，!!的作用是转换为bool值</span></span><br><span class="line">	local_rcv = !!(br-&gt;dev-&gt;flags &amp; IFF_PROMISC);</span><br><span class="line">	dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line">	<span class="comment">/*目的地址为多播地址*/</span></span><br><span class="line">	<span class="keyword">if</span> (is_multicast_ether_addr(dest)) &#123;</span><br><span class="line">		<span class="comment">/* by definition the broadcast is also a multicast address */</span></span><br><span class="line">		<span class="comment">/*如果目的地址是广播地址，将数据包也发往本地一份*/</span></span><br><span class="line">		<span class="keyword">if</span> (is_broadcast_ether_addr(dest)) &#123;</span><br><span class="line">			pkt_type = BR_PKT_BROADCAST;</span><br><span class="line">			local_rcv = <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pkt_type = BR_PKT_MULTICAST;</span><br><span class="line">			<span class="comment">//igmp snooping留给网桥子系统的外部接口函数，</span></span><br><span class="line">			<span class="comment">//当网桥接收了igmp数据包后就会调用该函数进行后续处理</span></span><br><span class="line">			<span class="keyword">if</span> (br_multicast_rcv(br, p, skb, vid))</span><br><span class="line">				<span class="keyword">goto</span> drop;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果网桥端口状态此时还是BR_STATE_LEARNING,则丢弃。</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;state == BR_STATE_LEARNING)</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	<span class="comment">//将网桥所属的net_device放入skb的私有数据中（struct br_input_skb_cb）</span></span><br><span class="line">	BR_INPUT_SKB_CB(skb)-&gt;brdev = br-&gt;dev;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_INET) &amp;&amp;</span><br><span class="line">	    (skb-&gt;protocol == htons(ETH_P_ARP) ||</span><br><span class="line">	     skb-&gt;protocol == htons(ETH_P_RARP))) &#123;</span><br><span class="line">		br_do_proxy_suppress_arp(skb, br, vid, p);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ENABLED(CONFIG_IPV6) &amp;&amp;</span><br><span class="line">		   skb-&gt;protocol == htons(ETH_P_IPV6) &amp;&amp;</span><br><span class="line">		   br-&gt;neigh_suppress_enabled &amp;&amp;</span><br><span class="line">		   pskb_may_pull(skb, <span class="keyword">sizeof</span>(struct ipv6hdr) +</span><br><span class="line">				 <span class="keyword">sizeof</span>(struct nd_msg)) &amp;&amp;</span><br><span class="line">		   ipv6_hdr(skb)-&gt;nexthdr == IPPROTO_ICMPV6) &#123;</span><br><span class="line">			struct nd_msg *msg, _msg;</span><br><span class="line"> </span><br><span class="line">			msg = br_is_nd_neigh_msg(skb, &amp;_msg);</span><br><span class="line">			<span class="keyword">if</span> (msg)</span><br><span class="line">				br_do_suppress_nd(skb, br, vid, p, msg);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">switch</span> (pkt_type) &#123;</span><br><span class="line">	<span class="comment">//组播包</span></span><br><span class="line">	<span class="keyword">case</span> BR_PKT_MULTICAST:</span><br><span class="line">		<span class="comment">//获取组播转发项，设置local_rcv为true，组播包也要发往本地一份。</span></span><br><span class="line">		mdst = br_mdb_get(br, skb, vid);</span><br><span class="line">		<span class="keyword">if</span> ((mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) &amp;&amp;</span><br><span class="line">		    br_multicast_querier_exists(br, eth_hdr(skb))) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((mdst &amp;&amp; mdst-&gt;host_joined) ||</span><br><span class="line">			    br_multicast_is_router(br)) &#123;</span><br><span class="line">				local_rcv = <span class="literal">true</span>;</span><br><span class="line">				br-&gt;dev-&gt;stats.multicast++;</span><br><span class="line">			&#125;</span><br><span class="line">			mcast_hit = <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			local_rcv = <span class="literal">true</span>;</span><br><span class="line">			br-&gt;dev-&gt;stats.multicast++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">//单播包</span></span><br><span class="line">	<span class="keyword">case</span> BR_PKT_UNICAST:</span><br><span class="line">		<span class="comment">//根据目的MAC地址查找fdb表，看是否有对应的表项</span></span><br><span class="line">		dst = br_fdb_find_rcu(br, dest, vid);</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果找到目的MAC对应的表项</span></span><br><span class="line">	<span class="keyword">if</span> (dst) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> now = jiffies;</span><br><span class="line">		<span class="comment">//送入上层处理</span></span><br><span class="line">		<span class="keyword">if</span> (dst-&gt;is_local)</span><br><span class="line">			<span class="keyword">return</span> br_pass_frame_up(skb);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (now != dst-&gt;used)</span><br><span class="line">			dst-&gt;used = now;</span><br><span class="line">		<span class="comment">//根据fdb转发表项进行转发，若这里local_rcv 为1,（即端口处于混杂模式IFF_PROMISC），则会克隆一份再转发</span></span><br><span class="line">		<span class="comment">//传入的第一个参数dst-&gt;dst 即为要转发的目的端口</span></span><br><span class="line">		br_forward(dst-&gt;dst, skb, local_rcv, <span class="literal">false</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//进行广播或者组播洪泛</span></span><br><span class="line">		<span class="keyword">if</span> (!mcast_hit)</span><br><span class="line">			br_flood(br, skb, pkt_type, local_rcv, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			br_multicast_flood(mdst, skb, local_rcv, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//local_rcv标记为1，送入上层处理。</span></span><br><span class="line">	<span class="keyword">if</span> (local_rcv)</span><br><span class="line">		<span class="keyword">return</span> br_pass_frame_up(skb);</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">drop:</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-br-pass-frame-up"><a class="header-anchor" href="#3-br-pass-frame-up">¶</a>3.br_pass_frame_up</h2>
<p>数据包的目的 MAC 是本地的单播报文，广播，组播和网桥处于混杂模式时，报文都会通过 br_pass_frame_up 函数交由上层处理。</p>
<p>作用：</p>
<p>调用 NF_BR_LOCAL_IN 处钩子函数，最后调用 br_netif_receive_skb 函数，绕一圈后，交友上层处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">br_pass_frame_up</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">indev</span>, *<span class="title">brdev</span> = <span class="title">BR_INPUT_SKB_CB</span>(<span class="title">skb</span>)-&gt;<span class="title">brdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span> = <span class="title">netdev_priv</span>(<span class="title">brdev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_vlan_group</span> *<span class="title">vg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pcpu_sw_netstats</span> *<span class="title">brstats</span> = <span class="title">this_cpu_ptr</span>(<span class="title">br</span>-&gt;<span class="title">stats</span>);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//统计网桥设备上的收包流量数据</span></span><br><span class="line">	u64_stats_update_begin(&amp;brstats-&gt;syncp);</span><br><span class="line">	brstats-&gt;rx_packets++;</span><br><span class="line">	brstats-&gt;rx_bytes += skb-&gt;len;</span><br><span class="line">	u64_stats_update_end(&amp;brstats-&gt;syncp);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取网桥设备上的VLAN组</span></span><br><span class="line">	vg = br_vlan_group_rcu(br);</span><br><span class="line">	<span class="comment">/* Bridge is just like any other port.  Make sure the</span></span><br><span class="line"><span class="comment">	 * packet is allowed except in promisc modue when someone</span></span><br><span class="line"><span class="comment">	 * may be running packet capture.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(brdev-&gt;flags &amp; IFF_PROMISC) &amp;&amp;</span><br><span class="line">	    !br_allowed_egress(vg, skb)) &#123;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//记录数据包的收包网络设备</span></span><br><span class="line">	indev = skb-&gt;dev;</span><br><span class="line">	<span class="comment">//将数据包的收包设备改为网桥设备</span></span><br><span class="line">	<span class="comment">//当再次进入__netif_receive_skb_core时就不会再次进入桥处理了，因为网桥上没有注册rx_handler 函数</span></span><br><span class="line">	skb-&gt;dev = brdev;</span><br><span class="line">	<span class="comment">//配置数据包vlan相关信息</span></span><br><span class="line">	skb = br_handle_vlan(br, <span class="literal">NULL</span>, vg, skb);</span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">	<span class="comment">/* update the multicast stats if the packet is IGMP/MLD */</span></span><br><span class="line">	<span class="comment">//如果数据包是组播，更新组播数据包的统计信息</span></span><br><span class="line">	br_multicast_count(br, <span class="literal">NULL</span>, skb, br_multicast_igmp_type(skb),</span><br><span class="line">			   BR_MCAST_DIR_TX);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用NF_BR_LOCAL_IN处钩子函数，最后调用br_netif_receive_skb函数。</span></span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,</span><br><span class="line">		       dev_net(indev), <span class="literal">NULL</span>, skb, indev, <span class="literal">NULL</span>,</span><br><span class="line">		       br_netif_receive_skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次进入 netif_receive_skb，由于 skb-dev 被设置成了 bridge，而 bridge 设备的 rx_handler 函数是没有被设置的，所以就不会再次进入 bridge 逻辑，而直接进入了主机上层协议栈。</p>
<p>相关函数</p>
<h3 id="br-netif-receive-skb"><a class="header-anchor" href="#br-netif-receive-skb">¶</a><code>br_netif_receive_skb()</code></h3>
<p>可以看到在 br_netif_receive_skb() 函数中调用了 netif_receive_skb() 函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">static int</span><br><span class="line">br_netif_receive_skb(struct net *net, struct sock *sk, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">	br_drop_fake_rtable(skb);</span><br><span class="line">	return netif_receive_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-br-forward"><a class="header-anchor" href="#4-br-forward">¶</a>4. br_forward()</h2>
<p>不是发往本地的数据包，但在 fdb 表中能找到对应的表项，则进行转发 br_forward()，若在 fdb 表中找不到对应表项就进行洪泛 br_blood().</p>
<p>作用：</p>
<p>主要是调用__br_forward() 转发报文</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * br_forward - forward a packet to a specific port</span></span><br><span class="line"><span class="comment"> * @to: destination port</span></span><br><span class="line"><span class="comment"> * @skb: packet being forwarded</span></span><br><span class="line"><span class="comment"> * @local_rcv: packet will be received locally after forwarding</span></span><br><span class="line"><span class="comment"> * @local_orig: packet is locally originated</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Should be called with rcu_read_lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_forward</span><span class="params">(<span class="keyword">const</span> struct net_bridge_port *to,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct sk_buff *skb, <span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//should_deliver测试是否应该将该包转发出去</span></span><br><span class="line">	<span class="keyword">if</span> (to &amp;&amp; should_deliver(to, skb)) &#123;</span><br><span class="line">		<span class="comment">//如果local_rcv为1，表明端口为混杂模式，先clone一份数据包再进行转发</span></span><br><span class="line">		<span class="keyword">if</span> (local_rcv)</span><br><span class="line">			deliver_clone(to, skb, local_orig);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			__br_forward(to, skb, local_orig);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (!local_rcv)</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-br-forward"><a class="header-anchor" href="#5-br-forward">¶</a>5. __br_forward()</h2>
<p>作用:</p>
<p>__br_forward() 函数根据数据包的来源（local_orig）分别进入不同的钩子点，如果数据包是从本地发出的，则进入 NF_BR_LOCAL_OUT，如果不是本地发出的，则进入 NF_BR_FORWARD 钩子，最后都进入 br_forward_finish() 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __br_forward(<span class="keyword">const</span> struct net_bridge_port *to,</span><br><span class="line">			 struct sk_buff *skb, <span class="keyword">bool</span> local_orig)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_vlan_group</span> *<span class="title">vg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">indev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line">	<span class="keyword">int</span> br_hook;</span><br><span class="line">	<span class="comment">//获取vlan组，这个组中有许多的vlanid，br_handle_vlan函数就是要在这个组中查找自己的vid</span></span><br><span class="line">	vg = nbp_vlan_group_rcu(to);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加vlan的相关配置</span></span><br><span class="line">	skb = br_handle_vlan(to-&gt;br, to, vg, skb);</span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//记录数据包的原始收包网络设备</span></span><br><span class="line">	indev = skb-&gt;dev;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将skb的dev修改为出口网络设备</span></span><br><span class="line">	skb-&gt;dev = to-&gt;dev;</span><br><span class="line">	<span class="comment">/*如果local_orig标志位(判断是否从本地发出的数据包)为false，就进入NF_BR_FORWARD钩子</span></span><br><span class="line"><span class="comment">	若为true，就进入NF_BR_LOCAL_OUT钩子点*/</span></span><br><span class="line">	<span class="keyword">if</span> (!local_orig) &#123;</span><br><span class="line">		<span class="keyword">if</span> (skb_warn_if_lro(skb)) &#123;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//不是本地发出的数据包，进入NF_BR_FORWARD</span></span><br><span class="line">		br_hook = NF_BR_FORWARD;</span><br><span class="line">		skb_forward_csum(skb);</span><br><span class="line">		net = dev_net(indev);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(netpoll_tx_running(to-&gt;br-&gt;dev))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!is_skb_forwardable(skb-&gt;dev, skb)) &#123;</span><br><span class="line">				kfree_skb(skb);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				skb_push(skb, ETH_HLEN);</span><br><span class="line">				br_netpoll_send_skb(to, skb);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//若是本地发出的数据包，进入NF_BR_LOCAL_OUT处理</span></span><br><span class="line">		br_hook = NF_BR_LOCAL_OUT;</span><br><span class="line">		net = dev_net(skb-&gt;dev);</span><br><span class="line">		indev = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//进入钩子点，最后执行br_forward_finish函数。</span></span><br><span class="line">	NF_HOOK(NFPROTO_BRIDGE, br_hook,</span><br><span class="line">		net, <span class="literal">NULL</span>, skb, indev, skb-&gt;dev,</span><br><span class="line">		br_forward_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-br-forward-finish"><a class="header-anchor" href="#6-br-forward-finish">¶</a>6. br_forward_finish()</h2>
<p><code>br_forward_finish()</code> 函数比较简单，调用 <code>NF_BR_POST_ROUTING</code> 处的钩子函数，最后进入 <code>br_dev_queue_push_xmit</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_forward_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING,</span><br><span class="line">		       net, sk, skb, <span class="literal">NULL</span>, skb-&gt;dev,</span><br><span class="line">		       br_dev_queue_push_xmit);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-br-dev-queue-push-xmit"><a class="header-anchor" href="#7-br-dev-queue-push-xmit">¶</a>7. br_dev_queue_push_xmit</h2>
<p>在 <code>br_dev_queue_push_xmit()</code> 中，会先 <code>skb_push(skb,ETH,HLEN);</code> 将 data 指向二层头部，然后调用 <code>dev_queue_xmit()</code> 发送报文。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_dev_queue_push_xmit</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_skb_forwardable(skb-&gt;dev, skb))</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//注意这句操作</span></span><br><span class="line">	skb_push(skb, ETH_HLEN);</span><br><span class="line">	br_drop_fake_rtable(skb);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_PARTIAL &amp;&amp;</span><br><span class="line">	    (skb-&gt;protocol == htons(ETH_P_8021Q) ||</span><br><span class="line">	     skb-&gt;protocol == htons(ETH_P_8021AD))) &#123;</span><br><span class="line">		<span class="keyword">int</span> depth;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (!__vlan_get_protocol(skb, skb-&gt;protocol, &amp;depth))</span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">		skb_set_network_header(skb, depth);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	dev_queue_xmit(skb);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">drop:</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-br-flood"><a class="header-anchor" href="#8-br-flood">¶</a>8. br_flood</h2>
<p><code>br_flood()</code> 也是调用 <code>__br_forward()</code> 函数转发报文。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/* called under rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_flood</span><span class="params">(struct net_bridge *br, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">	      <span class="keyword">enum</span> br_pkt_type pkt_type, <span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 igmp_type = br_multicast_igmp_type(skb);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span>;</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*遍历网桥设备的port_list，取出所有的网桥端口*/</span></span><br><span class="line">	list_for_each_entry_rcu(p, &amp;br-&gt;port_list, <span class="built_in">list</span>) </span><br><span class="line">        &#123;</span><br><span class="line">		<span class="comment">/* Do not flood unicast traffic to ports that turn it off, nor</span></span><br><span class="line"><span class="comment">		 * other traffic if flood off, except for traffic we originate</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">switch</span> (pkt_type) </span><br><span class="line">                &#123;</span><br><span class="line">		<span class="keyword">case</span> BR_PKT_UNICAST:</span><br><span class="line">			<span class="keyword">if</span> (!(p-&gt;flags &amp; BR_FLOOD))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> BR_PKT_MULTICAST:</span><br><span class="line">			<span class="keyword">if</span> (!(p-&gt;flags &amp; BR_MCAST_FLOOD) &amp;&amp; skb-&gt;dev != br-&gt;dev)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> BR_PKT_BROADCAST:</span><br><span class="line">			<span class="keyword">if</span> (!(p-&gt;flags &amp; BR_BCAST_FLOOD) &amp;&amp; skb-&gt;dev != br-&gt;dev)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/* Do not flood to ports that enable proxy ARP */</span></span><br><span class="line">                <span class="comment">/*代理arp*/</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;flags &amp; BR_PROXYARP)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> ((p-&gt;flags &amp; (BR_PROXYARP_WIFI | BR_NEIGH_SUPPRESS)) &amp;&amp;</span><br><span class="line">		    BR_INPUT_SKB_CB(skb)-&gt;proxyarp_replied)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">		prev = maybe_deliver(prev, p, skb, local_orig);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(prev))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		<span class="keyword">if</span> (prev == p)</span><br><span class="line">			br_multicast_count(p-&gt;br, p, skb, igmp_type,</span><br><span class="line">					   BR_MCAST_DIR_TX);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (!prev)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (local_rcv)</span><br><span class="line">		deliver_clone(prev, skb, local_orig);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__br_forward(prev, skb, local_orig);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (!local_rcv)</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-br-mulicast-flood"><a class="header-anchor" href="#9-br-mulicast-flood">¶</a>9. br_mulicast_flood()</h2>
<hr>
<p>以后再分析，肚子饿了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/* called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_multicast_flood</span><span class="params">(struct net_bridge_mdb_entry *mdst,</span></span></span><br><span class="line"><span class="function"><span class="params">			struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">BR_INPUT_SKB_CB</span>(<span class="title">skb</span>)-&gt;<span class="title">brdev</span>;</span></span><br><span class="line">	u8 igmp_type = br_multicast_igmp_type(skb);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port_group</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">rp</span>;</span></span><br><span class="line"> </span><br><span class="line">	rp = rcu_dereference(hlist_first_rcu(&amp;br-&gt;router_list));</span><br><span class="line">	p = mdst ? rcu_dereference(mdst-&gt;ports) : <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (p || rp) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">port</span>, *<span class="title">lport</span>, *<span class="title">rport</span>;</span></span><br><span class="line"> </span><br><span class="line">		lport = p ? p-&gt;port : <span class="literal">NULL</span>;</span><br><span class="line">		rport = rp ? hlist_entry(rp, struct net_bridge_port, rlist) :</span><br><span class="line">			     <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)lport &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)rport) &#123;</span><br><span class="line">			port = lport;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">if</span> (port-&gt;flags &amp; BR_MULTICAST_TO_UNICAST) &#123;</span><br><span class="line">				maybe_deliver_addr(lport, skb, p-&gt;eth_addr,</span><br><span class="line">						   local_orig);</span><br><span class="line">				<span class="keyword">goto</span> delivered;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			port = rport;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		prev = maybe_deliver(prev, port, skb, local_orig);</span><br><span class="line">delivered:</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(prev))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		<span class="keyword">if</span> (prev == port)</span><br><span class="line">			br_multicast_count(port-&gt;br, port, skb, igmp_type,</span><br><span class="line">					   BR_MCAST_DIR_TX);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)lport &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)port)</span><br><span class="line">			p = rcu_dereference(p-&gt;next);</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)rport &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)port)</span><br><span class="line">			rp = rcu_dereference(hlist_next_rcu(rp));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (!prev)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (local_rcv)</span><br><span class="line">		deliver_clone(prev, skb, local_orig);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__br_forward(prev, skb, local_orig);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (!local_rcv)</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<p><a href="http://ebtables.netfilter.org/br_fw_ia/br_fw_ia.html" target="_blank" rel="noopener">ebtables/iptables interaction on a Linux-based bridge</a>
@ebtables @2.4.x kernel</p>
<p><a href="https://blog.csdn.net/sxd2001/article/details/125031113" target="_blank" rel="noopener">Iptables DNAT实现broadcast与unicast之间相互映射</a>
@sxd2001 分析ebtables 的redirect 和 iptables 的redirect</p>
<p><a href="https://blog.csdn.net/Sophisticated_/article/details/87923362" target="_blank" rel="noopener">Linux-4.20.8内核桥收包源码解析（七）--本地（br_pass_frame_up）or 转发（br_forward）</a>
@lw_yang @Linux-4.20.8</p>
<p><a href="http://blog.chinaunix.net/uid-28541347-id-5750406.html" target="_blank" rel="noopener">Linux 3.10 kernel bridge转发逻辑</a>
@lvyilong316 @Linux 3.10 kernel</p>
<p><a href="https://blog.csdn.net/linyt/article/details/5191512" target="_blank" rel="noopener">kernel 网桥代码分析</a>
@海枫 @ 2.6.24.4</p>
<p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76674232" target="_blank" rel="noopener">桥数据包处理函数——br_handle_frame_finish（七）</a>
@不留你的名字</p>
<p><a href="https://www.cnblogs.com/super-king/p/bridge_implement.html" target="_blank" rel="noopener">Bridge实现</a>
@SuperKing @linux 2.6.18</p>
<p><a href="https://www.cnblogs.com/ck1020/p/5894235.html" target="_blank" rel="noopener">LInux下桥接模式详解三</a>
@jack.chen @linux 3.10.1</p>
<p><a href="https://blog.csdn.net/one_clouder/article/details/52877737" target="_blank" rel="noopener">协议栈报文接收之netif_receive_skb函数分析</a>
@one_clouder @Linux4.1.12</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>bridge</tag>
        <tag>netfilter</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样成为一名优秀的算法工程师</title>
    <url>/public/2018/10/01/AI/how_algorithm_engineer/</url>
    <content><![CDATA[<blockquote>
<p>转载 原创： AI学习与实践平台
TODO: 看完里面的文章，对每篇文章做个总结，实验+文章。</p>
</blockquote>
<h2 id="1-导言"><a class="header-anchor" href="#1-导言">¶</a>1. 导言</h2>
<p>怎样成为一名优秀的算法工程师？这是很多从事人工智能学术研究和产品研发的同学都关心的一个问题。面对市场对人才的大量需求与供给的严重不足，以及高薪水的诱惑，越来越多的人开始学习这个方向的技术，或者打算向人工智能转型。市面上各种鱼龙混杂的培训班以及误导人的文章会把很多初学者带入歧途，浮躁的跟风将会让你最后收获甚微，根本达不到企业的用人要求。为了更好的帮助大家学习和成长，少走弯路，在今天的文章里，<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485551&amp;idx=2&amp;sn=a6689528f10aedab3fce91857eec877b&amp;chksm=fdb695f8cac11cee025ad6d8d77ed90f7169142d6b20b2f5a6945b58edd97c27225f4a2eba91&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SIGAI</a> 的作者以自己的亲身经历和思考，为大家写下对这一问题的理解与答案。</p>
<p>首先来看一个高度相关的问题：一个优秀的算法工程师必须具备哪些素质？我们给出的答案是这样的：</p>
<ul>
<li>数学知识</li>
<li>编程能力</li>
<li>机器学习与深度学习的知识</li>
<li>应用方向的知识</li>
<li>对自己所做的问题的思考和经验</li>
</ul>
<p>除去教育背景，逻辑思维，学习能力，沟通能力等其他方面的因素，大多数公司在考察算法工程师的技术水平时都会考虑上面这几个因素。接下来我们将按照这几个方面进行展开，详细的说明如何学习这些方面的知识以及积累经验。</p>
<a id="more"></a>
<h2 id="2-数学知识"><a class="header-anchor" href="#2-数学知识">¶</a>2. 数学知识</h2>
<p>与其他工作方向如app、服务器开发相比，以及与计算机科学的其他方向如网络，数据库，分布式计算等相比，人工智能尤其是机器学习属于数学知识密集的方向。在各种书籍，论文，算法中都充斥着大量的数学公式，这让很多打算入门的人或者开始学习的人感到明显的压力。首先我们考虑一个最核心的问题：机器学习和深度学习究竟需要哪些数学知识？在<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485551&amp;idx=2&amp;sn=a6689528f10aedab3fce91857eec877b&amp;chksm=fdb695f8cac11cee025ad6d8d77ed90f7169142d6b20b2f5a6945b58edd97c27225f4a2eba91&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SIGAI</a>之前的公众号文章“<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483713&amp;idx=1&amp;sn=1e7c81381d16806ac73e15691fe17aec&amp;chksm=fdb69cd6cac115c05f1f90b0407e3f8ae9be8719e454f908074ac0d079885b5c134e2d60fd64&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">学好机器学习需要哪些数学知识</a>”里，我们已经给出了答案。先看下面这张表：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image003.gif" alt="EB5E93E91C3643F991C93D61F363373E.jpeg"></p>
<p>更多算法工程师的必读文章，请关注SIGAICN公众号</p>
<p>上面的表给出了各种典型的机器学习算法所用到的数学知识点。我们之前已经总结过，理解绝大多数算法和理论，有微积分/高等数学，线性代数，概率论，最优化方法的知识就够了。除流形学习需要简单的微分几何概念之外，深层次的数学知识如实变函数，泛函分析等主要用在一些基础理论结果的证明上，即使不能看懂证明过程，也不影响我们使用具体的机器学习算法。概率图模型、流形学习中基于图的模型会用到图论的一些基本知识，如果学习过离散数学或者数据结构，这些概念很容易理解。除此之外，某些算法会用到离散数学中的树的概念，但很容易理解。</p>
<h3 id="2-1-高等数学"><a class="header-anchor" href="#2-1-高等数学">¶</a>2.1 高等数学</h3>
<p>如果你已经学过这些大学数学课，只要把所需的知识点复习一遍就够了。对于微积分，通俗易懂而又被广为采用的是同济版的高等数学：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image005.gif" alt="88F2EB8BDFE1448EBD2DF61848E355FD.jpeg"></p>
<p>在机器学习中主要用到了微分部分，积分用的非常少。具体的，用到了下面的概念：</p>
<ul>
<li>导数和偏导数的定义与计算方法，与函数性质的关系</li>
<li>梯度向量的定义</li>
<li>极值定理，可导函数在极值点处导数或梯度必须为0</li>
<li>雅克比矩阵，这是向量到向量映射函数的偏导数构成的矩阵，在求导推导中会用到</li>
<li>Hessian矩阵，这是2阶导数对多元函数的推广，与函数的极值有密切的联系</li>
<li>凸函数的定义与判断方法</li>
<li>泰勒展开公式</li>
<li>拉格朗日乘数法，用于求解带等式约束的极值问题</li>
</ul>
<p>其中最核心的是多元函数的泰勒展开公式，根据它我们可以推导出梯度下降法，牛顿法，拟牛顿法等一系列最优化方法。</p>
<p>如果你想要深入的学习微积分，可以阅读数学系的教程，称为数学分析：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image007.gif" alt="DEB5F0D2FC584E0B96B263FE1D559AFF.jpeg"></p>
<p>与工科的高等数学偏重计算不同，它里面有大量的理论证明，对于锻炼数学思维非常有帮助。北大张筑生先生所著的数学分析可谓是国内这方面教材的精品。</p>
<h3 id="2-2-线性代数"><a class="header-anchor" href="#2-2-线性代数">¶</a>2.2 线性代数</h3>
<p>下面来看线性代数，同样是同济版的教材：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image009.gif" alt="48D5E515A7144CE6A9CB78162F6ECAAF.jpeg"></p>
<p>如果想更全面系统的学习线性代数，可以看这本书：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image011.gif" alt="BF71AB68DB2B4D71AC8D2B3263C197E5.jpeg"></p>
<p>相比之下，线性代数用的更多。具体用到的知识点有：</p>
<ul>
<li>向量和它的各种运算，包括加法，减法，数乘，转置，内积</li>
<li>向量和矩阵的范数，L1范数和L2范数</li>
<li>矩阵和它的各种运算，包括加法，减法，乘法，数乘</li>
<li>逆矩阵的定义与性质</li>
<li>行列式的定义与计算方法</li>
<li>二次型的定义</li>
<li>矩阵的正定性</li>
<li>特征值与特征向量</li>
<li>奇异值分解</li>
<li>线性方程组的数值解</li>
</ul>
<p>机器学习算法处理的数据一般都是向量、矩阵或者张量。经典的机器学习算法输入的数据都是特征向量，深度学习算法在处理图像时输入的2维的矩阵或者3维的张量。掌握这些概念是你理解机器学习和深度学习算法的基础。</p>
<h3 id="2-3-概率论"><a class="header-anchor" href="#2-3-概率论">¶</a>2.3 概率论</h3>
<p>概率论国内理工科专业使用最多的是浙大版的教材：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image013.gif" alt="91E918CF7ED84C7488BDDFFC7594E0D4.jpeg"></p>
<p>如果把机器学习所处理的样本数据看作随机变量/向量，就可以用概率论的方法对问题进行建模，这代表了机器学习中很大一类方法。在机器学习里用到的概率论知识点有:</p>
<ul>
<li>随机事件的概念，概率的定义与计算方法</li>
<li>随机变量与概率分布，尤其是连续型随机变量的概率密度函数和分布函数</li>
<li>条件概率与贝叶斯公式</li>
<li>常用的概率分布，包括正态分布，伯努利二项分布，均匀分布</li>
<li>随机变量的均值与方差，协方差</li>
<li>随机变量的独立性</li>
<li>最大似然估计</li>
</ul>
<p>这些知识不超出普通理工科概率论教材的范围。</p>
<h3 id="最优化"><a class="header-anchor" href="#最优化">¶</a>最优化</h3>
<p>最后来说最优化，几乎所有机器学习算法归根到底都是在求解最优化问题。求解最优化问题的指导思想是在极值点出函数的导数/梯度必须为0。因此你必须理解梯度下降法，牛顿法这两种常用的算法，它们的迭代公式都可以从泰勒展开公式而得到。</p>
<p>凸优化是机器学习中经常会提及的一个概念，这是一类特殊的优化问题，它的优化变量的可行域是凸集，目标函数是凸函数。凸优化最好的性质是它的所有局部最优解就是全局最优解，因此求解时不会陷入局部最优解。如果一个问题被证明为是凸优化问题，基本上已经宣告此问题得到了解决。在机器学习中，线性回归、岭回归、支持向量机、logistic回归等很多算法求解的都是凸优化问题。</p>
<p>拉格朗日对偶为带等式和不等式约束条件的优化问题构造拉格朗日函数，将其变为原问题，这两个问题是等价的。通过这一步变换，将带约束条件的问题转换成不带约束条件的问题。通过变换原始优化变量和拉格朗日乘子的优化次序，进一步将原问题转换为对偶问题，如果满足某种条件，原问题和对偶问题是等价的。这种方法的意义在于可以将一个不易于求解的问题转换成更容易求解的问题。在支持向量机中有拉格朗日对偶的应用。</p>
<p>KKT条件是拉格朗日乘数法对带不等式约束问题的推广，它给出了带等式和不等式约束的优化问题在极值点处所必须满足的条件。在支持向量机中也有它的应用。</p>
<p>如果你没有学过最优化方法这门课也不用担心，这些方法根据微积分和线性代数的基础知识可以很容易推导出来。如果需要系统的学习这方面的知识，可以阅读《凸优化》，《非线性规划》两本经典教材。</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image015.gif" alt="B00246CBCFB446789B2F7F63F3292099.jpeg"></p>
<h2 id="3-编程能力"><a class="header-anchor" href="#3-编程能力">¶</a>3. 编程能力</h2>
<p>编程能力是学好机器学习和深度学习的又一大基础。对于计算机类专业的学生，由于本科已经学了c语言，c++，数据结构与算法，因此这方面一般不存在问题。对于非计算机专业的人来说，要真正学好机器学习和深度学习，这些知识是绕不开的。</p>
<h3 id="3-1-C"><a class="header-anchor" href="#3-1-C">¶</a>3.1 C++</h3>
<p>虽然现在大家热衷于学习python，但要作为一名真正的算法工程师，还是应该好好学习一下c++，至少，机器学习和深度学习的很多底层开源库都是用它写的；很多公司线上的产品，无论是运行在服务器端，还是嵌入式端，都是用c++写的。此外，如果你是应届生，在校园招聘时不少公司都会面试你c++的知识。</p>
<p>C++最经典的教材无疑是c++ primer：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image017.gif" alt="3E0DE0E336474B81A2F89F2190628186.jpeg"></p>
<p>对做算法的人来说，这本书其实不用全部看，把常用的点学完就够了。对于进阶，Effective c++是很好的选择，不少公司的面试题就直接出自这本书的知识点：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image019.gif" alt="DDCC32DD5E6D405588CB4B6F4A94BFE5.jpeg"></p>
<p>接下来说python，相比c++来说，学习的门槛要低很多，找一本通俗易懂的入门教程学习一遍即可。</p>
<h3 id="3-2-数据结构和算法"><a class="header-anchor" href="#3-2-数据结构和算法">¶</a>3.2 数据结构和算法</h3>
<p>数据结构和算法是编写很多程序的基础，对于机器学习和深度学习程序也不例外。很多算法的实现都依赖于数组，链表，数，排序，查找之类的数据结构和基础算法。如果有时间和精力，把算法导论啃一遍，你会有不一样的感受：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image021.gif" alt="E077608423D7473ABF1DBF75C482E060.jpeg"></p>
<p>对于应届生来说，学完它对于你通过大互联网和人工智能公司校园招聘的技术面试也非常有用。</p>
<p>上面说的只是编程语言的程序设计的理论知识，我们还要考虑实际动手能力。对于开发环境如gcc/g++，visual studio之类的工具，以及gdb之类的调试工具需要做到熟练使用。如果是在linux上开发，对linux的常用命令也要熟记于心。这方面的知识看各种具体的知识点和教程即可。另外，对于编程的一些常识，如进程，线程，虚拟内存，文件系统等，你最好也要进行了解。</p>
<h2 id="4-机器学习与深度学习的知识"><a class="header-anchor" href="#4-机器学习与深度学习的知识">¶</a>4. 机器学习与深度学习的知识</h2>
<p>在说完了数学和编程基础之后，下面我来看核心的内容，机器学习和深度学习知识。机器学习是现阶段解决很多人工智能问题的核心方法，尤其是深度学习，因此它们是算法工程师的核心知识。在这里有一个问题：是否需要先学机器学习，还是直接学深度学习？如果是一个专业的算法工程师，我的建议是先学机器学习。至少，你要知道机器学习中的基本概念， 过拟合，生成模型，ROC曲线等，上来就看深度学习，如没有背景知识你将不知所云。另外，神经网络只是机器学习中的一类方法，对于很多问题，其他机器学习算法如logistic回归，随机森林，GBDT，决策树等还在被大规模使用，因此你不要把自己局限在神经网络的小圈子里。</p>
<h3 id="4-1-ML和DP的教材"><a class="header-anchor" href="#4-1-ML和DP的教材">¶</a>4.1 ML和DP的教材</h3>
<p>首先来看机器学习，这方面的教材很多，周志华老师的机器学习，李航老师的统计学习方法是国内的经典。这里我们介绍国外的经典教材，首先是PRML：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image023.gif" alt="BE2D3D5817344DE0831B718D3F891899.jpeg"></p>
<p>PRML 下载地址 <a href="https://www.microsoft.com/en-us/research/publication/pattern-recognition-machine-learning/" target="_blank" rel="noopener">link</a></p>
<p>此书深厚，内容全面，涵盖了有监督学习，无监督学习的主要方法，理论推导和证明详细深入，是机器学习的经典。此外还有模式分类这本书，在这里不详细介绍。</p>
<p>本书主要内容包括：
<strong>第一章：简介</strong>
概率论、模型选择、决策理论、信息理论</p>
<p><strong>第二章：概率分布</strong>
二元变量、多项变量、高斯分布、指数分布族、非参数方法</p>
<p><strong>第三章：线性模型回归问题</strong>
线性基函数模型、偏置方差分解、贝叶斯线性回归、贝叶斯模型比较、The Evidence Approximation、固定基函数的局限性</p>
<p><strong>第四章：线性模型分类问题</strong>
判别函数、概率生成模型、概率判别模型、拉普拉斯逼近、贝叶斯逻辑回归</p>
<p><strong>第五章：神经网络</strong>
前馈神经网络、网络训练、误差反向传播、Hessian矩阵、神经网络的正则化、混合密度网络、贝叶斯神经网络</p>
<p><strong>第六章：Kernel方法</strong>
对偶表示、构造核、径向基函数网络、高斯过程</p>
<p><strong>第七章：Sparse Kernel Machines</strong>
最大边缘分类器、相关向量机</p>
<p><strong>第八章：图模型</strong>
贝叶斯网络、条件独立性、马尔科夫随机场、图模型的推理</p>
<p><strong>第九章：混合模型和EM</strong>
K-means聚类、高斯混合、EM算法</p>
<p><strong>第十章：近似推断</strong>
变分推断、高斯的变分混合、变分线性回归、指数族分布、局部变分方法、变分logistic回归、Expectation Propagation</p>
<p><strong>第十一章：采样方法</strong>
基本采样算法、马尔科夫链蒙特卡洛、吉布斯采样、切片采样、混合蒙特卡洛算法、估计划分函数</p>
<p><strong>第十二章：连续潜在变数</strong>
主成分分析，Probabilistic PCA，Kernel PCA，非线性潜变量模型</p>
<p><strong>第十三章：序列数据</strong>
马尔可夫模型，隐马尔可夫模型，Linear Dynamical Systems</p>
<p><strong>第十四章：混合模型</strong>
贝叶斯模型平均法，Committees，Boosting，基于树的模型，条件混合模型</p>
<p>深度学习目前最权威的教程是下面这本书：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image025.gif" alt="A39AD50565E141F89B08C93CCD7DEDFC.jpeg"></p>
<p>它涵盖了深度学习的方方面面，从理论到工程，但美中不足的是对应于介绍的相对较少。</p>
<p>强化学习是机器学习很独特的一个分支，大多数人对它不太了解，这方面的教程非常少，我们推荐下面这本书：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image027.gif" alt="115B0E32F06F4538A76CB9B610F63B8C.jpeg"></p>
<p>美中不足的是这本书对深度强化学习没有介绍，因为出版的较早。不知最新的版本有没有加上这方面的内容。</p>
<p>在这里需要强调的是，你的知识要系统化，有整体感。很多同学都感觉到自己学的机器学习太零散，缺乏整体感。这需要你多思考算法之间的关系，演化历史之类的问题，这样你就做到胸中有图-机器学习算法地图。其实，<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485551&amp;idx=2&amp;sn=a6689528f10aedab3fce91857eec877b&amp;chksm=fdb695f8cac11cee025ad6d8d77ed90f7169142d6b20b2f5a6945b58edd97c27225f4a2eba91&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SIGAI</a>在之前的公众号文章“<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485306&amp;idx=1&amp;sn=fc8cc8de313bdb61dcd39c1dedb240a4&amp;chksm=fdb69aedcac113fb4b18c74248a313536ded50bade0e66b26f332ab247b148519da71ff2a3c0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">机器学习算法地图</a>”里已经给你总结出来了。</p>
<h3 id="4-2-开源库"><a class="header-anchor" href="#4-2-开源库">¶</a>4.2 开源库</h3>
<p>上面介绍了机器学习和深度学习的理论教材，下面来说实践问题。我们无需重复造车轮子，熟练的使用主流的开源库是需要掌握的一项技能。对于经典的机器学习，常用的库的有:</p>
<ul>
<li>libsvm</li>
<li>liblinear</li>
<li>XGBoost</li>
<li>OpenCV</li>
<li>HTK</li>
<li>Weka</li>
</ul>
<p>在这里我们不一一列举。借助于这些库，我们可以方便的完成自己的实验，或是研发自己的产品。对于深度学习，目前常用的有：</p>
<ul>
<li>Caffe</li>
<li>TensorFlow</li>
<li>MXNet</li>
</ul>
<p>除此之外，还有其他的。对于你要用到的开源库，一定要理解它的原理，以及使用中的一些细节问题。例如很多算法要求输入的数据先做归一化，否则效果会非常差，而且面临浮点数溢出的问题，这些实际经验需要你在使用中摸索。如果有精力把这些库的核心代码分析一遍，你对实现机器学习算法将会更有底气。以深度学习为例，最核心的代码无非是实现：</p>
<ul>
<li>各种层，包括它们的正向传播和反向传播</li>
<li>激活函数的实现</li>
<li>损失函数的实现</li>
<li>输入数据的处理</li>
<li>求解器，实现各种梯度下降法</li>
</ul>
<p>这些代码的量并不大，沉下心来，我相信一周之内肯定能分析完。看完之后你会有一种豁然开朗的感觉。</p>
<h2 id="5-应用方向的知识"><a class="header-anchor" href="#5-应用方向的知识">¶</a>5. 应用方向的知识</h2>
<p>接下来是各个方向的知识，与机器学习有关的应用方向当前主要有：</p>
<ul>
<li>机器视觉</li>
<li>语音识别</li>
<li>自然语言处理</li>
<li>数据挖掘</li>
<li>知识图谱</li>
<li>推荐系统</li>
</ul>
<p>除此之外，还有其他一些特定小方向，在这里不一一列举。这些具体的应用方向一般都有自己的教材，如果你以后要从事此方向的研究，系统的学习一遍是必须的。</p>
<h2 id="6-实践经验与思考"><a class="header-anchor" href="#6-实践经验与思考">¶</a>6. 实践经验与思考</h2>
<p>在说完理论与实践知识之后，最后我们来说经验与思考。在你确定要做某一个方向之后，对这个方向的方法要有一个全面系统的认识，很多方法是一脉相承的，如果只追求时髦看最新的算法，你很难做出学术上的创新，以及工程上的优化。对于本问题所有的经典论文，都应该化时间细度，清楚的理解它们解决了什么问题，是怎么解决的，还有哪些问题没有解决。例如：</p>
<ul>
<li>机器视觉目标检测中的遮挡问题</li>
<li>推荐系统中的冷启动问题</li>
<li>自然语言处理中文分词中的歧义切分问题</li>
</ul>
<p>只有经过大量的编程和实验训练，以及持续的思考，你才能算得上对这个方向深刻理解，以至于有自己的理解。很多同学对自己实现轮上的算法没有底气，解决这个问题最快的途径就是看论文算法的开源代码，在github上有丰富的资源，选择一些合适的，研究一下别人是怎么实现的，你就能明白怎么实现自己的网络结构和损失函数，照葫芦画瓢即可。</p>
<p>计算机以及人工智能是一个偏实践的学科，它的方法和理论既需要我们有扎实的理论功底，又需要有丰富的实践能力与经验。这两个方面构成了算法工程师最主要的素质。科学的学习路径能够让你取得好的学习效果，同时也缩短学习时间。错误和浮躁的做法则会让你最后事倍功半。这是  <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485551&amp;idx=2&amp;sn=a6689528f10aedab3fce91857eec877b&amp;chksm=fdb695f8cac11cee025ad6d8d77ed90f7169142d6b20b2f5a6945b58edd97c27225f4a2eba91&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SIGAI</a> 对想进入这个领域，或者刚进入这个领域的每个人要说的！</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image029.gif" alt="07382DFD55044B48927C8B054DE6F745.png"></p>
<h2 id="7-其他材料"><a class="header-anchor" href="#7-其他材料">¶</a>7. 其他材料</h2>
<h3 id="7-1-科普类"><a class="header-anchor" href="#7-1-科普类">¶</a>7.1 科普类</h3>
<p>【‍获取码】SIGAI0413
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483705&amp;idx=1&amp;sn=c6e7c4a2e14a2469308b41eb60f155ac&amp;chksm=fdb69caecac115b8712653600e526e99a3f6976fdaa2f6b6a09388fa6f9677ccb57b40c40ae3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">机器学习——波澜壮阔四十年 </a></p>
<p>【获取码】SIGAI0620
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484981&amp;idx=1&amp;sn=d3003468b9853851923844812993e060&amp;chksm=fdb69ba2cac112b4dac620d52100ebd033eb679f29340726a67297c4d6980b16c7cc91122028&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解计算：从√2到AlphaGo ——第1季 从√2谈起</a></p>
<p>【获取码】SIGAI0704
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485155&amp;idx=1&amp;sn=990cc7400751c36e9fef0a261e6add2a&amp;chksm=fdb69b74cac112628bdae14c6435120f6fece20dae9bf7b1ffc8b8b25e5496a24160feca0a72&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解计算：从√2到AlphaGo ——第2季 神经计算的历史背景</a></p>
<h3 id="7-2-数学类"><a class="header-anchor" href="#7-2-数学类">¶</a>7.2 数学类</h3>
<p>【获取码】SIGAI0417
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483713&amp;idx=1&amp;sn=1e7c81381d16806ac73e15691fe17aec&amp;chksm=fdb69cd6cac115c05f1f90b0407e3f8ae9be8719e454f908074ac0d079885b5c134e2d60fd64&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">学好机器学习需要哪些数学知识</a></p>
<p>【获取码】SIGAI0511
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484111&amp;idx=1&amp;sn=4ed4480e849298a0aff828611e18f1a8&amp;chksm=fdb69f58cac1164e844726bd429862eb7b38d22509eb4d1826eb851036460cb7ca5a8de7b9bb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解梯度下降法</a></p>
<p>【获取码】SIGAI0518
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484439&amp;idx=1&amp;sn=4fa8c71ae9cb777d6e97ebd0dd8672e7&amp;chksm=fdb69980cac110960e08c63061e0719a8dc7945606eeef460404dc2eb21b4f5bdb434fb56f92&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解凸优化</a></p>
<p>【获取码】SIGAI0531
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484651&amp;idx=1&amp;sn=a0e4ca5edb868fe3eae9101b71dd7103&amp;chksm=fdb6997ccac1106a61f51fe9f8fd532045cc5d13f6c75c2cbbf1a7c94c58bcdf5f2a6661facd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解牛顿法 </a></p>
<h3 id="7-3-机器学习类"><a class="header-anchor" href="#7-3-机器学习类">¶</a>7.3 机器学习类</h3>
<p>【获取码】SIGAI0428
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483937&amp;idx=1&amp;sn=84a5acf12e96727b13fd7d456c414c12&amp;chksm=fdb69fb6cac116a02dc68d948958ee731a4ae2b6c3d81196822b665224d9dab21d0f2fccb329&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">用一张图理解SVM的脉络</a></p>
<p>【获取码】SIGAI0505
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483977&amp;idx=1&amp;sn=401b211bf72bc70f733d6ac90f7352cc&amp;chksm=fdb69fdecac116c81aad9e5adae42142d67f50258106f501af07dc651d2c1473c52fad8678c3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解神经网络的激活函数</a></p>
<p>【获取码】SIGAI0522
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484495&amp;idx=1&amp;sn=4f3a6ce21cdd1a048e402ed05c9ead91&amp;chksm=fdb699d8cac110ce53f4fc5e417e107f839059cb76d3cbf640c6f56620f90f8fb4e7f6ee02f9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【实验】理解SVM核函数和参数的作用</a></p>
<p>【获取码】SIGAI0601
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484658&amp;idx=1&amp;sn=f5c9f92c272c75883bf8e6f532559f11&amp;chksm=fdb69965cac11073f49048caef5d7b9129614090a363d9ef7f3d1b9bc59948d2217d2bca7b7b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【群话题精华】五月集锦—机器学习和深度学习中一些值得思考的问题   </a></p>
<p>【获取码】SIGAI0602
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484692&amp;idx=1&amp;sn=9b389aa65208c778dddf17c601afbee1&amp;chksm=fdb69883cac1119593934734e94c3b71aa68de67bda8a946c1f9f9e1209c3b6f0bf18fed99b8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">大话AdaBoost算法    </a></p>
<p>【获取码】SIGAI0606
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484754&amp;idx=1&amp;sn=b2c0d6798f44e13956bb42373e51d18c&amp;chksm=fdb698c5cac111d3e3dca24c50aafbfb61e5b05c5df5b603067bb7edec8db049370b73046b24&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解主成分分析（PCA）    </a></p>
<p>【获取码】SIGAI0611
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484827&amp;idx=1&amp;sn=043d7d0159baaddfbf92ed78ee5b1124&amp;chksm=fdb6980ccac1111a9faeae7f517fee46a1dfab19612f76ccfe5417487b3f090ab8fc702d18b8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解决策树  </a></p>
<p>【获取码】SIGAI0613
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484859&amp;idx=1&amp;sn=2c4db22fb538953a62a90983e3e1f99d&amp;chksm=fdb6982ccac1113a82e92be325bb07a947d54090274654375f3b50e11e1abd809fb7358bde16&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">用一句话总结常用的机器学习算法</a></p>
<p>【获取码】SIGAI0618
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484954&amp;idx=1&amp;sn=c28b7f07c22466e91b1ef90e9dbe3ad1&amp;chksm=fdb69b8dcac1129bc6e78fca1d550e2b18238ad1c240c73b280d4e529f9f93c4626b3ac45ea2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解过拟合</a></p>
<p>【获取码】SIGAI0627
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485074&amp;idx=1&amp;sn=0ebf1bf8f49e9c46075fe3803d04c95d&amp;chksm=fdb69b05cac112132d280c70af3923ca4c3cccfa5fcd8628b79d4b246b3b2decbc80a180abb3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">k近邻算法</a></p>
<p>【获取码】SIGAI0704
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485306&amp;idx=1&amp;sn=fc8cc8de313bdb61dcd39c1dedb240a4&amp;chksm=fdb69aedcac113fb4b18c74248a313536ded50bade0e66b26f332ab247b148519da71ff2a3c0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">机器学习算法地图</a></p>
<p>【获取码】SIGAI0706
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485446&amp;idx=1&amp;sn=57d7d866443810c20c4ea2c6ee8018cc&amp;chksm=fdb69591cac11c8773638b396abe43c0161e4d339f0fa845e54326be3e8c4933a3b6a2713dae&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">反向传播算法推导—全连接神经网络</a></p>
<h3 id="7-4-深度学习类"><a class="header-anchor" href="#7-4-深度学习类">¶</a>7.4 深度学习类</h3>
<p>【获取码】SIGAI0426
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483816&amp;idx=1&amp;sn=fc52765b012771d4736c9be4109f910e&amp;chksm=fdb69c3fcac115290020c3dd0d677d987086a031c1bde3429339bb3b5bbc0aa154e76325c225&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">卷积神经网络为什么能够称霸计算机视觉领域？</a></p>
<p>【获取码】SIGAI0508
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484037&amp;idx=1&amp;sn=13ad0d521b6a3578ff031e14950b41f4&amp;chksm=fdb69f12cac11604a42ccb37913c56001a11c65a8d1125c4a9aeba1aed570a751cb400d276b6&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">深度卷积神经网络演化历史及结构改进脉络-40页长文全面解读 </a></p>
<p>【获取码】SIGAI0515
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484310&amp;idx=1&amp;sn=0fc55a2784a894100a1ae64d7dbfa23d&amp;chksm=fdb69e01cac1171758cb021fc8779952e55de41032a66ee5417bd3e826bf703247e243654bd0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">循环神经网络综述—语音识别与自然语言处理的利器</a></p>
<p>【获取码】SIGAI0625
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485042&amp;idx=1&amp;sn=cdcf8d4b07acf64c7a6f5f7c1a731a12&amp;chksm=fdb69be5cac112f377766984afb87313c1e1c58d94c80005f0f6f6af61ee5a4bd1bf6c6157b6&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">卷积神经网络的压缩与加速</a></p>
<p>【获取码】SIGAI0709
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485551&amp;idx=1&amp;sn=213f48c4e55bee688cf0731097bb832c&amp;chksm=fdb695f8cac11ceef3ef246c54d811dd64d8cc45fc75488c374c7aa95f72c1abfb55555ef0b7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener"> 生成式对抗网络模型综述</a></p>
<h3 id="7-5-机器视觉类"><a class="header-anchor" href="#7-5-机器视觉类">¶</a>7.5 机器视觉类</h3>
<p>【获取码】SIGAI0420
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483726&amp;idx=1&amp;sn=9fef4cc1766ea4258749f8d40cc71a6e&amp;chksm=fdb69cd9cac115cf4eba16081780c3b64c75e1e55a40bf2782783d5c28f00c6f143426e6f0aa&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">人脸识别算法演化史</a></p>
<p>【获取码】SIGAI0424
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483731&amp;idx=1&amp;sn=237c52bc9ddfe65779b73ef8b5507f3c&amp;chksm=fdb69cc4cac115d2ca505e0deb975960a792a0106a5314ffe3052f8e02a75c9fef458fd3aca2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">基于深度学习的目标检测算法综述</a></p>
<p>【获取码】SIGAI0503
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483950&amp;idx=1&amp;sn=a3a5b7907b2552c233f654a529931776&amp;chksm=fdb69fb9cac116af5dd237cf987e56d12b0d2e54c5c565aab752f3e366c0c45bfefa76f5ed16&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">人脸检测算法综述</a></p>
<p>【获取码】SIGAI0525
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483950&amp;idx=1&amp;sn=a3a5b7907b2552c233f654a529931776&amp;chksm=fdb69fb9cac116af5dd237cf987e56d12b0d2e54c5c565aab752f3e366c0c45bfefa76f5ed16&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【SIGAI综述】行人检测算法   </a></p>
<p>【获取码】SIGAI0604
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484711&amp;idx=1&amp;sn=bb7644e101b5924f54d6800b952dc3aa&amp;chksm=fdb698b0cac111a6605f5b9b6f0478bf21a8527cfad2342dbaaf624b4e9dcc43c0d85ae06deb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">FlowNet到FlowNet2.0：基于卷积神经网络的光流预测算法 </a></p>
<p>【获取码】SIGAI0608
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484784&amp;idx=1&amp;sn=ceafb54203f4e930ae457ad392b9f89c&amp;chksm=fdb698e7cac111f13d8229d7dcc00b4a7305d66de3da1bd41e7ecc1d29bfa7be520d205c53e9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">人体骨骼关键点检测综述 </a></p>
<p>【获取码】SIGAI0615
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484909&amp;idx=1&amp;sn=c02ee17e5175230ed39ad63e73249f5c&amp;chksm=fdb6987acac1116c0108ec28424baf4ea16ca11d2b13f20d4a825d7b2b82fb8765720ebd1063&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">目标检测算法之YOLO</a></p>
<p>【获取码】SIGAI0622
​    <a href="https://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485005&amp;idx=1&amp;sn=0d4fb43b8db2a8046c64a9cfcbf3f478&amp;chksm=fdb69bdacac112cce05c8b735b4f8b1ccf2348bea55a30af2055fc328958bb8f1ffd0f819bd2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">场景文本检测——CTPN算法介绍</a></p>
<p>【获取码】SIGAI0629
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485142&amp;idx=1&amp;sn=c0e01da30eb5e750be453eabe4be2bf4&amp;chksm=fdb69b41cac11257ae22c7dac395e9651dab628fc35dd6d3c02d9566a8c7f5f2b56353d58a64&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">自然场景文本检测识别技术综述</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>《形象美学》摘录笔记</title>
    <url>/public/2019/07/21/readings/xingxiangmeixue/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p><img src="/public/2019/07/21/readings/xingxiangmeixue/book_cover.png" alt="book_cover"></p>
<p><a href="https://book.douban.com/subject/30434860/" target="_blank" rel="noopener">《形象美学》</a>这本书是我偶然间看到的，本人很少买衣服，自认为衣品极差，被老妈诟病。以前的观点是多买，买一些品牌好的。每当要去买衣服的时候（计划一年两次），总是有很多困扰。图书馆看到此书，恰合我意，翻阅全书，或许有望提高衣品，提升人生品味了，哈哈哈。</p>
<p>此书的作者是一位研究人物形象设计的大学教师，并有着多年服装顾问的实战经验。书前四章有很多服装的基础理论，搭配等技巧，书后两章给出驭装的细节方法和一个必备的衣服仓库的采购整理建议。本博文中将整理书中的重点，供各位同好们参考。</p>
<p>此书历经10 年完成（书中官方介绍），分为<strong>塑型、悦色、妆饰、驭装、理橱、博雅</strong>六个章节。书本主要分析了衣服的材质、款式、色彩、场合，以期帮助读者从尊重、认识、爱上自己的长相与身材开始，到认识与识别商品进行实践，最终达到人衣匹配，内外合一的境界。</p>
<a id="more"></a>
<p>本博文将此书内容分为两个部分阐述。博文第一部分为塑型、悦色、妆饰、驭装，代表着从材质、款式、色彩和场合四个角度分析衣服，为衣服的基本原理；博文第二部分理橱、博雅，为实践部分，即整理衣服鞋帽，合理配置。</p>
<h2 id="一、基本理论"><a class="header-anchor" href="#一、基本理论">¶</a>一、基本理论</h2>
<p>衣服的基本理论分为材质、款式、色彩和场合四个方面。</p>
<h3 id="1-材质"><a class="header-anchor" href="#1-材质">¶</a>1. 材质</h3>
<p><strong>按面料材质分</strong>：天然纤维面料、化学纤维、混纺面料。</p>
<table>
<thead>
<tr>
<th>天然纤维面料</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>棉织物</td>
<td>易掉色</td>
<td>日常休闲、随和温柔、平实、易于亲近</td>
</tr>
<tr>
<td>麻织物</td>
<td>易折皱</td>
<td>随性率真、污垢易除</td>
</tr>
<tr>
<td>丝织物</td>
<td>比较难打理</td>
<td></td>
</tr>
<tr>
<td>毛织物</td>
<td>毛衣</td>
<td>丝毛洗涤剂</td>
</tr>
<tr>
<td>丝织物</td>
<td>少见</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>化学纤维</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>再生纤维</td>
<td>易掉色</td>
<td></td>
</tr>
<tr>
<td></td>
<td>天丝纤维</td>
<td>随性率真、污垢易除</td>
</tr>
<tr>
<td></td>
<td>莫代尔纤维</td>
<td>木材、内衣</td>
</tr>
<tr>
<td></td>
<td>醋酯纤维</td>
<td>光泽感、[天鹅绒织锦]</td>
</tr>
<tr>
<td>合成纤维</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>混纺面料</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>比如</td>
<td>毛衣</td>
<td>涤纶（30%-40%）、氨纶（3%-7%）</td>
</tr>
</tbody>
</table>
<p><strong>按纺织工艺分</strong>：梭织、针织。</p>
<table>
<thead>
<tr>
<th>纺织工艺</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>梭织</td>
<td></td>
<td>斜纹、平纹、缎纹</td>
</tr>
<tr>
<td>针织</td>
<td></td>
<td>手感好，不保形，挺括</td>
</tr>
</tbody>
</table>
<p><strong>面料档次</strong></p>
<table>
<thead>
<tr>
<th>档</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>低</td>
<td></td>
<td>普通化学</td>
</tr>
<tr>
<td>普通</td>
<td></td>
<td>棉、麻</td>
</tr>
<tr>
<td>中档</td>
<td></td>
<td>天丝、氨纶</td>
</tr>
<tr>
<td>高档</td>
<td></td>
<td>羊毛织物、桑蚕丝织物、小牛皮、小羊皮</td>
</tr>
<tr>
<td>顶级</td>
<td></td>
<td>羊绒织物、羊驼毛织物</td>
</tr>
</tbody>
</table>
<p><strong>材料小结</strong>：相近材料越轻越好（羊毛&lt;羊绒），材料对齐格子和条纹。</p>
<blockquote>
<p>Tip: 与其花便宜价钱买回一堆无用的东西，不如花一些心思在辨别服装的档次和价值上。购回衣服一定要试穿（材质和版型）。</p>
</blockquote>
<h3 id="2-款式"><a class="header-anchor" href="#2-款式">¶</a>2. 款式</h3>
<p>款式，即衣服的型。包括轮廓、量感、比例。</p>
<h4 id="2-1-轮廓"><a class="header-anchor" href="#2-1-轮廓">¶</a>2.1 轮廓</h4>
<table>
<thead>
<tr>
<th>轮廓</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>直线</td>
<td>粗：力量，霸气 细：秀气，敏锐灵动</td>
<td></td>
</tr>
<tr>
<td>直线+曲线</td>
<td></td>
<td></td>
</tr>
<tr>
<td>曲线</td>
<td>大曲线：浪漫、妩媚、经典、奢华、或熟惑。小曲线：可爱、秀美、温柔、年轻化。</td>
<td></td>
</tr>
</tbody>
</table>
<p>配饰、衣物上图案中也有直 中 曲。</p>
<ul>
<li>直线：格子、条纹、几何形。</li>
<li>中：动物纹、字母、波普艺术图案。</li>
<li>曲：波点（圆点）、花卉、波纹线，佩花纹理线</li>
</ul>
<h4 id="2-2-量感"><a class="header-anchor" href="#2-2-量感">¶</a>2.2 量感</h4>
<table>
<thead>
<tr>
<th>描述</th>
<th>面料</th>
<th>配饰</th>
</tr>
</thead>
<tbody>
<tr>
<td>重型 多变</td>
<td>牛仔布/皮革</td>
<td>夸张</td>
</tr>
<tr>
<td>适中 线形柔和</td>
<td>棉麻、针织、磨砂皮</td>
<td>适中</td>
</tr>
<tr>
<td>轻 平实 常见 变化少</td>
<td>真丝、纱、薄针织</td>
<td>小巧可爱</td>
</tr>
</tbody>
</table>
<h4 id="2-3-比例"><a class="header-anchor" href="#2-3-比例">¶</a>2.3 比例</h4>
<p><strong>服装轮廓对应身材，服装图案和装饰对应人脸。</strong></p>
<p>“型”形式美法则</p>
<ol>
<li>统一与变化</li>
<li>节奏与韵律。宽窄：上宽下窄。长短：内外。上长下短，不要一样。</li>
</ol>
<p>经典款式上融入当季流行的元素。</p>
<h3 id="3-色彩"><a class="header-anchor" href="#3-色彩">¶</a>3. 色彩</h3>
<h4 id="3-1-色彩分类"><a class="header-anchor" href="#3-1-色彩分类">¶</a>3.1 色彩分类</h4>
<table>
<thead>
<tr>
<th>色彩分类</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>无彩色</td>
<td>黑白灰</td>
<td></td>
</tr>
<tr>
<td>有彩色</td>
<td>红橙黄绿蓝紫</td>
<td>明快艳丽</td>
</tr>
<tr>
<td></td>
<td>+白</td>
<td>轻快爽朗</td>
</tr>
<tr>
<td></td>
<td>+灰</td>
<td>优雅含蓄</td>
</tr>
<tr>
<td></td>
<td>+黑</td>
<td>沉稳庄重</td>
</tr>
<tr>
<td>独立色</td>
<td>金银</td>
<td>不建议日常</td>
</tr>
</tbody>
</table>
<p><strong>色彩三要素</strong>：色相、明度（亮度）、纯色（彩度）</p>
<p>色相：基础色，色系。冷暖。 <a href="http://blog.sina.com.cn/s/blog_4b933df90102x35r.html" target="_blank" rel="noopener">伊登色相环</a> 色立体</p>
<p>明度：加白色，亮暗，浅深。</p>
<p>纯度：色彩饱和和纯净程度。常用鲜艳，浑浊或艳。鲜与灰。</p>
<blockquote>
<p>平常说的亮，指的是明度而非纯度。
色相，冷与暖；明度，亮与暗（浅与深）；纯度，鲜艳与浑浊（鲜与灰）。</p>
</blockquote>
<p><img src="/public/2019/07/21/readings/xingxiangmeixue/sexianghuan.png" alt="sexianghuan"></p>
<h4 id="3-2-肤色"><a class="header-anchor" href="#3-2-肤色">¶</a>3.2 肤色</h4>
<table>
<thead>
<tr>
<th>肤色</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>肤色色相</td>
<td>冷暖</td>
<td>冷：泛青，或黄至青灰的肤色，如小麦色，古铜色，橄榄色。暖：偏黄或偏红的肤色，如象牙色，黄橙色，咖啡色</td>
</tr>
<tr>
<td>肤色色明</td>
<td>黑白</td>
<td>高明度：偏白偏亮。低明度：偏黑偏暗。</td>
</tr>
<tr>
<td>肤色纯度</td>
<td>轻薄透明，密实紧致</td>
<td>低纯度：；皮肤较薄，晶莹剔透，面部较易泛红印。高纯度：密实紧致，给人厚重感，光泽度较强。</td>
</tr>
</tbody>
</table>
<p><a href="https://jingyan.baidu.com/article/020278116a838c1bcc9ce529.html" target="_blank" rel="noopener">肤色选颜色</a> 肤色的四季理论。此部分来自百度。</p>
<p><strong>Spring 春季型</strong></p>
<p>肤色特征：浅象牙色，暖米色，细腻而有透明感。
眼睛特征：眼珠为亮茶色，黄玉色，眼白感觉有湖兰色。
发色特征：明亮如绢的茶色，柔和的棕黄色、栗色。发质柔软。</p>
<p>春季型人的色彩搭配原则——最适合自己颜色的要点是：不能太旧，太暗。春季型人的服饰基调属于暖色系中的明亮色调，在色彩搭配上应遵循鲜明、对比的突出自己的俏丽。使用范围最广的颜色是黄色，选择红色时，以橙红、桔红为主。
特别提示：对春季型人来说，黑色是最不适合的颜色，过深过重的颜色会与春季型人白色的肌肤、飘逸的黄发出现不和谐音，会使春季型人看上去显得暗淡。春季型人的特点是明亮、鲜艳。属于春季型的人用明亮、鲜艳的颜色打扮自己，会比实际年龄显得年轻。</p>
<p><strong>Summer 夏季型</strong></p>
<p>肤色特征：粉白，乳白色皮肤，带蓝色调的褐色皮肤，小麦色皮肤。
眼睛特征：目光柔和，眼珠呈焦茶色，深棕色。
发色特征：轻柔的黑色、灰黑色，柔和的棕色或深棕色。</p>
<p>夏季型人的色彩搭配原则——拥有健康的肤色，水粉色的红晕，浅玫瑰色的嘴唇，柔软的黑发，给人以非常柔和优雅的整体印象。夏季型人适合以蓝色为底调的柔和淡雅的颜色，这样才能衬托出她们温柔、恬静的个性。夏季型人适合穿深浅不同的各种粉色、蓝色和紫色，以及有朦胧感的色调，在色彩搭配上，最好避免反差大的色调，适合在同一色相里进行浓淡搭配。</p>
<p>特别提示：选择适合自己的颜色的要点是：颜色一定要柔和、淡雅。夏季型人不适合穿黑色，过深的颜色会破坏夏季型人的柔美，可用一些浅淡的灰蓝色、蓝灰色、紫色来代替黑色。夏季型人穿灰色会非常高雅，但注意选择浅至中度的灰，但注意夏季型人不太适合藏蓝色。</p>
<p><strong>Autumn 秋季型</strong></p>
<p>肤色特征：瓷器般的象牙色皮肤，深桔色、暗驼色或黄橙色。肤色匀整，色泽偏橘，无透明感，肤质密实，肤质的纯度较高。不易出现红晕，肤色偏深，也有少部分人肤色呈现瓷器般浅象牙白色
眼睛特征：深棕色、焦茶色、眼白呈暖白色。
发色特征：有光泽的褐色、棕色或者铜色、巧克力色。</p>
<p>秋季型人的色彩搭配原则—— 是四季色中最成熟而华贵的代表，最适合的颜色是金色，苔绿色，橙色等深而华丽的颜色。选择红色时，一定要选择砖红色和与暗桔红相近的颜色。秋季型人的服饰基调是暖色系中的沉稳色调。浓郁而华丽的颜色可衬托出秋季型人成熟高贵的气质，越浑厚的颜色也越能衬托秋季型人陶瓷般的皮肤。</p>
<p>特别提示：选择适合自己的颜色的要点是：颜色要温暖，浓郁。秋季型人穿黑色会显得皮肤发黄，可用深棕色来代替。</p>
<p>最佳用色：金色，姜黄，橄榄绿，土红，土黄，咖啡色，深褐色，等浓郁而温暖的色彩。</p>
<p><strong>Winter 冬季型</strong></p>
<p>肤色特征：青白或略带橄榄色，带青色的黄褐色。冷调的看不到红晕的肤色。
眼睛特征：眼睛黑白分明，目光锐利，眼珠为深黑色，焦茶色。
发色特征：乌黑发亮，黑褐色，银灰、深酒红。</p>
<p>冬季型人的色彩搭配原则—— 最适合纯色，选择红色时，可选正红、酒红和纯正的玫瑰红。在四季颜色中，只有冬季型人最适合使用黑、纯白、灰这三种颜色，藏蓝色也是冬季型人的专利色。但在选择深重颜色的时候一定要有对比色出现。</p>
<p>特别提示：选择适合自己的颜色的要点是：颜色要鲜明，光泽度高。冬季型人着装一定要注意色彩的对比，只有对比搭配才能显得惊艳、脱俗</p>
<blockquote>
<p>如何确定自己的肤色为冷暖色？
找一个审美较好的朋友陪着去逛街，试穿五件以上不同暖色调的衣服，再试穿五件以上不同冷色调的衣服。</p>
</blockquote>
<h4 id="3-3-色彩的错觉"><a class="header-anchor" href="#3-3-色彩的错觉">¶</a>3.3 色彩的错觉</h4>
<ul>
<li>色彩的膨胀与收缩。冷，暗，低纯度收缩。暖，亮，高纯度膨胀。</li>
<li>色彩的硬和软。灰黑，深蓝，是硬朗，坚强的色彩，用于职场谈判，强调严谨，强势，理性的态度。粉红，粉黄，为相对温和柔软的色彩，与朋友约会，家庭亲子活动，强调关心，关怀。同时与面料的质感有很大关系。当然也要善用流行色。</li>
</ul>
<h4 id="3-4-衣服配色原理"><a class="header-anchor" href="#3-4-衣服配色原理">¶</a>3.4 衣服配色原理</h4>
<ol>
<li>色相和谐法。色相类似，明纯改变。冷暖一样，上明下暗。</li>
<li>明度和谐法。明度类似，色相纯度改变。上冷下暖。</li>
<li>纯度和谐法。纯度相近。色相明度不同。</li>
<li>有色彩，无彩搭配。黑白灰</li>
<li>色彩面积大小和谐法。主次，点缀。</li>
<li>色彩的呼应。A、图案与服装色彩的呼应，外花内单，外单内花，单是花中的一个颜色。花色：花卉，格子，条纹，圆点，动物纹，火腿纹，电脑抽像图。B、配饰，帽子与上衣颜色一致，领带、围巾也相呼应。</li>
<li>面料质地与色彩。同色不同质。同质不同色。</li>
<li>面料与肤质。面料粗细，与脸部很相关。</li>
</ol>
<h3 id="4-场合"><a class="header-anchor" href="#4-场合">¶</a>4. 场合</h3>
<p>TPO法则：Time Place Object。Time主要为季节。Place为地点，室内还是室外，办公场所还是在家里。Object 穿着的目的，为了什么事情而穿。接下来两个常用场景来说一说。</p>
<h4 id="职场"><a class="header-anchor" href="#职场">¶</a>职场</h4>
<p>与个人职业气质相契合，与个人年龄相契合，与工作环境、工作特点、行业要求相契合。</p>
<p>领带分为小中大结，身材瘦小适合小结，身材适中适合中结，身材高大适合大结。领结搭配礼服多一点。衬衫要过腕，斜纹代表勇敢，波纹线代表活泼跳跃，圆点代表关怀。带鞋带的皮鞋很正式。</p>
<h4 id="休闲"><a class="header-anchor" href="#休闲">¶</a>休闲</h4>
<ol>
<li>旅游：舒适。颜色红黄绿，游山玩水；颜色黑白，城市。</li>
<li>逛街，访友，约会。不穿太正式，体现自我风格。遇见春节等喜庆节日穿红色。</li>
<li>日常运动健身</li>
<li>家居：休闲家居服，睡衣。圆点卡通，有利于休息，全家尽量一致，和谐。</li>
</ol>
<h2 id="二、理橱博雅"><a class="header-anchor" href="#二、理橱博雅">¶</a>二、理橱博雅</h2>
<h3 id="衣服类别："><a class="header-anchor" href="#衣服类别：">¶</a>衣服类别：</h3>
<ol>
<li>
<p>职业装
上班或适合上班，商务，公务活动穿着的服装，多为正装，套装。</p>
</li>
<li>
<p>便装
逛街，聚会，旅行，郊游时穿着的服装，比正装、套装稍显随意，休闲些的服装。</p>
</li>
<li>
<p>家居休闲服
买菜，散步，接送孩子时穿着轻松自在的外出服。</p>
</li>
<li>
<p>运动服
打球、跑步、游泳、健身时穿着的服装，因运动的不同而具有不同功能和特性的服装。</p>
</li>
<li>
<p>礼仪服
参加典礼、庆功宴、年会、酒会，音乐会，高规格的戏剧演出等社交活动时穿着的服装。</p>
</li>
<li>
<p>睡衣
睡眠时穿着的有利于人身心放松的服装。</p>
</li>
<li>
<p>内衣</p>
</li>
</ol>
<blockquote>
<p>周一至周五的上班族，衣橱中一半为职业服，平时注意将各类服装备齐。</p>
</blockquote>
<h3 id="整理技巧"><a class="header-anchor" href="#整理技巧">¶</a>整理技巧</h3>
<ol>
<li>清理衣橱中现存的服饰，旧的打包。</li>
<li>检查衣橱中留下的服饰，检查是否污渍，掉色，掉线。</li>
<li>系统、规律地吊挂，摆放衣服饰品。比如：按 春夏 秋冬，按上下装，按功能分。</li>
</ol>
<blockquote>
<p>大而厚的衣服要用大衣架。裤子用夹。丝质用有海绵垫肩的衣架。针织服装不用吊挂，容易变形。</p>
</blockquote>
<ol start="4">
<li>为衣橱中现有的服饰做搭配。发现新搭配。</li>
<li>列出衣橱中缺少的单品清单。在搭配时发现缺少的清单。列出购物时的清单。（在商场中可以带上自己想要搭配的衣物，或者存在手机上）</li>
<li>将衣橱中的服装拍照留存，求助一些专业的朋友，或者设计师。</li>
</ol>
<blockquote>
<p>洗涤时，检查口袋！！！分开洗涤！！！
棉麻反面晒，拉平一下。
羽绒服晒到一半干，要拍打一下。
买一些合适的晾衣架。</p>
</blockquote>
<h3 id="理智购买"><a class="header-anchor" href="#理智购买">¶</a>理智购买</h3>
<ol>
<li>购买服装需定位。衣橱中缺少的是哪一种类型，哪一个季节，哪一种场合穿着的衣服鞋帽。</li>
<li>买衣之前试穿。</li>
<li>不买贵的或便宜的，只买合适的。</li>
<li>贵精不贵多，重质不重量。</li>
<li>购衣时，检查衣服。是否需要“干洗”，比如正装。颜色，条纹是否对齐，勾线齐整等等</li>
</ol>
<blockquote>
<p>怎样才能避免使白衬衫的领口，腋下因汗渍而发黄？穿衬衫前将蜡质止汗膏涂抹在衬衫领口及腋下部位，可以隔绝汗液侵蚀，延长白衬衫的寿命。油渍，用纸巾吸一下，然后用牙膏处理一哈。</p>
</blockquote>
<h3 id="博雅-明礼修身提升综合素养"><a class="header-anchor" href="#博雅-明礼修身提升综合素养">¶</a>博雅 明礼修身提升综合素养</h3>
<blockquote>
<p>“若要有优美的嘴唇，请讲亲切的话；若要有优雅的姿态，请记住走路时行人不止你一个。“
---奥黛丽·赫本</p>
</blockquote>
<p>走路可选择带节奏感的旋律，如414拍的音乐，踏着音乐不停地练习，增强走路的节奏感和律动。</p>
<p>心中盛满美好之人，脚步时轻盈的；心理盛满爱心的人，脚步是温柔的；心理盛满阳光的人，脚步是快乐的；心里盛满信念之人，步伐也会因此而变得坚定。</p>
<p>适宜香水：闻香识人，听语知人。</p>
<p>读万卷书，行万里路，与万人谈。</p>
<p>美不自美，因人而彰。</p>
<p>世物自美，需要生活的艺术家运用慧眼发现美。通过丰富多彩的载体创造美，在人和人之间传递美。</p>
<h2 id="三、总结"><a class="header-anchor" href="#三、总结">¶</a>三、总结</h2>
<p>买衣服考虑四个方面，材质（棉麻为主要）、款式（轮廓、量感、比例）、颜色（色相、明度、纯度）、场合（工作、休闲）。<a href="#%E6%95%B4%E7%90%86%E6%8A%80%E5%B7%A7">整理衣橱</a>，<a href="#%E7%90%86%E6%99%BA%E8%B4%AD%E4%B9%B0">理智购买</a>。</p>
<p><strong>最后，真诚地感谢《形象美学》的作者，黄焱冰老师！！！也希望自己有更好的衣品</strong></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>个人管理</tag>
        <tag>《形象美学》</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」BGmi – 自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人</title>
    <url>/public/2022/07/15/test/202207/2022-07-01-063258020141/</url>
    <content><![CDATA[<p>「转」<a href="https://www.appinn.com/bgmi/" target="_blank" rel="noopener">BGmi – 自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人</a></p>
<a id="more"></a>
<p><strong>BGmi</strong> 是一款开源的自动追番的工具，通过多个数据源订阅番剧更新，使用 aria2、transmission 等工具下载，Web
管理界面，全平台适用。折腾一次，永久使用，适合所有正在追番的懒人。@<a href="https://www.appinn.com/bgmi/" target="_blank" rel="noopener">Appinn</a></p>
<p><img src="https://img3.appinn.net/images/202206/appinn-2022-06-29t202618-430.jpg!o" alt="BGmi -自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人"></p>
<p>原文来自 @<a href="https://www.appinn.com/author/390080445/" target="_blank" rel="noopener">root</a>。</p>
<p>大家好，由于你 B 4
月新（鸽了太久已经不新了）番十分不给力，什么都看不了，加上本人人懒，不想搜索网盘并下载，就想找个能自动追番的工具。根据之前的经验，RSS
是可以实现这个需求的，但是感觉 rss 配置起来很复杂，就想看看有没有什么简单的方式来实现，去 gayhub 上搜了一圈，发现了 bgmi 这个工具。</p>
<p><img src="https://img3.appinn.net/images/202206/bgmi_admin.jpg!o" alt="BGmi - 自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人12"></p>
<p>bgmi 可以同步最新番剧数据，帮助订阅番剧并实现自动追番，同时提供 WebUI 给出还不错的追番日历。</p>
<p>在日历中看到想追的番剧，只要点击订阅就可以了。bgmi 支持多个番剧数据源，支持多种下载软件，同时内置的 WebUI
播放器据说支持弹幕（虽然我没成功），可以按需选择，自由定制。</p>
<p>![BGmi - 自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人
13](<a href="https://img3.appinn.net/images/202206/screen-" target="_blank" rel="noopener">https://img3.appinn.net/images/202206/screen-</a>
appinn2022-06-29-21-16-26.jpg!o)</p>
<p>bgmi 本身是命令行脚本，使用前需要配置下载器。作者提供了一个集成好各项配置的 docker
镜像，推荐使用这个镜像获得更加懒人化的使用体验。本文截图全部来自 docker 版本搭建。</p>
<h2 id="获取"><a class="header-anchor" href="#获取">¶</a>获取</h2>
<ul>
<li><a href="https://kutt.appinn.net/iivedD" target="_blank" rel="noopener">GitHub</a></li>
</ul>
<hr>
<p>青小蛙尝试了一下，结果发现网络联通是最大的问题，如果能解决这个问题，用起来还是挺顺手的。</p>
<p>简易教程，基于 <a href="https://github.com/BGmi/bgmi-docker-all-in-one" target="_blank" rel="noopener">Docker</a>：</p>
<pre><code>docker run -d --name bgmi -v 本地路径:/bgmi -p 80:80 -p 9091:9091 -e BGMI_ADMIN_TOKEN=admin -e TZ=Asia/Hongkong codysk/bgmi-all-in-one
</code></pre>
<p>然后要等一会，再进入容器安装前台界面，以及更新日历：</p>
<pre><code>docker exec -it bgmi /bin/bash
bgmi install
bgmi cal
</code></pre>
<p>就可以了。可以进入容器后使用 <code>export https_proxy=http://127.0.0.1:8123</code> 设置代理，速度会好很多。</p>
<p>![BGmi - 自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人
14](<a href="https://img3.appinn.net/images/202206/screen-" target="_blank" rel="noopener">https://img3.appinn.net/images/202206/screen-</a>
appinn2022-06-29-21-24-10.jpg!o)</p>
<p>原文：<a href="https://www.appinn.com/bgmi/" target="_blank" rel="noopener">https://www.appinn.com/bgmi/</a></p>
<hr>
<p><a href="http://www.appinn.com/copyright/?utm_source=feeds&amp;utm_medium=copyright&amp;utm_campaign=feeds" title="版权声明" target="_blank" rel="noopener">(C)</a>2021 青小蛙 for
<a href="http://www.appinn.com/?utm_source=feeds&amp;utm_medium=appinn&amp;utm_campaign=feeds" title="本文来自小众软件" target="_blank" rel="noopener">小众软件</a> | [加入我们](<a href="http://www.appinn.com/join-" target="_blank" rel="noopener">http://www.appinn.com/join-</a>
us/?utm_source=feeds&amp;utm_medium=joinus&amp;utm_campaign=feeds &quot;加入小众软件&quot;) |
<a href="https://meta.appinn.net/c/faxian/?utm_source=feeds&amp;utm_medium=contribute&amp;utm_campaign=feeds" title="给小众软件投稿" target="_blank" rel="noopener">投稿</a> | [订阅指南](<a href="http://www.appinn.com/feeds-" target="_blank" rel="noopener">http://www.appinn.com/feeds-</a>
subscribe/?utm_source=feeds&amp;utm_medium=feedsubscribe&amp;utm_campaign=feeds
&quot;可以分类订阅小众，Windows/MAC/游戏&quot;)<br>
3659b075e72a5b7b1b87ea74aa7932ff<br>
<a href="https://www.appinn.com/bgmi/#comments" title="to the comments" target="_blank" rel="noopener">点击这里留言、和原作者一起评论</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」老牌截图工具 PicPick 更新，新增录屏功能，支持 MP4/GIF 格式</title>
    <url>/public/2022/07/15/test/202207/2022-07-02-041120453414/</url>
    <content><![CDATA[<p>「转」<a href="https://www.appinn.com/picpick-6-2/" target="_blank" rel="noopener">老牌截图工具 PicPick 更新，新增录屏功能，支持 MP4/GIF 格式</a></p>
<a id="more"></a>
<p>老牌的多功能截图工具 <a href="https://www.appinn.com/tag/picpick/" target="_blank" rel="noopener">PicPick</a> 于6月27日发布了 v6.2.1
版本，新增录屏功能，支持保存为 MP4 或 GIF
动画格式，支持麦克风或系统声音，简单易用。@<a href="https://www.appinn.com/picpick-6-2/" target="_blank" rel="noopener">Appinn</a></p>
<p><img src="https://img3.appinn.net/images/202206/picpick-screen-capturing.jpg!o" alt="老牌截图工具 PicPick 更新，新增录屏功能，支持 MP4/GIF格式"></p>
<h2 id="PicPick-新增录屏功能"><a class="header-anchor" href="#PicPick-新增录屏功能">¶</a>PicPick 新增录屏功能</h2>
<p>PicPick 的录屏功能有一个简洁的工具栏，可选全屏或区域录制，可以快速选择录制格式、声音，以及是否包括鼠标光标：</p>
<p>![老牌截图工具 PicPick 更新，新增录屏功能，支持 MP4/GIF 格式
32](<a href="https://img3.appinn.net/images/202206/screen-" target="_blank" rel="noopener">https://img3.appinn.net/images/202206/screen-</a>
appinn2022-06-29-12-52-43.jpg!o)</p>
<p>设置已自带中文，可以修改录屏质量、FPS、音频参数等，这些功能大部分都可以在工具栏上设置：</p>
<p>![老牌截图工具 PicPick 更新，新增录屏功能，支持 MP4/GIF 格式
33](<a href="https://img3.appinn.net/images/202206/screen-" target="_blank" rel="noopener">https://img3.appinn.net/images/202206/screen-</a>
appinn2022-06-29-12-51-14.jpg!o)</p>
<p>最后，PicPick 针对个人及家庭用户免费，但不提供自动更新，需要用户手动更新。</p>
<h2 id="获取"><a class="header-anchor" href="#获取">¶</a>获取</h2>
<ul>
<li><a href="https://kutt.appinn.net/GzqoNN" target="_blank" rel="noopener">官网</a></li>
<li><a href="https://d.appinn.com/picpick-6-2/" target="_blank" rel="noopener">搬运</a></li>
</ul>
<h2 id="PicPick-主要功能"><a class="header-anchor" href="#PicPick-主要功能">¶</a>PicPick 主要功能</h2>
<h3 id="屏幕截图"><a class="header-anchor" href="#屏幕截图">¶</a>屏幕截图</h3>
<p>截获屏幕截图、活动窗口的截图、桌面滚动窗口的截图和任何特定区域的截图等等</p>
<ul>
<li>支持多个监控环境、捕捉光标、自动保存和文件命名等功能</li>
<li>支持浮动部件捕获栏，这样您就可以非常方便地截图了</li>
<li>定制自己的键盘快捷方式。</li>
<li>全屏</li>
<li>活动窗口</li>
<li>窗口控制</li>
<li>滚动窗口</li>
<li>区域</li>
<li>固定区域</li>
<li>自由截图</li>
<li>重复上一次的截图</li>
<li>截图小部件</li>
<li>使用光标截图</li>
<li>延迟捕获</li>
<li>自动保存</li>
</ul>
<h3 id="图片编辑器"><a class="header-anchor" href="#图片编辑器">¶</a>图片编辑器</h3>
<p>内置图片编辑器并且包括最新的 Ribbon 风格菜单，可注释和标记图片</p>
<ul>
<li>绘画</li>
<li>插入文本</li>
<li>箭头、线条</li>
<li>形状</li>
<li>气球</li>
<li>标记工具</li>
<li>裁剪</li>
<li>调整尺寸</li>
<li>旋转</li>
<li>反转</li>
<li>灰度</li>
<li>马赛克</li>
<li>框架</li>
<li>水印</li>
<li>模糊</li>
<li>锐化</li>
<li>亮度</li>
<li>色相/饱和度</li>
<li>色彩平衡</li>
</ul>
<h3 id="保存、分享或发送"><a class="header-anchor" href="#保存、分享或发送">¶</a>保存、分享或发送</h3>
<p>一旦完成了获取和编辑你的照片之后，你可以保存、分享图片或将图片发送给其他人</p>
<ul>
<li>剪贴板</li>
<li>图片文件</li>
<li>PDF</li>
<li>打印机</li>
<li>网址</li>
<li>Dropbox</li>
<li>Google Drive</li>
<li>OneDrive</li>
<li>Box</li>
<li>脸书</li>
<li>推特</li>
<li>Skype</li>
<li>FTP服务器</li>
<li>电子邮件</li>
<li>微软 Word</li>
<li>微软 PowerPoint</li>
<li>微软 Excel</li>
<li>外部程序</li>
</ul>
<h3 id="颜色选择器"><a class="header-anchor" href="#颜色选择器">¶</a>颜色选择器</h3>
<p>使用内置的放大镜窗口来帮助你找到屏幕上准确的像素颜色代码。</p>
<p>支持 RGB，HTML，C++ 和 Delphi。</p>
<h3 id="调色板"><a class="header-anchor" href="#调色板">¶</a>调色板</h3>
<p>使用支持 RGB 和 HSV 的 Photoshop 的颜色选择器来探索和优化像素颜色代码。</p>
<h3 id="像素标尺"><a class="header-anchor" href="#像素标尺">¶</a>像素标尺</h3>
<p>帮助你测量对象的大小并将对象精确地放置在屏幕上。</p>
<p>支持水平和垂直方向、单位（像素，英寸和厘米）、DPI 设置(72, 96, 120, 300)和皮肤。.</p>
<h3 id="放大镜"><a class="header-anchor" href="#放大镜">¶</a>放大镜</h3>
<p>您可以使用便捷的放大镜工具来查看桌面上任何区域。</p>
<h3 id="瞄准器"><a class="header-anchor" href="#瞄准器">¶</a>瞄准器</h3>
<p>这个功能能够确定图片的相对坐标位置。</p>
<p>这在某些场合是非常实用，例如：开发 HTML 图片映射。</p>
<h3 id="量角器"><a class="header-anchor" href="#量角器">¶</a>量角器</h3>
<p>它能够帮助您测量屏幕上的任意角度。选择一个中心和一个位置,然后测量这个位置距离中心的角度。</p>
<p>这个功能可以应用于各种摄影、数学和图形应用中。</p>
<h3 id="白板"><a class="header-anchor" href="#白板">¶</a>白板</h3>
<p>你可以在桌面上设置虚拟白板。你可以用它来展示事物或者在桌面上绘画。</p>
<p>原文：<a href="https://www.appinn.com/picpick-6-2/" target="_blank" rel="noopener">https://www.appinn.com/picpick-6-2/</a></p>
<hr>
<h2 id="相关阅读"><a class="header-anchor" href="#相关阅读">¶</a>相关阅读</h2>
<ul>
<li><a href="https://www.appinn.com/picpick-180/" title="Permanent Link: 经典截图软件 PicPick 更新至 1.8.0 版本" target="_blank" rel="noopener">经典截图软件 PicPick 更新至 1.8.0 版本</a></li>
<li><a href="https://www.appinn.com/picpick/" title="Permanent Link: PicPick – 不可多得的经典截图工具" target="_blank" rel="noopener">PicPick - 不可多得的经典截图工具</a></li>
<li><a href="https://www.appinn.com/picpick-6-0/" title="Permanent Link: Picpick 6.0 发布，就多了一个黑暗模式？" target="_blank" rel="noopener">Picpick 6.0 发布，就多了一个黑暗模式？</a></li>
<li><a href="https://www.appinn.com/picpick-v2-2/" title="Permanent Link: PicPick v2.2 添加分享社会化网络功能" target="_blank" rel="noopener">PicPick v2.2 添加分享社会化网络功能</a></li>
<li><a href="https://www.appinn.com/picpick-4/" title="Permanent Link: 经典截图工具 PicPick 新增了许多小图章[Win]" target="_blank" rel="noopener">经典截图工具 PicPick 新增了许多小图章[Win]</a></li>
</ul>
<hr>
<p><a href="http://www.appinn.com/copyright/?utm_source=feeds&amp;utm_medium=copyright&amp;utm_campaign=feeds" title="版权声明" target="_blank" rel="noopener">(C)</a>2021 青小蛙 for
<a href="http://www.appinn.com/?utm_source=feeds&amp;utm_medium=appinn&amp;utm_campaign=feeds" title="本文来自小众软件" target="_blank" rel="noopener">小众软件</a> | [加入我们](<a href="http://www.appinn.com/join-" target="_blank" rel="noopener">http://www.appinn.com/join-</a>
us/?utm_source=feeds&amp;utm_medium=joinus&amp;utm_campaign=feeds &quot;加入小众软件&quot;) |
<a href="https://meta.appinn.net/c/faxian/?utm_source=feeds&amp;utm_medium=contribute&amp;utm_campaign=feeds" title="给小众软件投稿" target="_blank" rel="noopener">投稿</a> | [订阅指南](<a href="http://www.appinn.com/feeds-" target="_blank" rel="noopener">http://www.appinn.com/feeds-</a>
subscribe/?utm_source=feeds&amp;utm_medium=feedsubscribe&amp;utm_campaign=feeds
&quot;可以分类订阅小众，Windows/MAC/游戏&quot;)<br>
3659b075e72a5b7b1b87ea74aa7932ff<br>
<a href="https://www.appinn.com/picpick-6-2/#comments" title="to the
comments" target="_blank" rel="noopener">点击这里留言、和原作者一起评论</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」Typing Learner – 硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」[Windows/macOS]</title>
    <url>/public/2022/07/15/test/202207/2022-07-04-050658902152/</url>
    <content><![CDATA[<p>「转」<a href="https://www.appinn.com/typing-learner/" target="_blank" rel="noopener">Typing Learner – 硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」[Windows/macOS]</a></p>
<a id="more"></a>
<p><strong>Typing Learner</strong> 是一款能够从字幕中生成的词库（单词本）的 Windows、macOS
工具，它通过分析、过滤，洗掉熟悉的单词，只保留生词，然后进行键盘记忆背单词的过程，与众不同之处在于，背单词时会有原始字幕可以参考，并且还能实时预览电影片段。@[Appinn](<a href="https://www.appinn.com/typing-" target="_blank" rel="noopener">https://www.appinn.com/typing-</a>
learner/)</p>
<p><img src="https://img3.appinn.net/images/202207/appinn-2022-07-03t115649-847.jpg!o" alt="Typing Learner - 硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」[Windows/macOS]24"></p>
<p>就先来看这个直喊好家伙的 @<a href="https://meta.appinn.net/t/topic/33783/6?u=qingwa" target="_blank" rel="noopener">nicetry</a> 同学吧：</p>
<p>好家伙！好家伙！！好家伙！！！</p>
<p>刚开始不是太明白怎么用，琢磨了一会儿，自己新建了一个简单词库.txt,用Typing Learner洗出来一个词库，再用这个简单的词库去把视频里的熟词洗掉。</p>
<p>这个软件毫无疑问就是我一直想要的。赶紧注册了<a href="https://meta.appinn.net/" target="_blank" rel="noopener">小众软件论坛</a>来感谢感谢<img src="https://meta.appinn.net/images/emoji/apple/pray/2.png?v=12" alt=":pray:t2:"></p>
<p>最后有一点不成熟的小建议：：背单词词模式下可不可以设置快捷键到Ctrl+1，2，3之类的，按照从上往下的位置按对应着按就行了，替代Ctrl+P Ctrl+L
Ctrl+K Ctrl+E，这样不用去记忆快捷键。下面的视频也可以给前面标上数字，按对应的数字就播放对应的视频。</p>
<p><img src="https://meta.appinn.net/uploads/default/original/3X/7/0/703d3c1ec43d12c19dcbe065187813900b6cac2f.jpeg" alt="Typing Learner - 硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」[Windows/macOS]25"></p>
<p>还有就是内存447MB感觉有点高了，仅次于Chrome。</p>
<p>太激动了，感觉有点语无伦次，再次感谢<img src="https://meta.appinn.net/images/emoji/apple/pray/2.png?v=12" alt=":pray:t2:">。</p>
<hr>
<p>来看看开发者的介绍吧，青小蛙准备先用两天再说：</p>
<h2 id="Typing-Learner应用简介"><a class="header-anchor" href="#Typing-Learner应用简介">¶</a><a href="https://meta.appinn.net/t/topic/33783#h-5" target="_blank" rel="noopener"></a>Typing Learner应用简介</h2>
<p>可以用 MKV 视频生成词库（单词本），让每个单词都有具体的语境。然后通过语境记忆单词，句子，字幕。</p>
<p><img src="https://meta.appinn.net/uploads/default/optimized/3X/9/3/9347232d422f4859d1da3a5de397f7043e9bff2c_2_690x370.png" alt="Demo-Word-Dark"></p>
<h3 id><a class="header-anchor" href="#">¶</a></h3>
<p><a href="https://meta.appinn.net/uploads/default/original/3X/7/1/717d9b88167e22eec29871791858fc5487bad6af.png" target="_blank" rel="noopener"></a><a href="https://meta.appinn.net/uploads/default/original/3X/7/1/717d9b88167e22eec29871791858fc5487bad6af.png" target="_blank" rel="noopener"></a>1.
记忆单词</p>
<p>从 MKV 生成的词库（单词本）每个单词都有具体的语境，记忆单词时每个单词都可用重复输入多次，直到觉得记住为止，每个单元 20
个词，记完一个单元还有默写测试，检查记忆效果。</p>
<p>默认使用 Enter 键切换下一个单词，如果要使用自动切换，可以使用 Ctrl + A 开启自动切换。推荐第一次记忆不认
识的单词时，使用非自动切换，第二天复习的时候再打开自动切换。</p>
<h3 id="2-抄写字幕"><a class="header-anchor" href="#2-抄写字幕">¶</a>2. 抄写字幕</h3>
<p>可以抄写你感兴趣的电影、电视剧、纪录片、TED演讲、歌词。可以抄写多种语言的字幕。</p>
<h3 id="3-抄写文本"><a class="header-anchor" href="#3-抄写文本">¶</a>3. 抄写文本</h3>
<p>可以抄写 <a href="https://www.gutenberg.org/" target="_blank" rel="noopener">古腾堡计划</a> 所有 txt
格式的电子书，非<a href="https://www.gutenberg.org/" target="_blank" rel="noopener">古腾堡计划</a> 的电子书，抄写前可能需要先格式化，把每行的字母数量限制在 75
个以内。</p>
<p><img src="https://meta.appinn.net/uploads/default/original/3X/3/e/3ec4e34fcaf2f01c27d369b774683f0b0b363b04.png" alt="Typing Learner - 硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」[Windows/macOS]26"></p>
<h3 id="内置常用词库"><a class="header-anchor" href="#内置常用词库">¶</a>内置常用词库</h3>
<p>内置了常用词库(单词本)：四级、六级、专四、专八、考研、TOEFL、IELTS、GRE、GMAT、SAT、牛津核心词、北师大版高中英语、人教版英语、商务英语、外研版英语、新概念英语。这些词是没有链接字幕的，后续可用根据自己感兴趣，链接字幕词库。</p>
<h3 id="从视频中生成词库"><a class="header-anchor" href="#从视频中生成词库">¶</a>从视频中生成词库</h3>
<p>[可以用MKV 视频生成词库(单词本) ](<a href="https://github.com/tangshimin/typing-" target="_blank" rel="noopener">https://github.com/tangshimin/typing-</a>
learner/wiki/%E4%BB%8E-MKV-%E8%A7%86%E9%A2%91%E7%94%9F%E6%88%90%E8%AF%8D%E5%BA%93)，让每个单词都有具体的语境。有了这个功能，今后就可以一边追美剧一边学英语了。</p>
<p><img src="https://meta.appinn.net/uploads/default/original/3X/2/7/279e34036387e4f855eb0f8a64f40e7c0b3f2f18.png" alt="Typing Learner - 硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」[Windows/macOS]27"></p>
<p>过滤词库，过滤熟悉的单词。</p>
<p>歌词转字幕</p>
<p>合并词库，可以把一整季的电视剧生成的多个字幕词库合并成一个词库。</p>
<p>学习完一章之后，可以选择进入默写模式，在默写模式整个章节的单词是重新随机排序的，默写完了会出现默写的正确率。</p>
<p>学习完整个词库之后，还有一个随机排序整个词库的功能。</p>
<h2 id="获取"><a class="header-anchor" href="#获取">¶</a><a href="https://meta.appinn.net/t/topic/33783#github-6" target="_blank" rel="noopener"></a>获取</h2>
<ul>
<li><a href="https://kutt.appinn.net/3wXLui" target="_blank" rel="noopener">GitHub</a></li>
</ul>
<p>更多细节参见发现频道：<a href="https://meta.appinn.net/t/topic/33783" target="_blank" rel="noopener">https://meta.appinn.net/t/topic/33783</a></p>
<p>青小蛙觉得，通过喜欢的剧集字幕来学习英文，一直都是一条捷径，通往内心的捷径，有好工具值得试试。</p>
<p>原文：<a href="https://www.appinn.com/typing-learner/" target="_blank" rel="noopener">https://www.appinn.com/typing-learner/</a></p>
<hr>
<h2 id="相关阅读"><a class="header-anchor" href="#相关阅读">¶</a>相关阅读</h2>
<ul>
<li><a href="https://www.appinn.com/typing-io/" title="Permanent Link: Typing.io – 编程语言打字练习 [Web]" target="_blank" rel="noopener">Typing.io - 编程语言打字练习 [Web]</a></li>
<li><a href="https://www.appinn.com/typing-stats/" title="Permanent Link: Typing Stats – 找出你最强壮的手指[Firefox]" target="_blank" rel="noopener">Typing Stats - 找出你最强壮的手指[Firefox]</a></li>
<li><a href="https://www.appinn.com/search-engine-switcher/" title="Permanent Link: 搜索引擎切换器 – 快速在 8 款搜索引擎间切换[油猴脚本]" target="_blank" rel="noopener">搜索引擎切换器 - 快速在 8 款搜索引擎间切换[油猴脚本]</a></li>
</ul>
<hr>
<p><a href="http://www.appinn.com/copyright/?utm_source=feeds&amp;utm_medium=copyright&amp;utm_campaign=feeds" title="版权声明" target="_blank" rel="noopener">(C)</a>2021 青小蛙 for
<a href="http://www.appinn.com/?utm_source=feeds&amp;utm_medium=appinn&amp;utm_campaign=feeds" title="本文来自小众软件" target="_blank" rel="noopener">小众软件</a> | [加入我们](<a href="http://www.appinn.com/join-" target="_blank" rel="noopener">http://www.appinn.com/join-</a>
us/?utm_source=feeds&amp;utm_medium=joinus&amp;utm_campaign=feeds &quot;加入小众软件&quot;) |
<a href="https://meta.appinn.net/c/faxian/?utm_source=feeds&amp;utm_medium=contribute&amp;utm_campaign=feeds" title="给小众软件投稿" target="_blank" rel="noopener">投稿</a> | [订阅指南](<a href="http://www.appinn.com/feeds-" target="_blank" rel="noopener">http://www.appinn.com/feeds-</a>
subscribe/?utm_source=feeds&amp;utm_medium=feedsubscribe&amp;utm_campaign=feeds
&quot;可以分类订阅小众，Windows/MAC/游戏&quot;)<br>
3659b075e72a5b7b1b87ea74aa7932ff<br>
<a href="https://www.appinn.com/typing-learner/#comments" title="to the
comments" target="_blank" rel="noopener">点击这里留言、和原作者一起评论</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」语雀，即将开源！</title>
    <url>/public/2022/07/15/test/202207/2022-07-14-102828713392/</url>
    <content><![CDATA[<p>「转」<a href="https://zhuanlan.zhihu.com/p/540713275" target="_blank" rel="noopener">语雀，即将开源！</a></p>
<a id="more"></a>
<p>选择一款合适、称手的云笔记应用，可谓是每个程序员必须面临的一大难题之一。</p>
<p>依我个人需求而言，云笔记应用最广泛的应用，就是撰写技术文档、编程笔记，以及梳理项目架构、团队工作流程。</p>
<p>从上述几点需求来看，这款笔记需要满足于集笔记撰写、文档管理、团队协作于一体，且对中文用户支持度友好。</p>
<p>我目前在用的，是一款叫「 <strong>语雀</strong> 」的文档与知识库工具，由支付宝研发出品。</p>
<p>2018 年的时候，我便早早接触到了这款工具，当时使用需求比较简单，就是在上面记录一些琐碎的编程笔记，如开发环境配置、Bug 问题总结、工具使用指南等等。</p>
<p>直到 2019 年，我在上面看到有人频频发布了不少优质编程资料（如《前端九部》），才意识到，这东西原来还能这么玩。</p>
<p>前阵子在水友群里看到有人在说，语雀接下来要开源了，才突然想起有这么一款优质工具还没跟大家分享过。</p>
<p>今天就来看看，这款号称最懂程序员的云笔记，到底有多好用。</p>
<p><img src="https://pic2.zhimg.com/v2-9d6fff6bdaf3e5e7cb22881349989149_b.jpg" alt></p>
<h3 id="功能特性"><a class="header-anchor" href="#功能特性">¶</a><strong>功能特性</strong></h3>
<h3 id="1-特色卡片"><a class="header-anchor" href="#1-特色卡片">¶</a><strong>1. 特色卡片</strong></h3>
<p>对于平时操作电脑习惯用快捷键的我来说，「特色卡片」可以说是我使用频率最高的产品功能之一。</p>
<p>当你打开编辑器，敲下斜杆 <code>/</code>时，它便会展示各种可供插入的编辑器特性。</p>
<p>就像这样：</p>
<p><img src="https://pic2.zhimg.com/v2-9568ee56f92fd76d18d463a026a3c3b9_b.gif" alt></p>
<p>斜杆 <code>/</code>快捷键支持快速插入视频、图片、附件、代码块、思维导图、Emoji 表情等诸多内容，还可以添加日历、投票、打卡等各种互动程序。</p>
<p><img src="https://pic2.zhimg.com/v2-016dae9ed93025690a81f7c6bfedcf69_b.jpg" alt></p>
<p><strong>2. 数据表</strong></p>
<p>在当今这个数据大爆发时代，我们对数据的处理与操作也更加频繁，Excel 那干巴巴的数据列表，已经很难满足我的日常使用需求。</p>
<p>而在语雀中，有一项不同于 Excel 的数据表功能，就是能直接将同一份数据，按照不同的视图进行切换展示。</p>
<p><img src="https://pic4.zhimg.com/v2-fe68f93a15b8229ca59eb61c188997b7_b.gif" alt></p>
<p>在将数据录入完成之后，即可一键切换至相册、表格、看板等视图，效果颇为惊艳。</p>
<p><strong>3. 在线绘图</strong></p>
<p>平时撰写各种技术文档或编程笔记时，流程图、思维导图、架构图，基本上是无往不利的几大神器。</p>
<p>正所谓「一图胜千言」，将不易于理解的流程与技术，通过直观的图片进行表达，才能减少他人的沟通与学习成本。</p>
<p>可能是知道这项需求对于程序员的重要性，因此语雀团队在提供基础的绘图功能外，还额外加入了一个模板生成功能。</p>
<p>你可以基于官方提供的或自行创建的模板，来快速生成指定图形。</p>
<p><img src="https://pic3.zhimg.com/v2-df9c620071f3d445d12bd823ddaef6da_b.gif" alt></p>
<p>这种方式省时又省力，也很符合程序员「Don't repeat yourself」的编程理念。</p>
<p>如果你用语法来完成图形绘制，那也没问题。</p>
<p>还记得咱们前面提到的快捷键<code>/</code>吗？敲下它，然后选择对应的模板，或手写语法内容，即可在线完成绘制。</p>
<p><img src="https://pic3.zhimg.com/v2-35d59a911ad706313499ce5ed1999b6e_b.gif" alt></p>
<p><strong>4. 个人知识库</strong></p>
<p>在技术圈内，偶尔会看到不少程序员使用 GitBook 来撰写技术教程，但是对国内用户来说，Gitbook 的访问速度，以及产品友好度都有很大提升空间。</p>
<p>语雀的文档管理功能，是我见过为数不多，能够超越 Gitbook 的国产笔记应用。</p>
<p>基于它所提供的功能，便可轻而易举的打造出一个属于自己的编程知识库。</p>
<p>当你在线浏览某个技术知识库时，那种感觉，宛如在看一本精心写就的编程书籍。</p>
<p><img src="https://pic1.zhimg.com/v2-94a7bf9f4a5076267097f370fa70b604_b.jpg" alt></p>
<p><strong>5. 数据安全</strong></p>
<p>最近几年，有不少互联网公司都被爆出存在数据泄露的问题，究其根本原因，还是平台的网络安全防控工作没做好。</p>
<p>因此，现在我在挑选一款合适的互联网产品时，除了将用户体验，交互设计考量在内之余，还会着重了解它的安全性。</p>
<p>在这一点上，语雀就做的蛮好，多地备份、双重加密、ISO 安全认证体系，该有的东西，基本上都有了。</p>
<p>毕竟在其背后提供安全技术支持的，可是支付宝的团队，这块要没整好，那不得啪啪打脸？</p>
<p><img src="https://pic3.zhimg.com/v2-f9a480b8ed2058ae319baf49e3c08556_b.jpg" alt></p>
<h3 id="总结"><a class="header-anchor" href="#总结">¶</a><strong>总结</strong></h3>
<p>除了上述功能之外，对于程序员来说，语雀还支持 LaTeX 数学公式、代码块高亮、Markdown 编辑、PDF 在线上传与预览等多种功能。</p>
<p>综合体验下来，基本上，这可以说是一款专为程序员而生的云笔记应用了。从各个方面看，也十分贴近我的使用需求。</p>
<p>再过一阵子，语雀项目的各个组件，以及相关代码，应该就会陆续在 GitHub
开源，感兴趣的同学可以留意下。未来项目正式开源，我们也会在第一时间到公众号通知大家。</p>
<p>文中所提到的所有开源项目与工具，已收录至 GitHubDaily 的开源项目列表中。</p>
<p>该列表包含了 GitHub 上诸多高质量、有趣实用的开源技术教程、开发者工具、编程网站等内容。</p>
<p>从 2015 年至今，累积分享 3500+ 个开源项目，有需要的，可访问下方 GitHub 地址自取：</p>
<p>GitHub： <em><a href="https://link.zhihu.com/?target=https%3A//github.com/GitHubDaily/GitHubDaily" target="_blank" rel="noopener">https://
github.com/GitHubDaily/GitHubDaily</a></em></p>
<p><img src="https://pic3.zhimg.com/v2-99a7200d98bb42b7bbc4d7990e1972f2_b.jpg" alt></p>
<p>好了，今天的分享到此结束，感谢大家抽空阅读，我们下期再见。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>「202207月度汇报」ttrss</title>
    <url>/public/2022/07/15/test/202207/202207/</url>
    <content><![CDATA[<p>total: 13</p>
<a id="more"></a>
<h2 id="BGmi-–-自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人"><a class="header-anchor" href="#BGmi-–-自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人">¶</a><a href="https://www.appinn.com/bgmi/" target="_blank" rel="noopener">BGmi – 自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人</a></h2>
<p>pubdata:2022-06-30 02:48:00
markdate:2022-07-01 06:32:58.020141</p>
<h2 id="老牌截图工具-PicPick-更新，新增录屏功能，支持-MP4-GIF-格式"><a class="header-anchor" href="#老牌截图工具-PicPick-更新，新增录屏功能，支持-MP4-GIF-格式">¶</a><a href="https://www.appinn.com/picpick-6-2/" target="_blank" rel="noopener">老牌截图工具 PicPick 更新，新增录屏功能，支持 MP4/GIF 格式</a></h2>
<p>pubdata:2022-06-29 07:19:19
markdate:2022-07-02 04:11:20.453414</p>
<h2 id="白板与笔记融合：我的四个氢图使用场景"><a class="header-anchor" href="#白板与笔记融合：我的四个氢图使用场景">¶</a><a href="https://sspai.com/post/73246" target="_blank" rel="noopener">白板与笔记融合：我的四个氢图使用场景</a></h2>
<p>pubdata:2022-06-30 03:30:02
markdate:2022-07-03 01:08:35.583781</p>
<h2 id="跨时空圆桌：伟大创作者们如何安排日常生活"><a class="header-anchor" href="#跨时空圆桌：伟大创作者们如何安排日常生活">¶</a><a href="https://sspai.com/post/73779" target="_blank" rel="noopener">跨时空圆桌：伟大创作者们如何安排日常生活</a></h2>
<p>pubdata:2022-06-15 09:30:00
markdate:2022-07-03 01:50:35.971655</p>
<h2 id="Typing-Learner-–-硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」-Windows-macOS"><a class="header-anchor" href="#Typing-Learner-–-硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」-Windows-macOS">¶</a><a href="https://www.appinn.com/typing-learner/" target="_blank" rel="noopener">Typing Learner – 硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」[Windows/macOS]</a></h2>
<p>pubdata:2022-07-03 04:07:39
markdate:2022-07-04 05:06:58.902152</p>
<h2 id="创建自己的第一个-Power-Automate-工作流，从此繁琐操作是路人"><a class="header-anchor" href="#创建自己的第一个-Power-Automate-工作流，从此繁琐操作是路人">¶</a><a href="https://sspai.com/post/73710" target="_blank" rel="noopener">创建自己的第一个 Power Automate 工作流，从此繁琐操作是路人</a></h2>
<p>pubdata:2022-07-05 10:44:47
markdate:2022-07-06 11:29:55.648077</p>
<h2 id="为-WSL-配置这些新功能，不用虚拟机也能体验完整-Linux"><a class="header-anchor" href="#为-WSL-配置这些新功能，不用虚拟机也能体验完整-Linux">¶</a><a href="https://sspai.com/post/74167" target="_blank" rel="noopener">为 WSL 配置这些新功能，不用虚拟机也能体验完整 Linux</a></h2>
<p>pubdata:2022-07-08 03:30:00
markdate:2022-07-09 03:08:43.747852</p>
<h2 id="当飞盘成为人类的玩具，我们该如何参与这场游戏"><a class="header-anchor" href="#当飞盘成为人类的玩具，我们该如何参与这场游戏">¶</a><a href="https://sspai.com/post/73505" target="_blank" rel="noopener">当飞盘成为人类的玩具，我们该如何参与这场游戏</a></h2>
<p>pubdata:2022-06-06 08:00:00
markdate:2022-07-10 01:36:40.114938</p>
<h2 id="走进小众但不冷门的房车世界"><a class="header-anchor" href="#走进小众但不冷门的房车世界">¶</a><a href="https://sspai.com/post/74043" target="_blank" rel="noopener">走进小众但不冷门的房车世界</a></h2>
<p>pubdata:2022-07-01 08:04:43
markdate:2022-07-10 02:09:34.733003</p>
<h2 id="从盲目崇拜到理性使用，谈谈我眼中的「双向链接」"><a class="header-anchor" href="#从盲目崇拜到理性使用，谈谈我眼中的「双向链接」">¶</a><a href="https://sspai.com/post/73407" target="_blank" rel="noopener">从盲目崇拜到理性使用，谈谈我眼中的「双向链接」</a></h2>
<p>pubdata:2022-05-27 06:31:27
markdate:2022-07-11 14:31:37.724795</p>
<h2 id="打开终端总有好心情：我的美化方案及配置分享"><a class="header-anchor" href="#打开终端总有好心情：我的美化方案及配置分享">¶</a><a href="https://sspai.com/post/74216" target="_blank" rel="noopener">打开终端总有好心情：我的美化方案及配置分享</a></h2>
<p>pubdata:2022-07-11 08:00:51
markdate:2022-07-12 04:52:00.122103</p>
<h2 id="咖啡美酒冷泡茶，这些消暑饮品在家就能动手做"><a class="header-anchor" href="#咖啡美酒冷泡茶，这些消暑饮品在家就能动手做">¶</a><a href="https://sspai.com/post/74196" target="_blank" rel="noopener">咖啡美酒冷泡茶，这些消暑饮品在家就能动手做</a></h2>
<p>pubdata:2022-07-10 07:17:11
markdate:2022-07-12 05:03:55.504330</p>
<h2 id="语雀，即将开源！"><a class="header-anchor" href="#语雀，即将开源！">¶</a><a href="https://zhuanlan.zhihu.com/p/540713275" target="_blank" rel="noopener">语雀，即将开源！</a></h2>
<p>pubdata:2022-07-12 08:19:47
markdate:2022-07-14 10:28:28.713392</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>茅盾文学奖、诺贝尔文学奖</title>
    <url>/public/2019/02/05/readings/nobel_maodun_literature/</url>
    <content><![CDATA[<p><strong>前言</strong>
世界和民族的优秀作品。
漫漫长路，读书成长。</p>
<h2 id="茅盾文学奖"><a class="header-anchor" href="#茅盾文学奖">¶</a>茅盾文学奖</h2>
<p><strong>第十届茅盾文学奖获奖篇目 (2015—2018)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《人世间》</td>
<td>梁晓声</td>
<td>中国青年出版社</td>
</tr>
<tr>
<td>《牵风记》</td>
<td>徐怀中</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《北上》</td>
<td>徐则臣</td>
<td>北京十月文艺出版社</td>
</tr>
<tr>
<td>《主角》</td>
<td>陈 彦</td>
<td>北京十月文艺出版社</td>
</tr>
<tr>
<td>《应物兄》</td>
<td>李 洱</td>
<td>人民文学出版社</td>
</tr>
</tbody>
</table>
<p><a href="https://mp.weixin.qq.com/s/j-siAAyFx2wa2sc4k0qZyQ" target="_blank" rel="noopener"> 中国作家网 第十届茅盾文学奖揭晓（附5位获奖作家介绍）</a></p>
<a id="more"></a>
<p><strong>第九届茅盾文学奖获奖篇目 (2011—2014)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《江南三部曲》</td>
<td>格　非</td>
<td>上海文艺出版社</td>
</tr>
<tr>
<td>《这边风景》</td>
<td>王　蒙</td>
<td>花城出版社</td>
</tr>
<tr>
<td>《生命册》</td>
<td>李佩甫</td>
<td>作家出版社</td>
</tr>
<tr>
<td>《繁花》</td>
<td>金宇澄</td>
<td>上海文艺出版社</td>
</tr>
<tr>
<td>《黄雀记》</td>
<td>苏　童</td>
<td>作家出版社</td>
</tr>
</tbody>
</table>
<p><strong>第八届茅盾文学奖获奖篇目 (2007—2010)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《你在高原》</td>
<td>张　炜</td>
<td>作家出版社</td>
</tr>
<tr>
<td>《天行者》</td>
<td>刘醒龙</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《蛙》</td>
<td>莫　言</td>
<td>上海文艺出版社</td>
</tr>
<tr>
<td>《推拿》</td>
<td>毕飞宇</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《一句顶一万句》</td>
<td>刘震云</td>
<td>长江文艺出版社</td>
</tr>
</tbody>
</table>
<p><strong>第七届茅盾文学奖获奖篇目 (2003—2006)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《秦腔》</td>
<td>贾平凹</td>
<td>作家出版社</td>
</tr>
<tr>
<td>《额尔古纳河右岸》</td>
<td>迟子建</td>
<td>北京十月文艺出版社</td>
</tr>
<tr>
<td>《湖光山色》</td>
<td>周大新</td>
<td>作家出版社</td>
</tr>
<tr>
<td>《暗算》</td>
<td>麦　家</td>
<td>世界知识出版社、人民文学出版社</td>
</tr>
</tbody>
</table>
<p><strong>第六届茅盾文学奖获奖篇目 (1999—2002)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《张居正》</td>
<td>熊召政</td>
<td>长江文艺出版社</td>
</tr>
<tr>
<td>《无字》</td>
<td>张　洁</td>
<td>北京十月文艺出版社</td>
</tr>
<tr>
<td>《历史的天空》</td>
<td>徐贵祥</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《英雄时代》</td>
<td>柳建伟</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《东藏记》</td>
<td>宗　璞</td>
<td>人民文学出版社</td>
</tr>
</tbody>
</table>
<p><strong>第五届茅盾文学奖获奖篇目 (1995—1998)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《抉择》</td>
<td>张　平</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《尘埃落定》</td>
<td>阿　来</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《长恨歌》</td>
<td>王安忆</td>
<td>作家出版社</td>
</tr>
<tr>
<td>《茶人三部曲》(一、二)</td>
<td>王旭烽</td>
<td>浙江文艺出版社</td>
</tr>
</tbody>
</table>
<p><strong>第四届茅盾文学奖获奖篇目 (1989—1994)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《战争和人》(一、二、三)</td>
<td>王　火</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《白鹿原》（修订本）</td>
<td>陈忠实</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《白门柳》(一、二)</td>
<td>刘斯奋</td>
<td>中国青年出版社</td>
</tr>
<tr>
<td>《骚动之秋》</td>
<td>刘玉民</td>
<td>人民文学出版社</td>
</tr>
</tbody>
</table>
<p><strong>第三届茅盾文学奖获奖篇目 (1985—1988)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《平凡的世界》</td>
<td>路　遥</td>
<td>中国文联出版公司</td>
</tr>
<tr>
<td>《少年天子》</td>
<td>凌　力</td>
<td>北京十月文艺出版社</td>
</tr>
<tr>
<td>《都市风流》</td>
<td>孙力、余小惠</td>
<td>浙江文艺出版社</td>
</tr>
<tr>
<td>《第二个太阳》</td>
<td>刘白羽</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《穆斯林的葬礼》</td>
<td>霍　达</td>
<td>北京十月文艺出版社</td>
</tr>
<tr>
<td>荣　誉　奖</td>
<td></td>
<td></td>
</tr>
<tr>
<td>《浴血罗霄》</td>
<td>萧　克</td>
<td>解放军文艺出版社</td>
</tr>
<tr>
<td>《金瓯缺》</td>
<td>徐兴业</td>
<td>海峡文艺出版社</td>
</tr>
</tbody>
</table>
<p><strong>第二届茅盾文学奖获奖篇目 (1982—1984)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《黄河东流去》</td>
<td>李　准</td>
<td>北京出版社</td>
</tr>
<tr>
<td>《沉重的翅膀》（修订本）</td>
<td>张　洁</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《钟鼓楼》</td>
<td>刘心武</td>
<td>人民文学出版社</td>
</tr>
</tbody>
</table>
<p><strong>第一届茅盾文学奖获奖篇目 (1977—1981)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《许茂和他的女儿们》</td>
<td>周克芹</td>
<td>百花文艺出版社</td>
</tr>
<tr>
<td>《东方》</td>
<td>魏　巍</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《将军吟》</td>
<td>莫应丰</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《李自成》 （第二卷）</td>
<td>姚雪垠</td>
<td>中国青年出版社</td>
</tr>
<tr>
<td>《芙蓉镇》</td>
<td>古　华</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《冬天里的春天》</td>
<td>李国文</td>
<td>人民文学出版社</td>
</tr>
</tbody>
</table>
<h2 id="诺贝尔文学奖"><a class="header-anchor" href="#诺贝尔文学奖">¶</a>诺贝尔文学奖</h2>
<p><a href="https://zh.wikipedia.org/wiki/%E8%AB%BE%E8%B2%9D%E7%88%BE%E6%96%87%E5%AD%B8%E7%8D%8E%E5%BE%97%E4%B8%BB%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">link</a></p>
<p>2017年得主：黑石一雄</p>
<p>日裔英国作家</p>
<p>代表作：《长日留痕》《无可慰藉》《上海孤儿》《被掩埋的巨人》</p>
<p>获奖理由：他的小说带有强大的情感力量，解开了我们与世界连接的虚幻深渊。</p>
<p>2016年得主：鲍勃·迪伦</p>
<p>美国作家</p>
<p>代表作：《答案在风中飘》、《像一块滚石》、《时光慢慢流逝》</p>
<p>获奖理由：在伟大的美国民谣传统中创造出新的诗歌意境</p>
<p>2015年</p>
<p>得主：斯韦特兰娜·阿列克谢耶维奇（女）</p>
<p>白俄罗斯作家</p>
<p>代表作：《切尔诺贝利的回忆：核灾难口述史》</p>
<p>获奖理由：世界文坛最高水准的感人作品，讲述了这个时代的苦难和勇气。</p>
<p>2014年得主：帕特里克·莫迪亚诺</p>
<p>法国作家</p>
<p>代表作：《暗店街》《星形广场》《青春咖啡馆》</p>
<p>获奖理由：唤醒了对最难以捕捉的人类命运的记忆和揭露了对人类生活的占领。</p>
<p>2013年得主：艾丽斯·芒罗(女)</p>
<p>代表作：《快乐影子舞》《逃离》</p>
<p>获奖理由：当代短篇小说大师。</p>
<p>2012年得主：莫言</p>
<p>中国作家</p>
<p>代表作：《红高粱》《丰乳肥臀》《蛙》</p>
<p>获奖理由：用魔幻现实主义的写作手法，将民间故事、历史事件与当代背景融为一体。</p>
<p>2011年得主：托马斯·特兰斯特勒默</p>
<p>瑞典诗人</p>
<p>代表作：《十七首诗》《途中的秘密》</p>
<p>获奖理由：他以凝炼、简洁的形象，以全新视角带我们接触现实。</p>
<p>2010年得主：马里奥·巴尔加斯·略萨</p>
<p>秘鲁与西班牙双重国籍的作家及诗人</p>
<p>代表作：《绿房子》《世界末日之战》《城市与狗》</p>
<p>获奖理由：他“对权力结构的制图般的描绘和对个人反抗的精致描写”。</p>
<p>2009年得主：赫塔·米勒</p>
<p>罗马尼亚裔的德国女性小说家、诗人、散文家。</p>
<p>代表作：《呼吸钟摆》《河水奔流》《行走界线》《狐狸那时已是猎人》</p>
<p>获奖理由：专注于诗歌以及散文的率真，描写了失业人群的生活图景。</p>
<p>2008年得主：勒·克莱齐奥</p>
<p>代表作：《战争》</p>
<p>获奖理由：展现了新的起点、诗意的冒险和感官狂喜；作为探险者，发掘了隐藏于主流文明底部和外部的人性。</p>
<p>2007年得主：多丽丝·莱辛（女）</p>
<p>英国作家</p>
<p>代表作：《金色笔记》</p>
<p>获奖理由：她用怀疑、热情、构想的力量来审视一个分裂的文明，其作品如同一部女性经验的史诗。</p>
<p>2006年得主：奥尔罕·帕慕克</p>
<p>土耳其作家</p>
<p>代表作：《我的名字叫红》</p>
<p>获奖理由：在寻找故乡的忧郁灵魂时，发现了文化碰撞和融合中的新象征。</p>
<p>2005年得主：哈罗德·品特</p>
<p>英国剧作家。</p>
<p>代表作：《看房者》《生日晚会》《归家》</p>
<p>获奖理由：他的戏剧以诗和画的创造性，深入表现了人类长期置身其中的处境。</p>
<p>2004年得主：埃尔弗里德·耶利内克（女）</p>
<p>奥地利女作家。</p>
<p>代表作：《钢琴教师》《死者的孩子》</p>
<p>获奖理由：因为她的小说和戏剧具有音乐般的韵律，她的作品以非凡的充满激情的语言揭示了社会上的陈腐现象及其禁锢力的荒诞不经。</p>
<p>2003年得主：约翰·马克斯韦尔·库切</p>
<p>南非作家。</p>
<p>代表作：《耻》《幽暗之乡》</p>
<p>获奖理由：精准地刻画了众多假面具下的人性本质。</p>
<p>2002年得主：凯尔泰斯·伊姆雷</p>
<p>匈牙利作家。</p>
<p>代表作：《无形的命运》</p>
<p>获奖理由：表彰他对脆弱的个人在对抗强大的野蛮强权时痛苦经历的深刻刻画以及他独特的自传体文学风格。</p>
<p>2001年得主：维·苏·奈保尔</p>
<p>印度裔英国作家</p>
<p>代表作：《神秘的按摩师》《米格尔街》</p>
<p>获奖理由：其著作将极具洞察力的叙述与不为世俗左右的探索融为一体，是驱策我们从扭曲的历史中探寻真实的动力。</p>
<p>2000年得主：高行健</p>
<p>法籍华人，剧作家、小说家。</p>
<p>代表作：《灵山》</p>
<p>获奖理由：其作品的普遍价值，刻骨铭心的洞察力和语言的丰富机智，为中文小说和艺术戏剧开辟了新的道路。</p>
<p>1999年得主：君特·格拉斯</p>
<p>德国作家。</p>
<p>代表作：《铁皮鼓》</p>
<p>获奖理由：其嬉戏之中蕴含悲剧色彩的寓言描摹出了人类淡忘的历史面目。</p>
<p>1998年得主：若泽·萨拉马戈</p>
<p>葡萄牙记者、作家</p>
<p>代表作：《失明症漫记》</p>
<p>获奖理由：由于他那极富想象力、同情心和颇具反讽意味的作品,我们得以反复重温那一段难以捉摸的历史。</p>
<p>1997年得主：达里奥·福</p>
<p>意大利讽刺剧作家</p>
<p>代表作：《喜剧的神秘》《一个无政府主义者的死亡》</p>
<p>获奖理由：其在鞭笞权威，褒扬被蹂躏者可贵的人格品质方面所取得的成就堪与中世纪《弄臣》一书相媲美。</p>
<p>1996年得主：维斯瓦娃·辛波丝卡（女）</p>
<p>波兰诗人</p>
<p>代表作：《向自己提出问题》《呼唤雪人》</p>
<p>获奖理由：由于其在诗歌艺术中警辟精妙的反讽，挖掘出了人类一点一滴的现实生活背后历史更迭与生物演化的深意。</p>
<p>1995年得主：谢默斯·希尼</p>
<p>爱尔兰诗人</p>
<p>代表作：《通向黑暗之门》《在外过冬》</p>
<p>获奖理由：由于其作品洋溢着抒情之美,包容着深邃的伦理,揭示出日常生活和现实历史的奇迹。</p>
<p>1994年得主：大江健三郎</p>
<p>日本小说家</p>
<p>代表作：《个人的体验》《万延元年的足球队》</p>
<p>获奖理由：通过诗意的想象力,创造出一个把现实与神话紧密凝缩在一起的想象世界，描绘现代的芸芸众生相，给人们带来了冲击。</p>
<p>1993年得主：托妮·莫里森（女）</p>
<p>美国作家</p>
<p>代表作：《最蓝的眼睛》《所罗门之歌》</p>
<p>获奖理由：其作品想象力丰富,富有诗意，显示了美国现实生活的重要方面。</p>
<p>1992年得主：德里克·沃尔科特</p>
<p>圣卢西亚诗人</p>
<p>代表作：《西印度群岛》</p>
<p>获奖理由：他的作品具有巨大的启发性和广阔的历史视野，是其献身多种文化的结果。</p>
<p>1991年得主：纳丁·戈迪默（女）</p>
<p>南非作家</p>
<p>代表作：《七月的人民》</p>
<p>获奖理由：以强烈而直接的笔触，描写周围复杂的人际与社会关系，其史诗般壮丽的作品，对人类大有裨益。</p>
<p>1990年得主：奥克塔维奥·帕斯</p>
<p>墨西哥诗人</p>
<p>代表作：《太阳石》</p>
<p>获奖理由：他的作品充满激情，视野开阔，渗透着感悟的智慧并体现了完美的人道主义。</p>
<p>1989年得主：卡米洛·何塞·塞拉</p>
<p>代表作：《为亡灵弹奏》</p>
<p>获奖理由：带有浓郁情感的丰富而精简的描写，对人类弱点达到的令人难以企及的想象力。</p>
<p>1988年得主：纳吉布·马哈富兹</p>
<p>埃及作家。</p>
<p>代表作：《街魂》</p>
<p>获奖理由：他通过大量刻画入微的作品—洞察一切的现实主义，唤起人们树立雄心—形成了全人类所欣赏的阿拉伯语言艺术。</p>
<p>1987年得主：约瑟夫·布罗茨基</p>
<p>苏裔美籍诗人</p>
<p>代表作：《从彼得堡到斯德哥尔摩》</p>
<p>获奖理由：他的作品超越时空限制，无论在文学上或是敏感问题方面都充分显示出他广阔的思想及浓郁的诗意。</p>
<p>1986年得主：沃莱·索因卡</p>
<p>尼日利亚剧作家、诗人、小说家、评论家</p>
<p>代表作：《雄狮与宝石》</p>
<p>获奖理由：他以广博的文化视野创作了富有诗意的关于人生的戏剧。</p>
<p>1985年得主：克洛德·西蒙</p>
<p>法国小说家</p>
<p>代表作：《弗兰德公路·农事诗》</p>
<p>获奖理由：由于他善于把诗人和画家的丰富想象与深刻的时间意识融为一 体，对人类的生存状况进行了深入的描写。</p>
<p>1984年得主：雅罗斯拉夫·塞弗尔特</p>
<p>捷克诗人</p>
<p>代表作：《紫罗兰》</p>
<p>获奖理由：他的诗富于独创性、新颖、栩栩如生，表现了人的不屈不挠精神和多才多艺的渴求解放的形象。</p>
<p>1983年得主：威廉·戈尔丁</p>
<p>英国作家</p>
<p>代表作：《蝇王·金字塔》</p>
<p>获奖理由：具有清晰的现实主义叙述技巧以及虚构故事的多样性与普遍性，阐述了今日世界人类的状况。</p>
<p>1982年得主：加夫列尔·加西亚·马尔克斯</p>
<p>哥伦比亚记者、作家</p>
<p>代表作：《百年孤独》《霍乱时期的爱情》</p>
<p>获奖理由：由于其长篇小说以结构丰富的想象世界，其中糅混着魔幻与现实，反映出一整个大陆的生命矛盾。</p>
<p>1981年得主：埃利亚斯·卡内蒂</p>
<p>英国德语作家</p>
<p>代表作：《迷茫》</p>
<p>获奖理由：作品具有宽广的视野、丰富的思想和艺术力量。</p>
<p>1980年得主：切斯拉夫·米沃什</p>
<p>波兰诗人</p>
<p>代表作：《拆散的笔记簿》</p>
<p>获奖理由：不妥协的敏锐洞察力，描述了人在激烈冲突的世界中的暴露状态。</p>
<p>1979年得主：奥德修斯·埃里蒂斯</p>
<p>希腊诗人</p>
<p>代表作：《英雄挽歌》</p>
<p>获奖理由：他的诗，以希腊传统为背景，用感觉的力量和理智的敏锐，描写现代人为自由和创新而奋斗。</p>
<p>1978年得主：艾萨克·巴什维斯·辛格</p>
<p>美国作家</p>
<p>代表作：《魔术师·原野王》</p>
<p>获奖理由：他的充满激情的叙事艺术，这种既扎根于波兰人的文化传统，又反映了人类的普遍处境。</p>
<p>1977年得主：阿莱克桑德雷·梅洛</p>
<p>西班牙诗人</p>
<p>代表作：《天堂的影子》</p>
<p>获奖理由：他的作品继承了西班牙抒情诗的传统和吸取了今天流派的风格，描述了人在宇宙和当今社会中的状况。</p>
<p>1976年得主：索尔·贝娄</p>
<p>美国作家</p>
<p>代表作：《赫索格》</p>
<p>获奖理由：由于他的作品对人性的了解，以及对当代文化的敏锐透视。</p>
<p>1975年得主：埃乌杰尼奥·蒙塔莱</p>
<p>意大利诗人</p>
<p>代表作：《生活之恶》</p>
<p>获奖理由：由于他杰出的诗歌拥有伟大的艺术性，在不适合幻想的人生里，诠释了人类的价值。</p>
<p>1974年得主1：哈里·埃德蒙·马丁逊</p>
<p>瑞典诗人</p>
<p>代表作：《露珠里的世界》</p>
<p>获奖理由：他的作品透过一滴露珠反映出整个世界。</p>
<p>得主2：埃温特·约翰逊</p>
<p>瑞典作家</p>
<p>代表作：《乌洛夫的故事》</p>
<p>获奖理由：以自由为目的，而致力于历史的、现代的广阔观点之叙述艺术。</p>
<p>1973年得主：帕特里克·怀特</p>
<p>澳大利亚小说家、剧作家</p>
<p>代表作：《风暴眼》</p>
<p>获奖理由：由于他史诗与心理叙述艺术，并将一个崭新的大陆带进文学中。</p>
<p>1972年得主： 亨利希·伯尔</p>
<p>德国作家</p>
<p>代表作：《女士及众生相》</p>
<p>获奖理由：为了表扬他的作品，这些作品兼具有对时代广阔的透视和塑造人物的细腻技巧，并有助于德国文学的振兴。</p>
<p>1971年得主： 巴勃鲁·聂鲁达</p>
<p>智利诗人</p>
<p>代表作：《情诗·哀诗·赞诗》</p>
<p>获奖理由：诗歌具有自然力般的作用，复苏了一个大陆的命运与梦想。</p>
<p>1970年得主：亚历山大·索尔仁尼琴</p>
<p>苏联作家</p>
<p>代表作：《癌症楼》《古拉格群岛》</p>
<p>获奖理由：由于他作品中的道德力量，籍著它，他继承了俄国文学不可或缺的传统。</p>
<p>1969年得主：萨缪尔·贝克特</p>
<p>法国作家</p>
<p>代表作：《等待戈多》</p>
<p>获奖理由：他那具有奇特形式的小说和戏剧作品，使现代人从精神困乏中得到振奋。</p>
<p>1968年得主：川端康成</p>
<p>日本小说家</p>
<p>代表作：《雪国·千只鹤·古都》</p>
<p>获奖理由：由于他高超的叙事性作品以非凡的敏锐表现了日本人精神特质。</p>
<p>1967年得主：安赫尔·阿斯图里亚斯</p>
<p>危地马拉诗人、小说家</p>
<p>代表作：《玉米人》</p>
<p>获奖理由：因为他的作品落实于自己的民族色彩和印第安传统，而显得鲜明生动。</p>
<p>1966年得主1：奈莉·萨克斯（女）</p>
<p>瑞典诗人</p>
<p>代表作：《逃亡》</p>
<p>获奖理由：因为她杰出的抒情与戏剧作品，以感人的力量阐述了以色列的命运。</p>
<p>得主2：萨缪尔·约瑟夫·阿格农以色列作家</p>
<p>代表作：《行为之书》</p>
<p>获奖理由：他的叙述技巧深刻而独特，并从犹太民族的生命汲取主题。</p>
<p>1965年得主：米哈伊尔·亚历山大罗维奇·肖洛霍夫</p>
<p>苏联作家</p>
<p>代表作：《静静的顿河》</p>
<p>获奖理由：由于这位作家在那部关于顿河流域农村之史诗作品中所流露的活力与艺术热忱——他籍这两者在那部小说里描绘了俄罗斯民族生活之某一历史层面。</p>
<p>1964年得主：让·保罗·萨特</p>
<p>法国哲学家、作家</p>
<p>代表作：《词语》</p>
<p>获奖理由：因为他那思想丰富、充满自由气息和探求真理精神的作品对我们时代发生了深远影响。</p>
<p>1963年得主：乔治·塞菲里斯</p>
<p>希腊诗人</p>
<p>代表作：《“画眉鸟”号》</p>
<p>获奖理由：他的卓越的抒情诗作，是对希腊文化的深刻感受的产物。</p>
<p>1962年得主：约翰·斯坦贝克</p>
<p>美国作家</p>
<p>代表作：《人鼠之间》</p>
<p>获奖理由：通过现实主义的、寓于想象的创作，表现出富于同情的幽默和对社会的敏感观察。</p>
<p>1961年得主：伊沃·安德里奇</p>
<p>南斯拉夫小说家</p>
<p>代表作：《桥·小姐》</p>
<p>获奖理由：由于他作品中史诗般的力量——他籍著它在祖国的历史中追寻主题，并描绘人的命运。</p>
<p>1960年得主：圣琼·佩斯</p>
<p>法国诗人和剧作家</p>
<p>代表作：《蓝色恋歌》</p>
<p>获奖理由：由于他高超的飞越与丰盈的想象，表达了一种关于如今这个时代之富于意象的沉思。</p>
<p>1959年得主：萨瓦多尔·夸西莫多</p>
<p>意大利诗人</p>
<p>代表作：《水与土》</p>
<p>获奖理由：由于他的抒情诗，以古典的火焰表达了我们这个时代中，生命的悲剧性体验。</p>
<p>1958年得主：鲍里斯·列昂尼多维奇·帕斯捷尔纳克</p>
<p>苏联俄罗斯诗人、小说家</p>
<p>代表作：《日瓦戈医生》</p>
<p>获奖理由：在当代抒情诗和俄国的史诗传统上，他都获得了极为重大的成就。</p>
<p>1957年得主：阿尔贝·加缪</p>
<p>法国作家</p>
<p>代表作：《局外人》</p>
<p>获奖理由：由于他重要的著作，在这著作中他以明察而热切的眼光照亮了我们这时代人类良心的种种问题。</p>
<p>1956年得主：胡安·拉蒙·希梅内斯</p>
<p>西班牙诗人</p>
<p>代表作：《悲哀的咏叹调》</p>
<p>获奖理由：由于他的西班牙抒情诗，成了高度精神和纯粹艺术的最佳典范。</p>
<p>1955年得主：赫尔多尔·奇里扬·拉斯克内斯</p>
<p>冰岛作家</p>
<p>代表作：《渔家女》</p>
<p>获奖理由：为了他在作品中所流露的生动、史诗般的力量，使冰岛原已十分优秀的叙述文学技巧更加瑰丽多姿。</p>
<p>1954年得主：欧内斯特·海明威</p>
<p>美国作家</p>
<p>代表作：《老人与海》</p>
<p>获奖理由：因为他精通于叙事艺术，突出地表现于其近著《老人与海》之中；同时也因为他对当代文体风格之影响。</p>
<p>1953年得主：温斯顿·丘吉尔</p>
<p>英国政治家、历史学家、传记作家</p>
<p>代表作：《不需要的战争》</p>
<p>获奖理由：由于他在描述历史与传记方面的造诣，同时由于他那捍卫崇高的人的价值的光辉演说。</p>
<p>1952年得主：弗朗索瓦·莫里亚克</p>
<p>法国小说家</p>
<p>代表作：《爱的荒漠》</p>
<p>获奖理由：因为他在他的小说中剖析了人生的戏剧，对心灵的深刻观察和紧凑的艺术。</p>
<p>1951年得主：帕尔·费比安·拉格奎斯特</p>
<p>瑞典诗人、戏剧家、小说家</p>
<p>代表作：《大盗巴拉巴》</p>
<p>获奖理由：由于他在作品中为人类面临的永恒的疑难寻求解答所表现出的艺术活力和真正独立的见解。</p>
<p>1950年得主：帕特兰·亚瑟·威廉·罗素</p>
<p>英国数学家、哲学家</p>
<p>代表作：《哲学—数学—文学》</p>
<p>获奖理由：表彰他所写的捍卫人道主义理想和思想自由的多种多样意义重大的作品。</p>
<p>1949年得主：威廉·福克纳</p>
<p>美国作家</p>
<p>代表作：《我弥留之际》《喧哗与骚动》</p>
<p>获奖理由：因为他对当代美国小说做出了强有力的和艺术上无与伦比的贡献。</p>
<p>1948年得主：托马斯·斯特恩斯·艾略特</p>
<p>英美诗人、剧作家、批评家</p>
<p>代表作：《四个四重奏》</p>
<p>获奖理由：对于现代诗之先锋性的卓越贡献。</p>
<p>1947年得主：安德烈·纪德</p>
<p>法国作家、评论家</p>
<p>代表作：《田园交响曲》《背德者》</p>
<p>获奖理由：为了他广泛的与有艺术质地的著作，在这些著作中，他以无所畏惧的对真理的热爱，并以敏锐的心理学洞察力，呈现了人性的种种问题与处境。</p>
<p>1946年得主：赫尔曼·黑塞</p>
<p>德国作家</p>
<p>代表作：《荒原狼》</p>
<p>获奖理由：他那些灵思盎然的作品——它们一方面具有高度的创意和深刻的洞见，一方面象征古典的人道理想与高尚的风格。</p>
<p>1945年得主：加夫列拉·米斯特拉尔（女）</p>
<p>智利诗人</p>
<p>代表作：《柔情》</p>
<p>获奖理由：她那由强烈感情孕育而成的抒情诗，已经使得她的名字成为整个拉丁美洲世界渴求理想的象征。</p>
<p>1944年得主：约翰内斯·威廉·扬森</p>
<p>丹麦小说家、诗人</p>
<p>代表作：《漫长的旅行》</p>
<p>获奖理由：由于籍著丰富有力的诗意想象，将胸襟广博的求知心和大胆的、清新的创造性风格结合起来。</p>
<p>1940年-1943年   未颁奖</p>
<p>1939年得主：弗兰斯·埃米尔·西兰帕</p>
<p>芬兰作家</p>
<p>代表作：《少女西丽亚》</p>
<p>获奖理由：由于他在描绘两样互相影响的东西——他祖国的本质，以及该国农民的生活时——所表现的深刻了解与细腻艺术。</p>
<p>1938年得主：赛珍珠（女）</p>
<p>美国作家</p>
<p>代表作：《大地》三部曲</p>
<p>获奖理由：她对于中国农民生活的丰富和真正史诗气概的描述，以及她自传性的杰作。</p>
<p>1937年得主：罗杰·马丁·杜·加尔</p>
<p>法国小说家</p>
<p>代表作：《蒂伯—家》</p>
<p>获奖理由：由于在他的长篇小说《蒂伯一家》中表现出来的艺术魅力和真实性。这是对人类生活面貌的基本反映。</p>
<p>1936年得主：尤金·奥尼尔</p>
<p>美国剧作家</p>
<p>代表作：《天边外》</p>
<p>获奖理由：由于他剧作中所表现的力量、热忱与深挚的感情——它们完全符合悲剧的原始概念。</p>
<p>1935年   未颁奖</p>
<p>1934年得主：路伊吉·皮兰德娄</p>
<p>意大利说家、戏剧家</p>
<p>代表作：《寻找自我》《六个寻找剧作家的角色》</p>
<p>获奖理由：他果敢而灵巧地复兴了戏剧艺术和舞台艺术。</p>
<p>1933年得主：伊凡·亚历克塞维奇·蒲宁</p>
<p>俄国作家</p>
<p>代表作：《米佳的爱》</p>
<p>获奖理由：由于他严谨的艺术才能，使俄罗斯古典传统在散文中得到继承。</p>
<p>1932年得主：约翰·高尔斯华绥</p>
<p>英国小说家、剧作家</p>
<p>代表作：《有产者》</p>
<p>获奖理由：为其描述的卓越艺术——这种艺术在《福尔赛世家》中达到高峰。</p>
<p>1931年得主：埃利克·阿克塞尔·卡尔费尔德</p>
<p>瑞典诗人</p>
<p>代表作：《荒原和爱情》</p>
<p>获奖理由：由于他在诗作的艺术价值上，从没有人怀疑过。</p>
<p>1930年得主：辛克莱·刘易斯</p>
<p>美国作家</p>
<p>代表作：《巴比特》</p>
<p>获奖理由：由于他充沛有力、切身和动人的叙述艺术，和他以机智幽默去开创新风格的才华。</p>
<p>1929年得主：保尔·托马斯·曼</p>
<p>德国作家</p>
<p>代表作：《布登勃洛克一家》《魔山》</p>
<p>获奖理由：由于他那在当代文学中具有日益巩固的经典地位的伟大小说《布登勃洛克一家》。</p>
<p>1928年得主：西格里德·温塞特（女）</p>
<p>挪威作家</p>
<p>代表作：《新娘—主人—十字架》</p>
<p>获奖理由：主要是由于她对中世纪北国生活之有力描绘。</p>
<p>1927年得主：亨利·柏格森</p>
<p>法国哲学家</p>
<p>代表作：《创造进化论》</p>
<p>获奖理由：因为他那丰富的且充满生命力的思想，以及所表现出来的光辉灿烂的技巧。</p>
<p>1926年得主：格拉齐亚·黛莱达（女）</p>
<p>意大利作家</p>
<p>代表作：《邪恶之路》</p>
<p>获奖理由：为了表扬她由理想主义所激发的作品，以浑柔的透彻描绘了她所生长的岛屿上的生活；在洞察人类一般问题上，表现的深度与怜悯。</p>
<p>1925年得主：乔治·萧伯纳</p>
<p>爱尔兰戏剧家</p>
<p>代表作：《圣女贞德》</p>
<p>获奖理由：由于他那些充满理想主义及人情味的作品——它们那种激动性讽刺，常涵蕴着一种高度的诗意美。</p>
<p>1924年得主：弗拉迪斯拉夫·莱蒙特</p>
<p>波兰作家</p>
<p>代表作：《福地》《农夫们》</p>
<p>获奖理由：我们颁奖给他，是因为他的民族史诗《农夫们》写得很出色。</p>
<p>1923年得主：威廉·勃特勒·叶芝</p>
<p>爱尔兰诗人、剧作家</p>
<p>代表作：《丽达与天鹅》</p>
<p>获奖理由：由于他那永远充满着灵感的诗，它们透过高度的艺术形式展现了整个民族的精神。</p>
<p>1922年得主：哈辛特·贝纳文特·伊·马丁内斯</p>
<p>西班牙作家</p>
<p>代表作：《不吉利的姑娘》</p>
<p>获奖理由：由于他以适当方式，延续了戏剧之灿烂传统。</p>
<p>1921年得主：阿纳托尔·法郎士</p>
<p>法国作家、文学评论家、社会活动家</p>
<p>代表作：《苔依丝》</p>
<p>获奖理由：他辉煌的文学成就，乃在于他高尚的文体、怜悯的人道同情、迷人的魅力，以及一个真正法国性情所形成的特质。</p>
<p>1920年得主：克努特·汉姆生</p>
<p>挪威小说家、戏剧家、诗人</p>
<p>代表作：《大地硕果—畜牧曲》</p>
<p>获奖理由：为了他划时代的巨著《土地的成长》。</p>
<p>1919年得主：卡尔·施皮特勒</p>
<p>瑞士诗人、小说家</p>
<p>代表作：《奥林帕斯之春》</p>
<p>获奖理由：特别推崇他在史诗《奥林帕斯之春》的优异表现。</p>
<p>1918年  未颁奖</p>
<p>1917年得主1：亨利克·彭托皮丹</p>
<p>丹麦小说家</p>
<p>代表作：《天国》</p>
<p>获奖理由：由于他对当前丹麦生活的忠实描绘。</p>
<p>得主2：卡尔·耶勒鲁普</p>
<p>丹麦作家</p>
<p>代表作：《磨坊血案》</p>
<p>获奖理由：因为他多样而丰富的诗作——它们蕴含了高超的理想。</p>
<p>1916年得主：魏尔纳·海顿斯坦姆</p>
<p>瑞典诗人、小说家</p>
<p>代表作：《朝圣年代》</p>
<p>获奖理由：褒奖他在瑞典文学新纪元中所占之重要代表地位。</p>
<p>1915年得主：罗曼·罗兰</p>
<p>法国作家、音乐评论家</p>
<p>代表作：《约翰·克利斯朵夫》</p>
<p>获奖理由：文学作品中的高尚理想和他在描绘各种不同类型人物时所具有的同情和对真理的热爱。</p>
<p>1914年    未颁奖</p>
<p>1913年得主：罗宾德拉纳特·泰戈尔</p>
<p>印度诗人、社会活动家主</p>
<p>代表作：《吉檀枷利—饥饿石头》</p>
<p>获奖理由：由于他那至为敏锐、清新与优美的诗；这诗出之于高超的技巧，并由于他自己用英文表达出来，使他那充满诗意的思想业已成为西方文学的一部分。</p>
<p>1912年得主：盖哈特·霍普特曼</p>
<p>德国剧作家、诗人</p>
<p>代表作：《群鼠》</p>
<p>获奖理由：欲以表扬他在戏剧艺术领域中丰硕、多样的出色成就。</p>
<p>1911年得主：莫里斯·梅特林克</p>
<p>比利时剧作家、诗人、散文家</p>
<p>代表作：《花的智慧》</p>
<p>获奖理由：由于他在文学上多方面的表现，尤其是戏剧作品，不但想象丰富，充满诗意的奇想，有时虽以神话的面貌出现，还是处处充满了深刻的启示。这种启示奇妙地打动了读者的心弦，并且激发了他们的想象。</p>
<p>1910年得主：保尔·约翰·路德维希·冯·海塞</p>
<p>德国作家</p>
<p>代表作：《特雷庇姑娘》</p>
<p>获奖理由：表扬这位抒情诗人、戏剧家、小说家以及举世闻名的短篇小说家，在他漫长而多产的创作生涯中，所达到的充满理想主义精神之艺术至境。</p>
<p>1909年得主：西尔玛·拉格洛夫(女)</p>
<p>瑞典作家</p>
<p>代表作：《尼尔斯骑鹅旅行记》</p>
<p>获奖理由：由于她作品中特有的高贵的理想主义、丰富的想象力、平易而优美的风格。</p>
<p>1908年得主：鲁道尔夫·欧肯</p>
<p>德国哲学家</p>
<p>代表作：《精神生活漫笔》</p>
<p>获奖理由：他对真理的热切追求、他对思想的贯通能力、他广阔的观察，以及他在无数作品中，辩解并阐释一种理想主义的人生哲学时，所流露的热诚与力量。</p>
<p>1907年得主：约瑟夫·鲁德亚德·吉卜林</p>
<p>英国小说家、诗人</p>
<p>代表作：《老虎！老虎！》</p>
<p>获奖理由：这位世界名作家的作品以观察入微、想象独特、气概雄浑、叙述卓越见长。</p>
<p>1906年得主：乔祖埃·卡尔杜齐</p>
<p>意大利诗人、文艺批评家</p>
<p>代表作：《青春诗》</p>
<p>获奖理由：不仅是由于他精深的学识和批判性的研究，更重要是为了颂扬他诗歌杰作中所具有的特色、创作气势，清新的风格和抒情的魅力。</p>
<p>1905年得主：亨利克·显克维支</p>
<p>波兰小说家</p>
<p>代表作：《第三个女人》《你往何处去》</p>
<p>获奖理由：由于他在历史小说写作上的卓越成就。</p>
<p>1904年得主1：何塞·埃切加赖</p>
<p>西班牙戏剧家、诗人</p>
<p>代表作：《伟大的牵线人》</p>
<p>获奖理由：由于它那独特和原始风格的丰富又杰出，作品恢复了西班牙喜剧的伟大传统。</p>
<p>得主2：弗雷德里克·米斯塔尔</p>
<p>法国诗人</p>
<p>代表作：《金岛》</p>
<p>获奖理由：他的诗作蕴涵之清新创造性与真正的感召力，它忠实地反映了他民族的质朴精神。</p>
<p>1903年得主：比昂斯滕·比昂松</p>
<p>挪威戏剧家、诗人、小说家</p>
<p>代表作：《挑战的手套》</p>
<p>获奖理由：他以诗人鲜活的灵感和难得的赤子之心，把作品写得雍容、华丽而又缤纷。</p>
<p>1902年得主：特奥多尔·蒙森</p>
<p>德国历史学家</p>
<p>代表作：《罗马史》</p>
<p>获奖理由：今世最伟大的纂史巨匠，此点于其巨著《罗马史》中表露无疑。</p>
<p>1901年得主：苏利·普吕多姆</p>
<p>法国诗人</p>
<p>代表作：《孤独与深思》</p>
<p>获奖理由：是高尚的理想、完美的艺术和罕有的心灵与智慧的实证。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>文学</tag>
        <tag>信息类</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」为 WSL 配置这些新功能，不用虚拟机也能体验完整 Linux</title>
    <url>/public/2022/07/15/test/202207/2022-07-09-030843747852/</url>
    <content><![CDATA[<p>「转」<a href="https://sspai.com/post/74167" target="_blank" rel="noopener">为 WSL 配置这些新功能，不用虚拟机也能体验完整 Linux</a></p>
<a id="more"></a>
<p>Windows Subsystem for Linux（WSL）是微软在 Windows 平台下支持 Linux
环境的子系统，一经推出便受到各大开发者的青睐。少数派平台上也有很多篇 WSL 相关的文章：</p>
<p>如果你也是一名深度学习科研人员，科研圈里的新文章大部分都是基于 Linux 环境的科研实验，而我们日常使用的电脑却是 Windows 平台。而普通的
Linux 虚拟机又无法访问显卡以获得深度学习加速。另一方面，有部分的科研实验开源了他们的 toolkit，但是却是使用 Linux 桌面环境开发的，在
Linux 服务器上也无法使用。</p>
<p>现在，随着时间的推移，WSL 不断迎来了它的功能增强，分别是 WSL2，NVIDIA CUDA on WSL，和 WSLg。它们各自解决了 WSL
在上述场景下不同的开发难题。</p>
<blockquote>
<p>「Microsoft loves Linux」</p>
</blockquote>
<p>本篇文章就是一个教程指导安装和配置 WSL 使其能够使用上上述的新功能。</p>
<h2 id="第二代-WSL-完整的-Linux-体验"><a class="header-anchor" href="#第二代-WSL-完整的-Linux-体验">¶</a>第二代 WSL 完整的 Linux 体验</h2>
<h3 id="主要区别"><a class="header-anchor" href="#主要区别">¶</a>主要区别</h3>
<p>WSL 目前有两个主要版本，分别称为 WSL1 和 WSL2。它们最大的不同是，WSL1 是基于动态翻译的方式将 Linux 的系统调用翻译为
Windows NT（Windows 操作系统的内核）的系统调用，而 WSL2 是基于虚拟机的，在 Windows 主系统之上创建完整的 Linux 内核。</p>
<p>开发者在 WSL1 中遇到的问题就是，部分 linux 的命令无法成功运行。当你遇到这个问题，将会一件非常恼火的事情。比如，WSL1 中无法成功运行
docker，因为需要 linux 关于名称空间的系统调用，而 WSL1 并不支持。最终，微软还是决定使用虚拟化技术来克服这一问题。</p>
<p>WSL1 和 WSL2 之间其它的主要功能比较，可以参照这这个[微软文档](<a href="https://docs.microsoft.com/zh-" target="_blank" rel="noopener">https://docs.microsoft.com/zh-</a>
cn/windows/wsl/compare-versions)中的表格：</p>
<p>![](<a href="https://cdn.sspai.com/2022/07/08/article/912b8d507ae889a00bc0a402cf53d203?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/07/08/article/912b8d507ae889a00bc0a402cf53d203?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>从表格中可以看出，WSL2 在功能支持的数量上明显优于 WSL1，但跨 OS 文件系统的性能这一项除外。后面我们会根据实际路径说明，如何避免跨 OS
文件访问以避免性能问题。</p>
<h3 id="启用-WSL2"><a class="header-anchor" href="#启用-WSL2">¶</a>启用 WSL2</h3>
<p>首先，WSL2 能在 Windows 11 or Windows 10, Version 1903, <strong>Build 18362</strong> 或更高的版本号中启用。</p>
<p>**方 式一：命令行方式。**最快捷的方式莫过于命令行，一行命令即可完成启用和安装，<code>wsl --install</code>
。该命令会帮助用户启用必要的系统组件，下载最新的 Linux 内核，设置 WSL2 为默认版本，下载并安装 Ubuntu 作为初始版本。</p>
<p>如果想要更细致的控制安装选项，可以使用下面的方式二手动启用。</p>
<p>**方 式二：图形选项卡。**由于 WSL2 的实现方式是基于虚拟机的形式，因此在 Windows功能 的菜单里需要打开两个关键的组件「Virtual
Machine Platform」和「Windows Subsystem for Linux」。否则是没有办法创建磁盘，启动并进入 WSL2 的，而
WSL1 仅需打开「Windows Subsystem for Linux」。</p>
<p>![](<a href="https://cdn.sspai.com/2022/07/08/article/afe8c101898830b30e575bf3b0be8636?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/07/08/article/afe8c101898830b30e575bf3b0be8636?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>经过重启电脑后，勾选的新功能将会被启动。打开终端，输入 <code>wsl --set-default-version 2</code> 命令即可将 WSL 的版本设置为使用
WSL2.</p>
<pre><code>PS C:\Users\someone&gt; wsl --set-default-version 2
For information on key differences with WSL 2 please visit https://aka.ms/wsl2
The operation completed successfully.
</code></pre>
<p>安装 Linux 发行版应该不必多说，通过 Windows 应用商店点击一下即可安装。</p>
<p>![](<a href="https://cdn.sspai.com/2022/07/08/article/7cd4993f3f41d623e94a5a092350d13b?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/07/08/article/7cd4993f3f41d623e94a5a092350d13b?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>默认情况下，这两种安装方式都会将 WSL 安装到系统盘。如果想要将 WSL 安装到非系统盘，可以参考下面这篇文章。</p>
<h3 id="WSL2-跨系统访问文件"><a class="header-anchor" href="#WSL2-跨系统访问文件">¶</a>WSL2 跨系统访问文件</h3>
<p>由于 WSL2 变成了一个虚拟机的形式，那么以前便捷的资源管理器访问 Linux 目录树的功能便不容易找到对应的位置了。</p>
<p>但是，在资源管理器中输入 <code>\\wsl$\Ubuntu-20.04\home\user</code> 可以通过 smb 协议访问 Linux
目录树，也可以将其绑定在网络位置中快速进入。</p>
<p>![](<a href="https://cdn.sspai.com/2022/07/08/article/eefd118642d88091f63a82daca7e24a4?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/07/08/article/eefd118642d88091f63a82daca7e24a4?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)dotfiles 很乱</p>
<p>能够使用系统的资源管理器访问虚拟机的文件真的很方便。在我的使用场景中，我会用来查看实验运行结果产生的图片，以初步判断目标检测的效果。而这之前，我都需要起一个
HTTP 服务来浏览或者通过 scp 拷贝一份到本机才能浏览。</p>
<h2 id="WSL-的图形小尾巴：-WSLg"><a class="header-anchor" href="#WSL-的图形小尾巴：-WSLg">¶</a>WSL 的图形小尾巴： WSLg</h2>
<p>![](<a href="https://cdn.sspai.com/2022/07/08/article/00fec78faec955ce829176b113c51ffa?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/07/08/article/00fec78faec955ce829176b113c51ffa?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)<a href="https://github.com/microsoft/wslg" target="_blank" rel="noopener">图源</a></p>
<p>WSLg 是微软开发的一套技术栈，致力于将 Linux 的 GUI 应用无感地带到 Windows 操作系统中。简单点来说，就可以通过开始菜单运行一个
Linux 的图形化应用，而用户却感知不到它其实运行在 WSL2 中。</p>
<p>在之前，如果想要运行 Linux 图形化应用，我们需要使用实体机/虚拟机安装完整的 Linux 桌面系统才行。更高级一点，需要在 Windows 端安装
XServer，然后通过 X11 forward 转发来渲染图形化。</p>
<p>WSLg 实现了相同的功能，且功能更丰富。首先，不需要完整的桌面系统环境的情况下，WSLg 更轻量化，只包含了显示服务器（X Window
Manager）。其次，XServer 仅支持 X11 App 这类应用，而 WSLg 进一步支持 Wayland App。最后，WSLg 方案引入了
RDP 的本地远程桌面方案显示 GUI 应用，能够最大限度地支持复制粘贴切换应用等一些列 Windows 的使用习惯。</p>
<p>如果你想体验一下现在 Linux 下的软件生态的话，WSLg 是一个支持最丰富的方案了，尝鲜完后也可以完全卸载 WSL2，干干净净，清清爽爽。</p>
<h3 id="安装-WSLg"><a class="header-anchor" href="#安装-WSLg">¶</a>安装 WSLg</h3>
<p>WSLg 要在 Windows 11 或更高的版本号中启用，注意 Windows 10 用户便无法使用该功能了。</p>
<p>WSLg 的安装更为简单，其实已经包含在上述的步骤中了。当执行 <code>wsl --install</code> 的时候，WSLg
也会被一并安装。如下图，我重新执行了一遍全新安装，WSL 所要求的相关组件也会自动安装，然后只需要重启一遍系统便能启动该功能。对于已安装 WSL2
的用户，可以执行 <code>wsl --update</code>。</p>
<p>![](<a href="https://cdn.sspai.com/2022/07/08/article/c3b70b5630dba4148ea079d238a1191a?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/07/08/article/c3b70b5630dba4148ea079d238a1191a?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)注意需要使用管理员权限运行</p>
<p>你可以通过 apt 安装 <code>x11-apps</code> 然后运行 <code>xeyes</code> 来确认安装成功。</p>
<p>但是，WSLg 也不是所有的图形应用都能完美运行，网上有不少的帖子表示很多用户遇到的困难，大部分都指向了 systemd
和图形驱动相关的问题。这也可以作为你的初步判断看看 WSLg 是否能满足自己的需求。</p>
<h3 id="实际应用"><a class="header-anchor" href="#实际应用">¶</a>实际应用</h3>
<p>在我的日常工作中，还需要对实验数据进行数据分析。我常常使用 python 调用 matplotlib 库绘制论文插图，通过 WSLg
可以方便地直接渲染并显示绘制的插图，这样我就能快速地迭代调整插图的细节。</p>
<p>在这之前，我都是通过 Google Colab 来完成绘图工作的。但是在实验的 artifacts 比较多和比较大的时候，我需要花费大量精力想办法把
artifacts 同步到 Colab 的运行时中；或者通过端口转发让 Colab 使用本地运行时来访问 artifacts。但无论哪种方法，都比不上
WSLg 来得直接和方便。</p>
<p>![](<a href="https://cdn.sspai.com/2022/07/08/article/8ef7fe939102c6a29f48299d1ade8953?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/07/08/article/8ef7fe939102c6a29f48299d1ade8953?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>Caption: 用我最喜欢的正弦函数来做演示</p>
<p>对于很多以 Linux 作为第一优先级支持的 GUI 应用，我认为也是很值得使用 WSLg 的，比如，著名仿真软件
<a href="https://gazebosim.org/home" target="_blank" rel="noopener">GAZEBO</a>、机器人软件包 <a href="https://www.ros.org/" target="_blank" rel="noopener">ROS</a>、生物信息工具
<a href="https://blast.ncbi.nlm.nih.gov/Blast.cgi" target="_blank" rel="noopener">Blast</a> 等。</p>
<p>![](<a href="https://cdn.sspai.com/2022/07/08/article/d083cc0e6ff8315d59ff5e4f707dd177?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/07/08/article/d083cc0e6ff8315d59ff5e4f707dd177?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>如果你有正好在练习和熟悉 Linux 的操作，那么我推荐你安装使用
<a href="https://github.com/teejee2008/timeshift" target="_blank" rel="noopener">Timeshift</a>
这款应用。它可以给你指定的路径创建备份作为还原点，然后就可以放心地折腾 WSL2 以学习 Linux 的使用，遇到问题后快速恢复。</p>
<p>![](<a href="https://cdn.sspai.com/2022/07/08/article/987980e2fc442fafd6e1aff6e125984e?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/07/08/article/987980e2fc442fafd6e1aff6e125984e?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>如果你有在电脑端阅读电子书的习惯，而且听说过江湖传说「Windows 的字体渲染是很糟糕的」，那么不妨试试字体渲染更好一些的 Linux 阅读器
<a href="https://johnfactotum.github.io/foliate/" target="_blank" rel="noopener">Foliate</a>。虽然有点曲线救国的意思，但也不失为一种不错的解决方案。</p>
<p>![](<a href="https://cdn.sspai.com/2022/07/08/article/9392f8e25f20df8dcf26e8071f7179b0?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/07/08/article/9392f8e25f20df8dcf26e8071f7179b0?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<h2 id="进击的-WSL-with-CUDA"><a class="header-anchor" href="#进击的-WSL-with-CUDA">¶</a>进击的 WSL with CUDA</h2>
<p>CUDA，全称「Compute Unified Device Architecture」，是 Nvidia 公司发行的针对自家公司 GPU
显卡的并行计算开发套件。使用 CUDA 这个开发套件可以直接访问 GPU 中的流处理器，更高效地完成大量且重复的简单计算。</p>
<p>由于 GPU 的并行计算能力比 CPU 强大，因此更加适合矩阵计算，图形渲染等任务。而目前很热门的深度学习技术正是因为大量使用的矩阵计算，所以对 CUDA
有很大的依赖。</p>
<p>在我的日常工作中需要对深度学习技术进行研究，现在 WSL 也能支持 CUDA
，对我来说就能降低对于服务器的需求，在本地机器上完成基础的代码编写和运行测试，然后再同步到服务器进行大规模的实验了。</p>
<h3 id="安装-CUDA"><a class="header-anchor" href="#安装-CUDA">¶</a>安装 CUDA</h3>
<p>CUDA on WSL 可以在 Windows 11 或 Windows 10, Version 21H2 及更高的版本号中启用。</p>
<p>很多同学看了微软和英伟达关于 CUDA on WSL 相关的文档，还是一头雾水。除了因为大量的英文描述以外，还因为他们都没有言简意赅地告诉你， <strong>整
个安装过程对于用户其实是非常简单的</strong>。</p>
<p>整个安装过程可以分为三步走：</p>
<ol>
<li>在 Windows 侧升级 Linux 内核；</li>
<li>安装 Nvidia 的显卡驱动；</li>
<li>在 WSL 内安装 Nvidia CUDA 的开发套件；</li>
</ol>
<p>![](<a href="https://cdn.sspai.com/2022/07/08/article/1819e41e89cf24e6ca0ca9f460d9325e?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/07/08/article/1819e41e89cf24e6ca0ca9f460d9325e?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)架构简易图示</p>
<p>第一步，升级 Linux 内核，这里需要分三种情况讨论：</p>
<ul>
<li>如果你是通过上述步骤全新安装的 WSL，那么你可以跳过这一步，因为初次安装就是最新的内核版本了。</li>
<li>如果你日常使用 Windows 打开了自动更新功能 <s>（ 最多关21天）</s>，那么你也不用升级，因为日常它就会帮你自动升级。</li>
<li>如果真的需要手动安装，<code>wsl --install</code>命令一键安装完成。</li>
</ul>
<p>最后你可以通过 <code>wsl cat /proc/version</code> 命令确认内核版本大于 5.10.43.3.</p>
<pre><code>PS C:\Users\someone&gt; wsl cat /proc/version
Linux version 5.10.102.1-microsoft-standard-WSL2 (oe-user@oe-host) (x86_64-msft-linux-gcc (GCC) 9.3.0, GNU ld (GNU Binutils) 2.34.0.20200220) #1 SMP Wed Mar 2 00:30:59 UTC 2022
</code></pre>
<p>第二步，安装 Nvidia 显卡驱动。这个其实大部分配置了英伟达显卡的个人电脑都已经安装了，否则根本无法正常使用显卡的功能。如果你能在系统托盘看到
Nvidia GeForce
Experience，那么说明你已经安装好了。如果没装，进入<a href="https://www.nvidia.com/download/index.aspx" target="_blank" rel="noopener">英伟达驱动官网</a>，选择自己的显卡型号下载安装包一路点下一步就好。</p>
<p>虽然 Nvidia 没说具体的版本号要求，只提了最新的驱动能支持。但个人来说我也推荐偶尔手动更新到最新版本，以获取更稳定高效的驱动表现 <s>和
更高的游戏性能</s>。</p>
<p>第三步，安装 Nvidia CUDA 的开发套件。Nvidia 的 [CUDA 官网](<a href="https://developer.nvidia.com/cuda-" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-</a>
downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=WSL-
Ubuntu&amp;target_version=2.0&amp;target_type=deb_local)中已经贴心地将 WSL 视作一个独立的 Linux
发行版，只要选择如下图的选项，根据网站下面显示的指令敲一遍就能顺利安装 CUDA 开发套件。整个过程和其它的发行版安装无异，完全不用额外的学习成本。</p>
<p>![](<a href="https://cdn.sspai.com/2022/07/08/article/8436c552831201c82d90b905125606cc?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/07/08/article/8436c552831201c82d90b905125606cc?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>从深度学习用户的角度来说，我并不推荐无脑安装最新的 CUDA 版本，除非自己清楚影响范围是什么。一般来说，使用深度学习环境如
<a href="https://pytorch.org/get-started/locally/" target="_blank" rel="noopener">pytorch</a> 和
<a href="https://www.tensorflow.org/install/gpu" target="_blank" rel="noopener">tensorflow</a> 官网中推荐安装的版本能获得最少 bug
的体验。因此，在 [CUDA 官网](<a href="https://developer.nvidia.com/cuda-" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-</a>
downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=WSL-
Ubuntu&amp;target_version=2.0&amp;target_type=deb_local) 下面选择 Archive of Previous CUDA
Releases 可以获取历史版本的安装指令。</p>
<p>在 WSL 下运行 <code>nvidia-smi</code> 等命令可以确认是否正确安装 CUDA 套件。</p>
<p>![](<a href="https://cdn.sspai.com/2022/07/08/article/2181f08f192d11fe84ec30fe73f58d45?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/07/08/article/2181f08f192d11fe84ec30fe73f58d45?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>至此，你已经安装完成了 WSL 下 CUDA 的全部依赖了，可以和普通的 Linux 环境一样正常安装使用深度学习的环境了。</p>
<h3 id="实际应用-2"><a class="header-anchor" href="#实际应用-2">¶</a>实际应用</h3>
<p>和大多数的深度学习科研工作者一样，我一般使用 CUDA 来运行深度学习应用。在 WSL 的环境下，编码体验和服务器端完全一样，但由于不用考虑和同学们分时复用
GPU，编码和测试就能够更频繁地交替。在同样的 RTX2080Ti 的显卡下，也没有明显感知到运行速度的差异。</p>
<p>![](<a href="https://cdn.sspai.com/2022/07/08/article/46e1f6213a9f6bddcf0ced9d16dc2cf2?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/07/08/article/46e1f6213a9f6bddcf0ced9d16dc2cf2?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>类似地，Intel 和 AMD 也有等同于 CUDA 的开发套件，分别是
<a href="https://www.intel.com/content/www/us/en/developer/tools/oneapi/overview.html#gs.53ka13" target="_blank" rel="noopener">oneAPI</a>
和 <a href="https://rocmdocs.amd.com/en/latest/" target="_blank" rel="noopener">ROCm</a>
。[微软](<a href="https://devblogs.microsoft.com/commandline/oneapi-l0-openvino-and-" target="_blank" rel="noopener">https://devblogs.microsoft.com/commandline/oneapi-l0-openvino-and-</a>
opencl-coming-to-the-windows-subsystem-for-linux-for-intel-
gpus/)和[英特尔](<a href="https://www.intel.com/content/www/us/en/artificial-" target="_blank" rel="noopener">https://www.intel.com/content/www/us/en/artificial-</a>
intelligence/harness-the-power-of-intel-igpu-on-your-machine.html)在博客中各自宣布了在
WSL2 中支持 oneAPI，但关于 ROCm 的消息还没有看到。对于另外两家的硬件有需求的读者可以去探索一下。</p>
<h2 id="后记"><a class="header-anchor" href="#后记">¶</a>后记</h2>
<p>软件的功能层出不穷，但永恒不变的还是那句话，适合自己的才是好的。如果你也有类似的需求，想要兼顾 Windows 系统上大量的常用软件，那么 WSL2
从这个角度看是很理想的选择，不妨试试。关于 WSL2 的使用有什么痛点以及更合适的使用场景和软件推荐，也欢迎在评论区留下你的评论。</p>
<p><strong>关 联阅读</strong>：</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/ai/directml/gpu-cuda-in-wsl" target="_blank" rel="noopener">Enable NVIDIA CUDA on WSL</a></li>
<li><a href="https://docs.nvidia.com/cuda/wsl-user-guide/index.html" target="_blank" rel="noopener">CUDA on WSL User Guide</a></li>
</ul>
<blockquote>
<p>下载 <a href="https://sspai.com/page/client" target="_blank" rel="noopener">少数派 2.0 客户端</a>、关注
<a href="https://sspai.com/s/J71e" target="_blank" rel="noopener">少数派公众号</a>，解锁全新阅读体验 📰</p>
</blockquote>
<blockquote>
<p>实用、好用的 <a href="https://sspai.com/mall" target="_blank" rel="noopener">正版软件</a>，少数派为你呈现 🚀</p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」咖啡美酒冷泡茶，这些消暑饮品在家就能动手做</title>
    <url>/public/2022/07/15/test/202207/2022-07-12-050355504330/</url>
    <content><![CDATA[<p>「转」<a href="https://sspai.com/post/74196" target="_blank" rel="noopener">咖啡美酒冷泡茶，这些消暑饮品在家就能动手做</a></p>
<a id="more"></a>
<p>转眼又是气温冲刺 40
度的夏天，粘腻的日子里想要来点清爽，空调、西瓜、冷饮是少不了的。说起冷饮，除了自己头顶烈日出门去买或者让别人头顶烈日送过来，适当屯点原料、然后自己在家制作也是一件能够同时收获成就感与满足感的美事。</p>
<p>如果你想动手试试，本文整理了此前少数派网站上发布过的、适合夏日的自制饮品制作方法，希望能为你提供一些参考。</p>
<h2 id="夏天更应喝一杯"><a class="header-anchor" href="#夏天更应喝一杯">¶</a>夏天更应喝一杯</h2>
<p>夏天到了更应该喝一杯了----爱喝咖啡的同事如是说。</p>
<p>作为大家生活中最常见的饮品之一，咖啡既可以冰饮也可以热饮，玩法和口味多样，对于咖啡爱好者来说自然也是最适合消暑的饮品。除了使用滤杯、挂耳和法压壶制作经典的咖啡热饮，你也可以试试自己在家制作冷萃。</p>
<p>只需要购买散装的冷泡袋，将咖啡粉装入袋中，再把咖啡袋丢进杯子之类的容器里并加入冷水，放进冰箱 6 到 8
小时便可饮用（亦可更久）。冷萃咖啡虽然没有热咖啡那样的扑鼻香气，但咖啡经过漫长的萃取过程缓缓释放，喝起来爽口又芬芳。</p>
<p>冰滴咖啡则是冰咖啡的另一种玩法，这种咖啡的滴滤和萃取借助冰水完成。由于萃取过程全程低温，所以冷萃和冰滴能去除咖啡中的酸、苦、涩等元素，呈现相对柔和、中性的口感。此外冰滴与冷萃在风味和口感上又有着微妙的区别，试过冷萃觉得不适合自己的不妨一试。</p>
<p>想要在家制作冰滴咖啡，你可以购买家用的冰滴器具，价格通常在 200~500
元之间。如果你已经有了全套手冲器具，也可以完全按照手冲流程，只是将「注入热水」一步换为「将大量冰块放在咖啡粉上，等待其自然融化」，也能得到一杯好咖啡。</p>
<p>![boxcnXckTHZyqx6AN2JvkkkFDZe](<a href="https://cdn.sspai.com/editor/u_/cb57mt5b34tbthquqjag?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb57mt5b34tbthquqjag?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)图片出处：<a href="http://lawrencehou.blogspot.com/2016/05/iwaki.html" target="_blank" rel="noopener">http://lawrencehou.blogspot.com/2016/05/iwaki.html</a></p>
<p>和冷萃咖啡一样，制作冰滴咖啡的中间过程只需等待，无需人工干预。不过相较而言，制作冰滴多了个预备冰块的步骤，需要提前准备。</p>
<p>当然了，既然是自行发挥，你也可以将咖啡和其它产品混合起来，制作出一些风味独特的饮品。比如很多人都推荐过的「凤梨咖啡」就只需要挤出凤梨汁加入冲好的咖啡中便可饮用，凤梨独有的香甜混合咖啡的清香，过程简单但口感非常不错；冰咖柠檬汽水作为「果汁加咖啡」的变体则非常适合汽水党，只需要预先做好一份冷萃咖啡再准备一罐冰镇雪碧，在杯中填满大量冰块后将咖啡和雪碧倒入杯中混合即可饮用。</p>
<p>![boxcnhUHrxoDAzxkprY5PyCisXb](<a href="https://cdn.sspai.com/editor/u_/cb57mtdb34tbt4lb7hv0?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb57mtdb34tbt4lb7hv0?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>如果你想让饮品在视觉上层次分明，还可以依循「冰块----雪碧----
咖啡」的顺序依次倒入杯内。冰咖柠檬汽水口感兼具咖啡的清醇和汽水的爽利，手边有器具和原料的朋友不妨动手试试。对了，去年备受好评的爆款「懒人冰格」咱还在卖，要不要再考虑一下？</p>
<p>![boxcn1KEcDcIWJXZF65HjRubeth](<a href="https://cdn.sspai.com/editor/u_/cb57mttb34tbthquqjb0?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb57mttb34tbthquqjb0?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)用过表示超好用的</p>
<p><strong>关 联阅读：</strong></p>
<ul>
<li><a href="https://sspai.com/post/55043" target="_blank" rel="noopener">炎炎夏日喝什么？夏日咖啡制作指南</a></li>
<li><a href="https://sspai.com/post/67455" target="_blank" rel="noopener">TA 有好物 | 夏天到来快乐吃冰，来试试一拉就出的「懒人冰格」</a></li>
</ul>
<h2 id="给自己来一杯-mojito"><a class="header-anchor" href="#给自己来一杯-mojito">¶</a>给自己来一杯 mojito</h2>
<p><em>* 未成年人请勿饮酒（成年人也请注意节制）。</em></p>
<p>一罐苏打水、一罐雪碧、一个青柠檬和少量可食用的新鲜薄荷叶，制作一杯无酒精莫吉托的原料就准备齐全了。</p>
<p>接下来我们将少量薄荷叶掰碎放入杯中，青柠檬切两半，一半挤青柠檬汁加入杯中并加入少量冰块，然后把苏打水和雪碧倒入杯中混合一下，并将另一半青柠檬切怀抱厚片、剩下的切成小块加入杯中……最后将厚片插在杯壁上，顶部撒两片薄荷叶即可饮用。</p>
<p>![boxcnv3CIjQCSbhwDpAWISEyYpf](<a href="https://cdn.sspai.com/editor/u_/cb57mulb34tbt4lb7hvg?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb57mulb34tbt4lb7hvg?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>作为一款非常经典的调制鸡尾酒，口感酸甜清爽的莫吉托是夏天酒吧里的热门选择。它的传统做法需要苏打水、朗姆酒、糖、青柠檬和薄荷叶，所以上面介绍这种无酒精莫吉托是推荐给不怎么爱喝酒的朋友的。</p>
<p>至于喜欢酒饮的朋友，如果你不喜欢啤酒的苦味，可以先试试「可尔必思啤酒」。顾名思义这种饮品制作需要两种原料：在日本家喻户晓的乳酸菌饮料可尔必思以及任意一种你喜欢的啤酒（当然一般不太建议选择修道院啤酒或者口味比较丰富的
IPA）。</p>
<p>可尔必思啤酒的制作方式也很简单，把一部分可尔必思放在下面作为基底，然后倒入啤酒大概到 7
成满，等待啤酒泡沫稍微消散一些，在上面再倒入适量的可尔必思就可以了。喝的时候则建议大口喝，同时喝到啤酒和可尔必思，这样既能感受到啤酒花的香味，同时可尔必思的酸甜又会盖住苦味，真是再完美不过了。</p>
<p>![boxcnqB9VYXXcaof5GY9u92O41t](<a href="https://cdn.sspai.com/editor/u_/cb57mv5b34tbthquqjbg?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb57mv5b34tbthquqjbg?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>与之类似的，你也可以试试早前风靡过日本的「漂浮梅酒」，它的原理和可尔必思啤酒类似，梅酒里含有多种的矿物质，很适合夏天流汗后饮用。同时梅酒酸甜的口味又有解腻的功效，正好可以用来中和香草冰激凌中的甜感。</p>
<p>![boxcnT28xYHKfCDAi9QXVAj3l3e](<a href="https://cdn.sspai.com/editor/u_/cb57mvlb34tbthquqjc0?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb57mvlb34tbthquqjc0?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>因此制作流程也同样简单，梅酒 +
香草冰激凌，把冰激凌球放入杯中，加入适量梅酒即可。值得注意的是越简单的搭配可能性也越多，选择梅酒和冰激凌的时候可以多多尝试。</p>
<p>最后，在下面这篇文章末尾还有一份流程略为复杂但成品非常诱人的桑格利亚汽酒制作方法，这里就当作彩蛋留给大家自己去尝试啦。</p>
<p><strong>关 联阅读：</strong><a href="https://sspai.com/post/56224" target="_blank" rel="noopener">6 款在家就能做的好喝饮品，伴你度过这个「史上最热」夏天</a></p>
<h2 id="茶叶的另一种打开方式"><a class="header-anchor" href="#茶叶的另一种打开方式">¶</a>茶叶的另一种打开方式</h2>
<p>如果你觉得奶茶不够健康、咖啡和鸡尾酒做起来比较麻烦，冷泡茶同样也是一个值得在家尝试的好选择。对本就喜欢喝茶的朋友来说，冷泡茶还能让我们以一种同样清甜、凉爽的方式享用喜欢的茶叶。</p>
<p>相比其它饮品，冷泡茶制作起来也相对轻松，一般而言，只需要把 10~15 克茶叶用 1000 毫升常温水泡好，放入冰箱冷藏 3~4 个小时即可。</p>
<p><img src="https://cdn.sspai.com/2022/07/10/5e98cca38a614d1c87c1815de441bf7e.PNG" alt></p>
<p>因此对冷泡茶自制来说，茶叶的选择更能影响最终成品的实际口感。虽然冰红茶可能是大多数人听过最熟悉的冷泡茶，但其实像绿茶、乌龙茶、白茶这些发酵程度更低的茶可能口感更佳。比如带果味的绿茶就很适合做冷泡，这类茶叶在低温下浸出的茶多酚较少，成品涩味更少，口感上会比热水冲泡更柔和，但同时又能凸显出果物的香味和质地，让茶饮更有层次感。</p>
<p>![boxcnyTSKTqDpBLYrPfSIXRlXHf](<a href="https://cdn.sspai.com/editor/u_/cb57n25b34tbthquqjcg?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb57n25b34tbthquqjcg?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>少数派的作者们也推荐过不少适合用来做冷泡茶的茶叶和饮品，比如 LUPICIA 的极品白桃乌龙和果味茶、UMTEA
优美茶的「控糖套装」、卡卡厨房的苦瓜乌龙茶和槐米铁观音甚至伊藤园的大麦茶……如果你选择的红茶，不妨考虑先热水洗一下再冷泡，否则冷泡后会有一点点淡淡的涩味。</p>
<p>![boxcnOncQQq8HiQVn52yVIElTWd](<a href="https://cdn.sspai.com/editor/u_/cb57n2db34tbthquqjd0?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb57n2db34tbthquqjd0?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>另外，上述冷泡茶其实也可以搭配梅子露、柠檬、薄荷、牛奶等不同配料制作出层次和口感都更加丰富的各类冷泡茶饮料，至于具体的操作方法和冷泡壶选择，大家可以参考下面这篇文章。</p>
<p><strong>关 联阅读：</strong><a href="https://sspai.com/post/62308" target="_blank" rel="noopener">比奶茶和快乐水更清凉低卡，用这杯冷泡茶留住你的夏天</a></p>
<p>阳光渐渐变得炽热，天空中的云彩也渐渐稀少，升高的气温是否又让你回想起了往年的晴空万里？除了空调和电扇，少不了的当然是夏季特饮啦！在你的记忆中（或者现在手中）会有哪些夏季特饮？</p>
<p>如果你还有其它分享，欢迎在评论区留言或前往<a href="https://sspai.com/bullet/1622443898" target="_blank" rel="noopener">一派</a>参与讨论。</p>
<blockquote>
<p>下载少数派 <a href="https://sspai.com/page/client" target="_blank" rel="noopener">客户端</a>、关注
<a href="https://sspai.com/s/J71e" target="_blank" rel="noopener">少数派公众号</a>，感受精彩数字生活 🍃</p>
</blockquote>
<blockquote>
<p>想申请成为少数派作者？<a href="https://sspai.com/apply/writing" target="_blank" rel="noopener">冲</a>！ 🚀</p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>【转】一文看懂Linux内核！Linux内核架构和工作原理详解</title>
    <url>/public/2021/12/23/linux/linux_in_one/</url>
    <content><![CDATA[<p>全文导读</p>
<ul>
<li><a href>Linux 内核预备工作</a></li>
<li><a href>Linux 内核体系结构简析</a></li>
<li><a href>Linux 体系结构和内核结构区别</a></li>
<li><a href>Linux 驱动的 platform 机制</a></li>
<li><a href>Linux 内核体系结构</a></li>
<li><a href>内核模块</a></li>
<li><a href>Linux 内核学习经验总结</a></li>
<li><a href>结尾</a></li>
</ul>
<a id="more"></a>
<h2 id="Linux-内核预备工作"><a class="header-anchor" href="#Linux-内核预备工作">¶</a>Linux 内核预备工作</h2>
<p>理解 Linux 内核最好预备的知识点：</p>
<p>懂 C 语言<br>
懂一点操作系统的知识<br>
熟悉少量相关算法<br>
懂计算机体系结构</p>
<p>Linux 内核的特点：</p>
<p>结合了 unix 操作系统的一些基础概念</p>
<img src="/public/2021/12/23/linux/linux_in_one/174749211_2_20191103041018392.jpeg" alt="174749211_2_20191103041018392" style="zoom:50%;">
<img src="/public/2021/12/23/linux/linux_in_one/174749211_3_20191103041018455.jpeg" alt="174749211_3_20191103041018455" style="zoom:60%;">
<p>Linux 内核的任务：</p>
<ol>
<li>
<p>从技术层面讲，内核是硬件与软件之间的一个中间层。作用是将应用层序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。</p>
</li>
<li>
<p>从应用程序的层面讲，应用程序与硬件没有联系，只与内核有联系，内核是应用程序知道的层次中的最底层。在实际工作中内核抽象了相关细节。</p>
</li>
<li>
<p>内核是一个资源管理程序。负责将可用的共享资源 (CPU 时间、磁盘空间、网络连接等) 分配得到各个系统进程。</p>
</li>
<li>
<p>内核就像一个库，提供了一组面向系统的命令。系统调用对于应用程序来说，就像调用普通函数一样。<br>
内核实现策略：</p>
</li>
<li>
<p>微内核。最基本的功能由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信。</p>
</li>
<li>
<p>宏内核。内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。目前支持模块的动态装卸 (裁剪)。Linux 内核就是基于这个策略实现的。<br>
哪些地方用到了内核机制？</p>
</li>
<li>
<p>进程（在 cpu 的虚拟内存中分配地址空间，各个进程的地址空间完全独立; 同时执行的进程数最多不超过 cpu 数目）之间进行通   信，需要使用特定的内核机制。</p>
</li>
<li>
<p>进程间切换 (同时执行的进程数最多不超过 cpu 数目)，也需要用到内核机制。</p>
</li>
</ol>
<p>进程切换也需要像 FreeRTOS 任务切换一样保存状态，并将进程置于闲置状态 / 恢复状态。</p>
<ol start="3">
<li>
<p>进程的调度。确认哪个进程运行多长的时间。<br>
Linux 进程</p>
</li>
<li>
<p>采用层次结构，每个进程都依赖于一个父进程。内核启动 init 程序作为第一个进程。该进程负责进一步的系统初始化操作。init 进程是进程树的根，所有的进程都直接或者间接起源于该进程。</p>
</li>
<li>
<p>通过 pstree 命令查询。实际上得系统第一个进程是 systemd，而不是 init（这也是疑问点）</p>
</li>
<li>
<p>系统中每一个进程都有一个唯一标识符 (ID), 用户（或其他进程）可以使用 ID 来访问进程。</p>
</li>
</ol>
<p>Linux 内核源代码的目录结构</p>
<p>Linux 内核源代码包括三个主要部分：</p>
<ol>
<li>
<p>内核核心代码，包括第 3 章所描述的各个子系统和子模块，以及其它的支撑子系统，例如电源管理、Linux 初始化等</p>
</li>
<li>
<p>其它非核心代码，例如库文件（因为 Linux 内核是一个自包含的内核，即内核不依赖其它的任何软件，自己就可以编译通过）、固件集合、KVM（虚拟机技术）等</p>
</li>
<li>
<p>编译脚本、配置文件、帮助文档、版权说明等辅助性文件</p>
</li>
</ol>
<p>使用 ls 命令看到的内核源代码的顶层目录结构，具体描述如下。</p>
<p>include/ ---- 内核头文件，需要提供给外部模块（例如用户空间代码）使用。</p>
<p>kernel/ ---- Linux 内核的核心代码，包含了 3.2 小节所描述的进程调度子系统，以及和进程调度相关的模块。</p>
<p>mm/ ---- 内存管理子系统（3.3 小节）。</p>
<p>fs/ ---- VFS 子系统（3.4 小节）。</p>
<p>net/ ---- 不包括网络设备驱动的网络子系统（3.5 小节）。</p>
<p>ipc/ ---- IPC（进程间通信）子系统。</p>
<p>arch// ---- 体系结构相关的代码，例如 arm, x86 等等。<br>
    arch//mach- ---- 具体的 machine/board 相关的代码。<br>
    arch//include/asm ---- 体系结构相关的头文件。<br>
    arch//boot/dts ---- 设备树（Device Tree）文件。</p>
<p>init/ ---- Linux 系统启动初始化相关的代码。<br>
block/ ---- 提供块设备的层次。<br>
sound/ ---- 音频相关的驱动及子系统，可以看作 “音频子系统”。<br>
drivers/ ---- 设备驱动（在 Linux kernel 3.10 中，设备驱动占了 49.4 的代码量）。</p>
<p>lib/ ---- 实现需要在内核中使用的库函数，例如 CRC、FIFO、list、MD5 等。<br>
crypto/ ----- 加密、解密相关的库函数。<br>
security/ ---- 提供安全特性（SELinux）。<br>
virt/ ---- 提供虚拟机技术（KVM 等）的支持。<br>
usr/ ---- 用于生成 initramfs 的代码。<br>
firmware/ ---- 保存用于驱动第三方设备的固件。</p>
<p>samples/ ---- 一些示例代码。<br>
tools/ ---- 一些常用工具，如性能剖析、自测试等。</p>
<p>Kconfig, Kbuild, Makefile, scripts/ ---- 用于内核编译的配置文件、脚本等。</p>
<p>COPYING ---- 版权声明。<br>
MAINTAINERS ---- 维护者名单。<br>
CREDITS ---- Linux 主要的贡献者名单。<br>
REPORTING-BUGS ---- Bug 上报的指南。</p>
<p>Documentation, README ---- 帮助、说明文档。</p>
<h2 id="Linux-内核体系结构简析"><a class="header-anchor" href="#Linux-内核体系结构简析">¶</a>Linux 内核体系结构简析</h2>
<p><img src="/public/2021/12/23/linux/linux_in_one/174749211_4_20191103041018502.jpeg" alt="174749211_4_20191103041018502"></p>
<p>图 1 Linux 系统层次结构</p>
<p>最上面是用户（或应用程序）空间。这是用户应用程序执行的地方。用户空间之下是内核空间，Linux 内核正是位于这里。GNU C Library （glibc）也在这里。它提供了连接内核的系统调用接口，还提供了在用户空间应用程序和内核之间进行转换的机制。这点非常重要，因为内核和用户空间的应用程序使用的是不同的保护地址空间。每个用户空间的进程都使用自己的虚拟地址空间，而内核则占用单独的地址空间。</p>
<p>Linux 内核可以进一步划分成 3 层。最上面是系统调用接口，它实现了一些基本的功能，例如 read 和 write。系统调用接口之下是内核代码，可以更精确地定义为独立于体系结构的内核代码。这些代码是 Linux 所支持的所有处理器体系结构所通用的。在这些代码之下是依赖于体系结构的代码，构成了通常称为 BSP（Board Support Package）的部分。这些代码用作给定体系结构的处理器和特定于平台的代码。</p>
<p>Linux 内核实现了很多重要的体系结构属性。在或高或低的层次上，内核被划分为多个子系统。Linux 也可以看作是一个整体，因为它会将所有这些基本服务都集成到内核中。这与微内核的体系结构不同，后者会提供一些基本的服务，例如通信、I/O、内存和进程管理，更具体的服务都是插入到微内核层中的。每种内核都有自己的优点，不过这里并不对此进行讨论。</p>
<p>随着时间的流逝，Linux 内核在内存和 CPU 使用方面具有较高的效率，并且非常稳定。但是对于 Linux 来说，最为有趣的是在这种大小和复杂性的前提下，依然具有良好的可移植性。Linux 编译后可在大量处理器和具有不同体系结构约束和需求的平台上运行。一个例子是 Linux 可以在一个具有内存管理单元（MMU）的处理器上运行，也可以在那些不提供 MMU 的处理器上运行。</p>
<p>Linux 内核的 uClinux 移植提供了对非 MMU 的支持。</p>
<p>图 2 是 Linux 内核的体系结构</p>
<p><img src="/public/2021/12/23/linux/linux_in_one/174749211_5_20191103041018549.jpeg" alt="174749211_5_20191103041018549"></p>
<p>图 2 Linux 内核体系结构</p>
<p>Linux 内核的主要组件有：系统调用接口、进程管理、内存管理、虚拟文件系统、网络堆栈、设备驱动程序、硬件架构的相关代码。</p>
<p>（1）系统调用接口</p>
<p>SCI 层提供了某些机制执行从用户空间到内核的函数调用。正如前面讨论的一样，这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 ./linux/kernel 中您可以找到 SCI 的实现，并在 ./linux/arch 中找到依赖于体系结构的部分。</p>
<p>（2）进程管理</p>
<p>进程管理的重点是进程的执行。在内核中，这些进程称为线程，代表了单独的处理器虚拟化（线程代码、数据、堆栈和 CPU 寄存器）。在用户空间，通常使用进程 这个术语，不过 Linux 实现并没有区分这两个概念（进程和线程）。内核通过 SCI 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSIX] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSIX 机制）。</p>
<p>进程管理还包括处理活动进程之间共享 CPU 的需求。内核实现了一种新型的调度算法，不管有多少个线程在竞争 CPU，这种算法都可以在固定时间内进行操作。这种算法就称为 O(1) 调度程序，这个名字就表示它调度多个线程所使用的时间和调度一个线程所使用的时间是相同的。O(1) 调度程序也可以支持多处理器（称为对称多处理器或 SMP）。您可以在 ./linux/kernel 中找到进程管理的源代码，在 ./linux/arch 中可以找到依赖于体系结构的源代码。</p>
<p>（3）内存管理</p>
<p>内核所管理的另外一个重要资源是内存。为了提高效率，如果由硬件管理虚拟内存，内存是按照所谓的内存页 方式进行管理的（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。</p>
<p>（4）虚拟文件系统</p>
<p>虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 SCI 和内核所支持的文件系统之间提供了一个交换层（请参看图 4）。</p>
<p><img src="/public/2021/12/23/linux/linux_in_one/174749211_6_20191103041018596.jpeg" alt="174749211_6_20191103041018596"></p>
<p>图 3 Linux 文件系统层次结构</p>
<p>在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。它们是给定文件系统（超过 50 个）的插件。文件系统的源代码可以在 ./linux/fs 中找到。文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集（与具体文件系统无关）。这个缓存层通过将数据保留一段时间（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。</p>
<p>（5）网络堆栈</p>
<p>网络堆栈在设计上遵循模拟协议本身的分层体系结构。回想一下，Internet Protocol (IP) 是传输协议（通常称为传输控制协议或 TCP）下面的核心网络层协议。TCP 上面是 socket 层，它是通过 SCI 进行调用的。socket 层是网络子系统的标准 API，它为各种网络协议提供了一个用户接口。从原始帧访问到 IP 协议数据单元（PDU），再到 TCP 和 User Datagram Protocol (UDP)，socket 层提供了一种标准化的方法来管理连接，并在各个终点之间移动数据。内核中网络源代码可以在 ./linux/net 中找到。</p>
<p>（6）设备驱动程序</p>
<p>Linux 内核中有大量代码都在设备驱动程序中，它们能够运转特定的硬件设备。Linux 源码树提供了一个驱动程序子目录，这个目录又进一步划分为各种支持设备，例如 Bluetooth、I2C、serial 等。设备驱动程序的代码可以在 ./linux/drivers 中找到。</p>
<p>（7）依赖体系结构的代码</p>
<p>尽管 Linux 很大程度上独立于所运行的体系结构，但是有些元素则必须考虑体系结构才能正常操作并实现更高效率。./linux/arch 子目录定义了内核源代码中依赖于体系结构的部分，其中包含了各种特定于体系结构的子目录（共同组成了 BSP）。对于一个典型的桌面系统来说，使用的是 x86 目录。每个体系结构子目录都包含了很多其他子目录，每个子目录都关注内核中的一个特定方面，例如引导、内核、内存管理等。这些依赖体系结构的代码可以在 ./linux/arch 中找到。</p>
<p>如果 Linux 内核的可移植性和效率还不够好，Linux 还提供了其他一些特性，它们无法划分到上面的分类中。作为一个生产操作系统和开源软件，Linux 是测试新协议及其增强的良好平台。Linux 支持大量网络协议，包括典型的 TCP/IP，以及高速网络的扩展（大于 1 Gigabit Ethernet [GbE] 和 10 GbE）。Linux 也可以支持诸如流控制传输协议（SCTP）之类的协议，它提供了很多比 TCP 更高级的特性（是传输层协议的接替者）。</p>
<p>Linux 还是一个动态内核，支持动态添加或删除软件组件。被称为动态可加载内核模块，它们可以在引导时根据需要（当前特定设备需要这个模块）或在任何时候由用户插入。</p>
<p>Linux 最新的一个增强是可以用作其他操作系统的操作系统（称为系统管理程序）。最近，对内核进行了修改，称为基于内核的虚拟机（KVM）。这个修改为用户空间启用了一个新的接口，它可以允许其他操作系统在启用了 KVM 的内核之上运行。除了运行 Linux 的其他实例之外， Microsoft Windows 也可以进行虚拟化。惟一的限制是底层处理器必须支持新的虚拟化指令。</p>
<h2 id="Linux-体系结构和内核结构区别"><a class="header-anchor" href="#Linux-体系结构和内核结构区别">¶</a>Linux 体系结构和内核结构区别</h2>
<p>1．当被问到 Linux 体系结构（就是 Linux 系统是怎么构成的）时，我们可以参照下图这么回答：<br>
从大的方面讲，Linux 体系结构可以分为两块：<br>
（1）用户空间：用户空间中又包含了，用户的应用程序，C 库<br>
（2）内核空间：内核空间包括，系统调用，内核，以及与平台架构相关的代码</p>
<p><img src="/public/2021/12/23/linux/linux_in_one/174749211_7_20191103041018642.jpeg" alt="174749211_7_20191103041018642"></p>
<p>2．Linux 体系结构要分成用户空间和内核空间的原因：</p>
<p>1）现代 CPU 通常都实现了不同的工作模式。</p>
<p>以 ARM 为例：ARM 实现了 7 种工作模式，不同模式下 CPU 可以执行的指令或者访问的寄存器不同：<br>
（1）用户模式  usr<br>
（2）系统模式  sys<br>
（3）管理模式  svc<br>
（4）快速中断  fiq<br>
（5）外部中断  irq<br>
（6）数据访问终止 abt<br>
（7）未定义指令异常</p>
<p>以（2）X86 为例：X86 实现了 4 个不同级别的权限，Ring0—Ring3 ;Ring0 下可以执行特权指令，可以访问 IO 设备；Ring3 则有很多的限制</p>
<p>2）所以，Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了 2 部分；</p>
<p>3．用户空间和内核空间是程序执行的两种不同状态，我们可以通过 “系统调用” 和“硬件中断“来完成用户空间到内核空间的转移</p>
<p>4．Linux 的内核结构（注意区分 LInux 体系结构和 Linux 内核结构）</p>
<p><img src="/public/2021/12/23/linux/linux_in_one/174749211_8_20191103041018705.jpeg" alt="174749211_8_20191103041018705"></p>
<h2 id="Linux-驱动的-platform-机制"><a class="header-anchor" href="#Linux-驱动的-platform-机制">¶</a>Linux 驱动的 platform 机制</h2>
<p>Linux 的这种 platform driver 机制和传统的 device_driver 机制相比，一个十分明显的优势在于 platform 机制将本身的资源注册进内核，由内核统一管理，在驱动程序中使用这些资源时通过 platform_device 提供的标准接口进行申请并使用。这样提高了驱动和资源管理的独立性，并且拥有较好的可移植性和安全性。下面是 SPI 驱动层次示意图，Linux 中的 SPI 总线可理解为 SPI 控制器引出的总线：</p>
<p><img src="/public/2021/12/23/linux/linux_in_one/174749211_9_20191103041018752.jpeg" alt="174749211_9_20191103041018752"></p>
<p>和传统的驱动一样，platform 机制也分为三个步骤：</p>
<p>1、总线注册阶段：</p>
<p>内核启动初始化时的 main.c 文件中的 kernel_init()→do_basic_setup()→driver_init()→platform_bus_init()→bus_register(&amp;platform_bus_type)，注册了一条 platform 总线（虚拟总线，platform_bus）。</p>
<p>2、添加设备阶段：</p>
<p>设备注册的时候 Platform_device_register()→platform_device_add()→(pdev→dev.bus = &amp;platform_bus_type)→device_add()，就这样把设备给挂到虚拟的总线上。</p>
<p>3、驱动注册阶段：</p>
<p>Platform_driver_register()→driver_register()→bus_add_driver()→driver_attach()→bus_for_each_dev(), 对在每个挂在虚拟的 platform bus 的设备作__driver_attach()→driver_probe_device(), 判断 drv→bus→match() 是否执行成功，此时通过指针执行 platform_match→strncmp(pdev→name , drv→name , BUS_ID_SIZE), 如果相符就调用 really_probe(实际就是执行相应设备的 platform_driver→probe(platform_device)。) 开始真正的探测，如果 probe 成功，则绑定设备到该驱动。</p>
<p>从上面可以看出，platform 机制最后还是调用了 bus_register() , device_add() , driver_register() 这三个关键的函数。</p>
<p>下面看几个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span>           </span></span><br><span class="line"><span class="class">(/<span class="title">include</span>/<span class="title">linux</span>/<span class="title">Platform_device</span>.<span class="title">h</span>)</span></span><br><span class="line"><span class="class">&#123;</span>        </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>    * name;        </span><br><span class="line"><span class="keyword">int</span>        id;        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span>    <span class="title">dev</span>;</span>        </span><br><span class="line">u32        num_resources;        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span>    * <span class="title">resource</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Platform_device 结构体描述了一个 platform 结构的设备，在其中包含了一般设备的结构体 struct device  dev; 设备的资源结构体 struct resource   * resource; 还有设备的名字 const char * name。（注意，这个名字一定要和后面 platform_driver.driver àname 相同，原因会在后面说明。）</p>
<p>该结构体中最重要的就是 resource 结构，这也是之所以引入 platform 机制的原因。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span>                            </span></span><br><span class="line"><span class="class">( /<span class="title">include</span>/<span class="title">linux</span>/<span class="title">ioport</span>.<span class="title">h</span>)</span></span><br><span class="line"><span class="class">&#123;</span>        </span><br><span class="line"><span class="keyword">resource_size_t</span> start;        </span><br><span class="line"><span class="keyword">resource_size_t</span> end;        </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;        </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">其中 flags位表示该资源的类型，start和end分别表示该资源的起始地址和结束地址(/include/linux/Platform_device.h)：</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span>              </span></span><br><span class="line"><span class="class">&#123;</span>        </span><br><span class="line"><span class="keyword">int</span> (*probe)(struct platform_device *);        </span><br><span class="line"><span class="keyword">int</span> (*remove)(struct platform_device *);        </span><br><span class="line"><span class="keyword">void</span> (*shutdown)(struct platform_device *);        </span><br><span class="line"><span class="keyword">int</span> (*suspend)(struct platform_device *, <span class="keyword">pm_message_t</span> state);        </span><br><span class="line"><span class="keyword">int</span> (*suspend_late)(struct platform_device *, <span class="keyword">pm_message_t</span> state);        </span><br><span class="line"><span class="keyword">int</span> (*resume_early)(struct platform_device *);        </span><br><span class="line"><span class="keyword">int</span> (*resume)(struct platform_device *);        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">Platform_driver结构体描述了一个platform结构的驱动。其中除了一些函数指针外，还有一个一般驱动的device_driver结构。</span><br></pre></td></tr></table></figure>
<p>名字要一致的原因：</p>
<p>上面说的驱动在注册的时候会调用函数 bus_for_each_dev(), 对在每个挂在虚拟的 platform bus 的设备作__driver_attach()→driver_probe_device(), 在此函数中会对 dev 和 drv 做初步的匹配，调用的是 drv-&gt;bus-&gt;match 所指向的函数。platform_driver_register 函数中 drv-&gt;driver.bus = &amp;platform_bus_type，所以 drv-&gt;bus-&gt;match 就为 platform_bus_type→match, 为 platform_match 函数，该函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">platform_match</span><span class="params">(struct device * dev, struct device_driver * drv)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> = <span class="title">container_of</span>(<span class="title">dev</span>, <span class="title">struct</span> <span class="title">platform_device</span>, <span class="title">dev</span>);</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">strncmp</span>(pdev-&gt;name, drv-&gt;name, BUS_ID_SIZE) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是比较 dev 和 drv 的 name，相同则会进入 really_probe（）函数，从而进入自己写的 probe 函数做进一步的匹配。所以 dev→name 和 driver→drv→name 在初始化时一定要填一样的。</p>
<p>不同类型的驱动，其 match 函数是不一样的，这个 platform 的驱动，比较的是 dev 和 drv 的名字，还记得 usb 类驱动里的 match 吗？它比较的是 Product ID 和 Vendor ID。</p>
<p>个人总结 Platform 机制的好处：</p>
<p>1、提供 platform_bus_type 类型的总线，把那些不是总线型的 soc 设备都添加到这条虚拟总线上。使得，总线——设备——驱动的模式可以得到普及。</p>
<p>2、提供 platform_device 和 platform_driver 类型的数据结构，将传统的 device 和 driver 数据结构嵌入其中，并且加入 resource 成员，以便于和 Open Firmware 这种动态传递设备资源的新型 bootloader 和 kernel 接轨。</p>
<h2 id="Linux-内核体系结构"><a class="header-anchor" href="#Linux-内核体系结构">¶</a>Linux 内核体系结构</h2>
<p>因为 Linux 内核是单片的，所以它比其他类型的内核占用空间最大，复杂度也最高。这是一个设计特性，在 Linux 早期引起了相当多的争论，并且仍然带有一些与单内核固有的相同的设计缺陷。</p>
<img src="/public/2021/12/23/linux/linux_in_one/174749211_10_20191103041018783.jpeg" alt="174749211_10_20191103041018783" style="zoom:50%;">
<p>为了解决这些缺陷，Linux 内核开发人员所做的一件事就是使内核模块可以在运行时加载和卸载，这意味着您可以动态地添加或删除内核的特性。这不仅可以向内核添加硬件功能，还可以包括运行服务器进程的模块，比如低级别虚拟化，但也可以替换整个内核，而不需要在某些情况下重启计算机。<br>
想象一下，如果您可以升级到 Windows 服务包，而不需要重新启动……</p>
<h2 id="内核模块"><a class="header-anchor" href="#内核模块">¶</a>内核模块</h2>
<p>如果 Windows 已经安装了所有可用的驱动程序，而您只需要打开所需的驱动程序怎么办? 这本质上就是内核模块为 Linux 所做的。内核模块，也称为可加载内核模块 (LKM)，对于保持内核在不消耗所有可用内存的情况下与所有硬件一起工作是必不可少的。</p>
<p><img src="/public/2021/12/23/linux/linux_in_one/174749211_11_20191103041018908.jpeg" alt="174749211_11_20191103041018908"></p>
<p>模块通常向基本内核添加设备、文件系统和系统调用等功能。lkm 的文件扩展名是. ko，通常存储在 / lib/modules 目录中。由于模块的特性，您可以通过在启动时使用 menuconfig 命令将模块设置为 load 或 not load，或者通过编辑 / boot/config 文件，或者使用 modprobe 命令动态地加载和卸载模块，轻松定制内核。</p>
<p>第三方和封闭源码模块在一些发行版中是可用的，比如 Ubuntu，默认情况下可能无法安装，因为这些模块的源代码是不可用的。该软件的开发人员 (即 nVidia、ATI 等) 不提供源代码，而是构建自己的模块并编译所需的. ko 文件以便分发。虽然这些模块像 beer 一样是免费的，但它们不像 speech 那样是免费的，因此不包括在一些发行版中，因为维护人员认为它通过提供非免费软件 “污染” 了内核。</p>
<p>内核并不神奇，但对于任何正常运行的计算机来说，它都是必不可少的。Linux 内核不同于 OS X 和 Windows，因为它包含内核级别的驱动程序，并使许多东西 “开箱即用”。希望您能对软件和硬件如何协同工作以及启动计算机所需的文件有更多的了解。</p>
<h2 id="Linux-内核学习经验总结"><a class="header-anchor" href="#Linux-内核学习经验总结">¶</a>Linux 内核学习经验总结</h2>
<p>开篇</p>
<p>学习内核，每个人都有自己的学习方法，仁者见仁智者见智。以下是我在学习过程中总结出来的东西，对自身来说，我认为比较有效率，拿出来跟大家交流一下。</p>
<p>内核学习，一偏之见；疏漏难免，恳请指正。</p>
<p>为什么写这篇博客</p>
<p>刚开始学内核的时候，不要执着于一个方面，不要专注于一个子系统就一头扎到实际的代码行中去，因为这样的话，牵涉的面会很广，会碰到很多困难，容易产生挫败感，一个函数体中（假设刚开始的时候正在学习某个方面的某个具体的功能函数）很可能掺杂着其他各个子系统方面设计理念（多是大量相关的数据结构或者全局变量，用于支撑该子系统的管理工作）下相应的代码实现，这个时候看到这些东西，纷繁芜杂，是没有头绪而且很不理解的，会产生很多很多的疑问，（这个时候如果对这些疑问纠缠不清，刨根问底，那么事实上就是在学习当前子系统的过程中频繁的去涉足其他子系统，这时候注意力就分散了），而事实上等了解了各个子系统后再回头看这些东西的话，就简单多了，而且思路也会比较清晰。所以，要避免 “只见树木，不见森林”，不要急于深入到底层代码中去，不要过早研究底层代码。</p>
<p>我在大二的时候刚开始接触内核，就犯了这个错误，一头扎到内存管理里头，去看非常底层的实现代码，虽然也是建立在内存管理的设计思想的基础上，但是相对来说，比较孤立，因为此时并没有学习其它子系统，应该说无论是视野还是思想，都比较狭隘，所以代码中牵涉到的其它子系统的实现我都直接跳过了，这一点还算聪明，当然也是迫不得已的。</p>
<p>我的学习方法</p>
<p>刚开始，我认为主要的问题在于你知道不知道，而不是理解不理解，某个子系统的实现采用了某种策略、方法，而你在学习中需要做的就是知道有这么一回事儿，然后才是理解所描述的策略或者方法。</p>
<p>根据自己的学习经验，刚开始学习内核的时候，我认为要做的是在自己的脑海中建立起内核的大体框架，理解各个子系统的设计理念和构建思想，这些理念和思想会从宏观上呈献给你清晰的脉络，就像一个去除了枝枝叶叶的大树的主干，一目了然；当然，肯定还会涉及到具体的实现方法、函数，但是此时接触到的函数或者方法位于内核实现的较高的层次，是主（要）函数，已经了解到这些函数，针对的是哪些设计思想，实现了什么样的功能，达成了什么样的目的，混个脸熟的说法在这儿也是成立的。至于该主函数所调用的其它的辅助性函数就等同于枝枝叶叶了，不必太早就去深究。此时，也就初步建立起了内核子系统框架和代码实现之间的关联，关联其实很简单，比如一看到某个函数名字，就想起这个函数是针对哪个子系统的，实现了什么功能。</p>
<p>我认为此时要看的就是 LKD3，这本书算是泛泛而谈，主要就是从概念，设计，大的实现方法上描述各个子系统，而对于具体的相关的函数实现的代码讲解很少涉及 (对比于 ULK3，此书主要就是关于具体函数代码的具体实现的深入分析，当然，你也可以看，但是过早看这本书，会感觉很痛苦，很枯燥无味，基本上都是函数的实现)，很少，但不是没有，这就很好，满足我们当前的需求，还避免我们过早深入到实际的代码中去。而且本书在一些重要的点上还给出了写程序时的注意事项，算是指导性建议。主要的子系统包括：内存管理，进程管理和调度，系统调用，中断和异常，内核同步，时间和定时器管理，虚拟文件系统，块 I/O 层，设备和模块。（这里的先后顺序其实就是 LKD3 的目录的顺序）。</p>
<p>我学习的时候是三本书交叉着看的，先看 LKD3，专于一个子系统，主要就是了解设计的原理和思想，当然也会碰到对一些主要函数的介绍，但大多就是该函数基于前面介绍的思想和原理完成了什么样的功能，该书并没有就函数本身的实现进行深入剖析。然后再看 ULK3 和 PLKA 上看同样的子系统，但是并不仔细分析底层具体函数的代码，只是粗略地、不求甚解地看，甚至不看。因为，有些时候，在其中一本书的某个点上，卡壳了，不是很理解了，在另外的书上你可能就碰到对同一个问题的不同角度的描述，说不准哪句话就能让你豁然开朗，如醍醐灌顶。我经常碰到这种情况。</p>
<p>并不是说学习过程中对一些函数体的实现完全就忽略掉，只要自己想彻底了解其代码实现，没有谁会阻止你。我是在反复阅读过程中慢慢深入的。比如 VFS 中文件打开需要对路径进行分析，需要考虑的细节不少 (.././ 之类的)，但是其代码实现是很好理解的。再比如，CFS 调度中根据 shedule latency、队列中进程个数及其 nice 值(使用的是动态优先级) 计算出分配给进程的时间片，没理由不看的，这个太重要了，而且也很有意思。</p>
<p>ULK3 也会有设计原理与思想之类的概括性介绍，基本上都位于某个主题的开篇段落。但是更多的是对支持该原理和思想的主要函数实现的具体分析，同样在首段，一句话综述函数的功能，然后对函数的实现以 1、2、3，或者 a、b、c 步骤的形式进行讲解。我只是有选择性的看，有时候对照着用 source insight 打开的源码，确认一下代码大体上确实是按书中所描述的步骤实现的，就当是增加感性认识。由于步骤中掺杂着各种针对不同实现目的安全性、有效性检查，如果不理解就先跳过。这并不妨碍你对函数体功能实现的整体把握。</p>
<p>PLKA 介于 LKD3 和 ULK3 之间。我觉得 PLKA 的作者（看照片，真一德国帅小伙，技术如此了得）肯定看过 ULK，无论他的本意还是有意，总之 PLKA 还是跟 ULK 有所不同，对函数的仔细讲解都做补充说明，去掉函数体中边边角角的情况，比如一些特殊情况的处理，有效性检查等，而不妨碍对整个函数体功能的理解，这些他都有所交代，做了声明；而且，就像 LKD3 一样，在某些点上也给出了指导性编程建议。作者们甚至对同一个主要函数的讲解的着重点都不一样。这样的话，对我们学习的人而言，有助于加深理解。另外，我认为很重要的一点就是 PLKA 针对的 2.6.24 的内核版本，而 ULK 是 2.6.11，LKD3 是 2.6.34。在某些方面 PLKA 比较接近现代的实现。其实作者们之所以分别选择 11 或者 24，都是因为在版本发行树中，这两个版本在某些方面都做了不小的变动，或者说是具有标志性的转折点（这些信息大多是在书中的引言部分介绍的，具体的细节我想不起来了）。</p>
<p>Intel V3，针对 X86 的 CPU，本书自然是系统编程的权威。内核部分实现都可以在本书找到其根源。所以，在读以上三本书某个子系统的时候，不要忘记可以在 V3 中相应章节找到一些基础性支撑信息。</p>
<p>在读书过程中，会产生相当多的疑问，这一点是确信无疑的。大到搞不明白一个设计思想，小到不理解某行代码的用途。各个方面，各种疑问，你完全可以把不理解的地方都记录下来 (不过，我并没有这么做，没有把疑问全部记下来，只标记了很少一部分我认为很关键的几个问题)，专门写到一张纸上，不对，一个本上，我确信会产生这么多的疑问，不然内核相关的论坛早就可以关闭了。其实，大部分的问题（其中很多问题都是你知道不知道有这么一回事的问题）都可以迎刃而解，只要你肯回头再看，书读百遍，其义自现。多看几遍，前前后后的联系明白个七七八八是没有问题的。我也这么做了，针对某些子系统也看了好几遍，切身体会。</p>
<p>当你按顺序学习这些子系统的时候，前面的章节很可能会引用后面的章节，就像 PLKA 的作者说的那样，完全没有向后引用是不可能的，他能做的只是尽量减少这种引用而又不损害你对当前问题的理解。不理解，没关系，跳过就行了。后面的章节同样会有向前章节的引用，不过这个问题就简单一些了 ，你可以再回头去看相应的介绍，当时你不太理解的东西，很可能这个时候就知道了它的设计的目的以及具体的应用。不求甚解只是暂时的。比如说，内核各个子系统之间的交互和引用在代码中的体现就是实现函数穿插调用，比如你在内存管理章节学习了的内存分配和释放的函数，而你是了解内存在先的，在学习驱动或者模块的时候就会碰到这些函数的调用，这样也就比较容易接受，不至于太过茫然；再比如，你了解了系统时间和定时器的管理，再回头看中断和异常中 bottom half 的调度实现，你对它的理解就会加深一层。</p>
<p>子系统进行管理工作需要大量的数据结构。子系统之间交互的一种方式就是各个子系统各自的主要数据结构通过指针成员相互引用。学习过程中，参考书上在讲解某个子系统的时候会对数据结构中主要成员的用途解释一下，但肯定不会覆盖全部（成员比较多的情况，例如 task_struct），对其它子系统基于某个功能实现的引用可能解释了，也可能没做解释，还可能说这个变量在何处会做进一步说明。所以，不要纠结于一个不理解的点上，暂且放过，回头还可以看的。之间的联系可以在对各个子系统都有所了解之后再建立起来。其实，我仍然在强调先理解概念和框架的重要性。</p>
<p>等我们完成了建立框架这一步，就可以选择一个比较感兴趣的子系统，比如驱动、网络，或者文件系统之类的。这个时候你再去深入了解底层代码实现，相较于一开始就钻研代码，更容易一些，而且碰到了不解之处，或者忘记了某个方面的实现，此时你完全可以找到相应的子系统，因为你知道在哪去找，查漏补缺，不仅完成了对当前函数的钻研，而且可以回顾、温习以前的内容，融会贯通的时机就在这里了。</p>
<p>《深入理解 linux 虚拟内存》(2.4 内核版本)，LDD3，《深入理解 linux 网络技术内幕》，几乎每一个子系统都需要一本书的容量去讲解，所以说，刚开始学习不宜对某个模块太过深入，等对各个子系统都有所了解了，再有针对性的去学习一个特定的子系统。这时候对其它系统的援引都可以让我们不再感到茫然、复杂，不知所云。</p>
<p>比如，LDD3 中的以下所列章节：构造和运行模块，并发和竞态，时间、延迟及延缓操作, 分配内存，中断处理等，都属于驱动开发的支撑性子系统，虽说本书对这些子系统都专门开辟一个章节进行讲解，但是详细程度怎么能比得上 PLKA，ULK3，LKD3 这三本书，看完这三本书，你会发现读 LDD3 这些章节的时候简直跟喝白开水一样，太随意了，因为 LDD3 的讲解比之 LKD3 更粗略。打好了基础，PCI、USB、TTY 驱动，块设备驱动，网卡驱动，需要了解和学习的东西就比较有针对性了。这些子系统就属于通用子系统，了解之后，基于这些子系统的子系统的开发—驱动 (需进一步针对硬件特性) 和网络(需进一步理解各种协议)—相对而言，其学习难度大大降低，学习进度大大加快，学习效率大大提升。说着容易做来难。达到这样一种效果的前提就是：必须得静下心来，认真读书，要看得进去，PLKA，ULK3 厚得都跟砖头块儿一样，令人望之生畏，如果没有兴趣，没有热情，没有毅力，无论如何都是不行，因为需要时间，需要很长时间。我并不是说必须打好了基础才可以进行驱动开发，只是说打好了基础的情况下进行开发会更轻松，更有效率，而且自己对内核代码的驾驭能力会更强大。这只是我个人见解，我自己的学习方式，仅供参考。</p>
<p>语言</p>
<p>PLKA 是个德国人用德语写的，后来翻译成英文，又从英文翻译成中文，我在网上书店里没有找到它的纸质英文版，所以就买了中文版的。ULK3 和 LKD3 都是英文版的。大牛们写的书，遣词造句真的是简洁，易懂，看原版对我们学习计算机编程的程序员来说完全不成问题，最好原汁原味。如果一本书确实翻译地很好，我们当然可以看中文版的，用母语进行学习，理解速度和学习进度当然是很快的，不作他想。看英文的时候不要脑子里想着把他翻译成中文，没必要。</p>
<p>API 感想</p>
<p>“比起知道你所用技术的重要性，成为某一个特别领域的专家是不重要的。知道某一个具体 API 调用一点好处都没有，当你需要他的时候只要查询下就好了。” 这句话源于我看到的一篇翻译过来的博客。我想强调的就是，这句话针应用型编程再合适不过，但是内核 API 就不完全如此。</p>
<p>内核相当复杂，学习起来很不容易，但是当你学习到一定程度，你会发现，如果自己打算写内核代码，到最后要关注的仍然是 API 接口，只不过这些 API 绝大部分是跨平台的，满足可移植性。内核黑客基本上已经标准化、文档化了这些接口，你所要做的只是调用而已。当然，在使用的时候，最好对可移植性这一话题在内核中的编码约定烂熟于心，这样才会写出可移植性的代码。就像应用程序一样，可以使用开发商提供的动态库 API，或者使用开源 API。同样是调用 API，不同点在于使用内核 API 要比使用应用 API 了解的东西要多出许多。</p>
<p>当你了解了操作系统的实现—这些实现可都是对应用程序的基础性支撑啊—你再去写应用程序的时候，应用程序中用到的多线程，定时器，同步锁机制等等等等，使用共享库 API 的时候，联系到操作系统，从而把对该 API 的文档描述同自己所了解到的这些方面在内核中的相应支撑性实现结合起来进行考虑，这会指导你选择使用哪一个 API 接口，选出效率最高的实现方式。对系统编程颇有了解的话，对应用编程不无益处，甚至可以说是大有好处。</p>
<p>设计实现的本质，知道还是理解</p>
<p>操作系统是介于底层硬件和应用软件之间的接口，其各个子系统的实现很大程度上依赖于硬件特性。书上介绍这些子系统的设计和实现的时候，我们读过了，也就知道了，如果再深入考虑一下，为什么整体架构要按照这种方式组织，为什么局部函数要遵循这样的步骤处理，知其然，知其所以然，如果你知道了某个功能的实现是因为芯片就是这么设计的，CPU 就是这么做的，那么你的疑问也就基本上到此为止了。再深究，就是芯片架构方面的设计与实现，对于程序员来讲，无论是系统还是应用程序员，足迹探究到这里，已经解决了很多疑问，因为我们的工作性质偏软，而这些东西实在是够硬。</p>
<p>比如，ULK3 中讲解的中断和异常的实现，究其根源，那是因为 Intel x86 系列就是这么设计的，去看看 Intel V3 手册中相应章节介绍，都可以为 ULK3 中描述的代码实现方式找到注解。还有时间和定时器管理，同样可以在 Intel V3 对 APIC 的介绍中获取足够的信息，操作系统就是依据这些硬件特性来实现软件方法定义的。</p>
<p>又是那句话，不是理解不理解的问题，而是知道不知道的问题。有时候，知道了，就理解了。在整个学习过程中，知道，理解，知道，理解，知道……，交叉反复。为什么开始和结尾都是知道，而理解只是中间步骤呢？世界上万事万物自有其规律，人类只是发现而已，实践是第一位的，实践就是知道的过程，实践产生经验，经验的总结就是理论，理论源于实践，理论才需要理解。我们学习内核，深入研究，搞来搞去，又回到了芯片上，芯片是物质的，芯片的功用基于自然界中物质本有的物理和电子特性。追本溯源，此之谓也。</p>
<p>动手写代码</p>
<p>纸上得来终觉浅，绝知此事要躬行。只看书是绝对不行的，一定要结合课本给出的编程建议自己敲代码。刚开始就以模块形式测试好了，或者自己编译一个开发版本的内核。一台机器的话，使用 UML 方式调试，内核控制路走到哪一步，单步调试看看程序执行过程，比书上的讲解更直观明了。一定要动手实际操作。</p>
<p>参考书</p>
<p>LDD3          Linux Device Driver 3rd</p>
<p>LKD3          Linux Kernel Development 3rd</p>
<p>ULK3          Understanding the Linux Kernel 3rd</p>
<p>PLKA          Professional Linux Kernel Architecture</p>
<p>UML            User Mode Linux</p>
<p>Intel V3       Intel? 64 and IA-32 Architectures Software Developer’s Manual Volume 3 (3A, 3B &amp; 3C): System Programming Guide</p>
<p>作者在写书的时候，都是以自己的理解组织内容，从自己的观点看待一个主题，关注点跟作者自身有很大的关系。出书的时间有先后，后来人针对同一个主题想要出书而又不落入窠臼，最好有自己的切入方式，从自己的角度讲解相关问题，这才值得出这本书，千篇一律是个掉价的行为，书就不值钱了。</p>
<p>尽信书不如无书。</p>
<p><a href="http://lwn.net/Articles/419855/" target="_blank" rel="noopener">http://lwn.net/Articles/419855/</a> 此处是一篇关于 LKD3 的书评，指出了其中的错误，当你读完的时候，不妨去找找，看一下自己在其中所描述的地方有什么特别的印象。</p>
<p><a href="http://lwn.net/Articles/161190" target="_blank" rel="noopener">http://lwn.net/Articles/161190</a> / 此处是一篇对 ULK3 的介绍，我认为其中很关键的几句话就可以给本书定位：</p>
<blockquote>
<p>Many of the key control paths in the kernel are described, step by step;</p>
<p>一步一步地讲述内核控制路径的实现。</p>
<p>The level of detail sometimes makes it hard to get a sense for the big picture, but it does help somebody trying to figure out how a particular function works.</p>
<p>对代码讲解的详细程度有时候很难让读者把握住它的主旨大意，但是确实有助于读者理解一个特定的函数到底是如何工作的。</p>
<p>Indeed, that is perhaps the key feature which differentiates this book. It is very much a “how it works” book, designed to help people understand the code.</p>
<p>事实上，这也正是本书与众不同的地方。更像一个 “如何工作” 的书，帮助读者理解代码实现。</p>
<p>It presents kernel functions and data structures, steps the reader through them, but does not, for example, emphasize the rules for using them. UTLK is a study guide, not a programming manual.</p>
<p>本书描述了内核函数和数据结构，引导读者穿行于其间，但是，并没有着重强调使用它们的法则。UTLK 是一本学习指南，而不是编程手册。</p>
</blockquote>
<p>这几句话对本书的描述非常到位。基于此，作为指导性原则，我们就可以很有效率地使用它了。</p>
<p>看一本技术书籍，书中的序言部分绝对是首先应该翻阅的，其次就是目录。我发现在阅读过程中我会频繁的查看目录，甚至是喜欢看目录。</p>
<h2 id="结尾"><a class="header-anchor" href="#结尾">¶</a>结尾</h2>
<p>兴趣的力量是无穷的。兴趣能带来激情，如果工作可以和兴趣结合到一起，工作起来才会有热情，那么工作就不只是工作了，更是一种享受。</p>
<p>Linux，我的兴趣，我的动力，我的方向，我的未来！</p>
<p>原文连接多处：<br>
图片来自：<a href="http://www.360doc.com/content/19/1103/16/36367108_870849346.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/19/1103/16/36367108_870849346.shtml</a><br>
 <a href="http://www.openpcba.com/web/contents/get?id=4638&amp;tid=15" target="_blank" rel="noopener">http://www.openpcba.com/web/contents/get?id=4638&amp;tid=15</a>【已失效】</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>内核开发</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」白板与笔记融合：我的四个氢图使用场景</title>
    <url>/public/2022/07/15/test/202207/2022-07-03-010835583781/</url>
    <content><![CDATA[<p>「转」<a href="https://sspai.com/post/73246" target="_blank" rel="noopener">白板与笔记融合：我的四个氢图使用场景</a></p>
<a id="more"></a>
<p><strong>Matrix 首页推荐</strong></p>
<p><a href="https://sspai.com/matrix" target="_blank" rel="noopener">Matrix</a>
是少数派的写作社区，我们主张分享真实的产品体验，有实用价值的经验与思考。我们会不定期挑选 Matrix 最优质的文章，展示来自用户的最真实的体验和观点。<br>
文章代表作者个人观点，少数派仅对标题和排版略作修改。</p>
<h2 id="引言"><a class="header-anchor" href="#引言">¶</a>引言</h2>
<p>在两个月前，我推送了《<a href="https://sspai.com/post/71842" target="_blank" rel="noopener">Heptabase：面向未来的知识操作系统</a>》一文，Heptabase
以其强大的视觉交互效果吸引了很多用户的关注。然而，Heptabase 对于很多读者而言，价格太贵。</p>
<p>对此，还有没有类似的 <strong>白 板和笔记融合</strong>的产品？有的，同类产品国外还有
[Muse](<a href="https://museapp.com/memos/2021-11-road-to-" target="_blank" rel="noopener">https://museapp.com/memos/2021-11-road-to-</a>
muse-2/)、<a href="https://www.scrintal.com/" target="_blank" rel="noopener">Scrintal</a>.
同样存在价格太贵以及付费比较麻烦等问题。今天推荐一款国产白板笔记软件----<a href="https://qingtu.co/" target="_blank" rel="noopener">氢图</a>.</p>
<h2 id="什么是氢图？"><a class="header-anchor" href="#什么是氢图？">¶</a>什么是氢图？</h2>
<p>什么是<a href="https://qingtu.co/" target="_blank" rel="noopener">氢图</a>？从产品形态上来说，这是一款以白板为基础，融合笔记功能的知识管理工具。通过强大的 <strong>可
视化</strong>功能，你可以在其中完成从资料收集、构思、组织笔记、创意写作等工作流。</p>
<p>具体而言，氢图以白板作为底层，提供了一个全新的可视化操作空间。如图。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/f87e9602464ca3528582fc4b647889e6.png" alt></p>
<ul>
<li><strong>画 板</strong>。氢图是由一个个画板组成。每个画板都是一个 <strong>无 限延伸</strong>的、独立的 <strong>工 作空间</strong>。画板由笔记、形状、文本、连线、文件等模块组成。</li>
<li><strong>笔 记</strong>。点击即可创建类似便签的 <strong>卡 片笔记</strong>，支持常见的笔记编辑功能。当然，卡片 <strong>颜 色</strong>、 <strong>尺 寸</strong>可以根据需要进行调整。</li>
<li><strong>形 状</strong>。本质上，这是一种带有特定形状的文本框。形状主要用于作为多个笔记的背景框，以表示这些笔记属于某个 <strong>主 题</strong>，或者 <strong>凸 显</strong>白板的 <strong>某 个区域</strong>。此外，这个形状也可用于 <strong>制 作流程图</strong>等场景。</li>
<li><strong>文 本</strong>。区别于 <strong>笔 记</strong>和 <strong>形 状</strong>， <strong>文 本</strong>模块允许用户创建一个不包含任何卡片背景的文本框。</li>
<li><strong>连 线</strong>。在氢图中的不同模块之间，添加各种带有特定方向的 <strong>有 向箭头</strong>。</li>
<li><strong>文 件</strong>。支持将 Word、PDF、图片等各种文件添加到当前画板之中。</li>
</ul>
<p>为了更好地展示氢图的功能，下面我将从 <strong>时 间管理和任务管理、思维辅助、笔记记录、创意写作</strong>等维度展示氢图的使用场景。</p>
<h2 id="时间管理和任务管理"><a class="header-anchor" href="#时间管理和任务管理">¶</a>时间管理和任务管理</h2>
<h3 id="GTD"><a class="header-anchor" href="#GTD">¶</a>GTD</h3>
<p><a href="https://gettingthingsdone.com/" target="_blank" rel="noopener">GTD</a> 即 Getting Things Done
的英文缩写，中文相关著作翻译为《搞定》。GTD
是一种时间管理方法，其核心理念是要求使用者将需要做的事情写下来，而不是花费精力记住这些任务，进而减轻了你的大脑压力，促使人们集中精力处理手头的任务。与此同时，GTD
提出了从收集 Capture -&gt;理清 Clarify -&gt;组织 Organize -&gt;回顾 Reflect -&gt;执行 Engage 的任务处理流程。</p>
<p>![Getting Things Done: Your Step-By-Step
Guide](<a href="https://cdn.sspai.com/2022/05/16/article/a72d9fa746f79b5590006550d20c878a?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/16/article/a72d9fa746f79b5590006550d20c878a?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>GTD 提供了清晰、可靠的任务组织系统。为了提高对于任务的组织能力，GTD 一般和看板工具进行结合。如图，我使用氢图模拟了基于看板视图的 GTD.
当然，你也可以将番茄钟工作法、四象限矩阵等方法融合至 GTD 之中。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/e9655b071500184b7ecfeee9e12a6bc5.png" alt></p>
<h3 id="艾森豪威尔矩阵"><a class="header-anchor" href="#艾森豪威尔矩阵">¶</a>艾森豪威尔矩阵</h3>
<p>艾森豪威尔矩阵，即常见的 <strong>四 象限法则</strong>。四象限法则使用 <strong>重 要</strong>和 <strong>紧
急</strong>两个维度，将时间区分为四个象限。具体如图。四象限法的形式不重要，重要的是为任务分配优先级的的思维方式，尽量将精力集中于自己的主要目标以及紧急事项，避免自己时间和精力的无端消耗。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/48f021cd4e83730b3b195ae46f2e1718.png" alt></p>
<h3 id="莫斯科（MoSCoW）方法"><a class="header-anchor" href="#莫斯科（MoSCoW）方法">¶</a>莫斯科（MoSCoW）方法</h3>
<p>关于莫斯科（MoSCoW）这种生产力方法的讨论比较少。同艾森豪威尔矩阵一样，这也是一种优先级排序的方法。MoSCoW 是 必须做/must-have,
应该做/should-have, 可以做/could-have 以及不去做/ will not have 的英文缩写。具体如图：</p>
<p><img src="https://cdn.sspai.com/2022/05/16/44203a851158cbb6dab1b603adb9488f.png" alt></p>
<p>MoSCoW 常用于团队的需求管理等场景。</p>
<p>以上内容主要介绍了每日的时间管理和任务管理。当然，你也可以利用画板特性，将这些笔记卡片进行堆栈和拼接，形成周计划、月计划、年计划等模版。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/6ada3110b46b0d61c4a1239e1708d76b.png" alt></p>
<h2 id="思维辅助"><a class="header-anchor" href="#思维辅助">¶</a>思维辅助</h2>
<p>氢图具有强大的可视化能力，赋予了其强大的思维辅助能力。你可以使用氢图进行头脑风暴等激发灵感和强化思维的各种思维辅助图。具体示范如图：</p>
<h3 id="思维导图"><a class="header-anchor" href="#思维导图">¶</a>思维导图</h3>
<p>关于莎士比亚创作内容的思维导图。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/692b55d8726c9a035ccb03fbf697c43f.png" alt></p>
<h3 id="概念图"><a class="header-anchor" href="#概念图">¶</a>概念图</h3>
<p><img src="https://cdn.sspai.com/2022/05/16/8e582139ea7191697ef4e6578266a936.png" alt></p>
<h3 id="流程图"><a class="header-anchor" href="#流程图">¶</a>流程图</h3>
<p><img src="https://cdn.sspai.com/2022/05/16/3776a865acd2eff7f5bb7cd0bfb3b0c7.png" alt></p>
<h3 id="时间轴"><a class="header-anchor" href="#时间轴">¶</a>时间轴</h3>
<p>时间轴在梳理某个人的主要经历或者某个事件等场景较为常见。比如，小说中的大事年表。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/0116569e2b1754430ebfa386908cb50a.png" alt></p>
<h3 id="矩阵分析"><a class="header-anchor" href="#矩阵分析">¶</a>矩阵分析</h3>
<p>使用氢图,
你可以利用现有的一些分析方法作为指导，建立相应的分析工具。其中，矩阵便是一种十分有用的分析工具。事实上，前面时间管理中的四象限矩阵便是矩阵分析的典型代表。此外，还有不少基于矩阵的分析工具。比如，SWOT
分析、价值 &amp; 投入分析。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/6137bd326365b035ba4bf8045057d591.png" alt></p>
<h3 id="SWOT-分析图"><a class="header-anchor" href="#SWOT-分析图">¶</a>SWOT 分析图</h3>
<p>SWOT 分析，也被称为优劣分析法。SWOT 是英文 Strengths/优势、Weaknesses/劣势、
Opportunities/机会、Threats/威胁四个单词的缩写。换而言之，SWOT
分析是指从自身的优势、劣势，以及外部竞争的机会和威胁等四个维度，分析竞争态势的方法。SWOT 分析可以用于个人或者群体决策。</p>
<p>如图，我使用氢图建立了 SWOT 分析图。比如，你可以对某个产品进行分析。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/e18b6a5bc8bfb7a8dd92e64e1b7f9210.png" alt></p>
<ul>
<li><strong>优 势</strong>：某个产品的竞争优势是什么？资源多、成本低……</li>
<li><strong>劣 势</strong>：某个产品的竞争劣势是什么？功能存在短板……</li>
<li><strong>威 胁</strong>：近一年来，增加了不少竞争对手。他们在某个领域比我们更为专注。此外，国家的政策监管日益严格。</li>
<li><strong>机 会</strong>：我们可以扩展核心业务，通过强大的产品生态体系吸引用户。</li>
</ul>
<h3 id="价值-投入分析图"><a class="header-anchor" href="#价值-投入分析图">¶</a>价值 &amp; 投入分析图</h3>
<p>如图，我使用氢图建立了按照价值和投入强度生成的矩阵。无论日常生活还是工作，理性的选择自然要避免高投入且低价值回报的事情，而将主要精力投入可以带来高价值回报的领域。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/aab5aaef77e679053e917e852b04a15e.png" alt></p>
<h3 id="灵感收集：情绪板"><a class="header-anchor" href="#灵感收集：情绪板">¶</a>灵感收集：情绪板</h3>
<p>灵感收集方法很多，最简单也可能是比较有效的方法，便是拿一张便签本或者电子便签快速收集你的灵感。</p>
<p>以氢图为例，你可以将其在电脑桌面端常驻打开。如果有了新的灵感，便在白板上快速使用快捷键新建一个笔记卡片，快速记录所思所想。</p>
<p>除此之外，今天介绍一种另类的灵感收集方法----情绪板。</p>
<p>Mood Board,
即情绪面板，或者情绪板。当你开始新的创意项目的时候，经常会发现唤醒特定的情绪比较有帮助。而使用文字表达情绪可能比较困难。此时，便需要借助情绪板。</p>
<p>情绪板，是指由于图像、文本、调色板等元素组成的视觉拼接展示。情绪板有一些特定的操作步骤，比如，确定目标、选择方向、关键字/衍生词提取、添加视觉元素/内容描述等。传统上，情绪板被设计师等群体使用。比如，适用于时尚、包装、海报、Logo
、婚礼等设计场景。很多设计团队在准备设计产品时，便会从情绪板开始，团队之间基于情绪板分享想法，讨论和确定产品的视觉风格。</p>
<p>在线数字白板是适合创建情绪板的绝佳载体。</p>
<p>![Why You Need an Inspiration Board | Tips for
Brides](<a href="https://cdn.sspai.com/2022/05/16/article/fcdebba65814410a23f734521db100a8?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/16/article/fcdebba65814410a23f734521db100a8?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>婚礼设计情绪板 Wedding MoodBoard</p>
<p>如今，情绪板已经成为收集灵感、激发创造性思维、勾勒想法的重要工具。情绪板的设计已经不再仅仅局限于设计师，一些内容创作者也会使用情绪板帮助他们唤起某些内容创作所需要的情绪。比如，小说家制作事件情绪板或者小说情绪板。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/16/article/bb03c1f47b8559d61ef586c800bea0a4?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/16/article/bb03c1f47b8559d61ef586c800bea0a4?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)创意作家的情绪板：关于白雪公主故事的情绪板</p>
<p>图源：&lt;<a href="https://thelitnerds.com/2019/10/06/how-to-spark-your-writing-with-mood-" target="_blank" rel="noopener">https://thelitnerds.com/2019/10/06/how-to-spark-your-writing-with-mood-</a>
boards/&gt;</p>
<p>基于上述理念，我使用氢图制作了围绕动漫主题的情绪板。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/d20ca89e6444d118c334ce10b17b5a0a.png" alt></p>
<h2 id="笔记记录"><a class="header-anchor" href="#笔记记录">¶</a>笔记记录</h2>
<h3 id="康奈尔笔记法"><a class="header-anchor" href="#康奈尔笔记法">¶</a>康奈尔笔记法</h3>
<p>康奈尔笔记法，要求使用者遵循记录（Record）、笔记（Reduce）、总结（Recite）、反思（Reflect）、复习（Review）等环节。因此，康奈尔笔记法也被称为
5R
法。如图，基于康奈尔笔记法的理念，使用氢图建立了对应的笔记模版。当然，这只是一种对于纸质笔记本的模拟。在具体做笔记的时候，不必要拘泥于具体的形式。你可以在你的当前笔记周围，快速添加主题为线索、总结、反思等卡片，并且根据需要调整对应的位置。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/02b59a209482d405375b708f43251659.png" alt></p>
<h3 id="麦肯锡笔记法"><a class="header-anchor" href="#麦肯锡笔记法">¶</a>麦肯锡笔记法</h3>
<p>麦肯锡笔记法建立了【空 - 雨 - 伞】的结构框架。原意是需要根据天气情况，判断是否下雨。如果下雨，那么便需要准备雨伞等工具。具体而言，在 <strong>空 -
雨 - 伞</strong>三个部分，分别写上 <strong>现 状描述 - 解释 -
行动</strong>。如果说，康奈尔笔记法更适合学习场景对于知识记录和吸收，那么麦肯锡笔记法更适合工作场景项目笔记记录。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/20db47df6116d38ce79d96c832041a40.png" alt></p>
<h3 id="Plus-Minus-Next-journaling"><a class="header-anchor" href="#Plus-Minus-Next-journaling">¶</a>Plus Minus Next journaling</h3>
<p>Plus Minus Next journaling 的字面意思即是加号、减号、下一步，其结构便如同命名一样，具体如图：在 &quot;+&quot;
一列写上一些正面的任务、事件、想法，而在&quot;-&quot;一列的内容则正好相反，在 &quot;-&gt;&quot; 则写上你的下一步的计划和想法。</p>
<p>![Plus Minus Next journaling - filled
example](<a href="https://cdn.sspai.com/2022/05/16/article/3e9d93947f99311560e9f82499050ba5?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/16/article/3e9d93947f99311560e9f82499050ba5?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>这种笔记方法适合进行周回顾和总结，简单易行。当然，你用这个表格追踪你每日的想法、情绪也是可以的。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/1d899e3211b50eb946adf02cccd2c624.png" alt></p>
<h3 id="卡片笔记法"><a class="header-anchor" href="#卡片笔记法">¶</a>卡片笔记法</h3>
<p>在《卡片笔记写作法》中，详细介绍了卡片笔记法的流程。具体而言，卡片笔记法将笔记区分为闪念笔记、文献笔记和永久笔记，要求人们将卡片盒作为自动对话的容器，持续地将闪念笔记、文献笔记转化为永久笔记，进而实现思考的过程。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/a1ed855b18b9b796ec780928ba384614.png" alt></p>
<p>在卡片笔记法中，通过自己的话和逻辑对笔记进行整理、评述非常关键。在这个过程中，最好进行自我提问和自我回答。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/3523f5f8837dd6294eca8faa4b8a3885.png" alt></p>
<p>当然，除此之外，还有不少笔记法。比如，INK 笔记法。希望你能找到适合自己的笔记法 <strong>。</strong></p>
<p><strong>INK 笔记法</strong>：具体参见 <a href="https://zhuanlan.zhihu.com/p/392225914" target="_blank" rel="noopener">INK 笔记法 ---- 建立属于你自己的
Workspace</a></p>
<p><img src="https://cdn.sspai.com/2022/05/16/6d9fd791249c1c6e40c0d43951c6b06a.png" alt></p>
<h2 id="创意写作"><a class="header-anchor" href="#创意写作">¶</a>创意写作</h2>
<h3 id="日志写作"><a class="header-anchor" href="#日志写作">¶</a>日志写作</h3>
<p>对于多数想要写作的人而言，日志写作是最好的开始。提起日志，你可能会问，日志和日记有什么区别。严格来说，日记更具有私人性质，而日志的内容则更为广泛，同时适用私人和工作场合。比如，你写日记的时候，可能会找一个私人空间安静地进行写作。而日志写作，则随时随地可以进行。</p>
<p>在我看来，这两者的区分并不重要。因为无论是日记还是日志，其本质上都是鼓励人们养成每日写作的习惯。因此，你采用何种形式并不重要。重要的是， <strong>每
天去写</strong>。 <strong>通 过写作进行思考</strong>。在日志写作中，让你的思绪、想法、灵感、情感、理性进行相互碰撞和升华。</p>
<p>卡片是很好的每日写作载体。你可以在氢图中，每日新建一张卡片，快速记录你的想法。</p>
<p>当然，为了推动日志写作的进行，你可以寻找并创建自己的写作仪式。国内外有不少作家推荐晨间日志/Morning Pages.
当然，你要是不习惯，你创造晚间日志也可以。</p>
<p>此外，很多人即便是面对卡片，可能便不知道如何下手。 <strong>写 作是与自我进行对话</strong>。那么，你可以在写作的时候，进行 <strong>自
问自答</strong>，如此便有了写作话题和思路。常见的各种写作模版，本质上便是提供了一套自问自答的写作流程。</p>
<p>对此，我个人比较推荐 <strong>九
宫格写作法</strong>。简单而言，便是提供九个方格，每个方格中填写一个主题或者问题，然后进行回答，最后再将这些内容进行整合。具体而言，九宫格写作法有自己的写作流程，推荐查看官方书籍《<a href="https://book.douban.com/subject/35129121/" target="_blank" rel="noopener">九宫格写作法</a>》。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/25ab9fcb7dfc367cb2d03b7ab1ad631a.png" alt></p>
<p>为了进行日志写作，我借鉴九宫格写作法的理念，制作了一个自问自答的日志写作模版。如图。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/4eed83491e6b266d6a867630d77f4dc5.png" alt></p>
<p>九宫格写作法提供了文章的基本内容。然而，如何对文章进行组织呢？学术论文的写作思路可以作为借鉴。如图。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/a51a9924b05cbece7c155df30da644f1.png" alt></p>
<p>我们可以从某个现象或者理论出发，引出我们的问题。随后，将这一问题进行拆分成多个子问题，并提出对应的假设。然后，文章的主体便是告诉读者，你的资料数据收集和处理的具体方法与技术。通过详细的论证，最终得出你的结论。</p>
<h3 id="小说写作：雪花写作法"><a class="header-anchor" href="#小说写作：雪花写作法">¶</a>小说写作：雪花写作法</h3>
<p>雪花写作法，英文为 the Snowflake Method.
如果按照这种方法的操作原理，翻译为&quot;雪花分形写作法&quot;更为准确。这是一种被众多小说家实践、行之有效的小说写作方法。</p>
<p>雪花写作法是由兰迪・英格曼森提出，其基本理念是&quot;好的小说是设计出来的，而不是像魔法一样凭空浮现&quot;。因此，雪花写作法是一种主张规划和设计小说结构、自上而下的小说写作方法。</p>
<p>雪花写作法主张从最初的故事摘要、人物角色等内容的简要介绍，按照一定的操作方法，逐步扩展成一本完整的小说。这一过程和数学上的科赫雪花曲线的生成逻辑高度相似。具体见配图。因此，被形象地命名为雪花写作法。</p>
<p>以下是雪花写作法操作流程的简要介绍：</p>
<ul>
<li>步骤 1: 用一小时，用一句话写出你的故事摘要；</li>
<li>步骤 2: 用一个小时，将一句话摘要扩展为一段摘要；</li>
<li>步骤 3: 构思故事中的人物角色；</li>
<li>步骤 4: 扩展步骤 2 中完成的故事摘要；</li>
<li>步骤 5: 扩展步骤 3 中的人物角色；</li>
<li>步骤 6: 扩展步骤 4 中的故事摘要；</li>
<li>步骤 7: 进一步扩展人物角色介绍；</li>
<li>步骤 8: 扩展步骤 6 中的故事梗概为供小说使用的场景清单；</li>
<li>步骤 9：扩展步骤 8 中的场景；</li>
<li>步骤 10：动笔开始写小说。</li>
</ul>
<p><img src="https://cdn.sspai.com/2022/05/16/399199f1ecffce8b7ec14effa1339f21.png" alt></p>
<p>从操作流程而言，雪花写作法相当于升级版的大纲写作，具有可操作性强，能满足快速构思和创作等场景。此外，诚然，雪花写作法采用了自上而下的创作思路，但是也不必陷入按部就班的教条主义。雪花写作法并不排斥自由写作。如果你在扩展已有故事架构的写作过程中，发现了更好的创意。那么，是继续按照原有规划，还是采用新的创意。答案是加入你的新创意。对于作品而言，创意最重要。事先进行自上而下的结构设计重要，在具体写作中自下而上对故事脉络、线索、人物等详情进行调整也是必要的补充。</p>
<p>如果你对雪花写作法感兴趣，可以进一步阅读兰迪・英格曼森的相关作品：</p>
<p>作为小说创作者，你可以使用氢图呈现你的整部小说的脉络。比如，在刚开始，你只有一个一句话摘要的卡片内容。随后，你按照雪花写作法的方法进行扩充，逐步增加三个子卡片、六个子卡片……
在这个过程中，你不断建立不同卡片之间的关系。随着这些卡片的不断增加，你的创作文本也会像雪花轮廓一样逐渐清晰起来。最终形成一篇可供发表的作品。</p>
<p>此外，你可以使用氢图建立可视化的小说角色设定面板或者人物关系图。具体范例，见下图：</p>
<p><strong>雪 花写作法*角色模版</strong></p>
<p><img src="https://cdn.sspai.com/2022/05/16/16bced8549e5b36ad2324c69a2b5535a.png" alt></p>
<p><strong>小 说人物关系图</strong>。如图，这是《甄嬛传》的人物关系图。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/5e9bad0a272816fcff0544225db0de74.png" alt></p>
<p>此外，你可以使用氢图建立 <strong>故 事发展时间线</strong>。比如，哈利波特大事年表。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/14df87307c759c7270dfc7d603160c6a.png" alt></p>
<h3 id="剧本写作：三幕剧"><a class="header-anchor" href="#剧本写作：三幕剧">¶</a>剧本写作：三幕剧</h3>
<h2 id="三幕剧是最为经典，也是最为常见的故事结构。简单而言，三幕剧便是开始、冲突、结局。我们耳熟能详的好莱坞大片，多数都是遵循了三幕剧结构。其中，第一幕交代出场人物、故事背景。在第一幕结束的时候，开始出现转折点"><a class="header-anchor" href="#三幕剧是最为经典，也是最为常见的故事结构。简单而言，三幕剧便是开始、冲突、结局。我们耳熟能详的好莱坞大片，多数都是遵循了三幕剧结构。其中，第一幕交代出场人物、故事背景。在第一幕结束的时候，开始出现转折点">¶</a>三幕剧是最为经典，也是最为常见的故事结构。简单而言，三幕剧便是开始、冲突、结局。我们耳熟能详的好莱坞大片，多数都是遵循了三幕剧结构。其中，第一幕交代出场人物、故事背景。在第一幕结束的时候，开始出现转折点</h2>
<p>某个干扰事件，锁定了基本冲突。第二幕是剧本故事的主体。其中，人物关系会进一步复杂化，事件也逐渐升级，最终达到极点，出现了全面对抗，进而达到了故事的高潮。第三幕主要是解决冲突，最终收尾结束。当然，在三幕剧之外，还有更为细化的衍生版本
---- 五幕剧等。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/e3fa3a1c63f9b07b0663563b67df9c58.png" alt></p>
<p>在氢图中，你可以在白板中，建立复杂的人物关系结构图、剧本结构图，建立剧本角色档案等等。或者，按照时间轴，为你创作的角色，建立角色年谱。</p>
<h2 id="结语"><a class="header-anchor" href="#结语">¶</a>结语</h2>
<p>以上便是氢图的一些使用场景，仅作为抛砖引玉。由于氢图的画板特性，你可以像是堆乐高积木那样，探索氢图使用的各种可能性。</p>
<p>氢图目前在 <strong>Beta 测试阶段</strong>，在测试结束后，会推出高级会员。所有参与 Beta 阶段的用户，将获赠参与 Beta
阶段相应时长的高级会员特权。感兴趣的读者，可以参与 Beta 测试。</p>
<p>由于在 Beta 阶段，自然存在不少短板：现在还是网页端，无桌面端和移动端；无模版市场功能；导入导出功能需要强化、无协作功能等。不过好在官方 <strong>更
新迭代速度很快</strong>，查看其官方更新日志，基本上两周更新一次。目前存在的多数短板，将会很快补上。具体可以查看<a href="https://qingtu.co/" target="_blank" rel="noopener">氢图</a>
的近期开发计划，可以查看其<a href="https://qingtu.co/board/77b23e0330ee4f9bad4c1108e0dff092" target="_blank" rel="noopener">官方路线图
RoadMap</a>.</p>
<p>氢图有一款相关产品<a href="https://qingk.com/" target="_blank" rel="noopener">氢刻</a>----一个全平台同步的 <strong>卡 片记忆工具</strong>。</p>
<p><img src="https://cdn.sspai.com/2022/05/16/798ebc7bcc4efa84898d002cd7277a6d.png" alt></p>
<p>此外，氢图的开发者的另外一款产品或许更为有名----国产大纲笔记软件的代表 <strong>幕 布</strong>。</p>
<p>从开发进展和开发背景来看，氢图值得关注和体验。感兴趣的话，请留言表达你对氢图这类工具的看法。</p>
<h2 id="注释"><a class="header-anchor" href="#注释">¶</a>注释</h2>
<ul>
<li><a href="https://qingtu.co/" target="_blank" rel="noopener">氢图</a></li>
<li><a href="https://qingk.com/" target="_blank" rel="noopener">氢刻</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/497318606" target="_blank" rel="noopener">视觉化笔记与思考工具 -「氢图」，全局化、可视化记录卡片笔记</a></li>
<li><a href="https://sspai.com/post/72719" target="_blank" rel="noopener">「氢图」视觉化笔记整理与思考工具，就像在桌面上整理一样自由</a></li>
</ul>
<blockquote>
<p>下载 <a href="https://sspai.com/page/client" target="_blank" rel="noopener">少数派 2.0 客户端</a>、关注
<a href="https://sspai.com/s/J71e" target="_blank" rel="noopener">少数派公众号</a>，解锁全新阅读体验 📰</p>
</blockquote>
<blockquote>
<p>实用、好用的 <a href="https://sspai.com/mall" target="_blank" rel="noopener">正版软件</a>，少数派为你呈现 🚀</p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」创建自己的第一个 Power Automate 工作流，从此繁琐操作是路人</title>
    <url>/public/2022/07/15/test/202207/2022-07-06-112955648077/</url>
    <content><![CDATA[<p>「转」<a href="https://sspai.com/post/73710" target="_blank" rel="noopener">创建自己的第一个 Power Automate 工作流，从此繁琐操作是路人</a></p>
<a id="more"></a>
<p>编注：本文为《<a href="https://sspai.com/series/273" target="_blank" rel="noopener">59 分钟就上手 Power Automate
Desktop</a>》栏目的试读文章。可能是少数派目前最具「信价比」的栏目，介绍 Power
Automate Desktop
这款能把你从重复繁琐的软件操作中解脱出来的效率工具。欢迎前往<a href="https://sspai.com/series/273" target="_blank" rel="noopener">详情页</a>了解栏目的具体内容。</p>
<p>点击<a href="https://www.jianguoyun.com/p/DRKZb7gQyODhBxjdw8sEIAA" target="_blank" rel="noopener">链接</a>，下载文章中演示时所用到的文件。</p>
<p>在上一篇文章中，我帮助大家厘清了通过 Power Automate Desktop（下文简称 PAD） 来解决问题的基本思路，那就是「抽象问题 &gt; 确定目标</p>
<blockquote>
<p>思考解决方案 &gt; 在 PAD 中实现」。同时，我们也简单地了解了 PAD
的工作区以及「数据」「变量」「控制结构」这些概念，通过掌握这些最基础的元素我们已经可以在 PAD 上创建一些简单的流了。</p>
</blockquote>
<p>那么，在第二节课程中我会带着大家一步步地创建一个流，通过这个案例让大家快速上手 PAD 的基本操作。另外，在本节课的最后我还为大家准备一份 PAD
的调试指南，可以帮助大家利用一些基本原则来快速定位 bug 以及解决 bug。</p>
<h2 id="流（Flow）是什么？"><a class="header-anchor" href="#流（Flow）是什么？">¶</a>流（Flow）是什么？</h2>
<p>流（Flow）是 PAD 中工作流的基本度量单位，一个流即是一系列操作的一个组合。在 PAD
的主界面中，我们看到的就是一个流列表，列表中的每一个项目都包含了流的名称、最近一次修改时间和状态。如果选中任意一个流，就会出现快速操作栏，在这里我可以对选中的流进行运行、停止以及编辑等操作。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/de8c3fa824294bf25c005ee739b6fa16.png" alt></p>
<p>在 PAD 里帮你完整解决一个问题的流程就是流，至于流是简单还是复杂，那就丰俭由人。用 PAD 逐个打开京东、淘宝的网址，这个操作可以是流；用 PAD
打开商品网址后，复制标题和价格到 Excel，这个操作可以是流；用 PAD 打开商品网址后，复制标题和价格到 Excel，然后把 Excel
作为附件发送给自己，同时抄送给同事，这个操作也可以是流。因此，一个流中的动作数量和复杂程度没有任何限制，只要这个流可以解决预想中的问题，就可以称之为一个完整的流。</p>
<h2 id="怎样创建自己的流"><a class="header-anchor" href="#怎样创建自己的流">¶</a>怎样创建自己的流</h2>
<h3 id="验证需求"><a class="header-anchor" href="#验证需求">¶</a>验证需求</h3>
<p>一个 PAD
的流从创建、调试到最终可用，都需要时间和精力去实现，这本身也是一种成本。而发明工具的最终目的还是要提高效率、解决问题，因此在动手创建流之前可以先想一想：</p>
<ul>
<li>这项工作是周期性的吗？</li>
<li>PAD 能为我节省多少时间？</li>
<li>根据工作的复杂程度，我想要完成创建一个流需要多长时间？</li>
</ul>
<p>比如现在你需要把 10 份 Word 文档中的数据汇总到同一个 Excel 中，这份工作可能几个月才需要做一次。这种情况下，用 PAD
去编写一个流就非常不划算。但如果你每天、每周都需要做同样的汇总操作，手工复制粘贴就应该被机器来替代了，节省的时间累积下来会非常可观。</p>
<p>如上文的例子所述，如果评估完成本和收益后还是觉得使用 PAD 更划算，那我们再来认真学习如何创建一个流也不迟。</p>
<h3 id="三步定位"><a class="header-anchor" href="#三步定位">¶</a>三步定位</h3>
<p>上文提到过，我们可以把 PAD 理解成一种编程工具，而利用编程工具解决问题可以分为三步：</p>
<ul>
<li>抽象问题，确定目标</li>
<li>找出解决方案</li>
<li>翻译成机器看的懂的语言</li>
</ul>
<p>那么把这个流程应用到 PAD 上，就可以得到如下步骤：</p>
<ul>
<li>把自己要优化的流程手动多跑几遍，想清楚过程中自己的鼠标键盘做了什么操作，使用了软件内的什么功能，对流程中各处的情况有个基本的认知。</li>
<li>画出整个流程的「流程图」。如果工作流比较复杂，可以把工作流切分成不同的模块。前期对 PAD 了解不多的时候，可以抽象的层次放得更低一些，甚至到每一个具体的步骤。这里的「流程图」其实就是把整个流程拆成几个不同的模块并用箭头连接一下，方便逐个击破。</li>
<li>参照流程图分模块拼接流并调试。用 PAD 创建流的时候多想想人工操作在这一步会怎么做，然后再看怎么用 PAD 实现它。</li>
</ul>
<h2 id="案例演示"><a class="header-anchor" href="#案例演示">¶</a>案例演示</h2>
<p>假如说我有一个需求：给定一批京东商品的网址，逐个在浏览器上访问，然后截图保留快照到本地文件夹，最后把文件夹打包压缩。</p>
<pre><code>https://item.jd.com/100008716820.html
https://item.jd.com/100001644698.html
https://item.jd.com/100015047660.html
</code></pre>
<p>按照上面说的三部定位法，我先想清楚这个问题需要怎么来解决，然后构思一个流程图，最后就是分模块构建，完成后再进行拼接。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/e72489a744d32d7ee2c1d05c33c99750.png" alt></p>
<h3 id="明确流程"><a class="header-anchor" href="#明确流程">¶</a>明确流程</h3>
<p>这里的需求相对简单，多体验几次就可以直接生成下面这份流程图。我们大致可以将这个流程分为两个部分：Excel 读取、浏览器循环打开网址并截图。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/ff2858560d6a1910cbe192c22f5ea5b0.png" alt></p>
<h3 id="分模块拼接"><a class="header-anchor" href="#分模块拼接">¶</a>分模块拼接</h3>
<h4 id="从获取商品网址列表"><a class="header-anchor" href="#从获取商品网址列表">¶</a>从获取商品网址列表</h4>
<p>首先我们需要做的是把相关的商品网址从 Excel 中提取出来。人工操作的时候，流程是「打开 Excel-选中所有 item -
复制」。我们希望这个流通用性更强，因为每次 Excel 中的 <strong>商 品的数量应该是不确定的</strong>。那我们该怎样确保每次都能选中所有的商品网址列表？</p>
<p><img src="https://cdn.sspai.com/2022/06/17/262d41483b5554d336ceeb7b48bf4737.png" alt></p>
<p>这时我们就需要想想，在人工操作的时候我们是怎么来确定选中区域的范围的？其实很简单，只要找到文字和空白行交界的地方，从第一行到这里就是该选中的位置。</p>
<p>所以在 PAD 里面，我们可以先定位出表格里第一个空白行，然后提取表格里面第一行到「第一个空白行-1」范围之间的内容。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/6cba21a8d0780a742d20350c99fcb0d8.png" alt></p>
<p>因为不同的模块是靠变量来传递信息的，上一个模块的输出是下一个模块的输入。上一个模块写好了，我们应该检查一下这个模块输出的内容是否满足我们的要求，如果不满足，则下一个模块也无法正常对接运行。</p>
<p>这里我们希望的输出是一个存放着所有需要遍历的网址列表 <code>ExcelData</code>，所以我们只需要观察在此部分模块结束时，<code>ExcelData</code>
中的数据是否符合我们的需求即可。</p>
<p>点击「运行」，等待流执行完成。完成后在「流变量」区域点击
<code>ExcelData</code>，发现数据类型的确是「数据表」，并且表中存放着需要遍历的所有网址，这就代表着这个模块我们已经创建成功了。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/ef2cc4d9b12be06a30cdcafb348ec208.png" alt></p>
<h4 id="单条网址打开后截图保存"><a class="header-anchor" href="#单条网址打开后截图保存">¶</a>单条网址打开后截图保存</h4>
<p>正常来讲，此处应该直接开始编写循环结构，但这样每次调试都需要运行一次之前的步骤，既耗时又增加了调试的复杂度，和我们「分模块拼接」的思想是相悖的。</p>
<p>因此，在循环这个模块里，我们其实 **只
需要一个存放着网址列表的变量输入。**为了方便下面的调试，可以全选上一个模块的动作，然后在右键菜单中选择「禁用操作」。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/a991d2d9c0d5881c937bef77110c7fc3.png" alt></p>
<p>这样一来，我们可以专心先把循环这个模块搞定。循环的本质是把一项工作重复很多遍，那要想写好循环，其实我们只需要把里面的工作搞清楚就行了，也就是----
给定一个网址，浏览器打开网址并截图保存。我们拿 <code>https://item.jd.com/100008716820.html</code> 举例子。</p>
<p>首先是用浏览器打开：</p>
<p><img src="https://cdn.sspai.com/2022/06/17/aa58f992a7ac975267fa171c63725a57.png" alt></p>
<p>通常浏览器打开一个网址还需要等待网页完全加载，网页加载不全的话截图也没意义，所以我们先人工加载一遍网页，估算网页加载时间大概在 2 秒，保险起见那我们就等
3 秒。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/5b40b147e38a3a0f82060926ef709f0d.png" alt></p>
<p>现在网页加载好了，我们该进行截图操作了。PAD 自己提供了三种截图的动作。</p>
<ul>
<li>获取屏幕截图：直接在屏幕的可视范围内截图。</li>
<li>获取网页的屏幕截图：会自动下拉完全网页，是网页的长图。</li>
<li>获取 UI 元素的屏幕截图：单个元素截图，暂时用不上。</li>
</ul>
<p>这里我们选择「获取屏幕截图」这个动作，多显示器的用户可以指定要截取的屏幕，单一屏幕可以直接选「所有屏幕」。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/69c8725aeee1dd2b85288075ff6c51b8.png" alt></p>
<p>我们希望截图能够以文件的形式保存，那么就需要指定一个本地路径。这里的本地路径可以在目标文件夹内随意复制一个文件的地址后粘贴进来，然后修改最后的文件名和文件后缀。等截图完了，我们就可以关闭浏览器。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/638db178bbb5d646eddb6410c6f7c64c.png" alt></p>
<p>当循环里的任务编写完后也需要做一次检查，点击「运行」看看目标文件夹内是否生成了对应的屏幕截图。</p>
<h4 id="编写循环任务"><a class="header-anchor" href="#编写循环任务">¶</a>编写循环任务</h4>
<p>我们现在尝试把单项任务放到循环里面。</p>
<p>首先，我们需要一个列表作为循环的输入。按照「分模块调试」的思想，我们应该另外创建一个存放网址的列表作为模块测试的输入源，避免前方动作耗时太长而降低模块测试的效率。不过，在这个案例中前方的动作数量较少，耗时不多，所以权且直接启用上一个模块的输出作为循环模块的输入。</p>
<p>接着，我们对 <code>ExcelData</code> 进行「for each」循环，每次循环到的网址储存到 <code>CurrentItem</code> 里面。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/3f74b6d20383926333d9924950e12e82.png" alt></p>
<p>因为循环里每次打开的网址不同，所以我们需要将原来固定的网址 <code>https://item.jd.com/100008716820.html</code>
变更为每次循环里的网址变量 <code>CurrentItem</code></p>
<p>点击「运行」，我们来看看是否这个模块按照我们的期望输出了三个商品的截图。很遗憾，没有。文件夹最后只有一张截图，这是因为我们所有的截图文件都采用了同一个文件名，每次新的截图把前一个覆盖直接掉了。</p>
<p>因此，我们需要让不同的截图拥有不同的名字。方法有很多，这里我想用网址中的数字编号来做唯一的匹配符。从网址里获取第 20 个字符后 12
个字符长度的内容，赋值为<code>ItemID</code>，然后放入图片的保存路径。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/9483e5aaf72a6dd00628b353db4ec966.png" alt><img src="https://cdn.sspai.com/2022/06/17/6ea44f11fd5968929f40c0e8999dcc6d.png" alt></p>
<p>此时再运行一次，就可以发现文件夹里成功包含了三张商品的截图。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/4456393c90330f0c13095695ed854aad.png" alt></p>
<h4 id="优化步骤"><a class="header-anchor" href="#优化步骤">¶</a>优化步骤</h4>
<p>虽然运行成功了，但是我们也能发现每次打开浏览器然后关闭太耗时。当循环次数少时尚能接受，次数增多后则非常难熬。</p>
<p>与开启关闭浏览器相比，在开启的浏览器中跳转新网址则会快很多，所以我们可以在循环外开启和关闭浏览器，循环内只完成不同网址的跳转。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/d73fba74e82d344a99243779ed70e2ac.png" alt></p>
<h4 id="打包文件夹"><a class="header-anchor" href="#打包文件夹">¶</a>打包文件夹</h4>
<p>打包压缩这一步很简单，PAD 有成熟的动作，拖进工作区填表即可。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/a37cfa24150e6c99e0d8a6b772ad4a6a.png" alt></p>
<h2 id="调试的方法"><a class="header-anchor" href="#调试的方法">¶</a>调试的方法</h2>
<p>在编写流的过程中，通常很难一次就直接跑通，多半都会遇到各种问题（Bug）。处理 Bug 经常会占整体编写时间的一半以上，那怎样相对高效地处理 Bug 呢？</p>
<p>很不幸，正因为 Bug 是意料之外的，所以我也很难直接告诉你一个框架性的处理 Bug 的流程。不过处理 Bug 可以拆成找 Bug 和解决 Bug
两个环节，还是有一些基本的原则可以帮助你事半功倍。</p>
<h3 id="找-Bug"><a class="header-anchor" href="#找-Bug">¶</a>找 Bug</h3>
<p>通常我们运行一个流，它报错时会直接提示你是在第几个操作上出了什么问题，这个时候你可以直接点开对应的操作看看是不是自己配置上出了什么错误。</p>
<p>比如下图的「提示-图像不存在」，原因在于我们的文件路径少了文件后缀，即文件的路径应该是
<code>D:\我的坚果云\常用模块案例\04-批量提取身份证信息\身份证图片集\身份证.png</code> ，而不是
<code>D:\我的坚果云\常用模块案例\04-批量提取身份证信息\身份证图片集\身份证</code> 。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/50095c92fd1f361cdf5e5d0aa203b733.png" alt></p>
<h4 id="设置断点"><a class="header-anchor" href="#设置断点">¶</a>设置断点</h4>
<p>简单的配置错误其实通过报错的信息就可以解决，但有时候我们会发现报错提示的操作的配置并没有问题，这就说明问题出在更前面的操作里。</p>
<p>这个时候我们可以通过设置断点，流运行到断点就会自动停止，只有我们点击「运行下一个操作」流才会继续往下运行，然后通过在变量区观察断点操作前后变量值的变化，就可以验证断点处的操作是否符合我们的要求。</p>
<h4 id="拆分模块"><a class="header-anchor" href="#拆分模块">¶</a>拆分模块</h4>
<p>在写一些比较复杂的流时，可能涉及到多个软件，以及数百个操作。这个时候如果想要验证的操作是第 80 个，那从头开始运行就会很耗时。</p>
<p>另外，调试的时候经常会运行数十次才能找到问题，如果每次都需要前面的操作运行几分钟，那整个调试的效率就会非常低。</p>
<p>这种场景下我会更建议大家将一个复杂的流拆成几个模块（通常是根据不同的软件），上一个模块的输出就是下一个模块的输入。然后除了测试模块，其他模块全部禁用，在测试模块前手动设置测试模块里所需变量的值，观察测试模块的输出是否符合预期。</p>
<h3 id="解决-Bug"><a class="header-anchor" href="#解决-Bug">¶</a>解决 Bug</h3>
<p>通常我们定位到 Bug 以后，整个问题其实就解决了一半。解决 Bug 的方法核心其实就是查文档、搜索然后不断修改验证。</p>
<p>PAD 中的每一个操作微软都提供了一个参考文档，可以点击「详细信息」快速直达。对照文档，可以看看自己的配置是否存在问题。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/e5425b5fab1d56561d3bbb4fb46612c8.png" alt></p>
<p>如果不是配置上的问题，那可以直接把报错信息复制到浏览器里查询，看看网络上有没有相关的解决方案。不过目前互联网上 PAD
的中文内容还是比较少，所以搜索时建议使用英文会得到更多相关的结果。</p>
<h3 id="PAD-自身的出错处理"><a class="header-anchor" href="#PAD-自身的出错处理">¶</a>PAD 自身的出错处理</h3>
<p>PAD 里任意一个操作下方其实都有一个「出错时」的配置选项，比如第一次出错后间隔一定时间自动重试，或者忽略错误继续流的运行，这其实也是一个帮助我们应对
Bug 的地方。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/c7795d199603815165d04ad9d5f7bfd0.png" alt></p>
<p>另一个方法是我们可以设置一个 <code>Warning</code>
变量存放我们想要观察的变量值，然后通过调用子流来输出。这个触发条件可以是报错就触发，也可以指定特定报错类型才触发。</p>
<p><img src="https://cdn.sspai.com/2022/06/17/24bea7e1c6e25629c410476d68209cb2.png" alt></p>
<h2 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h2>
<p>在本节课程中，我带着大家非常详细地创建了 PAD
上的第一个流，从验证需求开始，到明确流程，接着分模块把具体的操作动作编写完成，最后拼接成一个完整的流。在创建第一个流之后，我还向大家介绍了一些基本的 bug
调试方法，可以在最快的时间内找到并解决问题。当然话说回来，处理 Bug
终究不是一个标准化的过程，很多经验还是需要不断实践来积累。从下一节课开始，我将逐个介绍操作中的各个模块和动作，并辅以对应的实战案例，希望通过这些例子可以帮助大家在较短的时间内掌握这些模块，以应用到日常的流创作中。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」当飞盘成为人类的玩具，我们该如何参与这场游戏</title>
    <url>/public/2022/07/15/test/202207/2022-07-10-013640114938/</url>
    <content><![CDATA[<p>「转」<a href="https://sspai.com/post/73505" target="_blank" rel="noopener">当飞盘成为人类的玩具，我们该如何参与这场游戏</a></p>
<a id="more"></a>
<p>飞盘作为近几年在国内火热的一项运动，或多或少的出现在大家朋友圈里，不了解的人一看可能会纳闷，飞盘？这不是和宠物狗一起玩的吗？怎么流行起来了，就飞过来飞过去能有什么意思。我刚开始也是这么想，但是当我偶然参加了一次学校的飞盘社团活动，才发现这项运动是这么有趣，也觉得这项运动适合所有人。所以今天带大家了解一下飞盘这项「熟悉又陌生」的运动，这样以后大家刘畊宏跳累了，或者本草纲目听的耳朵起茧了，就可以叫上三五好友，一起来试试飞盘。</p>
<h2 id="飞盘的起源"><a class="header-anchor" href="#飞盘的起源">¶</a>飞盘的起源</h2>
<p>1949 年一位名叫弗雷德*莫里森的发明家制造了第一块飞盘，他称自己的发明为「莫里森的飞碟」，最早的飞盘是用金属制成的，可想而知，其飞行效果并不好。后来
Wham-O 公司收购了莫里森的发明，并将其更名为飞盘，飞盘的材质也慢慢由金属变为橡胶、塑料等。</p>
<p>经过几十年的发展，人们已经开发了一系列关于飞盘的运动和游戏，其中比较出名的项目有以下几个：</p>
<h4 id="飞盘高尔夫"><a class="header-anchor" href="#飞盘高尔夫">¶</a>飞盘高尔夫</h4>
<p>飞盘高尔夫是常规高尔夫的有趣替代品。在这个游戏中，玩家站在一个发球台，通过将飞盘扔进一个作为&quot;洞&quot;的立式篮子中得分。
扔进18洞掷球次数最少的选手获得胜利。飞盘高尔夫有专门的锦标赛事。</p>
<h4 id="极限飞盘"><a class="header-anchor" href="#极限飞盘">¶</a>极限飞盘</h4>
<p>极限飞盘是最受欢迎的飞盘运动，也是今天的主角，它结合了结合了足球、橄榄球和篮球项目。目标是通过将飞盘扔给对方端区的一名队员来得分，后面会详细介绍，极限飞盘非常受欢迎，将有可能成为2024
年奥运会项目。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/29/article/cdca2b90007d3529cdc5ba276adb0785?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/29/article/cdca2b90007d3529cdc5ba276adb0785?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)图片来自网络</p>
<h4 id="双飞盘赛"><a class="header-anchor" href="#双飞盘赛">¶</a>双飞盘赛</h4>
<p>在两支队伍的两名球员之间进行，比赛中需要两个飞盘。开始比赛时两队各持一片飞盘，双方持盘者必须将飞盘掷入对方的场地正方形中，同时也必须接住对方投掷过来的飞盘。如果没有掷入对方的防守区，则对手得分，如果在防守区中漏接对方投掷来的飞盘，对手得分。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/29/article/1c6b7a053cd24d6f6fea899006b8a43f?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/29/article/1c6b7a053cd24d6f6fea899006b8a43f?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)图片来自网络</p>
<h4 id="躲闪蜂"><a class="header-anchor" href="#躲闪蜂">¶</a>躲闪蜂</h4>
<p>用飞盘进行躲闪蜜蜂的游戏，和躲避球的游戏规则相似，但每队有 13
人，只有一个飞盘，通过扔飞盘击中对方进行淘汰，坚持到最后的队伍获胜，这个项目中的圆盘由厚织物制成，所以击中身体时不会很疼。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/29/article/e69377a5b60255a959b52edec411032f?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/29/article/e69377a5b60255a959b52edec411032f?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)图片来自网络</p>
<h2 id="飞盘是如何优雅地在空中飞翔的？"><a class="header-anchor" href="#飞盘是如何优雅地在空中飞翔的？">¶</a>飞盘是如何优雅地在空中飞翔的？</h2>
<p>飞盘为何能飞行如此远的距离？秘密在于其特殊的构造和自身的旋转。</p>
<p>当飞盘以一定的正迎角（下图中角
AOA，指飞盘与前进方向的夹角）掷出飞行时，会把一定质量的空气向下推，而飞盘自身就会受到空气反方向向上的力，即升力，升力对抗了飞盘自身的重力，飞盘得以在空中漂浮。</p>
<p>飞盘的升力与单位时间内下推空气的质量有关。简单来说就是升力与飞盘「飞行速度」有关，飞行速度越快，升力越大，飞行速度越慢，升力越小。正因如此飞盘最后总要落地，因为飞盘飞行中受到空气阻力影响，速度越来会越慢，升力也越来越小，最后在重力的作用下落地。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/29/article/14f851770d48921df7706baa28404c20?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/29/article/14f851770d48921df7706baa28404c20?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)图片来自参考资料 1</p>
<p>飞盘飞行时的正迎角（角
AOA）也与升力有关。较大的正迎角下升力较大，但是此时空气阻力也大（因为接触面积大），所以速度下降的更快，飞盘也会更早的落地。在较小的正迎角，虽然升力较小，但是空气阻力也较小，飞盘能飞行更远的距离。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/29/article/7dc14454e0320b67947489d11b0d2231?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/29/article/7dc14454e0320b67947489d11b0d2231?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)图片来自参考资料 1</p>
<p>飞盘自身的旋转对飞盘的飞行质量很重要。飞盘的旋转是它不会摇晃的原因，旋转的飞盘就像一个旋转的陀螺一样，在角动量的作用下使飞盘在飞行中具有稳定性。所以一个自转速度很高的飞盘前进路径十分稳定，不会发生偏移。反之，当飞盘自转速度很低时，稳定性较差，容易偏离轨迹，径直坠地。</p>
<p><img src="https://cdn.sspai.com/2022/05/29/2a5f6e3c1d1fadcfd5fa0772031ac24b.png" alt><img src="https://cdn.sspai.com/2022/05/29/7239bece868c1d0929e3af36154ee576.png" alt></p>
<p>此外，湍流和马格努斯效应等原理可以解释很多技巧性的飞盘投掷，如投掷处弧线运动轨迹的飞盘，这里就不过多探讨。我们只要理解了上面已经提到的原理，就足够帮助我们提高投掷飞盘的技巧。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/29/article/fa2a4cbfc61166ded9dbfd99f2ed8276?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/29/article/fa2a4cbfc61166ded9dbfd99f2ed8276?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)图片来自参考资料 1</p>
<h2 id="如何正确的扔盘和接盘？"><a class="header-anchor" href="#如何正确的扔盘和接盘？">¶</a>如何正确的扔盘和接盘？</h2>
<p>扔盘和接盘是飞盘最基本的玩法，掌握好这两种技巧，我们就可以用飞盘来进行各种各样的项目和游戏。</p>
<h3 id="扔盘"><a class="header-anchor" href="#扔盘">¶</a>扔盘</h3>
<p>常用的扔盘方法有正手扔和反手扔两种，反手扔是最基础的扔盘方法，最适合新手学习，正手扔难度更高，可以作为进阶动作掌握。</p>
<h4 id="反手扔盘"><a class="header-anchor" href="#反手扔盘">¶</a>反手扔盘</h4>
<p>用整个手握住飞盘，拇指在飞盘的顶部，食指应该靠在飞盘外缘，剩下的手指按在飞盘底部。</p>
<p><img src="https://cdn.sspai.com/2022/06/01/5192769fa52076dcebd5b7c879399ca1.GIF" alt>图片来自参考资料
2</p>
<p>如果是右手持盘，右脚放在前侧正对扔盘方向，左脚在后侧与扔盘方向垂直。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/29/article/ebcc96baf0668f8977abd667dc89009a?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/29/article/ebcc96baf0668f8977abd667dc89009a?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)图片来自参考资料 2</p>
<p>握住飞盘时，将手腕稍微向后弯曲。肘部弯曲，整个小臂手腕平行与地面。</p>
<p><img src="https://cdn.sspai.com/2022/06/01/15a49698dcc04fd5cc5caab4b5265568.GIF" alt>图片来自参考资料
2</p>
<p>将飞盘对准目标，目标通常为队友，有时也会把飞盘对准队友前进方向，以便队友在移动中接到飞盘。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/29/article/68ba0ecfd741a42ddb00256cf874635e?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/29/article/68ba0ecfd741a42ddb00256cf874635e?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)图片来自参考资料 2</p>
<p>伸展手臂，在手臂快要伸直时，快速伸展手腕，将飞盘朝向目标释放。出手时飞盘与上腹同高。</p>
<p><img src="https://cdn.sspai.com/2022/06/01/305d9a5ef55dfe7db531141bec1d1658.GIF" alt>图片来自参考资料
2</p>
<p>除了基本「手法」，还有一些小技巧值得你注意：</p>
<ul>
<li>保持飞盘与地面平行，这会让飞盘的正迎角更小，减小空气阻力，飞行更远的距离。</li>
<li>手臂的伸展速度决定了飞盘出手时的飞行速度，飞行速度越快，到达目标时间越短，升力也越大。</li>
<li>飞盘自身的旋转是快速伸展手腕的结果，转速越快，飞盘飞行时越稳定，不会发生偏转。</li>
</ul>
<h4 id="正手扔盘"><a class="header-anchor" href="#正手扔盘">¶</a>正手扔盘</h4>
<p>利用拇指、食指和中指进行握盘，大拇指折叠放置在飞盘上端，食指和中指伸直在飞盘下端，将无名指和小指折叠在手中（类似于握拳）。中指抵住飞盘内侧，食指应该保持笔直，指向手指的飞盘中心。也可以将食指和中指都抵制飞盘内侧，从而提供更大力量，但是控制力会下降。</p>
<p><img src="https://cdn.sspai.com/2022/06/01/c3742f606cf11f3cbfe7b13b947ef294.GIF" alt>图片来自参考资料
3</p>
<p>摆正姿势。一旦握住了飞盘，必须进行迈步以便扔出飞盘，双脚分开略大于肩宽，面向接盘人。膝盖应略微弯曲，以保持平衡进行发力。</p>
<p><img src="https://cdn.sspai.com/2022/06/01/2a6674eeb268679603499ac4dda5ae17.GIF" alt>图片来自参考资料
3</p>
<p>将飞盘往回移动，直到其位于肘部后侧，此时尽可能弯曲手腕，以便之后的发力。</p>
<p><img src="https://cdn.sspai.com/2022/06/01/f19552f45cca61670a9c73ea86f5d6ae.GIF" alt>图片来自参考资料
3</p>
<p>向前移动飞盘时，保持飞盘后侧略微向下，在水平方向上向下倾斜约 10 度。投掷时手和手臂应该与地面平行。</p>
<p><img src="https://cdn.sspai.com/2022/06/01/d3728edc073af6abf9759fed568a94b7.GIF" alt>图片来自参考资料
3</p>
<p>现在可以扔出飞盘，将手臂从从身体外侧移动到身体内侧，然后快速屈曲手腕。投掷时，身体也要旋转，力量由肩膀传递手臂再到飞盘。保持手掌朝上，从而使飞盘平稳出手。</p>
<p>仍然是一些 Tips：</p>
<ul>
<li>飞盘出手时，略微向下，在水平方向上向下倾斜约 10 度。</li>
<li>飞盘自身的旋转是快速屈曲手腕的结果，转速越快，飞盘飞行时越稳定，不会发生偏转。</li>
<li>可以在任意高度出手，以躲开防守。</li>
<li>出手时，手指的指向就是飞盘飞行的路径方向。</li>
</ul>
<p><img src="https://cdn.sspai.com/2022/06/01/aff5bd390b1b41fbddfa9bf895da302e.GIF" alt>图片来自参考资料
3</p>
<h3 id="接盘"><a class="header-anchor" href="#接盘">¶</a>接盘</h3>
<p>接盘技巧也非常重要，成功接到飞盘是游戏继续和得分的关键。常用的接盘方法有煎饼式、鳄鱼嘴式、双手式，以及单手式。</p>
<h4 id="煎饼式、鳄鱼嘴式"><a class="header-anchor" href="#煎饼式、鳄鱼嘴式">¶</a>煎饼式、鳄鱼嘴式</h4>
<p>采用这种方法接盘时，一只手在上，一只手在下，两只手相向运动夹住飞来的飞盘。这是最基础的接盘技巧，也是最安全的接盘技巧。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/29/article/2618816b2e12e14852790c5600669a40?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/29/article/2618816b2e12e14852790c5600669a40?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)图片来自网络：煎饼式接盘</p>
<h4 id="双手式"><a class="header-anchor" href="#双手式">¶</a>双手式</h4>
<p>采用这种方法接盘时，需要两只手同时抓住飞盘的边缘，如果飞盘在肩膀以上时，拇指在四指下方。</p>
<p>如果飞盘在肩膀以下时，拇指在四指上方。</p>
<p><img src="https://cdn.sspai.com/2022/05/29/7ffdeabbe23adfde440309046f78564d.png" alt><img src="https://cdn.sspai.com/2022/05/29/3e4053c699b5963bad0cf183f88eb58a.png" alt></p>
<h4 id="单手式"><a class="header-anchor" href="#单手式">¶</a>单手式</h4>
<p>和双手式动作类似，也是用手抓住飞盘的边缘，如果飞盘在肩膀以上时，拇指在四指下方如果飞盘在肩膀以下时，拇指在四指上方。这种方法成功率较低。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/29/article/28ae7a31fe7600318d638dd3e85cee2f?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/29/article/28ae7a31fe7600318d638dd3e85cee2f?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)图片来自网络：单手式接盘</p>
<h2 id="极限飞盘是什么？怎么玩？"><a class="header-anchor" href="#极限飞盘是什么？怎么玩？">¶</a>极限飞盘是什么？怎么玩？</h2>
<p>大家最近在朋友圈和网络上刷到的飞盘游戏是一种叫做「极限飞盘」的项目。</p>
<p>极限飞盘始于 1968 的美国，在哥伦比亚高中一名叫乔<em>希尔沃的同学向校学生会建议了他以飞盘进行橄榄球的想法，并起名为 「Frisbee
Ultimate」。这项结合了橄榄球的飞盘新玩法，受到学生们的热爱，次年该校便组织了两支学生队伍进行了第一次的比赛。之后乔</em>希尔沃联合其他同学一起制定了更加正式的规则，而后极限飞盘才正式在美国校队之间进行比赛。现在极限飞盘结合了橄榄球、足球、篮球等项目的特点，已发展成为一项全球性的运动。</p>
<p>正规的极限飞盘比赛一般采用 7V7
的人数配置，练习和娱乐时可以采用其他的人数配置。基本的玩法是，进攻方通过的传递飞盘前进，最后在防守方的端区成功接住飞盘得分，防守队则试图拦截飞盘，成功拦截后，球权交换，防守方成为进攻方。</p>
<p>正规的极限飞盘场地和足球场类似，当然也可以在空间足够大的空地上进行，场地两端有标记的端区（得分区），进攻方在得分区接到飞盘方可得分。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/29/article/7dca8c02e804f7a4de9a71345eab7598?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/29/article/7dca8c02e804f7a4de9a71345eab7598?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)图片来自网络：极限飞盘场地示意图</p>
<p><strong>极 限飞盘比赛的基本规则：</strong></p>
<p>对于进攻方</p>
<ul>
<li>接盘时如果不能立即停止，接到飞盘后要有明显的减速动作。</li>
<li>身体稳定持盘时不能发生双脚的移动（可以单脚固定进行转体）。</li>
<li>飞盘不能通过手对手传递，要有腾空阶段。</li>
</ul>
<p>对于防守方</p>
<ul>
<li>防守时不能有任何身体接触，防守距离不小于一个飞盘。</li>
<li>防守队员防守进攻方持盘者时，可进行 10S 的读秒（需要喊出声），进攻方在 10s 内未扔出则交换球权。</li>
<li>持盘者 3m 之内只能有一名防守者。</li>
<li>不能通过出声或其他方式干扰进攻者进行要盘。</li>
</ul>
<p>对于比赛</p>
<ul>
<li>飞盘落地、出界，无论最后谁碰到飞盘，球权都发生交换。</li>
<li>在极限飞盘项目中是没有裁判的，所有的犯规行为需要运动员自己裁决。</li>
<li>出现无法达成共识的争议时，可以采取回盘措施，即持盘者回到争议产生前的位置。</li>
</ul>
<p><strong>极 限飞盘比赛的基本流程</strong></p>
<p>通过猜投掷飞盘或硬币的正反来获得开场的球权。</p>
<p>开盘时，双方位于各自端区线上，双方举手示意可以开始比赛，防守方将飞盘扔向进攻方一侧，根据飞盘落点不同有以下情况：</p>
<ul>
<li>飞盘如果没有出届，则落点就是进攻方开始进攻的地方</li>
<li>飞盘出届进攻方在最近的边线开始进攻</li>
<li>进攻方可以尝试接住来自防守方的飞盘，但是要确保「准确接住」，如果接触了飞盘但是未接住导致飞盘落地了，则球权发生交换。</li>
</ul>
<p>进攻方通过一系列传递，成功将飞盘传至防守方端区接住，则成功得分，双方交换端区和球权，再次进行开盘。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/29/article/3fd7804b7c1d4286c8652b8cfd52a50e?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/29/article/3fd7804b7c1d4286c8652b8cfd52a50e?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)图片来自网络：端区接盘得分</p>
<p>进攻方失误（飞盘落地、出届、被抢断等），球权发生交换，防守方成为进攻方，在飞盘落地处或者抢断处开始进攻。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/29/article/6e0577925c18dc391d0d56b9b808440f?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/29/article/6e0577925c18dc391d0d56b9b808440f?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)图片来自网络：成功拦截并开始反击</p>
<p>以 15 分为一局，先获得 15 分的一方赢下这一局比赛。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/29/article/583a93c1243d3194375515829fa2efba?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/29/article/583a93c1243d3194375515829fa2efba?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)极限飞盘比赛基本流程</p>
<h2 id="为什么玩极限飞盘的人越来越多？"><a class="header-anchor" href="#为什么玩极限飞盘的人越来越多？">¶</a>为什么玩极限飞盘的人越来越多？</h2>
<p>**极
限飞盘技术门槛低，规则简单。**新手学习半个小时的扔盘接盘后，都就能掌握基本的扔盘（反手扔）接盘（双手接盘）技术。然后简单了解比赛的规则后，就可以进行一场娱乐赛。参加过两三次比赛后就能掌握所有的规则。所以相比于其他运动项目（篮球、网球等），极限飞盘是最容易入门的运动项目。</p>
<p>**极
限飞盘没有身体对抗，性别不是限制。**极限飞盘禁止了身体对抗，虽然对速度和爆发力依然有要求，但是一个女生完全可以去防守一个男生。所以在极限飞盘的比赛中，你可以看到女生成功防守男生，或者男女一起配合得分的画面。</p>
<p>![](<a href="https://cdn.sspai.com/2022/05/29/article/1fdf316518aa35708896a802ad5db74c?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/05/29/article/1fdf316518aa35708896a802ad5db74c?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)图片来自网络</p>
<p>**极
限飞盘作为一种团体项目，拥有良好的氛围。**在极限飞盘比赛里，最常听到的词一定是「好」，扔出一个飞行平稳距离很远的飞盘，即使队友没有接到，你能听到一句「好盘」。在几个防守队员间成功接住队友的传盘，你能收获一句「好接」。对手打出一波漂亮的配合，你也会忍不住说出一句
「漂亮」。在极限飞盘的赛场上永远不缺鼓励和赞美，这种精神，从老手传递给新手，又从新手传递给后来的初学者。</p>
<p><img src="https://cdn.sspai.com/2022/05/29/d8ae59dad880f8b93f344b3866d0b911.png" alt>图片来自网络</p>
<p>**极
限飞盘是一种新的社交方式，在锻炼的同时收获朋友。**作者身边的一个朋友喜欢玩飞盘的理由是「社恐，要去玩飞盘练练人际交往」。在极限飞盘里，你们前一秒还是陌生人，但是只要分在了一个队伍，你们关系就不自觉地近了一步，这一步恰好打破了那层阻碍交流的「壁垒」。作为队友你们可以顺畅的交流，讨论技巧，制定战术，得分时赞美，失误时鼓励。所以几场飞盘下来，你会发现不仅身体得到了锻炼，朋友也多了不少。</p>
<p><img src="https://cdn.sspai.com/2022/05/29/ffb5bbb77f48fc65165b5a3ad008034b.png" alt>图片来自网络</p>
<p>**在
极限飞盘中，可以跑的更快，可以扔的更远。**极限飞盘虽然门槛低，但是要玩的好也很难。首先是扔盘，随着距离增加，要想扔出精准飞盘就越来越难，特别是要做到从一方端区扔到另一方的端区，就需要大量的练习，不断提高技术动作。其次，在极限飞盘里跑的越快成功得分以及成功抢断的几率越大。此外，极限飞盘也对参与者的有氧耐力、爆发力、敏捷性等素质有一定要求。所以随着你技术和身体素质的提高，你在极限飞盘中的体验也会提高，这种提升没有限制，可以一直持续下去。</p>
<p><img src="https://cdn.sspai.com/2022/05/29/052285cde7089e2f7531c6a448d4bbac.png" alt>图片来自网络</p>
<p>**运
动虽好，谨防受伤。**虽然极限飞盘禁止身体对抗，但是难免有意外发生，特别是两个快速奔跑的人一旦发生碰撞就可能会造成损伤，此外也会发生奔跑中摔倒受伤的情况（一双防滑的鞋子非常重要）。所以大家在玩飞盘时，一定要注意安全，健康的身体是我们继续战斗的基础。</p>
<h2 id="我该如何开始这项运动？"><a class="header-anchor" href="#我该如何开始这项运动？">¶</a>我该如何开始这项运动？</h2>
<p>选择「合适的装备」是我们开始极限飞盘的第一步。首先是鞋子，极限飞盘一般在草地上进行，所以鞋子的防滑非常重要，这时可以选择一双足球鞋（碎钉足球鞋足够），或者越野鞋。其次，因为要经过大量的奔跑，服装需要紧身且透气，穿着长裤以及运动紧身衣裤可以防止摔倒时擦伤。此外，一双专门的飞盘手套和橄榄球手套可以防止接盘时手滑和手部受伤。</p>
<p><img src="https://cdn.sspai.com/2022/06/01/5d1a51817102eb376f9fcb06c91d3839.jpg" alt><img src="https://cdn.sspai.com/2022/06/01/6338282d9616baf4cc3568317d4a7a64.jpg" alt></p>
<p>第二步我们需要找到一起玩耍的伙伴。如果你在大城市或者高校，加入一个「飞盘俱乐部」是不错的选择。加入俱乐有很多好处，比如俱乐部有更专业更基础的教学，俱乐部会负责寻找场地、组织比赛等。同时还能在俱乐部遇到很多新面孔，交到新朋友。目前北京、上海、深圳飞盘俱乐部较多，大家可以在各种平台上搜索（其他城市也可以试试）。</p>
<p>如果所在的城市没有极限飞盘俱乐部，不要灰心，叫上三五好友同样可以开始这项运动。在淘宝上购买一个飞盘和四个角锥（标定场地用），飞盘推荐橡胶制的标准比赛用盘，不容易损坏。然后叫上几个好友去附近的空地，经过简单的练习后就可以开始尝试极限飞盘的比赛。慢慢的可能就有新的伙伴加入你们，因为这项运动入门简单，所以对新人的接纳程度也很高。人多起来后你也可以选择组建一个俱乐部，以便更好的开展这项运动。</p>
<p><img src="https://cdn.sspai.com/2022/06/01/bb245ef35a83a0506110366c71a2028a.jpg" alt>图片来自网络</p>
<p>最后，精湛的技术需要场下的多次练习。接盘和扔盘虽然看起来简单，但是随着距离的增加，扔盘的准确度就会下降，接盘也往往需要准确的判断以及快速的移动。所以刚开始接触飞盘的新手可以在从简单开始然后循序渐进增加难度，一开始只进行距离较近、双方站立不动的扔接盘练习，慢慢的增加距离。之后可以进行一些跑动中的传接盘练习，也可以增加一个防守者来模拟赛场的情景。相信经过大量的练习后你可以在赛场中表现的更好。</p>
<h2 id="写在最后"><a class="header-anchor" href="#写在最后">¶</a>写在最后</h2>
<p>飞盘独特的构造让其可以在空中优雅的飞行，于是人们拿它来进行各种形式的扔盘和接盘游戏。后来有人将橄榄球的玩法应用到了飞盘中，立马得到了大众的喜爱，经过不断的发展成为一项完善的运动项目，并命名为极限飞盘（Frisbee
Ultimate）。</p>
<p>最近几年国内也刮起了「飞盘热」，吸引更多人参加的同时也带来了一些争议。「滥占场地只为了拍几张照片发朋友圈」，「飞盘就是为了撩骚、秀身材和运动毫无关系」等等，产生争议的原因更多是参与者和批评者对飞盘项目的不了解。</p>
<p>当我们真正了解极限飞盘这个项目后，会发现它有很多优点：技术门槛低，规则简单，没有身体对抗，男女可以同场竞技，氛围良好，锻炼的同时收获朋友等等，所以我们更要正确的对待这个项目，吸引更多的人来亲身参与，让他们从中得到身体的锻炼，收获精神的快乐。而不是仅把它作为一种「社交平台的炫耀资本」，让这项运动变味。</p>
<p>希望大家通过这篇文章了解飞盘，学习飞盘，之后生活中也能尝试一下飞盘，更加希望快乐和健康能通过飞盘传递到大家的手中。最后附上一段极限飞盘比赛集锦，一起来感受一下极限飞盘这「溢出屏幕」的魅力。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」打开终端总有好心情：我的美化方案及配置分享</title>
    <url>/public/2022/07/15/test/202207/2022-07-12-045200122103/</url>
    <content><![CDATA[<p>「转」<a href="https://sspai.com/post/74216" target="_blank" rel="noopener">打开终端总有好心情：我的美化方案及配置分享</a></p>
<a id="more"></a>
<p>作为一个开发者，不论是本地代码运行调试还是在远程服务器上进行项目的部署运维，都离不开下图所示的终端，也就是科技电影中常出现的黑窗口。</p>
<p>![boxcnOw5iVEp66NkxfZrxAXyCxc](<a href="https://cdn.sspai.com/editor/u_/cb5pnltb34tbt4lb7kf0?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnltb34tbt4lb7kf0?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>各个操作系统一般都有自己默认的 Shell，如 Windows 操作系统下的「Powershell」、macOS 与 Linux 系统的 bash、zsh
等；带图形版界面的系统也都会预置终端仿真器（Terminal Emulator），如 macOS 平台下的「终端.app」以及 Linux
各发行版自带的终端程序等。</p>
<p>作为一个生产力工具爱好者与颜控，我对终端配置美化的折腾从未停止过，也几经迭代。可能与大多数开发者不同的是，我并不是某种特定方案的拥趸，而是会去尝试各种工具，依照自己的习惯进行配置降低各个方案之间的操作差异，在日常开发过程中根据用途无缝切换使用，有时甚至是随机选一个使用以切换心情。</p>
<p>本文主要讲述了我的终端方案选择及配置细节。</p>
<h2 id="终端配置方案需求"><a class="header-anchor" href="#终端配置方案需求">¶</a>终端配置方案需求</h2>
<p>终端配置分为几个方面：</p>
<ol>
<li><strong>工 具配置</strong>。在使用 macOS 或 Window 系统进行开发时，我们往往需要一个终端仿真器（Terminal Emulator）连接到本机开发环境或远程服务器。这通常是我们开发过程中的常驻应用，其颜值、响应速度与快捷键等也会很大程度影响我们的开发体验，因此是我们配置与美化的重点。</li>
<li><strong>功 能配置</strong>。我们在使用命令行对系统服务/文件进行一些操作时，需要使用 Shell，如 bash、zsh 等，对其进行一些命令提示、自动补全等配置能有效提升我们的使用体验。</li>
<li><strong>集 成配置</strong>。除了运行 git 等常用命令行工具外，终端往往还需要满足文本编辑、多任务管理等进阶需求。因此，通过终端配置实现 vim、tmux 等工具的深度集成也是我们开发体验优化的重要一环。</li>
</ol>
<p>我梳理了自己的终端使用需求，列出了以下几个核心要点：</p>
<ol>
<li><strong>风 格简约</strong>。作为一个每天都需要长时间面对的软件，再 fancy 的主题也会看腻，甚至影响自己的注意力。因此，我对终端工具外观与操作逻辑配置的基本思路为 Minimal Distraction，简约而不单调。</li>
<li><strong>响 应速度快</strong>。最开始我对终端的配置侧重在美观与功能，安装了很多插件配置，但也出现了每次软件开启会有几秒延迟的不良体验。因此，使用过程的响应速度也是我方案选择与优化的重点。</li>
<li><strong>可 定制性</strong>。因为我的代码编辑器与窗口管理使用的都是 Vim「HJKL」特殊键位，因此我也希望能够进行比较灵活的快捷键配置，降低自己在各个软件直接切换的成本。</li>
<li><strong>可 移植性</strong>。我时常需要在不同的设备上进行操作，偶尔也会有设备的迭代，会希望自己的配置能比较方便地移植到新设备/服务器等，最好是可以复用同一个配置文件。</li>
<li><strong>可 拓展性</strong>。我希望能够根据自己的需求拓展一些功能与插件，如使用 fzf 对文件或命令历史记录进行检索，通过命令跳转至指定目录，使用 waka-time 记录自己的编程时间等。</li>
</ol>
<h2 id="我的终端配置说明"><a class="header-anchor" href="#我的终端配置说明">¶</a>我的终端配置说明</h2>
<p>即使需求已经比较明确，找到合适的工具与配置方案依旧是一件困难但充满乐趣的事。接下来我将逐个对我仍在使用并且比较满意的方案进行描述，并提供我的配置文件供大家参考。</p>
<p>此外，因为我大多数时间都在 macOS 系统上进行开发，所以我的终端工具配置主要是基于 macOS 平台的，但有些工具或插件（如
Alacritty、ohmyzsh、Neovim 等）是跨平台的，配置方式大同小异，可以根据实际情况进行参照与配置。</p>
<h3 id="Warp"><a class="header-anchor" href="#Warp">¶</a>Warp</h3>
<p>![boxcnO4CwGASjlKWIOENxCPonHg](<a href="https://cdn.sspai.com/editor/u_/cb5pnmdb34tbthquqlog?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnmdb34tbthquqlog?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>我本身是一个折腾流，会希望能自己能够对各类配置有足够的定制化空间。然而，如果要我只推荐一款工具给刚使用终端不久的新手，我会毫不犹豫地选择「<a href="https://www.warp.dev/" target="_blank" rel="noopener">Warp</a>」。</p>
<p>Warp 是一个基于 Rust 开发的速度极快、功能强大且开箱即用的现代化终端工具。不需要额外配置就支持智能提示、AI 命令智能搜索、命令历史查询、自定义
workflow 等功能。</p>
<p>我是很早参与 Warp 内测的那一批用户，即使是在功能还很不完善的早期，我也被它精致的外观和顺滑的使用体验所惊艳到了。因为基于 Rust 语言开发，Warp
的命令执行与响应速度很快，并且它还内置了很多常用功能，我们无需在 Shell 层配置使用历史记录搜索、命令提示等各类插件就能获得强大的功能支持。</p>
<p>![boxcnWELdus1QwIiaqTeW2MzK3b](<a href="https://cdn.sspai.com/editor/u_/cb5pnmlb34tbt4lb7kfg?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnmlb34tbt4lb7kfg?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>它还有很多传统终端不具备的特色功能，如「block」的概念，每一条命令的执行都以一种「命令块」的形式呈现，可以通过上下左右键在各个 block
之间移动，避免了有些命令输出结果太长导致需要一直拉动滚动条阅览；并且我们可以通过右上角对特定 block 进行书签收藏、命令复制、内容检索甚至在线分享等。</p>
<p>![boxcnJ8b81UFpjnWyl30p1BfoSe](<a href="https://cdn.sspai.com/editor/u_/cb5pnmlb34tbuhnt4id0?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnmlb34tbuhnt4id0?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>与常规终端工具体验不同的是，Warp 的命令输入窗口长期固定在底部（更接近于
IDE），将我们命令输入与结果反馈进行了视觉上的分离；并且它的输入模式接近于文本编辑器，我们可以通过鼠标或是键盘任意移动光标编辑、修改命令或是输入多行命令依序执行，这也是我所认为的
Warp 的 killer feature。</p>
<p>![boxcnnD3b9yHwi3ihKuaQX0UpRe](<a href="https://cdn.sspai.com/editor/u_/cb5pnmtb34tbuhnt4idg?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnmtb34tbuhnt4idg?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>我们仅需在输入框使用对应的快捷键即可唤出历史记录检索、自定义 workflow
等功能，并且可以使用鼠标滚轮或是方向键进行选择，十分灵活。更强大的是，当我们使用 Warp 通过 SSH
连接到远程终端时，这些快捷键依然有效，如历史记录搜索等，而无需在目标服务器进行配置。</p>
<p>另外值得一提的是我们可以通过内置快捷键 <code>Command+D</code> 与 <code>Command+Shift+D</code>
来水平或垂直拆分终端，无需集成其他工具或进行额外配置。</p>
<p>随着技术的发展，文本编辑器不断迭代更新，增加了丰富的功能并提供了更好的使用体验，然而与我们开发人员朝夕相处的终端却一直发展迟缓，Warp
正是在这个阶段应运而生，也正如它官网所描述的那样：</p>
<blockquote>
<p>The terminal for the 21st century.</p>
</blockquote>
<h3 id="iTerm2"><a class="header-anchor" href="#iTerm2">¶</a>iTerm2</h3>
<p>在使用 Warp 之前，我的主力终端工具为 <a href="https://iterm2.com/" target="_blank" rel="noopener">iTerm2</a>，相信这也是很多开发者刚入手 Mac
时的必装软件（毕竟默认终端的颜值和可玩性都不太行）。iTerm2 是一个集美观与功能性为一体的老牌终端工具，即使是默认配置也已经很好的满足了我们的需求。</p>
<h4 id="外观与配色"><a class="header-anchor" href="#外观与配色">¶</a>外观与配色</h4>
<p>![boxcnnVLQYWAvMqZpNbT9HoHAsf](<a href="https://cdn.sspai.com/editor/u_/cb5pnn5b34tbt4lb7kg0?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnn5b34tbt4lb7kg0?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>我对一位 YouTuber <a href="https://www.craftz.dog/" target="_blank" rel="noopener">Takuya Matsuyama</a>
的配置加以改造，定制了一个性冷淡风外观方案。</p>
<p>首先在 <strong>偏 好设置</strong> - <strong>Appearance</strong> 部分对主题、Tab 栏与状态栏进行如下配置，保持较为简洁的布局。</p>
<p>![boxcnw30IomhsadmnVCN07zlryc](<a href="https://cdn.sspai.com/editor/u_/cb5pnndb34tbuhnt4ie0?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnndb34tbuhnt4ie0?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>完成主题配置后，右键底部状态栏可进行详细配置。我选取了部分状态栏组件实时显示设备状态，这部分可根据自己的偏好进行选择。</p>
<p>![boxcniBo6fQPqCPbh8G4195HJsc](<a href="https://cdn.sspai.com/editor/u_/cb5pnnlb34tbt90og080?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnnlb34tbt90og080?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>在 <strong>Profile</strong> - <strong>Colors</strong>
面板选取自己的主题配色或导入其他配色方案。可以点击<a href="https://github.com/pseudoyu/dotfiles/tree/master/iterm2" target="_blank" rel="noopener">这里</a>下载我的配置文件，导入并根据自己的需求进行调整。</p>
<p>![boxcnFI6QY4PkXzKLAm7rBC2nRh](<a href="https://cdn.sspai.com/editor/u_/cb5pnnlb34tbt90og08g?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnnlb34tbt90og08g?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>完成配色方案选择后，我通过调整 Transparency 和 Blur 来实现背景透明与毛玻璃效果（即窗口模糊），此处可以根据具体设备的视觉效果进行调整。</p>
<p>完成了终端工具的配置后，我们还需要对 Shell 进行配置，以集成一些定制主题、智能提示、搜索历史记录等拓展模块，我使用的是 zsh + ohmyzsh +
starship 方案，因这些配置各个方案通用，详见下述 Alacritty 配置说明部分。</p>
<h4 id="多服务器管理"><a class="header-anchor" href="#多服务器管理">¶</a>多服务器管理</h4>
<p>![boxcnkN1HAlzd80bNZTAbBaqgvc](<a href="https://cdn.sspai.com/editor/u_/cb5pnntb34tbt90og090?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnntb34tbt90og090?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>目前我主要使用 iTerm2 来连接我的各个远程主机/服务器，它提供了方便的多配置管理功能，可以通过设置不同的 Profiles
实现不同服务器或配置环境的快速切换，并且可以用醒目的 Badge 来作为标识。</p>
<p>![boxcnEchitPMDN96afe12tAFoNh](<a href="https://cdn.sspai.com/editor/u_/cb5pno5b34tbthquqlp0?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pno5b34tbthquqlp0?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>当我们在工作或个人使用中需要连接到多台开发机时，可以通过 <code>Command+O</code> 或通过右键 Dock 栏 iTerm2 图标选择对应 Profile
打开服务器，同时也可以通过内置快捷键 <code>Command+D</code> 与 <code>Command+Shift+D</code>
来水平或垂直拆分终端，便于多服务器同时操作，无需不断切换窗口。</p>
<h3 id="Alacritty"><a class="header-anchor" href="#Alacritty">¶</a>Alacritty</h3>
<p>iTerm2 已经是 macOS
平台上颜值与功能都非常平衡的终端工具了，但综合使用下来它的响应速度与配置的自由度还是不那么完美，因此我现在主要将其用于连接远程服务器，本地常用终端后续更换为了
<a href="https://alacritty.org/" target="_blank" rel="noopener">Alacritty</a>。</p>
<p>Alacritty 也是一款使用 Rust 编写的跨平台终端工具，提供了一些基础默认配置，并通过
<code>~/.config/alacritty/alacritty.yml</code>
文件进行各项自定义配置，可以点击<a href="https://github.com/pseudoyu/dotfiles/tree/master/alacritty" target="_blank" rel="noopener">这里</a>访问我的完整配置。</p>
<h4 id="外观配置"><a class="header-anchor" href="#外观配置">¶</a>外观配置</h4>
<p>![boxcnPYopkomew4SJHyTeaHQy8P](<a href="https://cdn.sspai.com/editor/u_/cb5pnodb34tbuhnt4ieg?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnodb34tbuhnt4ieg?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>外观部分我主要通过如下配置进行窗口与字体配置，实现了一种半透明的极简配置，甚至都没有任何边框与按钮，其他配置可自行查看，如选中即复制等在 iTerm2
上惯用的功能均可通过几个简单的配置项实现。</p>
<pre><code>window:
  opacity: 0.85
  padding:
    x: 18
    y: 16
  dynamic_padding: false
  decorations: buttonless
font:
  normal:
    family: &quot;MesloLGSDZ Nerd Font Mono&quot;
    style: Regular
  size: 13.0
  use_thin_strokes: true
</code></pre>
<h4 id="OHMYZSH-STARSHIP"><a class="header-anchor" href="#OHMYZSH-STARSHIP">¶</a>OHMYZSH + STARSHIP</h4>
<p>![boxcnfW5hCrRzPcO2b4t7IeKlVc](<a href="https://cdn.sspai.com/editor/u_/cb5pnodb34tbthquqlpg?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnodb34tbthquqlpg?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>我使用 zsh 作为默认终端，通过 ohmyzsh 来拓展插件功能。zsh + ohmyzsh 是目前非常流行的 Shell
配置方案，其具备了丰富的插件系统，可以通过几行配置轻松实现各项拓展功能。首先，我们按照其<a href="https://ohmyz.sh/#install" target="_blank" rel="noopener">官方说明</a>进行安装。</p>
<pre><code>sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;
</code></pre>
<p>安装完成后，通过在 <code>~/.zshrc</code> 中添加如下配置来启用 ohmyzsh：</p>
<pre><code>export ZSH=&quot;$HOME/.oh-my-zsh&quot;
source $ZSH/oh-my-zsh.sh
</code></pre>
<p>我配置了 starship 来美化 Shell
提示。同样，我们根据<a href="https://starship.rs/guide/#%F0%9F%9A%80-installation" target="_blank" rel="noopener">官方说明</a>进行安装配置：</p>
<pre><code>curl -sS https://starship.rs/install.sh | sh
</code></pre>
<p>完成后在 <code>~/.zshrc</code> 中添加如下配置即可：</p>
<pre><code>eval &quot;$(starship init zsh)&quot;
</code></pre>
<p>此外，我们还可以通过在 <code>~/.zshrc</code> 的 plugin 部分添加插件配置，例如我配置了如下插件支持，实现了智能提示、语法高亮、<code>Ctrl + R</code>
搜索命令历史记录以及 <code>j + </code>实现快捷跳转等。</p>
<pre><code>plugins=(
  git
  zsh-autosuggestions
  zsh-syntax-highlighting
  zsh-history-substring-search
  autojump
  zsh-wakatime
  fzf-zsh-plugin
)
</code></pre>
<p>我的完整配置可点击<a href="https://github.com/pseudoyu/dotfiles/tree/master/zsh" target="_blank" rel="noopener">这里</a>进行查看，各插件安装说明详见官方文档。</p>
<h4 id="TMUX"><a class="header-anchor" href="#TMUX">¶</a>TMUX</h4>
<p>![boxcn3GIjDa2RXoJr0mOhv2rsvc](<a href="https://cdn.sspai.com/editor/u_/cb5pnotb34tbthquqlq0?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnotb34tbthquqlq0?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>因为 Alacritty 本身不提供窗口拆分、Session 管理等功能，所以我们需要集成
<a href="https://github.com/tmux/tmux/wiki" target="_blank" rel="noopener">tmux</a> 这一强大的跨平台窗口管理工具。</p>
<p>macOS 平台用户用过 <code>brew install tmux</code>
安装即可，其他平台可根据<a href="https://github.com/tmux/tmux/wiki/Installing" target="_blank" rel="noopener">官方说明</a>进行安装。</p>
<p>其通过 <code>~/.tmux.conf</code>
进行配置，点击<a href="https://github.com/pseudoyu/dotfiles/tree/master/tmux" target="_blank" rel="noopener">这里</a>查看我的配置，因其配置使用需要一定学习与记忆成本，本文不做详述，建议通过官方文档或其他完整教程进行学习。</p>
<h4 id="NEOVIM"><a class="header-anchor" href="#NEOVIM">¶</a>NEOVIM</h4>
<p>我们的日常开发的代码编写一般在 VS Code 或 Jetbrains 家的 IDE
中进行，而调试则需要使用终端，如果不想频繁切换于各个软件之间，我们可以选择 vim 这一可用于命令行的编辑工具。</p>
<p>然而，原生 vim 就是一个简单的窗口，与我们的配置好的终端显得格格不入，因此，我们也将对 vim 进行美化配置。限于篇幅，本文不会涵盖 vim
的具体配置使用相关内容，仅对我的配置方案进行描述。</p>
<p>![boxcnNOHrdX73xzz92LmM7XNRFh](<a href="https://cdn.sspai.com/editor/u_/cb5pnp5b34tbt90og09g?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnp5b34tbt90og09g?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<p>我使用的是 neovim 这一 vim 的衍生版本，其高版本采用 lua 进行配置与插件管理。我使用的我的一个朋友
<a href="https://github.com/Cluas" target="_blank" rel="noopener">Cluas</a>
定制的方案，并在其基础上进行了一些修改调整，可点击<a href="https://github.com/pseudoyu/nvim/tree/pseudoyu" target="_blank" rel="noopener">这里</a>查看，仅需将
<code>nvim/</code> 目录 clone 或下载后复制到 <code>~/.config</code> 即可。</p>
<p>其显示效果如下：</p>
<p>![boxcnSGCyFsMJ3SbOn27lDdnDvd](<a href="https://cdn.sspai.com/editor/u_/cb5pnp5b34tbuhnt4if0?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnp5b34tbuhnt4if0?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)![boxcnMoeNKDMi5qC8otToXBKMSh](<a href="https://cdn.sspai.com/editor/u_/cb5pnpdb34tbuhnt4ifg?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/editor/u_/cb5pnpdb34tbuhnt4ifg?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)</p>
<h4 id="快捷键配置"><a class="header-anchor" href="#快捷键配置">¶</a>快捷键配置</h4>
<p>tmux 是一个强大的窗口管理工具，然而每次都需要使用 <code>&lt;Ctrl+b&gt;+ %</code> 或 <code>&lt;Ctrl+b&gt;+ :</code> 来进行水平或垂直分屏，或是使用
<code>&lt;Ctrl+b&gt;+ c</code> 来新建窗口等操作十分繁琐。</p>
<p>那么，有没有能够通过 macOS 自带的例如其他终端编辑器使用的 <code>Command+D</code>、<code>Command+Shift+D</code> 或 <code>Command+T</code>
来实现分屏或新建窗口等配置呢？</p>
<p>经过了一番调研与折腾，我参照着 <a href="https://www.joshmedeski.com/" target="_blank" rel="noopener">Josh Medeski</a> 的这篇「[macOS
Keyboard Shortcuts for tmux](<a href="https://www.joshmedeski.com/posts/macos-keyboard-" target="_blank" rel="noopener">https://www.joshmedeski.com/posts/macos-keyboard-</a>
shortcuts-for-tmux)」完美实现了这一需求。</p>
<p>其基本实现方式为，在终端输入 <code>xxd -psd</code> 命令后，键入所需要映射的 tmux 快捷键，如 <code>&lt;Ctrl+b&gt;+ c</code>，其会显示该输入的 hex
codes 为：</p>
<pre><code>^Bc
02630a
</code></pre>
<p>其中，<code>02</code> 代表 <code>&lt;Ctrl+b&gt;</code>，<code>63</code> 代表 <code>c</code>，而 <code>0a</code> 代表回车键，因此，在 tmux 中新建窗口的快捷键对应 hex code
为 <code>\x02\x63</code>。我们在 <code>~/.config/alacritty/alacritty.yml</code> 中的 key_bindings
部分配置如下选项即可：</p>
<pre><code>key_bindings:
  - { key: T, mods: Command, chars: &quot;\x02\x63&quot; }
</code></pre>
<p>其他快捷键配置实现原理一致，可点击<a href="https://github.com/pseudoyu/dotfiles/tree/master/alacritty" target="_blank" rel="noopener">这里</a>查看我的所有快捷键配置并自行修改调整。</p>
<h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2>
<p>至此，我对我目前所使用的三种终端工具进行了介绍与配置说明，开箱即用的 Warp 有其强大之处，iTerm2 在易用性与定制化上实现了不错的平衡，而
Alacritty 也自有折腾的乐趣。</p>
<p>如我前文所述，有时候换一个终端就是一种全新的心情，闲暇时不断优化折腾也不失为一种放松。当然，每个人的终端配置都各有自己的偏好与特点，本文只是对我的方案进行了介绍，更多满足了自己的审美追求与功能需求，希望能够为你的终端配置提供一个参考，如你在配置中遇到问题或有了更好的优化建议，也欢迎交流。</p>
<h4 id="关联阅读"><a class="header-anchor" href="#关联阅读">¶</a>关联阅读</h4>
<blockquote>
<p>下载 <a href="https://sspai.com/page/client" target="_blank" rel="noopener">少数派 2.0 客户端</a>、关注
<a href="https://sspai.com/s/J71e" target="_blank" rel="noopener">少数派公众号</a>，解锁全新阅读体验 📰</p>
</blockquote>
<blockquote>
<p>实用、好用的 <a href="https://sspai.com/mall" target="_blank" rel="noopener">正版软件</a>，少数派为你呈现 🚀</p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>琉璃易碎，人言易坠——关于《莺莺传》的叙事</title>
    <url>/public/2017/04/14/readings/yingyingzhuan/</url>
    <content><![CDATA[<blockquote>
<p>《西厢记》的书评:【琉璃易碎，人言易坠——关于《莺莺传》的叙事】转载
…全文:<a href="https://www.douban.com/doubanapp/dispatch?uri=/review/1200691/" target="_blank" rel="noopener">(豆瓣link)</a></p>
</blockquote>
<p>“半欲天明半未明，醉闻花气睡闻莺。 狌儿撼起钟声动，二十年来晓寺情。 ”男人四十的元微之写着酸酸的诗，回忆年少风流。假如我是元微之，我一定会这般写道：天空尚未亮透，微微透着点光，远处传来钟声，让我的思绪一下子回忆到二十年前，也是这样的一个早晨，在那所古寺的西厢，那个散发着鲜花一样香气的女子，用鸟儿般宛转的声音在我耳边低语：“钟声响了，想来我也该回去了。”那声音一直萦绕在耳边，十年、二十年、也许一辈子在我在记忆深处响起……。</p>
<a id="more"></a>
<p>夜宿古刹，偶遇佳人，相伴遥夜，缠绵缱绻，天明而别。这样的际遇，是最最典型的古代书生的爱情幻想。在一个陌生的地方，遇到一个陌生人，发生一段有始无终的感情。书生注定要做个过客，一生漂泊在对那个女子的思念中，却没有勇气长相守。</p>
<p>当我还是一个初中生的时候，我买来人民文学出版社的《西厢记》，上面盖本教科书，堂而皇之的上课看。但是很快，除了王实甫那华丽的辞藻，整个大团圆的故事构架让我兴趣索然，而前言里现代人给它冠上的什么“礼教叛逆者反抗封建卫道士”的宏大内涵更让我倒尽胃口。</p>
<p>在书后还附着元稹的《莺莺传》。《莺莺传》所描写的其实只是两个人的故事，两个恋爱的人后来分开的故事，没有太宏大的叙事，没有那些官腔的说教和露骨的批判。这样的故事是我所喜的；这样的故事，也是中国文人所津津乐道的。关于类似内容的作品也就汗牛充栋，数不胜数。或许从《诗经》的“氓之蚩蚩，抱布贸丝”开始，就没有谁打算给自己的爱情故事赋予太宏大的命题，只是后来的人突然犯失心疯，发现了字里行间的微言大义。所以我很景仰孔夫子他老人家，他的《论语》里每一个字都可以养活一大批的圣贤大师。</p>
<p>元稹的这篇传奇被人考据出是以自己为原型的故事，是一篇忏悔录。忏悔的味道我闻不出来，但是众前辈大师言之凿凿说张生便是元大才子，那我也就相信了罢。</p>
<p>《莺莺传》的开头，交代道“在贞元年间，有位张生，他性格温和而富有感情，风度潇洒，容貌漂亮，意志坚强，脾气孤僻”。古人向来有画脸谱的习惯，只要不是丑的太离谱，一般的名士贤臣都被描写成“性温茂，美风容”之类。但是据说元稹的家族是著名的鲜卑拓跋，鲜卑人的美貌是相当出名的，就好象现在说日本人长的猥亵一样出名，所以我有理由相信，元稹在这点上也许没有吹牛。</p>
<p>文章写道“以是年二十三，未尝近女色”，后面他自己解释道“登徒子非好色者，是有凶行；余真好色者，而适不我值。何以言之？大凡物之尤者，未尝不留连于心，是知其非忘情者也”，就仿佛现在的大学男生在卧谈会上被迫承认自己二十三岁高龄还是个处男，被人取笑之下只好解释“其实我哪里是没能力啊，我只是没遇到真正让我心动的；一般的庸脂俗粉我看不上眼，要是真有出类拔萃的，我也会追的。我是谈感情的，和你们玩肉体的垃圾是不一样的”诸如此类。但是考察元稹的家庭情况，他八岁丧父，在家族里又被同父异母的兄弟欺凌，从小随着母亲投奔舅氏，生活贫困，母亲教她念书。我们可以想象，一个幼年便寄人篱下，遭受贫困欺凌的味道，他只比林黛玉多了一个母亲而已，但是林黛玉在物质生活上绝对比他适意。我们的脑海里可以浮现这样一个人物性格：幼年丧父的人，对于男人所称道的齐家治国平天下之类的宏伟功名有着不同于常人的热情和执著，范仲淹就是很好的例子，所以元稹在事业上一直很上进努力，为达目的不惜代价不择手段，由于尝尽人情冷暖世态炎凉，他很敏感，这样的人物让我想到了《红与黑》里的主人公于连；他自幼由一个母亲抚养成人，一般这样的人具有恋母情结，对于女性有异于常人的喜好，所以他的性格里又有滥情懦弱的一面。多情和薄幸，坚毅和懦弱，正义和无耻都矛盾地体现在他身上，这也就能让我们更好的理解他后来为了追求功名而抛弃莺莺的举动了。由于家境贫寒，极端律己，自卑和敏感的元微之“内秉坚孤，非礼不可入”，就算偶尔参加朋友一起的游宴——古人的游宴和现在去歌舞厅唱歌跳舞一样，一般都安排了色情服务——“扰杂其间，他人皆汹汹拳拳，若将不及”，而他“容顺而已，终不能乱”。我不清楚他是不是冬天还要帮别人洗衣服赚钱，但是可以肯定他不会参与打牌这样不合礼仪的活动，所以也就不会有谁去污蔑他打牌作弊，不会有“樗蒲不胜，槌杀四生”的惨剧了。</p>
<p>在这里他第一次提到“物之尤者”，后面他还有段很著名的话也提到“尤物”，为自己抛弃莺莺的行为做解释“大凡天之所命尤物也，不妖其身，必妖于人”。如此看来，仿佛我们的元大才子是个叶公好龙式的人物，这边在说假如能遇到尤物一定会动真情，那边厢却在说尤物不害她自身，必定祸害他人。没有得到的时候千方百计的追求，到手以后又不迭地甩掉去追求新的目标。人总是这样矛盾的动物，永远不明白自己所追求的到底是什么。我们知道最后元稹娶了豪门韦家的女儿为妻，使得他在仕途平步青云。于此，我们不妨看成是理智和情欲的对立，一边是代表事业投机的豪门韦家联姻的机会，而一边只是爱过的漂亮的女子，理智告诉他应该离开那个女子，但是情欲却欲罢不能，但是最后我们知道理智战胜了情欲，感情只好盘踞在文字里去凭吊，所以元微之为我们贡献了很多首脍炙人口的情诗。</p>
<p>后来，张生，也就是元稹路过蒲州，搭救了寄住在普救寺的崔家寡妇一家。“是岁，浑瑊薨于蒲，有中人丁文雅，不善于军，军人因丧而扰，大掠蒲人。……先是张与蒲将之党有善，请吏护之，遂不及于难。十余日，廉使杜确将天子命以总戎节，令于军，军由是戢。”据《旧唐书·德宗纪》，贞元十五年十二月，河中绛州节度使浑瑊卒，以同州刺史杜确为河中尹、河中绛州观察使。元稹在贞元九年举明经科，并于贞元十五年在河中府任卑职，所以他和蒲将之党有交情，打个招呼关照一下也在情理之中；但据唐代举士制度，士之及第者还需要经过吏部考试才能正式任命官职，所以我们可以推测出在贞元十五年年底的时候，元稹便上路去长安应考，于是在蒲州遇上了莺莺一家。</p>
<p>我们知道这篇传奇是有虚构的成分，就如元稹在里边成了张君瑞，但是有一点细节仍然需要注意的，就是莺莺家族的姓氏。在唐朝时候，年轻人普遍的梦想有两个，金榜题名，娶七姓女；就如同现在的大学生的梦想，考上公务员，讨个有钱人做老婆。娶个有钱人做老婆可以少奋斗十年，这是基于现实利益的考量，而娶七姓女等于瞬间提升了自身家族的社会层次，也是基于现实利益的考量。在中国人的现实生活里，找不到“爱情”这两个字--有时候看历史真的会看到掩卷叹息，中国人过了几千年，还是一点长进都没有啊。唐代的士族世家已经逐渐没落，但是依然地位显赫，其中以陇西李氏、太原王氏、荥阳郑氏、范阳卢氏、清河崔氏、博陵崔氏、赵郡李氏等七姓十族最为著名，一般这些世家大族互为婚姻，自惜羽毛。唐高宗时宰相李义府为子向山东士族求婚不遂，而向朝廷建议禁止七姓十族自为婚姻。可见娶个望族女子为妻，是多么的艰难啊。莺莺是姓崔的，而且“财产甚厚，多奴仆”，很自然的就联想到了清河崔氏、博陵崔氏这些世家大族；但是很奇怪的是元稹描写的张生居然抛弃了莺莺，一个出身寒族的士子抛弃了一个那么美貌温柔的世家女子，仅仅只为了他自己所谓的“予之德不足以胜妖孽，是用忍情”么？考察元某人在政治上趋炎附势的态度，我是不相信他冠冕堂皇的话的。姑且让我用自己邪恶的想法去揣测他：那个被唤作莺莺的女子必定不是什么世家望族，所以元稹为了前途而抛弃了她，之所以故意写成崔氏，只是制造了一种假象，让读者有个印象那个莺莺是世家女子，我元微之离开她只是因为好男儿不该沉溺于爱情，你看为了理想我连世家女都放弃了啊。这便是文人的下作！</p>
<p>为了答谢这位刚认的远亲的救命之恩，于是请吃饭，贞元十五年十二月很快就在危机中渡过，这顿饭的时间也应该在贞元十六年的春天。当贞元十五年的大门“咣当”一声关掉，命运就载着我们的主人公来到了贞元十六年。饭局中张生曾问莺莺的年纪，“郑曰：‘今天子甲子岁之七月，终今贞元庚辰，生年十七矣。’”贞元庚辰，正是贞元十六年，那年元稹二十二岁，莺莺十七岁。</p>
<p>拿破仑指示说“请客的菜一定要好”，这个世间有好多的阴谋和决策在餐桌上议定，有好多缠绵或者惨烈的故事由餐桌上发端。郑国的子宋因为吃饭的时候分不到王八汤，结果一怒就干掉了郑灵公；而我们的张生，也就是元微之同学因为吃饭认识了莺莺姑娘。这表明吃饭是一次冒险，运气好的可以吃出一段情缘，运气不好的就要丢了性命，所以列位正要去吃饭相亲的同学们，你们要小心啊。</p>
<p>吃饭的时候，郑氏让儿子、女儿出来拜会救命恩人。那时侯未出阁的女子特别是大户人家的女子仿佛家之重宝，秘不见人；而郑氏却突然在一个年轻的刚认识不久的远房亲戚面前把女儿拉出来亮相，还要陪吃饭，哪怕这个年轻是救命恩人，这样的行为也是很突兀的，所以莺莺才会推三阻四的不想出来见面。郑氏这般的举动连一千多年后的我也想入非非，无疑也给了元稹兄弟很多假设的可能。不论当初的郑氏出于什么样的考虑做了这个决定，反正莺莺姑娘就此登场了。第一次召唤推说有疾，郑氏看起来很生气的说“张兄保尔之命，不然，尔且掳矣，能复远嫌乎”，这其中的话外之音，只能读者自己体会了。又过了很久，莺莺终于出场了。</p>
<p>“常服睟容，不加新饰，垂鬟接黛，双脸销红而已。颜色艳异，光辉动人”，简直惊为天人啊。我们很可以理解元稹的心情，在记忆里，那个已经离开的初恋情人总是最美丽的，而那第一次的见面总是浪漫得无法言说，第一眼里情人的样貌也是美艳不可方物。但是假如当时有照相的话，看到莺莺的照片也许你会失望，那个时代普遍流行的美女的体态是肥胖丰满的，那个时代美女的画像普遍有双下巴（有些是三下巴或者更多），面颊鼓鼓外凸，因为胖所以嘴巴也被挤的小小的嘟起来，实乃人间惨剧，竟无语凝噎！幸好莺莺不加新饰，保持了一点自然状态，否则那个惨白的面容、用红颜料描出的樱桃小嘴、脸上贴的花状的金钿和浓晕蛾翅眉足足可以把你吓死。</p>
<p>后面一句话很有意思：“张惊，为之礼。”张生看到莺莺那么漂亮，忙起来对她行礼。这个描写很传神，一般男子看到普通的女子，都保持一点点的风度，淡淡的仿佛视若不见；惟独见到美女，眼睛一亮，慌忙起身行礼，态度谦恭。足见莺莺之美。后来她坐到郑氏旁边，因为是郑氏强迫她出见的，所以她“凝睇怨绝，若不胜其体者”，那个样子就是《喜剧之王》里张柏芝所谓的“鹌鹑状”。如此楚楚动人的姿势，叫张生魂不守舍。问了年纪，只有十七岁，正是花季过后，果季之前，鲜脆欲滴，天真纯情的年纪啊！张生想和她找话题说话，但是莺莺就是不理睬他，一直到吃完饭也没有什么好说的。记得以前去参加一个朋友生日活动，饭桌遇上了朋友的表妹，也是一样的年轻明艳，也是一样的不理睬人，和她搭讪也装做没听见，搞得我们很没有面子，所以说，古往今来的好女孩一般都是很矜持的。由于没有机会接触，张生的思念就象潮水一样把他包围，所以他捉摸着要找个机会表白一下。</p>
<p>于是他从莺莺的小伙伴，侍女红娘那边入手。这个策略在以后的无数次实践当中被证明是极端正确的。大学里你要追求某个女生，先要从她寝室的室友下手，打通所有关节，请他们吃喝玩乐，最后那个女孩子身边所有的朋友都在说你好话，那你就成功一大半了。红娘被张生吓了一跳，问了个问题：“你既然那么喜欢，何不凭借你对我们家的恩情向夫人正式提亲呢（何不因其德而求娶焉）？”张生回答的话简直有点无耻了：“我从孩童时候起，性情就不随便附合。有时和妇女们在一起，也不曾看过谁。当年不肯做的事，如今到底还是在习惯上做不来。昨天在宴会上，我几乎不能控制自己。这几天来，走路忘了到什么地方去，吃饭也感觉不出饱还是没饱。恐怕过不了早晚，我就会因相思而死了。如果通过媒人去娶亲，又要‘纳采’，又要‘问名’，手续多得很，少说也得三四个月，那时恐我也就不会在人世了。你说我该怎么办呢？（余始自孩提，性不苟合。或时纨绮闲居，曾莫流盼。不为当年，终有所蔽。昨日一席间，几不自持。数日来，行忘止，食忘饱，恐不能逾旦暮。若因媒氏而娶，纳采问名，则三数月间，索我于枯鱼之肆矣。尔其谓我何？）”先吹捧自己性格不随便，然后表明见到莺莺姑娘连这样的性情也抛掉了，再不快点接近自己，就挂掉了，哪有时间挺到纳采问名啊。我从来不知道爱一个人，居然连三四个月都无法等待，这是赤裸裸的情欲，而非爱情；张生的第一目标是得到莺莺，而非和她相爱。情欲是正常的，但是不正常的是张生光明正大的以自己的情欲作为接近的借口，在一套绚丽机巧的辞藻下，其实裹挟着的不过是阿Q对吴妈的那句“我要跟你困觉”！</p>
<p>但是也许张生妇女工作做的好，红娘还真的帮他出主意，让他摇动笔杆。想来那时躲在深闺的大家闺秀并不知道外边文青的名声有多臭，结果一场悲剧上演了。</p>
<p>亚里士多德《诗学》言道：“性格为悲剧六大要素之一。”毫无疑问，莺莺的性格决定了她的悲剧结局。在她的身上我们看到矜持和热情，顺从和叛逆，坚定和认命矛盾的结合在了一起。前面我们已经注意到莺莺出场时的矜持，和在她母亲召唤下不肯出来见面的叛逆，但是当她看了张生的情诗之后却用那首暧昧的《明月三五夜》作为回应，把张生招来相见。“待月西厢下，迎风户半开。拂墙花影动，疑是玉人来。”这诗不论莺莺怎么强调“犹惧兄之见难,是用鄙靡之词，以求其必至”,都无法掩盖字里行间的情意和期盼。</p>
<p>二月十五的晚上，月亮大的吓人,文学青年元稹踏着美丽的月色，攀着墙边的杏花树翻过墙头投奔他的初恋去了。他来到西厢房,却只看到红娘躺在床上，双方都很奇怪。在红娘通报后，莺莺姑娘这才出现了。可能原本元大才子准备着类似“长夜漫漫，无心睡眠，没想到莺莺姑娘你也睡不着”之类的桥段，可是如此以来完全用不上了，而且莺莺姑娘一身包裹严实，表情严肃，狠狠地训斥了他一顿，然后扬长而去。元大才子只好承认都是月亮惹的祸，那样的月色太美太温柔，于是绝望了。元稹没有写他失恋后寻死觅活，更不像他自己说的“索之于枯鱼之肆”。但是很吊诡的是三天后莺莺就自荐枕席了。鉴于这段情节的突兀，《董解元西厢记诸宫调》里就设计了张生患相思病，莺莺探病的情节，王实甫也继承发扬了这段情节。这段情节看似让整个的故事情节更加合理，也让人物性格和心理有一定的起承转合，但其实是画蛇添足的一笔。</p>
<p>莺莺是一个性格矛盾的人，她对待未知的将来既期待又恐惧，她知道自己所做的是不容于世的，但是她对于爱情满怀憧憬而渴望冒险。在爱情的冲动下，她一步步滑向张生的怀抱。也许从第一次出来见这个救命恩人的时候，她便已经心存好感，起码我们知道张生的相貌世让人赏心悦目，这是爱情的基础；当看到张生的两首诗，更加倾慕于他。唐代的女孩子也和现在的女孩子一样，有自己心目中的白马王子。也许那个时代比较流行的梦中情人形象，就是元稹这样的才子。于是她情不自禁回了一首诗，也许只是想见他一面，但是理智告诉她这样做法的危险性。也许在红娘去通报的时候，她还在那里犹豫到底要不要去见。最后她决定去看一眼那个自己衷情的男子，她穿戴齐整。当爱上一个男人的女子，在那个男人面前总是很低很低,低到尘埃里,尘埃里便开出花来，于是她潜意识的想保持自己的尊严，她不想被他看成是轻薄的女子。她终于见到了他，在月色下，俊朗的男子期盼地看着自己，眼神顾盼之间，让人心旌摇荡；那淡淡的笑容，刚毅的嘴角，也许随着那夜的月色一起留在莺莺地记忆深处。她发觉自己陷入一种前所未有的危机，一种爱上别人为了那男子可以不顾一切的冲动，于是她板下脸来，义正词严地拒绝了那个男子。“非礼之动，能不愧心？特愿以礼自持，毋及于乱！”这些话在我看来倒有一大半是在对自己萌动的心说的，莺莺在警告自己不要逾越了礼，否则将万劫不复。男子一脸地失望，仿佛满地月光都成了严霜。她还是转身离去。但是正如元稹在《会真诗》里所写的“戏调初微拒，柔情已暗通”。我不知道莺莺在这三天里是如何地心情，我也不知道其中红娘起了多大地作用，但是我知道到了十八日的晚上，莺莺终于做了自己一生中最重要的决定。</p>
<p>“数夕，张生临轩独寝，忽有人觉之。惊骇而起，则红娘敛衾携枕而至，抚张曰：‘至矣！至矣！睡何为哉！’并枕重衾而去。张生拭目危坐久之，犹疑梦寐；然而修谨以俟。俄而红娘捧崔氏而至。至，则娇羞融冶，力不能运支体，曩时端庄，不复同矣。是夕，旬有八日也。斜月晶莹，幽辉半床。”唐贞元十六年二月十八日的夜晚，那一夜的经历对于元稹来说是如此的深刻，以至于很久以后依然清楚的记得那天的日期，那夜的月色。元稹在《会真诗》里清楚地描写了缠绵的经过，在千年之后的人们看来，那诗依然写得香艳露骨，荡人心旌：“微月透帘栊，萤光度碧空；遥天初缥缈，低树渐葱茏……低鬟蝉影动，回步玉尘蒙；转面流花雪，登床抱绮丛；鸳鸯交颈舞，翡翠合欢笼；眉黛羞频聚，朱唇暖更融；气清兰蕊馥，肤润玉肌丰；无力慵移腕，多娇爱敛躬；汗光珠点点，发乱绿松松……”。在晶莹的斜月下，天真善良的莺莺投奔了爱情，为了自己心爱的男子，为了梦想中的爱情，抛弃了一切，奉献了一切。也许古往今来有很多的人有这般的经历，曾经真心单纯地去爱一个人，为他（她）付出了一切。不管结果如何，起码在那一刻，付出的人是幸福的，虽然这样的幸福可能是要遭到报应的。</p>
<p>在现代人的眼光来看，莺莺这床也上的太快了些。其实这还不算彻底的，汉代的司马相如不过弹了次琴，卓文君便跟着他私奔了，连富翁老爹也不认了。那个时代，女子应允了一份爱情就等于一生一世，不会再有给你重来改过的机会。那是个严肃的时代，女子地位低下，虽然相对于其他朝代，唐朝的风气算是比较开明宽松，但是逾越礼制的爱情依然不容于世，和一个男子相恋，要么嫁给他，要么就是再也得不到幸福和爱情。如那位被元稹好友白居易赞为“醉娇胜不得，风嫋牡丹花”的徐州名妓关盼盼，在其丈夫徐州守帅张愔死后却被白居易讽刺她不肯殉情，逼得她不得不绝食自尽；又如步非烟，因为父母之命而嫁于功曹参军武公业，毫无爱情可言，于是她红杏出墙，爱上了攻读课业的书生赵象，被丈夫发现后，只是淡淡说了句“生既相爱，死亦何恨”，于是从容淡定，任凭丈夫拷打，不肯开口求饶一句，最后终于被活活打死，以暴疾而亡的名义埋了。那个时代的女子，很少可以拥有幸福的爱情，所以这充分体现了新社会的优越性，起码你谈几场恋爱没有关系，女孩子只要不失身还是会有幸福的。</p>
<p>红娘把枕头也带来了,在古时候,共同倚靠的枕头是充满暗示意味的情物，是在一起温柔缠绵的明证。本朝初年高阳公主嫁于房玄龄之子房遗爱为妻，却不爱房遗爱，在新婚之夜就把新郎拒于洞房之外。高贵的公主爱上了玄奘的高徒、最年轻却最聪慧的高僧辩机和尚，那时高阳公主十六岁，辩机和尚二十一岁。高阳公主送给辩机一个“金玉宝枕”，却被小偷偷出。结果事情因此泄露，高贵的辩机被腰斩于市，而高阳公主也一辈子恨上了自己的家族，“帝崩无哀容”。或许唐代的女子血液里奔流着冒险的因子，所以为了爱情不顾一切，哪怕被抛弃被鄙夷被万夫所指天地不容也再所不惜。于是整个唐朝给我们后人留下了一大堆让人向往的爱情故事。莺莺对待爱情的勇气，无疑是秉承了大唐女子一贯的风气，虽然她的命运因此让人心痛，但是她的形象也因此让人爱怜，在千百年后的今天依然让我爱慕钦佩。</p>
<p>“有顷，寺钟鸣，天将晓。红娘促去。崔氏娇啼宛转，红娘又捧之而去，终夕无一言。”如此“金风玉露一相逢”的时光过的总是很快，古寺的朝钟响起，天快亮了，莺莺也要离去了。对于类似的幽会后的早晨，《诗经》里便有很细致的描述：《郑风·女曰鸡鸣》里写道“女曰鸡鸣，士曰昧旦；子兴视夜，明星有烂”，女子在催促说“鸡已经在打啼了”，男子眷恋枕衾，“天还没全亮；你起身看夜空，启明星还闪闪发光”，然后慢慢谈到工作，谈到两个人的未来，谈到恩爱到白头，“宜言饮酒，与子偕老。琴瑟在御，莫不静好”；《齐风．鸡鸣》里写道“鸡既鸣矣，朝既盈矣。匪鸡则鸣，苍蝇之声。东方明矣，朝既昌矣。匪东方则明，月出之光”，女子催促男子快起身，男子淹留不肯，“那不是鸡叫，是苍蝇嗡嗡声，东边也没亮，那是月亮光而已”，回答言语可爱缠绵。钱钟书说：“莎士比亚剧中写情人欢会，女曰：‘天尚未明，此夜莺啼，非云雀鸣也。’男曰：‘云雀报曙，东方云开透日矣。’女曰：‘此非晨光，乃流星耳。’用以比勘。”但是我们注意到，莺莺和张生一夜缠绵，居然不交一词，只是在天明将别的时候，呜咽哭泣。这个写法相当传神，我们可以从那“山盟海誓”的缺失和离别时的哭泣，感受到莺莺内心的矛盾：她明知道她正在做一件可能万劫不复的错事，但是却无法控制内心对于张生的情意，爱情的那种使双方合二为一的强烈愿望战胜了对命运的恐惧，她不敢说话，因为说话就代表了清醒，她宁愿在一种迷醉的状态下委身于自己的爱人，抛却一切利益的得失、道德的禁梏；当天明将别，她仿佛恍然从梦中惊醒，好象做错了事的孩子一样，为自己的选择和命运哭泣，为自己所失去的哭泣。当然在这眼泪之中，对于离别的伤感，也占了一定的比重，所以在未来的十多天里，她再也没有和张生联系。</p>
<p>直到张生“赋《会真诗》三十韵，未毕，而红娘适至，因授之，以贻崔氏”，才又来与张生相会。想来未完的《会真诗》是个很好的说服自己的借口，只是来探讨文学罢了，但是总免不了“向谁行宿,不如休去”的挽留。于是这样相处了将近一个月。</p>
<p>“张生常诘郑氏之情，则曰：‘我不可奈何矣。’因欲就成之。”这是最常见的断句，莺莺说：“我没有办法告诉她。”于是张生便想亲自和郑氏谈谈，促成这件事。但是见家长的事突然没有下文，很快张生也去了长安，这样的情节安排无论如何都是不通的。幸好还有另外一个版本：“张生常诘郑氏之情，则曰：‘知不可奈何矣，因欲就成之。’”莺莺说她妈知道也没其他办法了，所以想促成我们的婚事。他们相处同居了一个月，而寺院内有崔家那么多的仆役，就算郑氏再昏懵，也应该了解到女儿的事情了。事已既此，无可奈何，女儿大了，心向外人，现在也只能期盼那男人能负责任把她娶去了。这样的心情很可以理解，我的一个朋友，和她女朋友两地分居，而且女孩子在当地做了教师，不错的职业，眼看因为家里反对要分手了，但是有天女孩子的父母偷听他们的电话，知道了女儿已经失身于我的朋友，于是第二天就让女儿把我的朋友叫去见面，很快便结了婚。所以很多时候，我都分不清自己到底是生活在古代还是生活在现代，一千多年下来，对待某些问题的做法还是一点都没变化。</p>
<p>但是张生可能很害怕被一桩寒门的婚姻套牢，一听这话赶快跑路；于是借口“为了梦想中金碧辉煌的长安,都市里充满了神奇的历险,满足一个男儿宏伟的心愿”，西下长安去了。去之前还先告诉了莺莺，“崔氏宛无难词，然而愁怨之容动人矣”。有一种哀伤，是哭不出来的，它会慢慢渗透进你的骨子，日日夜夜一点一滴地侵蚀你的情绪。或许她害怕自己会控制不住自己面对离别的悲伤，所以在张生将要走的第二天晚上，莺莺没有来。我总是不能理解女子的心思，明明想念你的，却不肯见面；明明想把你留下的，却早早地说出一路顺风的祝福；明明在说没有留下更多的甜蜜回忆，却连分手了也不肯来见最后一面，谁都无法想见女子的心里到底在想些什么，或许正是这样的复杂，才成就了莺莺形象的丰满。</p>
<p>但是很快，张生又回到了蒲州，又与莺莺相处了好几个月，也许是他无法放下这段感情，也许是长安尚未有“实现一个男儿宏伟志向”的机会，更可能是长安还没那么早开考，想最后的缠绵一下。莺莺的字和文章写的都很好，却从不给张生看；她写文章的水平很好，但是却好象什么都不懂的样子；她言辞敏捷，但是在外人面前却很少说话。或许这样的女孩子最是让人怜爱。“待张之意甚厚，然未尝以词继之。时愁艳幽邃，恒若不识，喜愠之容，亦罕形见”，莺莺是个内向的女孩子，有了情绪却不轻易流露，她不会口口声声地和你说“我爱你”，但是连她注视你的目光都能让你感到无限柔情，你无法知晓她的想法，但是却沉溺于她时时流露的情意。她喜欢弹琴来抒发情感，可能是心情忧郁，所以弹奏的曲子异常伤感。</p>
<p>不久张生便要去长安应试了，或许是下了决心终要割断前缘，一心功名，所以这个男人连说分手的勇气都没有，只能对着莺莺忧愁哀叹，自然他也是不肯去承诺些什么的。莺莺自然明白他的心思，面对爱人的负心薄情，做为一个弱女子又能说什么呢。莺莺是个坚强而又自尊的女子，她不会低声哀求张生留下，她态度恭敬，声音柔和，慢慢地对张生说：“始乱之，终弃之，固其宜矣，愚不敢恨。必也君乱之，君终之，君之惠也。则没身之誓，其有终矣，又何必深感于此行？然而君既不怿，无以奉宁。君常谓我善鼓琴，向时羞颜，所不能及。今且往矣，既君此诚。” 莺莺平静的面容下说出“始乱之，终弃之，固其宜矣，愚不敢恨”那是怎样的一种心痛呢，假如仅仅是个人爱情的失败也就罢了，但是其中还昭显出整个家族的衰败和老母最后一丝期望的落空。人很多时候并非为自己而活，所以人最不能承受的并非自身的失败，而是自身的失败给自己亲爱之人所带来的伤害。张生挥一挥衣袖，固然不带走一片云彩，还可以得到时人“善补过者”的赞誉，但是对于莺莺来说，不但她这一生的命运已经凄惨无疑，而且也给了她衰颓式微的家族一次重重的羞辱和打击。</p>
<p>她终于明白了“则没身之誓，其有终矣”，古往今来男女说着“山无陵，江水为竭，冬雷阵阵，夏雨雪，天地合，乃敢与君绝”的誓言，可大多数的人言语远比自身华丽，现实远没有恶化到世界末日，便已经支持不住，爱情一如华美的琉璃，碰触现实难免粉碎。</p>
<p>于是她为自己心爱的男子弹了最后一首曲子《霓裳羽衣曲序》，琴声因为心情悲伤而纷乱错杂，旁边的人都听着流泪，她终于弹不下去，扔下琴哭着跑到母亲的房里，再也没出来。在这部作品里，郑氏出场只有一次，侧面描写也并不多，但是我们却依然能想象一千多年前那位母亲的悲痛，为自己的命运，为家族的命运，更为自己女儿的命运感到悲伤。</p>
<p>第二天我们的元大才子便神清气爽地踏上西去长安的路途，但是那年他没有考中。于是他留在了长安，从莺莺的信中我们了解到，这个鄙薄的文青曾托人给莺莺寄去一封信，让她看开些，“以广其意”，顺便送去“花胜一合、口脂五寸”做为分手礼物。唐代女子喜欢用绢纸、金银等材料做出一朵朵花形的小物件，贴在脸上，唐代就称之为“花胜”或者“花钿”。元稹很潇洒地给分手后的情人送去长安最时尚的化妆品和首饰，想以此来弥补内心的愧疚。但凡女子都爱最新潮时尚的化妆品，犹以情人所赠为甚；但是我不知道淹留蒲州普救寺的母女，在这个穷乡僻壤突然看到负心的男人送来长安的时尚货色，会是怎样的心情，或许如后世李清照所言“泪融残粉花钿重”。</p>
<p>孤独无望地留在普救寺的莺莺回了一封信，那信却被张生炫耀于长安的朋友之间。就好象胡兰成把曾与他恩爱缠绵的女子都写进《今生今世》，古今文人下作起来都是一样。</p>
<p>对于自己的负心，元稹还借用了《左传》那句“夫有尤物,足以移人,苟非道德,则必有祸”，义正词严地发表了一通高论：“大凡天之所命尤物也，不妖其身，必妖于人。使崔氏子遇合富贵，乘宠娇，不为云为雨，则为蛟为螭，吾不知其变化矣。昔殷之辛，周之幽，据百万之国，其势甚厚。然而一女子败之，溃其众，屠其身，至今为天下戮笑。予之德不足以胜妖孽，是用忍情。”最可怕的是听众的反应，“于时坐者皆为深叹”，大家叹口气，居然没人指责张生的负心薄幸，或者有一点小小的同情给予莺莺。</p>
<p>对于美貌女子的恐惧，其实不过只是自身懦弱的借口罢了，男子严于律女子，宽于律己，实在是很无耻。《世说新语》里记载着石崇宴客让美人劝酒，如客人不饮，便杀掉劝酒的美人。有一次丞相王导和大将军王敦去赴宴，王导不善饮酒，也只好勉强自己喝，以至于喝醉了；而王敦死活不肯给面子，就是不喝，“已斩三人，颜色如故，尚不肯饮”。而此事，却被刘义庆归为“汰侈”，意思是奢侈浪费。在这里我们看到的是人正常情感的缺位，对于爱情和女性的残忍，却成了男子气度的象征。记得唐代曾有一个很出名的事件：军官冯燕，和同事张婴的漂亮老婆私通，张婴酗酒而归，冯燕逃避不及，只好藏到床底，却发觉自己的头巾还留在枕边，幸好张婴喝醉了并没发觉。于是冯燕指指头巾示意张妻把头巾取来免得事情败露，可是张妻会错了意，竟把枕边张婴的佩刀递给了他。冯燕看了张妻几眼，觉得这个女人太狠毒，就一刀砍下了张妻的头，然后戴上头巾走了。张婴于是就被认为杀害自己的妻子，被判死刑；结果在刑场上，冯燕出现了，他宣称张婴是无辜的，张妻是自己杀的。军政长官贾耽将此案据实上奏，并表示，宁愿免去自己的官职，也要为冯燕赎罪。最后皇帝的敕令是，将滑地的全部死刑犯同时赦免。这件案子影响很大，以至于那个时代的流行小说家沈下贤专门为之创作了传奇《冯燕传》；著名诗人司空图则写了长篇叙事诗《冯燕歌》，其中有一句诗写道“已为不平能割爱”，也就是说为了所谓的道德规范，能割舍爱情的才是大英雄。于是世情普遍鄙薄男欢女爱，积极培养冷血寡情的人，于是婚姻便成利益的交换，所谓的爱情只能沦落到勾栏瓦舍里去了。对比西方，希罗多德《历史》曾讲过吕底亚王坎道列斯的故事。坎道列斯认为自己的妻子是世上最美丽的女子，于是他想拿来炫耀了，他强迫他的亲信巨吉斯看王后的身体，以便确认这一点；不得已，巨吉斯只好藏在卧室，看了王后的身体。王后知道此事后，认为是奇耻大辱，就将巨吉斯召来，给他两个选择：要么他杀掉国王，“变成我的丈夫并取得吕底亚的王位”；要么被处死。结果巨吉斯选择了前者，他杀死了国王，并娶了王后，登上了吕底亚的王位。我们从中可以看到东西方文明对待情欲的差别。遗风留至如今，家里关心你的结婚对象，不是双方有多么相爱，感情有多深厚，而是这个人家里怎样，是不是老实，有没有本事赚钱升官；假如你斗胆和他们说起你们的爱情，于是大家都开始哄堂大笑或者不屑一顾，仿佛看你就是一个不成熟的孩子、精神错乱的病人。对于爱情的信仰，或许只存在于看戏的那段辰光。</p>
<p>有了这样一种社会心理氛围，再加上有太子少保韦夏卿的赏识，那么元稹抛弃寒门女子莺莺而迎娶豪门韦家的千金韦丛，也就顺理成章了。但吊诡的是在蒋防写的《霍小玉传》里，元稹的老丈人韦夏卿却对负心薄行的朋友李益这般说：“风光甚丽，草木荣华。伤哉郑卿，衔冤空室！足下终能弃置，实是忍人。丈夫之心，不宜如此。足下宜为思之！”蒋防此人在仕途上得到过元稹的推荐，所以他写及元稹的岳父时总要润色拔高一下，只是他的恩公看到这番话时是否会心头一颤？</p>
<p>或许是虬髯客已没，不会再有人“衔之十年”也要去取“天下负心者”的头颅心肝下酒，所以男人也就越发理直气壮地负心薄幸。负心人元稹没有得到什么报应，又过了一年多后，也就是贞元十九年他登拔萃科，署秘书省校书郎，娶了韦夏卿之女韦丛为妻，并在那一年与同中书判拔萃科的白居易相识订交，从此元白之名满天下。元稹在《梦游春七十韵》中写道：“当年二纪初，嘉节三星度……韦门正全盛，出入多欢裕。”在元稹志得意满，欢娱畅快之时，莺莺也匆匆嫁于他人了。后来元稹偶然路过莺莺居住的地方，以莺莺表兄的身份求见，终不得一见。莺莺的不复相见，是对情人的深深失望，或许她会深深的认同鱼玄机说的“易求无价宝，难得有情郎”；她没有霍小玉那般刚烈，她也许也会哀怜自己“我为女子，薄命如斯，是丈夫负心若此”，但她却说不出“我死之後，必为厉鬼，使君妻妾，终日不安”的话。莺莺只写了首诗给元稹，硬着骨头咬着牙说“弃置今何道，当时且自亲”，既然都已经分开了不爱我了又有什么好说的呢，当时恩爱缠绵也就足够了，让他“还将旧时意，怜取眼前人”，因为懂得，所以慈悲。当爱情归于寂寥，繁华消于落寞，一切都只存在与记忆里，曾经的美好，只能活在心底。“惆怅旧欢如梦，觉来无处追寻”。或许她也明白，往事只能追忆，不可重温。曾经年少单纯的莺莺已经死了，只留下一具逐渐衰老的躯壳和悲伤的灵魂继续苟活。现实那样丑恶，我们却不得不活下去。</p>
<p>我真的怀疑元稹所谓的“曾经沧海难为水，除却巫山不是云”到底指哪一位，是莺莺，还是韦丛，抑或是薛涛？元和四年，韦丛去世，元稹写了三十三篇诗来悼念她，其中最有名的一句：“惟将终夜长开眼，报答平生未展眉。”根据陈寅恪先生的考证，这个“长开眼”不仅仅是睡不着的意思，“所谓‘常开眼’者，自比鳏鱼（有“鳏鱼眼长开”这一说法），即自誓终鳏之义”（陈寅恪《元白诗笺证稿》），元稹信誓旦旦的要为韦丛终生不娶，鳏孤到死了。但事实证明，元稹是个文过饰非的人，在韦丛凑趣去世的那年，他邂逅薛涛，两人相恋了一年后将之抛弃，可怜薛涛为之终身不嫁，“只欲栏边安枕席，夜深闲共说相思”；两年后纳妾安氏，又过数年续弦裴淑。简直是“取次花丛频回顾”啊！所以观陈寅恪先生对其评价“自私自利。综其一生行迹，巧宦固不待言，而巧婚尤为可恶也。岂其多情哉？实多诈而已矣”并不为过。</p>
<p>读《元长庆集》，常免不了痛恨为什么如此深情优美的诗句却出自一个那么薄情负心的伧夫之手。雪莱在《致云雀》中说：“我们最甜美的歌，就是那些倾吐最哀伤的思想的。”不知道元稹所哀伤的到底是什么。贝克尔在《抗拒死亡》中说的：“所有动人心弦的事中，对死的恐惧是首当其冲的。”他的悼亡诗写的那么情深意切，大概是出于对死亡本身的恐惧和悲哀吧。</p>
<p>或许不该过分指责元稹，他也不过是为了功名奔波的庸人，这个世界原本就是为庸人所设的。太过恩爱的情侣总是不容于世：苏东坡与王弗已是“十年生死两茫茫”了；陆游和唐婉儿只能“一怀愁绪，几年离索”；刘克庄在哀叹“旧日风烟草树，而今总断人肠”；冒辟疆和董小宛“一生清福,九年占尽,九年折尽矣”；还有纳兰性德，感慨着“被酒莫惊春睡重，睹书消得泼茶香，当时只道是寻常”。但是起码他们是能真心相爱的，就算不能“执子之手，与子偕老”，起码也是“骨化形销而丹诚不泯”，却可怜了单纯的莺莺，一个人用余生去背负全部的思念、悔恨和指摘。</p>
<p>史籍上再没有关于莺莺以后生活的记载，或许她一生坎坷，慢慢地消磨了纯真善良，成了世间常见的庸俗势利的妇人。但哪怕是这样，我依然相信在她心底的最幽深隐蔽的角落、最柔嫩脆弱的地方，记忆会像一把锯齿慢慢地来回剧着那根最纤细的神经，午夜梦回的时候，依然会为贞元十六年的那个男子泪流满面。</p>
<p>我怕我鄙薄的文字无法完美地译出那女子悲伤的文字，且让我们再细细读一读那信的原文,体会一下她的心情吧：</p>
<p>捧览来问，抚爱过深。儿女之情，悲喜交集。兼惠花胜一合、口脂五寸，致耀首膏唇之饰。虽荷殊恩，谁复为容？睹物增怀，但积悲叹耳。伏承使于京中就业，进修之道，固在便安。但恨僻陋之人，永以遐弃。命也如此，知复何言！自去秋已来，常忽忽如有所失。于喧哗之下，或勉为语笑，闲宵自处，无不泪零。乃至梦寐之间，亦多感咽离忧之思。绸缪缱绻，暂若寻常，幽会未终，惊魂已断。虽半衾如暖，而思之甚遥。一昨拜辞，倏逾旧岁。长安行乐之地，触绪牵情。何幸不忘幽微，眷念无斁，鄙薄之志，无以奉酬。至于终始之盟，则固不忒。鄙昔中表相因，或同宴处。婢仆见诱，遂致私诚。儿女之心，不能自固。君子有援琴之挑，鄙人无投梭之拒。及荐寝席，义盛意深。愚陋之情，永谓终托。岂期既见君子，而不能定情，致有自献之羞，不复明侍巾帻。没身永恨，含叹何言！倘仁人用心，俯遂幽眇，虽死之日，犹生之年。如或达士略情，舍小从大，以先配为丑行，以要盟为可欺，则当骨化形销，丹诚不泯，因风委露，犹托清尘。存没之诚，言尽于此。临纸呜咽，情不能申。千万珍重，珍重千万！玉环一枚，是儿婴年所弄，寄充君子下体所佩。玉取其坚润不渝，环取其终始不绝。兼乱丝一绚、文竹茶碾子一枚。此数物不足见珍，意者欲君子如玉之真，弊志如环不解。泪痕在竹，愁绪萦丝，因物达情，永以为好耳。心迩身遐，拜会无期。幽愤所钟，千里神合。千万珍重！春风多厉，强饭为嘉。慎言自保，无以鄙为深念。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>故事</tag>
        <tag>《莺莺传》</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」走进小众但不冷门的房车世界</title>
    <url>/public/2022/07/15/test/202207/2022-07-10-020934733003/</url>
    <content><![CDATA[<p>「转」<a href="https://sspai.com/post/74043" target="_blank" rel="noopener">走进小众但不冷门的房车世界</a></p>
<a id="more"></a>
<p><strong>Matrix 首页推荐</strong></p>
<p><a href="https://sspai.com/matrix" target="_blank" rel="noopener">Matrix</a>
是少数派的写作社区，我们主张分享真实的产品体验，有实用价值的经验与思考。我们会不定期挑选 Matrix 最优质的文章，展示来自用户的最真实的体验和观点。</p>
<p>文章代表作者个人观点，少数派仅对标题和排版略作修改。</p>
<h2 id="前言：小众但不冷门的新市场"><a class="header-anchor" href="#前言：小众但不冷门的新市场">¶</a>前言：小众但不冷门的新市场</h2>
<p>对于今天的中国市场来说，房车依然是一个小众领域，但你不能再说它「冷门」了。</p>
<p>自 2010 年以来，我国的房车市场一直在高速发展，这源自于国家政策的支持与国内房车文化的兴起。</p>
<p>在十三五期间，全国各省市在中央政策的指引下规划了各自的房车营地建设规划，2014
年《关于加快发展体育产业促进体育消费的若干意见》，提出要引导发展户外营地、汽车露营营地等设施；2016
年《关于加快发展健身休闲产业的指导意见》提出重点建设一批山地户外营地、自驾车房车营地等；2018
年《关于完善促进消费体制机制进一步激发居民消费潜力的若干意见》提出支持自驾车、旅居车等消费大众化发展，加强相关公共配套基础设施建设；2019
年《关于进一步激发文化和旅游消费潜力的意见》指出要着力开发自驾车旅居车旅游产品；2022 年 1 月 20
日新华社播发的《十四五旅游业发展规划》中又明确提到要重点推进旅居车及营地、可移动旅居设备等自主创新及高端制造……</p>
<p>乘联会数据显示，中国房车市场近年来也在快速增长，年销量从 2017 年的不足 5000 辆增至 2021 年的 12582 辆。今年第一季度，我国房车销量为
2425 辆，同比增长
17%。​这些都表明国家相关部门一直都很重视国内房车市场，同时，随着国内房车市场的高速发展，国家也在不断根据实际情况制定新法规、新政策。</p>
<p>比如今年 4 月 1 日，「C1 驾照只能开 6 米以内车型，却能开前后车相加超过 10 米的拖挂房车」这个 BUG 终于被修复，有关部分专门为此新增了
C6 驾照；此外法规上对于自行式房车的上装标准也于今年 1 月 1 日起开始实施，规定了房车车内净高度不低于
1750mm、需有独立卫生间、装置需固定（限制外置厨房），并明确房车的正式名称为「小型旅居车」。作为对比，新规之前房车行驶证上写的是「小型专用客车」。</p>
<p>事实上，早在 2015 年公安部就下发过关于指导基层交管部门对于拖挂房车的执法意见，因为那时候包括拖挂房车在内的所有房车在国内都还是一个新事物。​</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/1330b2001f3f063f3250dbb4c6f8c99d?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/1330b2001f3f063f3250dbb4c6f8c99d?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)我国房车相关法规一直在与时俱进</p>
<p>所以如果你已经通过其它渠道接触过房车，想要进一步了解房车入门的一些相关知识甚至考虑入手房车，这篇文章将通过几个常见问题为你提供一些必要的指引。</p>
<h2 id="Q1：聊「房车」时我们在聊什么车"><a class="header-anchor" href="#Q1：聊「房车」时我们在聊什么车">¶</a>Q1：聊「房车」时我们在聊什么车</h2>
<p>宏观上来说，我们所讨论房车一般分为 <strong>自 行式房车</strong>和 <strong>拖 挂房车</strong>。</p>
<p>自行式房车简单说就是自己有发动机和轮子，自己会跑，房和车是一体的。自行式房车往下又细分为 A 型、B 型和 C 型房车。</p>
<p><strong>A 型房车</strong>指的是那些长度超过 6
米、以大巴、卡车为底盘、内部空间巨大、配置奢侈的豪华房车，也因此这种房车的售价高高在上，不管是字面意义上还是延伸意义上，都不是普通人能「驾驭」得了的，这里就不细说了。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/89ab820b05c6d5f8e5830f343f411f2c?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/89ab820b05c6d5f8e5830f343f411f2c?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)可以放跑车的奢华A型房车</p>
<p><strong>B
型房车</strong>一般由厢式货车整车改装而来，不改变车身的整体结构，虽然有的厂家会更换部分车顶或拓宽窗户以获得更大空间（如奇瑞瑞弗），但不会改变车子原厂的碰撞安全性和耐久性，外观低调，开起来的感觉和开一个普通的厢式货车是一样的。</p>
<p>为了有更大的空间，国内 B 型车一般使用大通 V90、依维柯欧胜这类长轴高顶的底盘，成品房车售价一般在 30
万以上。也有的厂家使用小尺寸的面包车或轻客，售价较低，但一般没有卫生间且空间较小，人也站不直，这类房车更偏向于床车而不是真正意义的房车，需要注意。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/30/article/166c627f6b457a6fffae6257ae65e834?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/30/article/166c627f6b457a6fffae6257ae65e834?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)小型B型房车更偏向于床车</p>
<p>B 型房车相较于 C 型房车外观低调不会引起围观，较低的车高能通过更多的限高，开起来更灵活可以兼顾日常通勤，车型选择也很多，如果想当家用车使用，就选择长度
5.5 米甚至 5 米的高顶房车，空间也不会差，如果已经有通勤车，可以顶着蓝牌的上限选择长度 5 米 99 的底盘获得更大的空间。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/22514ca82e5243322d3fd1d6b5edab46?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/22514ca82e5243322d3fd1d6b5edab46?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)中短轴B型房车能兼顾日常</p>
<p><strong>C 型房车</strong>最明显的一个特点就是有个大额头，相比于 B 型房车其纵向空间利用率更高，它的大额头能直接比 B 型房车多一个全尺寸大床出来。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/30/article/6aa5626f6786a9b1e3800d7093bab9fa?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/30/article/6aa5626f6786a9b1e3800d7093bab9fa?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)上汽大通原厂出品的 C 型房车</p>
<p>C
型的底盘大部分是皮卡和轻卡去掉驾驶室后面的载货斗安装上房车专用箱体而来，设计不受原车的尺寸限制，空间充裕。车身材质以玻璃钢中间填充保温材质、木骨架的「三明治」车身为主流，高档的会用铝合金和钢作为骨架，但不论用什么材质，车身耐久性和强度必然不能和通过碰撞测试的B型房车相提并论。</p>
<p>C 型的另一个优点是保温隔热性能比 B 型更好。​</p>
<p>C
型房车的种类百花齐放，售价从十几万到几十上百万都有，其底盘以轻客和皮卡为主，也有采用卡车作为底盘的，空间更大但驾驶感较差。小货车底盘的房车售价较低，但通常动力很差，也鲜有自动挡的选项，而且小货车载重能力有限，无法携带很多水、安装容量更大的生活电池，空间也很难做大，只适合一到两人使用，而且开车要佛系。</p>
<p>例如新飞集团的祥菱房车，不带卫生间的版本仅售 9.98 万（带独立卫生间 10.58 万），应该是国内最便宜的 C
型房车了，当然配置肯定很低没法用，我个人预估整备到能正常用的程度后大概总成本在 15 万左右，轻松圆房车梦。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/cac9845354bec18b1d1acb596abf94aa?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/cac9845354bec18b1d1acb596abf94aa?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)新飞祥菱房车</p>
<p>另外很多高端 C
型房车会有拓展设计，在驻车时拓展机构可以展开带来更大的额外空间，不过其复杂的拓展结构可能会增加故障率，接缝部分年久老化后会带来漏水问题，一些小厂的拓展房车甚至连淋雨测试都做不好。</p>
<p>![](<a href="https://cdn.sspai.com/2022/07/01/article/f97d1420a61db386213ef518790dfa55?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/07/01/article/f97d1420a61db386213ef518790dfa55?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)奇瑞瑞弗的双拓展房车</p>
<p>拖挂房车是很多老炮的钟爱，也是欧美房车市场的主流选择，在美国市场甚至 90%
以上都是拖挂房车，因为拖挂房车没有驾驶室、底盘没有传动系统，因此空间利用率更高居住更舒适，布局也更加灵活。在我国，虽然人口密集、多山路的东部和南部地区并不适合拖挂行驶，但地广人稀、风景壮阔的大东北、大西北和川藏地区和美国的道路情况比较类似，而且这些地方相对来说基础公用设施较差，很适合空间大、装载能力更强的拖挂房车行驶。国内常见的拖挂玩法是开一个
SUV 再牵引一个拖挂，到一个地方把拖挂停在方便停车的郊区，然后脱掉房车开着 SUV 进城玩耍。</p>
<p><img src="https://cdn.sspai.com/2022/06/30/fc1c87f1d6df0ff2d226d96a82ebdb8e.jpeg" alt>各式各样的拖挂房车</p>
<h2 id="Q2：房车的驾照、保险与上牌"><a class="header-anchor" href="#Q2：房车的驾照、保险与上牌">¶</a>Q2：房车的驾照、保险与上牌</h2>
<p>对于自行式房车，只要是长度在 6 米以内、上蓝牌的车辆都是 C1 照即可驾驶（自动挡 C2 可驾驶），保险和上牌与家用轿车的费用和流程是差不多的。</p>
<p>对于拖挂房车，则需要另外考取 C6 驾照才能驾驶（或持有 A2）。根据《道路交通安全法实施条例》第 56 条，「小型载客汽车只允许牵引旅居挂车或者总质量
700 千克以下的挂车。」有的小伙伴可能会对这条产生误解，以为只能拉 700 公斤以下的房车，其实这里提到了两个不同的概念：旅居挂车和 700
公斤以下的挂车，他们同属于挂车。​旅居挂车就是我们说的拖挂房车，而根据 C6 驾照的准驾要求，可以驾驶的是轻型牵引挂车且两车相加小于4500
KG，轻型的定义是 750KG-4500KG。至于 700KG 以下的挂车则属于微型挂车了。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/7a8a8d9256fd219b42c6bafed1cd981e?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/7a8a8d9256fd219b42c6bafed1cd981e?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)不同类型挂车的定义</p>
<p>根据 2020
年实施的公安部公共安全行业标准，挂车也属于机动车，因此拖挂房车也是需要上牌的，而且上牌流程和家用车基本一致，需要注意的就是拖挂房车上牌不需要拖挂的交强险，这点在下面细说；然后有的小检测站可能没有检测过拖挂房车所以会不给你检、有的车管所会要求先交购置税再检测等。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/c56167ce5f147e0a3f185a7fd01ec086?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/c56167ce5f147e0a3f185a7fd01ec086?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)拖挂也属于机动车</p>
<p>需要明确的是，根据《道路交通安全法》，拖挂房车是不需要投保交强险的，交强险和牵引的前车共享，如果交强险的额度不够赔偿，再由拖挂的商业险进行承担。所以我们只要购买拖挂房车的商业险就好了。不过由于拖挂还不流行，所以很多小城市的保险公司业务员根本不知道怎么给拖挂房车上保险，他们很可能会给你上特种车辆的保险，这种保险是很贵的，一定要沟通好。一辆十几万的拖挂房车，三者险加车损险一般
1500 元以内就可以搞定。​</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/7f3cf484904844e92eeb1de2cb824d4f?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/7f3cf484904844e92eeb1de2cb824d4f?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)拖挂无交强险</p>
<p>在给拖挂房车上牌时也不需要提供拖挂的交强险，但要提交前车的交强险，这里要注意的是，拖挂房车可以由任意车辆牵引，上牌时上交当时牵引车的交强险即可，不一定非得是你自己车辆的交强险。</p>
<h2 id="Q3：房车能代替租房吗？"><a class="header-anchor" href="#Q3：房车能代替租房吗？">¶</a>Q3：房车能代替租房吗？</h2>
<p>​​除了游玩以外，近年来开始有越来越多的人产生了用房车代替租房甚至买房的想法，因为在大城市租一个居住环境和地理位置比较好的房子房租不菲，而买一辆三十来万的房车，或者同级别二十来万的二手房车，不仅有了一个自己的居所，还有了自己的一辆车，可谓一举两得。</p>
<p>然而这个问题其实没有标准答案，因为房车生活的一些缺点对一部分人来说可以接受，一些优点对一部分人来说反而是缺点， <strong>这
是由不同的工作性质、生活品质要求等条件决定的</strong>。​</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/10fd9bfa65ed09a3ece3729a6ac38ab0?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/10fd9bfa65ed09a3ece3729a6ac38ab0?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)你能接受长期住房车吗？</p>
<p><strong>​ 先说房车的成本</strong>。</p>
<p>​想用房车代替租房，有这个想法的朋友，应该是想省钱同时又拥有一定现金的，可以认为平时生活条件过得去，薪资水平不错，对生活品质有一定要求。这样的话，廉价房车和豪华房车就不考虑了。因为廉价房车故障率、空间、使用便利性等方面不足，会影响居住体验；而豪华房车则脱离了省钱的初衷。</p>
<p>综合这两方面的考虑，一辆水电配置过关、动力不拖后腿的大品牌准新二手房车是一个很好的选择，目前在国内 20
万左右可以买到，使用年限在两年以内，但以手动挡居多。</p>
<p>这个价位的二手房车成色非常新，很多在 10000
公里以内，「房」的部分也基本没有使用痕迹，简单翻新消毒就可以使用，而且还在保质期内，到手可以去厂家检测一遍，有什么问题立马走保修解决。而且购置二手车可以挤掉房车售价中的水分，也没有购置税，以后想售出时，贬值幅度也大大小于购买新车。</p>
<p>这个价格已经预估了升级配置的预算，配置方面基本足够日常使用，包含了微波炉、冰箱等基本电器和七八度左右的电源，如果是配置很低的素车，入手成本还会更低。</p>
<p><strong>然 后是用车成本。</strong></p>
<p>房车的保险大约 5000 元一年，油费可以自己按需求计算，保养大概平均一年 1000
元。其它的使用成本，例如房车马桶要用降解剂这类，我认为租房也会有类似的固定成本，就不另外计算。</p>
<p>还有最关键的停车成本，这个可能是决定你能不能用房车代替租房的关键因素。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/c00e10aac4143feaaaa9abdb5165267c?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/c00e10aac4143feaaaa9abdb5165267c?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)你能在公司附近找到合适的停车位吗？</p>
<p>我有一位关注者就是实践用房车代替租房的车友。他在某一线城市的高新区上班，公司里车位充足，有免费 Wi-Fi
覆盖，离公厕很近，接水或排放废水也方便。他车上的电可以使用一个多星期，快没电了就开到旁边的充电桩充满电再开回自己车位。最关键的是他们公司的车位是免费的。其实以他公司停车位对房车的友好程度，即使车位要收取一定费用都是令人满意的。</p>
<p>对他来说这种生活方式唯一的缺点就是加班变多，并且变得理所当然。</p>
<p><strong>然 而这样的停车条件对于很多上班族们来说应该是不太现实的----
离公厕近、离充电桩近、车位不紧张、停车免费或费用低</strong>。对于在市中心上班的人来说，可能有个车位都太难，遑论上述这几个条件了。</p>
<p>还有一个很容易被忽视的成本是房车的贬值，虽然购买二手房车可以很大程度上减缓这方面的损失，但也并不是小数目。这个成本并不是很好估算，据我对二手房车市场的观察，一辆二十万左右的二手房车，购买后每年的贬值金额大约在
1 万左右。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/b035b4459274a58f017ced22dceab647?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/b035b4459274a58f017ced22dceab647?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)房车办公</p>
<p><strong>再 说长期居住在房车的舒适性。</strong></p>
<p>6 米长、2 米宽，这大约是 C1 驾照可驾驶房车的最大尺寸，如果是有额头床的 C 型房车，那么可使用面积就是 12 平米；如果是没有升降床设计的 B
型房车，扣掉车头部分之后，使用面积大概在 10 平米。</p>
<p>虽然面积小，但房车的好处是五脏俱全，有洗手间、床、厨房、办公区。</p>
<p>我曾在某一线城市市中心租过合租房的单间，800 元的月租只有一个8
平米左右的隔间，卫生间和厨房是公共区域。和这比起来，房车的居住舒适性是远远超过的，而且隐私和安全方面也更安心。</p>
<p><strong>当 然，从另一方面也可以说房车小小的空间里什么都有，什么都并不完整</strong>。</p>
<p>生活便利性是居住舒适性的另一决定性因素，这一方面，租房基本是可以打败房车的。房车的水、电、燃料全部都要自己补充，而且补起来并不方便。生活用水只能去公厕接来后输进房车水箱里；用电方面冬天还好，耗电不大，需要用空调的夏天，每天都需要充电，要么着几小时车把电充满，要么找充电桩；燃料方面也还好，对大多数喜欢叫外卖、偶尔做饭的上班族来说网购几箱丁烷气罐足够用很长时间，微波炉也能解决很多速冻食物，但如果你喜欢每顿都自己炒菜的话，房车就与你无缘了，因为目前国内这个价位还没有能解决车内炒菜的油烟问题；如果在车外炒菜，第二天应该就会被停车场赶走了。</p>
<p>在这些问题上，房车不仅要付出更多的精力去解决，耗费的成本也是要大于租房的。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/466433bf8d21dd045a3908446cd965cd?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/466433bf8d21dd045a3908446cd965cd?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)房车生活需要更强的动手能力</p>
<p>此外，如果长期住在房车里，必定会面临很多问题，可能某天冰箱突然不工作了，或者窗户漏水了等等。租房当然也会遇到这些问题，但房车上出现的概率会高很多，毕竟每天风吹日晒的。如果你没有一定的动手能力，那么这些小问题也会很影响心情。</p>
<p>长期居住在房车的另一大缺点，是天气对房车舒适性的影响要远大于房屋。因为房车无法提供和砖瓦混凝土相提并论的物理保护能力。当遇到强风、冰雹、大雨、冰雪和台风等恶劣天气时在房车里的体验会非常差，甚至危险。不说恶劣天气，仅仅下雨天时，雨滴落在车顶的噼啪声可能也会让部分人崩溃。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/aadb5244caa82fc66f8cf4404f39aac7?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/aadb5244caa82fc66f8cf4404f39aac7?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)恶劣天气对房车的影响更大</p>
<p>房车生活自由的理念吸引了不少年轻人：全部家当都在四个轮子上，这让他们可以不用忌惮跳槽搬家带来的繁琐和损失；他们可以省下大量的通勤时间，在周末时可以开着房车去郊区甚至周边城市度假。</p>
<p><strong>但
另一方面，长期居住在房车的生活方式并不适合所有人</strong>。咱们中国人注重安土重迁、落叶归根，有一个自己的房子是大多数人的愿望，房车这种像浮萍一样的生活会让这类人感到不舒服或者焦虑。</p>
<p>无论如何，房车代替房子并不是件可以轻易下决定的事情，务必要结合自己的实际情况再做定夺，最好先租一辆房车体验一段时间。</p>
<h2 id="Q4：电动房车是房车的未来吗"><a class="header-anchor" href="#Q4：电动房车是房车的未来吗">¶</a>Q4：电动房车是房车的未来吗</h2>
<p>国内房车起步较晚，正好也赶上了近几年新能源汽车爆发的时间。自然而然地，电动房车也进入了我们的视野。</p>
<p>那你应该考虑一辆电动房车吗？</p>
<p><strong>如 果让我来说房车最大的缺点是什么，那就是电太不够用了----
尤其是夏季</strong>。无论是房车市场成熟的欧美国家还是在国内，长期驻车的情况下水电难以自给自足都是个大问题，这其中又以夏季的用电最难解决。</p>
<p>因为在冬季取暖可以使用化石燃料，储存方便效率也高，而在夏季降温就只能用电了，而且由于房车的保温隔热性能远不如房屋，所以空调只能长时间在最大功率运行，耗电量奇高，主流价位房车携带的电池绝大部分都在
20 度以内，这点电最多只能坚持两天，而且大部分平价房车携带的电池只有 10 度左右。</p>
<p>国外的解决方式是遍布全国的营地，短期内我国不可能实现。目前我国房车充电的方式，正在从小功率行车充电配合太阳能及交流慢充向大功率行车充电配合充电桩快充的方向发展，但成本低且无需改装的前者依然占据主流，这意味着大部分房车的充电效率很低，无法在夏季支撑每天开着空调驻扎，即使有交流充电桩，长期占用既不现实也不道德，且充电桩所在的位置一般也不适合房车驻扎。</p>
<p>所以我国房车的玩法长期以来都是「候鸟式」的，即炎热的夏季就去往气候凉爽的地区。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/5e3aa0ff2cb73bdadbfe220b2de929a3?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/5e3aa0ff2cb73bdadbfe220b2de929a3?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)电车配拖挂可能是现阶段比较好的方案</p>
<p>那电动房车是房车的未来吗？</p>
<p>电动房车必定自带几十度甚至 100
度以上的电池（房车可利用空间大）和快充系统。这些电足够房车空调无忧使用一周以上，并能留下足够的电量从驻扎地去往充电站快速补满电。而且电车扭矩大的特点刚好可以弥补大自重的房车起步不灵活的缺点。</p>
<p>其实我认为在现阶段，增程式混合动力的车型最适合做成房车。房车自重很大，起步时油耗极高、灵活性极差，电机刚好可以弥补这两个缺点；增程系统相当于自带了小几十度电加一个发电机，随时可以补电，真正做到了电能上长期自给自足；房车以长途旅行为主，而且体型太大，与地下停车场充电桩和大部分小型充电站绝缘，没有充电焦虑的增程式就很完美了。</p>
<p>当然，由于房车重量大的关系，续航里程必然不佳，但现在电池封装技术也在飞速发展，而且房车的空间也能装下更多电池，所以我对这个问题的解决很有信心。</p>
<p>电动房车另一个好处是能节约可观的旅行成本，因为房车大多是长途行驶的，而且油耗基本是家用车的两倍，换成电动后能省不少油钱。</p>
<p>![Vision Vehicle Fuel-Cell Electric RV Is A 300-Mile Wheeled Smart
Home](<a href="https://cdn.sspai.com/2022/06/30/article/099b9fd7091cc3fd2d163af0c26639b4?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/30/article/099b9fd7091cc3fd2d163af0c26639b4?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)电动房车在市场成熟的欧美也处于起步阶段</p>
<p>不过在现阶段，无论是国内外都极少有电动房车，因为虽然现在纯电轿车、纯电 SUV 已经普及，纯电 MPV 也开始发力，但适合用作房车底盘的纯电车型还没上市。</p>
<p>有的朋友会说现在没有电动房车是因为房车销量太小，没有厂家会针对这个小市场做电动房车，但我不认同这个观点，因为房车并不是像传统车辆那样从底盘、车身开始，从零立项研发的，而是直接在现有车型的基础上通过改装的方式安上「上装」部分（即房车中房的部分）完成一辆房车开发的。</p>
<p>例如其实早在 2019 年就有房车厂以吉利增程式卡车底盘为基础改装房车了，但由于该底盘本身技术并不成熟因此反响不大。</p>
<p>国内房车底盘以皮卡、小型货车、厢式货车、轻型卡车等车型为主，而这些车辆类型成熟的纯电版本目前市面上很少（直接安个电池就叫电动货车的那种不算），适合改装成房车的就更少了，所以现在电动房车极其稀有，消费者基本没有选择，等到各大厂商的电动皮卡（对应
C 型房车）、厢货（对应 B 型房车）开发成熟，房车厂家自然会采购电动车型作为房车底盘进行改装，到时市面上就会有很多电动房车开始涌现了。</p>
<h2 id="附：主流价位房车推荐"><a class="header-anchor" href="#附：主流价位房车推荐">¶</a>附：主流价位房车推荐</h2>
<h3 id="德发圆梦-365L（4-98万）"><a class="header-anchor" href="#德发圆梦-365L（4-98万）">¶</a>德发圆梦 365L（4.98万）</h3>
<blockquote>
<p>仅 5 万的入门拖挂房车。</p>
</blockquote>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/9e6f0acae915b40e7cbe0e5c229e8a68?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/9e6f0acae915b40e7cbe0e5c229e8a68?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)德发365</p>
<p>这款拖挂式房车采用中置单轴设计，牵引车动力排量 1.8 升以上的车辆均可进行牵引，车内空间最多能够满足 3 人居住需求，不过推荐一到二人使用。厢体尺寸为
3650<em>2100</em>1800(mm)，轮胎参数为 185/R14。</p>
<p>这辆车特点是采用德发自主研发生产的房车专用底盘，没用进口底盘，所以成本控制比较好。底盘进行了喷塑处理，防锈性能比较好。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/1fbfa7dbe9d5c24ea23248d2f615b8a6?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/1fbfa7dbe9d5c24ea23248d2f615b8a6?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)户型图![](<a href="https://cdn.sspai.com/2022/06/29/article/7b611debb4b3ee83d051b45686bb588c?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/7b611debb4b3ee83d051b45686bb588c?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)布局</p>
<p>车内布局是比较经典的车尾部双人铺+卫生间+车前部环形卡座沙发（卡座放平后是单人铺）+开放式厨房，床铺配有阅读照明灯，USB
充电口、床下及顶部均带有储物柜，衣物和床上用品等可以放置其中。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/4261327f4c91f80ae179763949d9d8e7?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/4261327f4c91f80ae179763949d9d8e7?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)卫生间</p>
<p>遗憾的是卫生间空间比较局促，不过配置还算齐全，有洗手池、淋浴花洒、梳妆镜、便携马桶、储物柜、储物架等，简单洗漱冲澡没问题。​</p>
<p>配置方面标配的是 80L 清水箱、80L 灰水箱、100W 太阳能、双向换气扇、1000W 充逆变一体机、100AH 胶体电池（标配无备胎）。</p>
<p>电力方面配置很弱，如果用新能源车拖的话无所谓，花 1 万购置空调和厨房相关电器即可，用油车拖的话还要再花 1 万左右升级电池和逆变器。</p>
<h3 id="新飞祥菱房车（10-54-万）"><a class="header-anchor" href="#新飞祥菱房车（10-54-万）">¶</a>新飞祥菱房车（10.54 万）</h3>
<blockquote>
<p>仅十万的入门自行式房车。</p>
</blockquote>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/120fdd517ddee93240b8559a52f827f8?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/120fdd517ddee93240b8559a52f827f8?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)车友实测开到西藏没问题</p>
<p>​本车基于福田祥菱微卡底盘打造，总质量 2.9 吨，采用 1.5 升汽油发动机、后驱、手动变速箱，核载 6 人，动力孱弱，因此车身长度较小，整车尺寸为
5260<em>1835</em>2650mm，但五脏俱全，卫生间、厨房、会客区、床铺等关键设施齐全，且空间并不小。当然储物空间相应的会比较少。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/edac48cdfd1a0e07346015d84e4bd341?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/edac48cdfd1a0e07346015d84e4bd341?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)厨卫区![](<a href="https://cdn.sspai.com/2022/06/29/article/c79fa395a21831d4d72eb870cb9c261b?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/c79fa395a21831d4d72eb870cb9c261b?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)客厅![](<a href="https://cdn.sspai.com/2022/06/29/article/741130d244bb2a8d62f32806af2c2088?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/741130d244bb2a8d62f32806af2c2088?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)会客区可以拼床</p>
<p>配置上，这个价格不用想太多，标配 150AH 铅酸电池、1000W 逆变、清水箱 110L、灰水箱
67L、电磁炉、洗手池、星光顶灯。这个配置无法到手就玩，自行加装到可使用的成本需3.5 万左右。</p>
<h3 id="新飞全顺-B-型房车（19-98-万）"><a class="header-anchor" href="#新飞全顺-B-型房车（19-98-万）">¶</a>新飞全顺 B 型房车（19.98 万）</h3>
<blockquote>
<p>二十万级别自行式房车。</p>
</blockquote>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/e1c66f421f64804cb8e75068da09c993?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/e1c66f421f64804cb8e75068da09c993?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)​B型车外观低调</p>
<p>依然是来自新飞集团的一款房车，这应该是目前市面上最便宜的全顺底盘房车了，起售价 19.98 万。整车尺寸 5341<em>2032</em>2407mm，内高约
1700mm，C1 驾照可以驾驶。为了压缩成本，整车采用原厂色调，没有任何拉花等修饰。​</p>
<p>动力方面采用的是 2.0T柴油发动机，5 速手动变速箱，额定功率 90KW，油箱大小
70L。车身外部配有遮阳棚、户外照明、电动踏步、房车专用加水口、充电口等。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/96d0b9980e2bcc63f4f977be9a6edaf6?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/96d0b9980e2bcc63f4f977be9a6edaf6?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)驾驶室![](<a href="https://cdn.sspai.com/2022/06/29/article/b4611d54fdf4c8bb0766fb99ddab6069?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/b4611d54fdf4c8bb0766fb99ddab6069?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)会客区​![](<a href="https://cdn.sspai.com/2022/06/29/article/5b94279e75da5a6706e22c957950b09a?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/5b94279e75da5a6706e22c957950b09a?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)纵床布局![](<a href="https://cdn.sspai.com/2022/06/29/article/e9be9a9a3241806ae16f6195c24848d6?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/e9be9a9a3241806ae16f6195c24848d6?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)横床布局![](<a href="https://cdn.sspai.com/2022/06/29/article/e7c3566ef4f6e86bf10ca2851f5e26b7?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/e7c3566ef4f6e86bf10ca2851f5e26b7?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)卫生间</p>
<p>上装部分有后横床和纵床布局，可以根据需求灵活选择，个人比较推崇横床布局。会客区配有电视、换气扇、商务座椅及 12V
制冷空调。厨房区配备冰箱、电磁炉、洗菜池等设备，安装有 220V 插座和射灯。纵床布局的床铺尺寸为 1650<em>800mm，可以拓展为
2200</em>1100mm，勉强可以睡两个成年人。受限于空间，卫生间采用推拉式卷帘门设计。​​</p>
<p>配置方面，标配 105L 清水箱和 40L 灰水箱、105AH 铅酸电池、1000W
逆变器、电热水器、电磁炉、便携式马桶、车载冰箱、倒车影像等。配置很低，提车后加装到使用配置大概还要花 2-3 万元。</p>
<h3 id="览众长城炮（汽油四驱、自动挡、31-88-万、柴油加-1-万）"><a class="header-anchor" href="#览众长城炮（汽油四驱、自动挡、31-88-万、柴油加-1-万）">¶</a>览众长城炮（汽油四驱、自动挡、31.88 万、柴油加 1 万）</h3>
<blockquote>
<p>三十万级别自行式房车。</p>
</blockquote>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/21acab964d02917226c5da61d1740da7?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/21acab964d02917226c5da61d1740da7?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)外观</p>
<p>整车尺寸 5990<em>2190</em>3030mm，蓝牌 C 本可以驾驶。底盘配置上颇有亮点，柴油版搭载 2.0T 柴油涡轮增压发动机，最大功率
120kw，峰值扭矩 400nm；汽油版搭载 2.0T 的汽油涡轮增压发动机，最大功率 140kw，峰值扭矩 360nm；两者都采用采埃孚 8AT
自动挡变速箱。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/a26b0e2ad5e008394924c2ac9502a4a1?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/a26b0e2ad5e008394924c2ac9502a4a1?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)驾驶室</p>
<p>本车还采用了 TOD 电控四驱系统，带有中央差速锁以及后桥电控式差速锁，接近角 29 度、离去角 21 度。最小离地间隙
227mm，脱困性和通过性比较好。主驾支持六向电动调节，副驾支持四向电动调节，配备安全气囊和侧气囊、无钥匙进入、９
寸的中控大屏、多功能方向盘、定速巡航、胎压监测、ABS+EBD+TCS+RMI+ESC。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/ff3ce12028407f7c0bfc4d2acf3d6fea?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/ff3ce12028407f7c0bfc4d2acf3d6fea?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)A布局![](<a href="https://cdn.sspai.com/2022/06/29/article/df2bc1c978a9cf6b04db3e2e14b750d8?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/df2bc1c978a9cf6b04db3e2e14b750d8?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)​B布局</p>
<p>这款车有 A、B 两种布局，A布局会客区位于车厢中部，采用常规的四人对向卡座搭配升降餐桌，会客桌可扩展和收纳，可以拼成一张尺寸为 1700*900mm
床铺；B 布局的会客区则移动到了尾部区域，采用对坐式沙发设计，中间配有会客桌，在沙发垫的后方是隐藏式可翻转床板，可变成上下铺单人床，下铺也可以对坐沙发拼床。</p>
<p>![](<a href="https://cdn.sspai.com/2022/06/29/article/593f3c04b53022bded35b7c0bf433171?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/593f3c04b53022bded35b7c0bf433171?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)额头床![](<a href="https://cdn.sspai.com/2022/06/29/article/af39ea5a1319e265dacf7eaf1cba37a1?imageView2/2/w/1120/q/40/interlace/1/ignore-" target="_blank" rel="noopener">https://cdn.sspai.com/2022/06/29/article/af39ea5a1319e265dacf7eaf1cba37a1?imageView2/2/w/1120/q/40/interlace/1/ignore-</a>
error/1)卫生间</p>
<p>配置方面，标配 150L 净水箱，50L 灰水箱、240AH 锂电、3000W 充电逆变一体机、24
英寸液晶电视、回音壁、电磁炉、洗菜池、抽油烟机、微波炉、85L 冰箱、顶置空调、遮阳篷、房车专用马桶、洗衣机等。除了电池比较小以外，其他配置都比较齐全。</p>
<p>以上便是本文的全部内容，如果你有任何相关的问题或疑问，欢迎在评论区留言交流。</p>
<blockquote>
<p>下载 <a href="https://sspai.com/page/client" target="_blank" rel="noopener">少数派 2.0 客户端</a>、关注
<a href="https://sspai.com/s/J71e" target="_blank" rel="noopener">少数派公众号</a>，解锁全新阅读体验 📰</p>
</blockquote>
<blockquote>
<p>实用、好用的 <a href="https://sspai.com/mall" target="_blank" rel="noopener">正版软件</a>，少数派为你呈现 🚀</p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」从盲目崇拜到理性使用，谈谈我眼中的「双向链接」</title>
    <url>/public/2022/07/15/test/202207/2022-07-11-143137724795/</url>
    <content><![CDATA[<p>「转」<a href="https://sspai.com/post/73407" target="_blank" rel="noopener">从盲目崇拜到理性使用，谈谈我眼中的「双向链接」</a></p>
<a id="more"></a>
<p><strong>Matrix 首页推荐</strong></p>
<p><a href="https://sspai.com/matrix" target="_blank" rel="noopener">Matrix</a>
是少数派的写作社区，我们主张分享真实的产品体验，有实用价值的经验与思考。我们会不定期挑选 Matrix 最优质的文章，展示来自用户的最真实的体验和观点。<br>
文章代表作者个人观点，少数派仅对标题和排版略作修改。</p>
<h2 id="写在前面"><a class="header-anchor" href="#写在前面">¶</a>写在前面</h2>
<p>这两年，「双向链接」简直就是知识管理领域的流量明星。</p>
<p>资本追捧它，认为它具有巨大的商业潜力。2020 年，<a href="https://sspai.com/post/72995" target="_blank" rel="noopener">Roam Research 收获 A 轮融资 900
万美元，估值超两亿美元</a>，投资者中不乏资本圈的知名人士。几款亲民的平替软件，如
RoamEdit、Logseq 也在 Roam Research 耀眼的光辉下，承其精华顺势而生。一些具备强大的链接功能，又做出自身特色的知识管理软件，如
Obsidian、Remnote 一跃而起，在各自领域收获了一批忠实粉丝。传统的行业头部软件也不甘示弱，优雅简约的老牌大纲软件 Workflowy
已将反向链接和镜像复制功能完美嵌入，小而美的日程管理软件 <a href="https://sspai.com/post/72479" target="_blank" rel="noopener">Agenda 在 v14
更新里也把双向链接功能加进新版本</a>。此外，我们非常熟悉的、主打 Database 功能的
Notion，和主打颜值的块编辑器软件 Craft
也毫无悬念地都支持双向链接，加上一些我们熟知的国产软件，双链笔记家族的规模可谓前所未有地壮大。时至今日，一款立足文档编辑或知识管理的软件绝不能对双链功能视而不见，毕竟后者的地位早已从一个有附加值的亮点功能，变成了许多用户的「一票取舍」。</p>
<p>如果我们再往下思考一步，就会发现无论是概念层面，还是实践层面，「双向链接」都是早已有之的东西；功能上，很多双链能够做到的，其他方式也能轻松替代。但不得不承认的是，键入双括号构建双链的丝滑便捷又是真切可感的，「双向链接」这个功能的确给笔记软件增添了前所未有的使用体验，许多深度体验过的用户不是无脑尬吹，而是发自内心地喜爱和推荐这类产品。</p>
<p>有关双向链接的话题，不少朋友都已经深入讨论辨析过，尤其是王树义老师、和燕燕、吕立青、空谷、yuchen_lea
等朋友的相关文章给了我许多启发。即便如此，我还是想用自己的思维框架再聊聊「双向链接」：</p>
<ul>
<li>「双向链接」到底是个什么东西？</li>
<li>它在软件层面是如何实现的？</li>
<li>它给我们带来的神奇体验是实打实的，还只是我们作为知识管理者的虚妄想象？</li>
<li>具体使用过程中，我们究竟是应该用双向链接，还是应该打标签？……</li>
<li>哪些软件更适合进行知识间的互通互联？</li>
</ul>
<p>以下就是我对这些问题的感悟和反思，错漏之处还请指正。</p>
<h2 id="一、「双向链接」到底是个什么东西？"><a class="header-anchor" href="#一、「双向链接」到底是个什么东西？">¶</a>一、「双向链接」到底是个什么东西？</h2>
<p>双向链接到底是什么？请用一句话解释。</p>
<ul>
<li>如果在物理课上回答，就是：从家能走到学校（从 A 到 B），从学校也能走回家（从 B 到 A）。</li>
<li>语文课上，就是：我中有你，你中有我。</li>
<li>美术课上，就是米开朗基罗的《创世记》：亚当将手伸向上帝的同时，上帝也在将手伸向亚当。（逐渐离谱……）</li>
</ul>
<p><img src="https://cdn.sspai.com/2022/05/23/e17cb3105070e4d598c203df3bf13616.jpeg" alt>米开朗基罗
西斯廷教堂天顶壁画局部《创世记》</p>
<p>那么，回到知识管理领域，我们通常所说的知识的「双向链接」究竟是什么呢？</p>
<p>先不着急回答。我们以一个写日记的场景为例，从简化的模型开启双链的思考。</p>
<h3 id="原型：日记本里的「mini-双链」"><a class="header-anchor" href="#原型：日记本里的「mini-双链」">¶</a>原型：日记本里的「mini 双链」</h3>
<p>新年当天，你拿出了一个新笔记本，打算每天都记录一页日记。8 号那天，你一整天什么事也没做，于是就在第 8 页上写下了大大的几个字： <strong>1 月 8 日
今日无事</strong>。</p>
<p>怅惘之余，你忽然想起来 3 号那天也什么都没干，写的是同样的日记内容，你想在同样的心情页面下方建立起关联，于是就在第 8 日的页面下方备注了一行小字： **
见 1 月 3 日**。这样，你就在 A 点建立了一个跳转到 B 点的索引，建立了一个单向（从 A 到 B）的关联。</p>
<p>接下来，你翻回第 3 页，觉得应该在 3 号那天日记下方也补上一句： ** 见 1 月 8 日**。这个简单又贴心的索引，就是一个反向链接（从 B 到
A）。两步做完，你就在自己的日记本里建立了一个双向索引，其内核就是「双向链接」。Bingo！轻轻松松，一个神奇的双链就这么创造出来了。</p>
<p>以上例子是一个最基本的思维模型，也是许多双链笔记软件主打的一系列炫酷外壳的核心。从 A 到 B，和从 B 到 A 的路径都打通了。如果一个人 <s>偷
看你的日记本（大误</s>，他无论是翻到第 3 页，也是第 8 页，都会找到另一页，这就是双链。</p>
<p>（更多传统笔记的双向链接的思考，请参考 @和燕燕
<a href="https://sspai.com/post/69671" target="_blank" rel="noopener">翻阅外公的活页笔记本，我对双向链接与卢曼笔记法感触更深了</a>）</p>
<p><img src="https://cdn.sspai.com/2022/05/23/908d108b867f02b102ee4f49e4c5b42c.png" alt>Roam
Research 主页上的经典示意图，蓝色连接线处等同于上文所说的双向索引（双向链接）</p>
<h3 id="去魅：双向链接无处不在"><a class="header-anchor" href="#去魅：双向链接无处不在">¶</a>去魅：双向链接无处不在</h3>
<p>既然我们把双链的基本模型搭建起来了，那么当下流行的双链笔记软件和它又是怎样的关系呢？是不是说，只有支持双链的笔记软件，才能提供笔记之间的相互连接？</p>
<p>答案是：no，no，no，前面讲了那么多，就是想用日记本的例子来说明，知识间的相互连接其实很普遍，也很简单！</p>
<p>不但传统纸质的笔记本可以通过两个「索引指示词」轻松链接两个知识条目。传统的 Word
文档一样能做到：只要在一个文档里备注另一个文档的「存储路径」，另一个同样这么操作，那么我们完全可以自信地声称：这两个 Word 文档实现了神奇的双向链接。</p>
<p>此外，目前绝大多数笔记软件都可以为库里的每个文档，甚至是每个文本块、每条大纲节点生成一个专属的内部链接，通过在文本之间链接，同样可以实现轻松互联。</p>
<p>所以，我们对于「双向链接」的迷思随即消散 <strong>：
不是只有打着「双向链接」旗号的笔记软件才可以进行知识之间的双向互联。毋宁说，几乎所有的笔记形态都可以实现这一点</strong>。双向链接这个概念在知识领域一点都不稀奇，就连缺乏技术工具的古代人，也可以轻松靠笔墨实现知识互联。</p>
<h3 id="辨析：什么是双链，什么又不是双链"><a class="header-anchor" href="#辨析：什么是双链，什么又不是双链">¶</a>辨析：什么是双链，什么又不是双链</h3>
<p>双向链接这个概念火了之后，在舆论的喧嚣中，还与其他不少其他时髦概念混淆起来。</p>
<p>比如，不少人在谈到「双向链接」到底有多牛时，势必就要以卢曼教授传奇的学术人生作为例证。但是，如果细加辨析，二者之间的关联其实是非常有限的。坦率说，我也直到读到
@yuchen_lea 的这篇文章
<a href="https://sspai.com/post/65273" target="_blank" rel="noopener">《请不要神化双链笔记》</a>，才意识到自己从来没有认真思考过卡片笔记法里，双向链接到底占有怎样的位置，之前只是简单地把两者混作一谈，当作定论囫囵吞下了。</p>
<p>再比如，具有酷炫视觉效果的「知识图谱」，似乎也是随着双链笔记一起流行起来的。不过二者归根结底仍是两种东西：没有双向链接也可以打造知识图谱，好的双链软件也可以不提供知识图谱功能；更不论知识图谱在这类笔记软件里是否具有实用性，在信息呈现上有哪些问题了。参见
@和燕燕 <a href="https://sspai.com/post/67996" target="_blank" rel="noopener">《我们需要什么样的双向链接，它适合你吗》</a>？</p>
<p>关于双向链接不是什么，上面两篇文章里面已经有很详细的说明，在此不再赘述，欢迎自行翻阅。</p>
<h2 id="二、双链笔记软件：哪里不一样？"><a class="header-anchor" href="#二、双链笔记软件：哪里不一样？">¶</a>二、双链笔记软件：哪里不一样？</h2>
<p>既然从概念层面，双向链接不是个石破天惊的东西，那么在实践层面，双链笔记软件为什么又能够给我们带来如此丝滑的体验呢？</p>
<h3 id="正方观点-1：自动生成的「反向链接」"><a class="header-anchor" href="#正方观点-1：自动生成的「反向链接」">¶</a>正方观点 1：自动生成的「反向链接」</h3>
<p>首先我们来看，支持双向链接的软件，比起日记本、Word 文档还有不支持双向链接的笔记软件，多出来的核心功能究竟有哪些。</p>
<p>抛开那些花里胡哨的小功能，如果说真有什么是「双链笔记」这个名称下所独有的、核心的功能，那就是每当你在创建一个从 A 到 B 的链接时，它会自动帮你生成一个从
B 到 A 的反向链接。虽然你还停留在 A 的页面上，但 A 和 B 之间的双向索引已经完成。</p>
<p>除了生成反向链接之外，此类软件通常还会在 B 的页面上，自动汇总链接到它的所有反链的信息，查看起来非常方便。</p>
<p>我们通常理解的「双向链接」主要就是通过 <strong>用 户主动加入一个链接，软件自动生成与之对应的反向链接</strong>
来实现的。这里我简单地梳理了一下，看看双链软件究竟帮我们干了哪些事情：</p>
<ul>
<li>【第一步：连上】当我们建立了 A 到 B 的连接时，系统也帮助我们完成了 B 到 A 的连接。</li>
<li>【第二种：可见】我们在 A 页面可以看到 B，B 页面上也能看到 A。不用你再手动操作，效率更高。</li>
<li>【第三种：汇总】所有曾经链接到 B 的页面，都会在 B 页面上展现，因此起到了一个信息汇总、整合的作用。</li>
</ul>
<p>这个功能对于注重知识之间相互关联的用户来说，确实非常实用。等到你后续使用和查看的时候，双链笔记软件默默在后台做的一切，便会为你的思考赋予价值。尤其在大量收集、整理资料的时候，哪怕能省略一个简单的操作，也能极大地提升效率。否则，如果每一条都需要人工标注，哪怕你再重视这个效果，可能到头来也会因为繁琐而放弃。</p>
<h2 id="我想用一个比方来表达初遇双链时那种真切的心情。如果在日记本里，你在第-8-页写下「-见-1-月-3-日」的一刹那，第-3页的页面底部瞬间出现一行小字：-1-月-8-日今日无事，仿佛霍格沃兹的咒语一样，闪着微微的荧光。无论你有没有注意到它，点不点进去检查，它都一定会出现，从不缺席。见至此景，想必很多人也会为此感到欣喜"><a class="header-anchor" href="#我想用一个比方来表达初遇双链时那种真切的心情。如果在日记本里，你在第-8-页写下「-见-1-月-3-日」的一刹那，第-3页的页面底部瞬间出现一行小字：-1-月-8-日今日无事，仿佛霍格沃兹的咒语一样，闪着微微的荧光。无论你有没有注意到它，点不点进去检查，它都一定会出现，从不缺席。见至此景，想必很多人也会为此感到欣喜">¶</a>我想用一个比方来表达初遇双链时那种真切的心情。如果在日记本里，你在第 8 页写下「 <strong>见 1 月 3 日</strong>」的一刹那，第 3
页的页面底部瞬间出现一行小字： <strong>1 月 8 日
今日无事</strong>，仿佛霍格沃兹的咒语一样，闪着微微的荧光。无论你有没有注意到它，点不点进去检查，它都一定会出现，从不缺席。见至此景，想必很多人也会为此感到欣喜</h2>
<p>这确实是一个简单的操作，或许几行代码就能搞定，甚至连手动操作也可以完成。但正是因为我们之前没有留意过它，所以当它问世时，才会因为简洁和直观而如此具有吸引力。</p>
<p><img src="https://cdn.sspai.com/2022/05/24/0e73a352881c06189398680351251c0e.png" alt><img src="https://cdn.sspai.com/2022/05/24/bca2024839a9b14665137570c90b8dc4.png" alt></p>
<h3 id="反方观点-1：可被替代的双链功能？"><a class="header-anchor" href="#反方观点-1：可被替代的双链功能？">¶</a>反方观点 1：可被替代的双链功能？</h3>
<p>双链笔记确实提供了一种快速链接的思路，可我们只能通过双链符号，才能在不同的页面之间建立关联吗？我们难道不可以加标签吗？不可以直接搜索关键词吗？效果难道不是一样的吗？</p>
<p>我们还从记日记这个场景入手，再来想一种常见的情景。</p>
<p>整个 1
月份你都很颓废，好些天都无所事事。你想了想，干脆把所有类似心情的日子都关联起来吧！这样，不用逐页翻查笔记本，也能找齐这些日子。想做到这一点，方法很多。</p>
<p>我们最常做的方法，就是把日记本上的某一页当成索引页，标题就叫：「 <strong>今 日无事</strong>」。如果哪天你什么都没做，就会在当日页面上记下「 <strong>今
日无事</strong>」，标注 <strong>索 引符号</strong>，然后再去索引页记下当天的日期。</p>
<p>这样一来，相当于「 <strong>今 日无事</strong>」被你设置成了关键词，而在它和所有相关日期之间都建立了联系。只要你查找名叫「 <strong>今
日无事</strong>」的索引页，就会看到汇总在这个关键词下面的全部信息。</p>
<p>请注意，上面说的索引符号，如果使用双链功能，那就是我们非常熟悉的双方括号（ [[]] ）；如果使用其他软件，或是在双链笔记软件里，同样可以换成
tag（#）符号，换言之，打标签的方式一样可以在上述过程中双向互联啊！那为什么还要双链呢？</p>
<p>这个问题涉及不同的软件设计，解释起来略有些复杂，我试着说一下我现阶段的理解：</p>
<ul>
<li>加双链和打标签在某种程度上是等价的。在许多双链笔记软件自己的理解中（感受最明显的是 Logseq），关键词前面用 # 符号和用 [[]] 都可以。换句话说，你想打标签就打标签，想加双链就加双链。</li>
<li>实际操作上二者还是有区别的。比如，对于主题词，如果你都是靠打标签的方式，那么软件里最好有个汇总标签的页面，比如 Obsidian 里的 tag 汇总插件，或是 Dynalist 里的 tag pane。这样，你才可以在某个地方直接找到全部标签。而双向链接不存在这个问题，你只要设置了主题词，那么这个词就变成了词条，你在词条页面下方随时随地都可以把关联到它的条目一次看全，还可以在里面随时增补信息，后一点是标签管理做不到的。</li>
</ul>
<p><img src="https://cdn.sspai.com/2022/05/24/5ac213cd19ea81cb9b15cf1466f44c95.png" alt><img src="https://cdn.sspai.com/2022/05/24/942159676769eca547181e10888e4a0a.png" alt></p>
<ul>
<li>
<p>适用范围也不太一样。有些场景是双向链接能做的，而标签做不到的。<br>
再拿刚才的日记本举例。你并不想设置索引页，而是别出心裁，每次都回到第一次记录「今日无事」的页面（3 号那天），在那天的页面上标注新的日期。比如你翻开日记，第
8 日、第 12 日、第 13 日都记着： ** 见 1 月 3 日**，而第 3 页下面则写着三行字： ** 见 1 月 8 日**、 ** 见 1 月
12 日、见 1 月 13
日**。这样，你就通过之前说的双向链接的方式，在这些页面之间建立了连接。这种方式虽然有点骚操作，但是确实是只有双向链接能实现的，因为你总不能把 1 月 3
日设成标签： <strong>#1 月 3 日</strong>，那样的话你当天页面信息就损失了。<br>
另外，实践中还有一个更常见的操作。如果你平时写过很多文章，想在某几篇文章里面提到彼此，那么在现有的条件下，在文章里加个双链就可以，再为此设计一个标签，未免太费事了。</p>
</li>
<li>
<p>哲学层面也有差异。双链功能构建的内容，是有主次地位的。在关键词条目和引用它的其他条目之间，就着原本与副本的差异。而标签则是一个没有原本的东西（以 tag 为主题词的搜索页面或可以看成原本），而在每个加 tag 的内容都是等价的。这两者的本体论差异，造就了其使用上的各种差别。（逐渐离谱……）</p>
</li>
<li>
<p>具体使用上，我们每个人对如何使用双链、如何使用标签、如何使用搜索是有独特喜好的，而且在不同的软件环境里，使用方式确实会有差异。这篇文章里就不再细说了。</p>
</li>
</ul>
<p>据此，在双向链接是否可以被替代这个问题上，我的观点是这样的：没错，虽然双链功能确实可以被替代（甚至连标签也可以不用，如果有一个强大的搜索功能，上述所有问题都可以在搜索页面完成），但任何工具并不一定具备有完全独创排他的功能、全新的适用范围和使用方式，才可以被称为好工具。
<strong>双 链功能上虽然和先前的工具有所重合，可以被替代，但依旧不影响它在自己独特使用场合下丝滑柔顺、无可置疑的体验。</strong></p>
<h3 id="综合评价：双链笔记，用着是香"><a class="header-anchor" href="#综合评价：双链笔记，用着是香">¶</a>综合评价：双链笔记，用着是香</h3>
<p>结合上面的正反两点，我们会发现，我们没必要振臂高歌，赞誉软件里的「双链功能」是跨时代的伟大创举。但公允地评价，双链笔记在操作层面引入的便捷性也是真实存在的。</p>
<p>以我个人的体会，大多数人在描述双向链接的神奇之处时，他们表达的其实是一整套丝滑的流程：</p>
<ul>
<li>**便 捷的快捷键 **：轻松键入双方括号（ [[]] ) 添加主题词，这已经成为同类产品的标配；</li>
<li><strong>自 动化检索 + 搜索建议</strong>：软件会根据你的输入信息，进行全文档检索，为你提供可链接的主题词参考，确保你能够迅速锁定之前记录的信息；</li>
<li><strong>主 题词界面自动生成</strong>：哪怕之前你没有创建过该关键词，系统也能通过上述步骤直接为它生成一个页面，不用担心系统报错；</li>
<li><strong>支 持词条自动改名</strong>：如果你修改了主题词名称，所有链接里显示的名称也会同时自动修改；</li>
<li><strong>镜 像功能</strong>（这是 Workflowy 里的命名，即键入双圆括号 (()) 呼出的操作）：将之前的内容正文直接复制到新的页面下，彼此之间构成镜像，无论更改或删除哪一个，其他所有镜像内容均会实时改变。</li>
<li>……</li>
</ul>
<p>这一整套组合拳或许才是双链软件最让人感到惊艳、最离不开的地方。而且正是这些具体的功能使用起来是否方便、操作上是否顺滑，决定了某一款特定的双链笔记软件是否好用、是否强大，毕竟有些功能是一些软件拥有，而另一些目前没有，将来很可能也没有的。</p>
<p>在 Roam Research
和其他众位双链笔记软件问世之前，我们不是不可以建立双向链接，而是操作的繁琐限制了我们的手脚，绝大多数人都不会手动给每个链接再匹配上它的反链，查询和修改也都有一定的时间成本（想一想翻日记本、找
Word 文档的例子）。而在双链笔记一炮打响之后，我们开始使用这个功能，从而培养起知识互联的认知和使用习惯。</p>
<p>随着时间的推移，「双向链接」深入人心，变得不再神秘，甚至成为人人都了解、人人都会用的日常功能，但别忘记，它也在去魅的过程中潜移默化地影响了我们在知识积累、整理、记忆、输出时的方方面面，进而让我们对知识管理获得了更加深入的思考。</p>
<p>这就是麦克卢汉那句 <strong>「 媒介即信息」</strong>
背后的涵义：工具的变革其实会潜移默化改变我们的思维。给文本之间建立起便捷易操作的双向链接，哪怕仅作为一个微不足道的设计上的进步，它的意义也是不可忽视的。</p>
<h2 id="三、双链笔记，我最爱用哪一款"><a class="header-anchor" href="#三、双链笔记，我最爱用哪一款">¶</a>三、双链笔记，我最爱用哪一款</h2>
<p>一本正经说了半天，最后加点私货，谈谈我在使用过程中总结的一点心得，以及我自己青睐的几款双链笔记软件。</p>
<h3 id="一点点使用心得"><a class="header-anchor" href="#一点点使用心得">¶</a>一点点使用心得</h3>
<p>我是从 21 年初入坑双链笔记软件的，初次邂逅的就是
Obsidian，初遇的体验如同电光火石。我足足花了有一个月的时间，每天就像打了鸡血一样，摸鱼熬夜，把之前所有存在各个网络文档里的笔记、文章分门别类地制作成上千张概念卡，塞进了庞大的软件库里。每每想到无数张闪耀着智慧的卡片即将通过「双向链接」连成一片，发出夺目的光彩时，我就心神迷醉。</p>
<p>在此之后我像粉丝追星一样，按图索骥把一众支持双链的软件尝试了个遍，从 Craft、Notion，再到 Logseq、Remnote，再到
Workflowy、Dynalist 等等。目前唯一的遗憾是迄今没有使用过业界王者 Roam
Research，心水了很久，但因为高耸入云的价格一直没有下定决心去买。</p>
<p>最开始使用双链笔记软件的阶段，我其实整个人是蒙的。有人推荐哪个软件好，我就屁颠屁颠去试用了，对自己的需求也不太了解，对软件的定位更无从把握。后来用得多了，可选的软件也多了，我开始从对特定功能的追逐，慢慢地去思考不同软件到底区别在哪里。以下是一点浅见，还不成熟，欢迎大家拍砖指正。</p>
<h4 id="双链软件的大体分类"><a class="header-anchor" href="#双链软件的大体分类">¶</a>双链软件的大体分类</h4>
<p>笔记类软件或知识管理类软件，在产品的基本结构上是有所区别的。</p>
<ul>
<li><strong>线 性 / 文本软件</strong>，如 Obsidian、思源笔记等。这一类在我理解，基本结构就是我们通常说的文档，类似于 Word。每个文档里面的内容是相对松散的，没有严格的层次关系或分区，所以通常情况下我们是把一整个文档视为基本单元的。</li>
<li><strong>大 纲型软件</strong>，比较直观的像 Workflowy、Dynalist 等，基本单元是一个个的大纲节点，呈现高度的结构化特征，彼此是有清晰的逻辑层级的。Roam Research 更是其中最知名的一个，Logseq、Remnote 也是。</li>
<li><strong>块 编辑器软件</strong>，如 Notion、Craft 等。基础结构是一个个的块（Block），每个块里都可以插入文本、图片、视频乃至表格等富文本信息。块的结构比文档的结构更小一些，但在块与块之间，通常不像大纲软件那样强调逻辑层级的。我个人感觉在知识链接上，类似软件体验一般，以下不多做讨论。</li>
</ul>
<p><img src="https://cdn.sspai.com/2022/05/24/8a1703d810b0afe9b66ad61344c426d8.png" alt><img src="https://cdn.sspai.com/2022/05/24/bffbefadfa93e4d3fc1ab55073e6bbcf.png" alt></p>
<h4 id="大纲软件的优势"><a class="header-anchor" href="#大纲软件的优势">¶</a>大纲软件的优势</h4>
<p>一旦划分好类别，我们就会直观地发现：大纲型软件相比于文本软件，天然就是最适合做双向链接的笔记软件，因为它的基本结构更细，所以可以用于链接的内容也更丰富了。这意味着，无论你的文档有多大，内容有多少，你都可以深入到它们内部，和里面的每一条大纲进行互联互动。而且，由于一般人很少会把大量的文本写进同一条大纲节点里（许多大纲软件的排版体验会让用户克制这种操作，换言之，频繁有这类操作需求的用户是不匹配大纲软件工具的），所以一条大纲的容量天然就是有限的，粒度
----可以建立链接的基本结构----自然就是精细的。</p>
<p>与此相比，根据我们再熟悉不过的 Word
使用体验，一个文本型软件的容量就要大得多了。你可以在里面放上一篇日记，也可以放进去一篇长篇小说。如果是后者，可想而知，这个文档的粒度就要远远大于一个大纲节点。</p>
<p>当然，文本型软件想要实现更好的粒度也不是没有机会。起码有好几种思路。一是设计者给文档里的每一行进行标记，比如说都标上行号，这样通过编码的方式，就能在文档内部细分到了「行」这个单位；二是给文档内部划分为「块」，比如说，如果用户设置了某一个区域的逻辑关系和大小标题，那么就可以把大标题覆盖的所有区域设置成为一个「块」，这样也可以直接「块引用」到这个部分。----当然，由于我没有深入研究过文本型软件的产品设计，这些思考只能算作是我个人的思想实验，但它们帮我很好地想清楚了我的需求是什么，以及我这样的需求应该匹配怎样的双链笔记软件。</p>
<h4 id="反链内容的实际呈现"><a class="header-anchor" href="#反链内容的实际呈现">¶</a>反链内容的实际呈现</h4>
<p>还有一个我个人高频使用的信息，那就是软件在反向链接处会体现哪些内容。还以日记本举例，当我们在第 8 页写下「 <strong>见 1 月 3 日</strong>」后，3
号那天页面下面自动出现的，究竟是「 <strong>见 1 月 8 日</strong>」，还是「 <strong>见 1 月 8 日
今日无事</strong>」，还是包括更多元的信息（如这个日记本的名称、8
号那天页面上后来增加的其他内容），在不同的软件里是有差异的。在信息量更大、双向链接更多的情况下，这部分内容的设计就格外重要了。</p>
<p>涉及每个软件设计细节的内容我就不在此分析了，详细可见语雀作者 @Chief Torturer
的文章：<a href="https://www.yuque.com/deerain/gannbs/ffqk2e" target="_blank" rel="noopener">《双向链接时代的快速无压记录》</a>，这位作者的想法给了我很大启发，该专栏下的所有文章都值得一读。</p>
<h3 id="私人红黑榜"><a class="header-anchor" href="#私人红黑榜">¶</a>私人红黑榜</h3>
<p>之前说过，我从 Obsidian 入坑双链，在里面积累了大量的素材。加上社区强大的插件支持，理论上说，Obsidian
完全可以满足我的日常需求。不过，或许就是因为 Obsidian 太强、容量太大的缘故，我在日常记录时，经常很不情愿地打开
Obsidian，感觉到一种无形的压力。另外，加上我最近需要在 ios、Android 系统间反复横跳，如果不加购 Obsidian
的同步功能（涨价了，现在的价格有点超预算了），多平台同步确实有点问题。</p>
<p>能够出色解决这个问题的，目前是 Workflowy，就是那款老牌优雅的大纲写作软件。由于它多端同步很顺畅、本身也加入了双链的功能，对标 Roam
Research 的前两种（[[]] 、(()) ），对我来说完全够用。经由
Workflowy，我意识到，大纲写作是多么无压、轻松；而且，省去大量修改格式的步骤，这样的使用对我这样一个排版强迫症来说，简直完美。另外，因为我日常有其他软件（如
Agenda、Fantastical、Marginnote）做富文本笔记管理、日程管理、电子书阅读，所以我只用 Workflowy
记录灵感、写日常计划和总结、汇总阅读清单、写文章打草稿列提纲等等内容，一旦引入双链，很多内容实现联通，效果杠杠的。</p>
<p>当然，我同时也还有使用 Logseq、Remnote，这两者在我看来基本上是等价的，它们各有一些闪光功能（Logseq 的 TODO
功能可以自动计时，Remnote 强大的复习功能），存储方式有所差异（Logseq 本地、Remnote
我用云端库），我不用使用得特别重，但是有需要的时候，因为数据传输也方便（Logseq 可以直接打开 md 文件，Remnote
的导入也简单），所以也偶尔一用。</p>
<p>以上是非常推荐的软件，Roam Research 我可能很快也会入坑。</p>
<p>下面还有些我个人不太喜欢的使用体验，仅供参考。</p>
<p>像功能强大的块编辑器软件，如 Notion、Craft
等，可以插入文本、图片、视频乃至表格等富文本信息，按道理应该用起来很爽。但根据我个人的使用体验，双向链接对于大多数块编辑器软件来说更像是一种附加功能，在知识的连接层面体验一般，尤其是在你非常关注知识链接本身，而不是积累内容的丰富程度和呈现美观度时，就会容易失望。</p>
<p>还有期待高、失望高的
Dynalist，我本来用它作为大纲笔记软件，但无意中发现了它也支持双链功能。不过可能是因为双链只是产品设计的一个小亮点，在展示上，你会发现双链的页面呈现冗余信息很多，不过好玩的是，我正是因为
Dynalist 这个「直白」的设计，才看清楚双向链接的本质原来就是内链地址搜索。当然，我最后弃坑的直接原因是多端同步快把我逼疯了，双链上，我觉得
Dynalist 做得是有可取之处的。</p>
<p><img src="https://cdn.sspai.com/2022/05/24/d7dc175f20c4ceb2e2dd4b16e0e1eb91.png" alt>《叫魂》这个页面旁边提供了快速查看反链信息的设置（还可以点击进入页面底部查看）、虽不好看，但好处是告诉了我们反链信息的原理就是搜索！</p>
<h2 id="尾声"><a class="header-anchor" href="#尾声">¶</a>尾声</h2>
<p>用双链软件进行知识管理的这一年，我开始从对「双向链接」这个概念不加反思地追逐崇拜，到逐渐清楚自己的使用习惯、软件喜好、任务目标。站在今日，我知道未来我还会怀着饱满的热情，深度体验某款双链笔记软件，但那绝不是因出于双链的迷信，而只是出于对产品功能的体验、对尝试新事物的热爱。</p>
<p>以上，就是本文的所有内容，写了非常久，中间增删很多次，也有很多想法在写下来的时候才觉得不够成熟。但所有的一切，在写完的时候都觉得值了。这是我自己对「双向链接」一个阶段性的探索成果，希望未来还能有更多的领悟。谢谢大家的时间。</p>
<blockquote>
<p>下载 <a href="https://sspai.com/page/client" target="_blank" rel="noopener">少数派 2.0 客户端</a>、关注
<a href="https://sspai.com/s/J71e" target="_blank" rel="noopener">少数派公众号</a>，解锁全新阅读体验 📰</p>
</blockquote>
<blockquote>
<p>实用、好用的 <a href="https://sspai.com/mall" target="_blank" rel="noopener">正版软件</a>，少数派为你呈现 🚀</p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」跨时空圆桌：伟大创作者们如何安排日常生活</title>
    <url>/public/2022/07/15/test/202207/2022-07-03-015035971655/</url>
    <content><![CDATA[<p>「转」<a href="https://sspai.com/post/73779" target="_blank" rel="noopener">跨时空圆桌：伟大创作者们如何安排日常生活</a></p>
<a id="more"></a>
<p>2007 年 7
月一个周日下午，美国作家梅森*柯瑞正在办公室里，想赶出第二天截稿的稿子。他是个早起的人，每天五点半即起，早上十分专注，但下午就心不在焉了。因此，虽然
deadline
迫在眉睫，但梅森却在摸鱼：他看看新闻，泡泡咖啡，收拾收拾东西，完全无心工作。摸到鱼外焦里嫩之际，不禁开始反思，责怪自己五点半起床的习惯严重降低了下午的工作效率。于是他上网搜索其他作家的生活习惯，看看能否参考一下。这类资料并不难找，而且十分有趣，梅森觉得应该把它们收集起来。这天下午，他创立了博客「<a href="https://dailyroutines.typepad.com/" target="_blank" rel="noopener">日常作息</a>」。这个博客陆续收集了一百多位作家、作曲家、思想家、科学家等创作者的生活习性记录，受到各大媒体关注，后被集结成书，台湾和大陆俱有引进。至于那篇稿子，梅森拖到了次日早上最后一分钟压线交卷。</p>
<p><img src="https://cdn.sspai.com/2022/06/13/544f1410813c0e816deea95b8d073961.png" alt>梅森*柯瑞和他的著作，图自
<a href="https://www.masoncurrey.com/" target="_blank" rel="noopener">masoncurrey.com</a><img src="https://cdn.sspai.com/editor/u_/cajhenlb34tcvb1j9pdg.png" alt>「日常作息」博客，<a href="https://dailyroutines.typepad.com/" target="_blank" rel="noopener">图源</a></p>
<p>梅森这份创作者名单不乏如雷贯耳之人：伏尔泰、康德、贝多芬、巴尔扎克、雨果、达尔文、马克思、福楼拜、托尔斯泰、柴可夫斯基、特斯拉、爱因斯坦、毕加索、卡夫卡、村上春树……他们当中很多人生活在距我们上百年的历史时期，与今人的生活习惯必有很多差异。但实际上，我们对于如何安排日常生活的困惑都是相通的：</p>
<ul>
<li>有必要为自己设定时间表吗？</li>
<li>几点睡觉？几点起床？</li>
<li>工作时间越长越好吗？</li>
<li>设立工作目标有用吗？</li>
<li>怎样提高工作效率？</li>
<li>琐事干扰太多，如何保持专注不分心？</li>
<li>作为创作者，如何获取灵感？</li>
<li>摸鱼应该有负罪感吗？</li>
<li>不工作的时候怎么玩？</li>
<li>……</li>
</ul>
<p>诸位将本文中看到各位伟大创作者们对如上问题给出的回答。将这些几百年前的回答和如今的番茄钟、GTD、健康监测等工具对照，有助于剥离数字时代的华丽外壳，思考自我管理的本质。不过，这些回答未必是「解决方案」，因为很多问题他们自己也没有解决；也不必因为作品伟大就推崇他们的一切习惯，世上并无完美无缺之人。这是一场跨时空圆桌会，诸位拣选有启发或有趣味的部分即可。</p>
<h2 id="关于时间表"><a class="header-anchor" href="#关于时间表">¶</a>关于时间表</h2>
<p>不妨想象一下：如果无需上班，不用上学，自由地安排二十四小时，你会过上规律性的生活吗？其实不用想象----
回忆自己假期的表现就知道答案了。本文涉及到的创作者们大部分就过着这样自由的生活：他们并没有一份今天意义上的「工作」。他们可以用创作养活自己，做自己的老板，自由地支配时间，就像是自由职业者。那么，他们会有规律地安排自己的生活吗？他们的自制力会像传说中那样异于常人吗？</p>
<h3 id="创作者们会有规律地安排日常生活吗？"><a class="header-anchor" href="#创作者们会有规律地安排日常生活吗？">¶</a>创作者们会有规律地安排日常生活吗？</h3>
<p>回答是肯定的。大部分创作者会按照一定的范式安排日常生活：他们有相对固定的睡眠、创作、休闲时间段，这也使整理出一份他们的时间表成为可能。</p>
<p>下图便是 23
位著名创作者的简要时间表。补充说明：图中时间段只表示大概时间，并非都那么准时；也并未完全表示创作者一生的时间安排，只代表某个人生阶段；只展示了工作日，不代表休息日或假期。</p>
<p>特斯拉在图中的时间表是他为爱迪生公司做学徒时的作息。他总是从十点半一直工作到次日凌晨五点，著名资本家爱迪生称赞他是「卷王之王」：「我有许多工作勤奋的助理，但你可谓其中的佼佼者」。后来他离职创业，成立了「特斯拉电气公司」，工作时间改为中午十二点至午夜。</p>
<p>佛洛依德每天要花大量时间接待患者，持续到晚上九点。晚上剩余时间他还要写作、阅读、为精神分析期刊做编辑工作，忙到凌晨一点或更晚，因此图中他显得十分忙碌。但是他有一个奢侈的调剂
----每年长达三个月的假期，在山上疗养中心远足、钓鱼、采草莓或蘑菇、陪伴家人。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajheo5b34tcvr93tui0.jpeg" alt>本文涉及的部分创作者的时间表，作者制图。版式部分参考了
<a href="https://podio.com/site/creative-routines#" target="_blank" rel="noopener">creative routinues</a></p>
<h3 id="去做「习惯的动物」"><a class="header-anchor" href="#去做「习惯的动物」">¶</a>去做「习惯的动物」</h3>
<p>与我们类似，很多创作者的规律性依习惯和生活事务而自然形成。但一些创作者也会有意识地规划安排自己的时间。康德和史蒂芬*金为自己订立的时间表堪称苛刻：他们每天都在大约相同的时间行动，如同钟表般规律。</p>
<p>诗人海因里希<em>海涅如此描写哲学家康德的日常：「康德的一生很难描写，因为他既没有生活，也没有历史。他在德国东北边陲老城柯尼斯堡偏远的静巷中，过着规律、机械、近乎抽象的单身汉生活。我相信当地天主教堂的那口大钟工作的规律性都不如其市民伊曼努尔</em>康德。他起床、喝咖啡、写作、上课、吃饭、散步，一切都有它固定的时间。当康德下午穿着灰外套，拄着西班牙手杖出门时，邻居就知道那一定是三点半。」</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajheolb34tcve3bs7lg.jpeg" alt>康德像，Johann
Gottlieb Becker
绘。<a href="https://commons.wikimedia.org/wiki/File:Kant_gemaelde_3.jpg" target="_blank" rel="noopener">图源</a></p>
<p>画家培根被评价为「习惯的动物」：起床第一件事就是作画，直至中午。整个下午和漫长的夜晚，他有大把的时间作乐，喝酒、夜店、宵夜，夜夜笙歌、通宵达旦，靠安眠药睡几个钟头，再早起画画，一生如此。</p>
<p>作家史蒂芬*金：「必须要有日程表----
每天大约同一时间进写作间，写完上千字才出来，让你能够养成习惯，就像你每天晚上大约都在同样的时间上床，依同样的规矩准备睡觉和做梦一样。不论是写作还是睡眠，我们都要学会保持身体的静止，而同时我们也鼓励心智从平凡庸碌的日常生活中解放。」</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajheotb34tcvb1j9pe0.png" alt>史蒂芬*金，图自
<a href="https://stephenking.com/the-author/" target="_blank" rel="noopener">stephenking.com</a></p>
<p>俄国作家格拉宁作品《奇特的一生》记录了昆虫学家柳比歇夫的时间管理方法：他 56 年如一日定量地管理自己的时间。每天以小于 15
分钟的精确度，记录自己做了什么事，花了多长时间；每月、每年分类统计各项花费的时间，并分析哪些不必要的事项用时过长，以持续改进。柳比歇夫一生涉猎广泛，著作甚丰，生前发表了七十余部学术著作，但他的时间管理法比学术成就受关注得多。</p>
<h3 id="像钟表一样生活？我做不到"><a class="header-anchor" href="#像钟表一样生活？我做不到">¶</a>像钟表一样生活？我做不到</h3>
<p>虽然康德这些位「珠玉在前」，但人非机器，要求自己像钟表一般行事未免过分苛求。也许你也曾立下雄心壮志，为自己订立了完善的时间管理计划，只是不出几天就无疾而终。别自责，别内疚，下面这些创作者的「打脸」故事告诉你：其实我们都一样。</p>
<p>心理学家威廉*詹姆斯极为推崇规律作息：「我们越具有把生活琐事交给不费心力的自动行为照管的能力，就能解放出越高的智慧和能力，让他发挥适当的功能。再没有比毫无习惯，一切都优柔寡断更可悲的人。」但其实这可悲的人就是指他自己：他有严重的拖延症，做事犹犹豫豫，生活散漫无纪，永远不能坚持规律的作息。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajhep5b34tcvr93tuj0.png" alt>威廉*詹姆斯，Notman
Studios 摄。<a href="https://commons.wikimedia.org/w/index.php?curid=16250941" target="_blank" rel="noopener">图源</a></p>
<p>小说家海勒写作慢如龟速，他的第一本小说《第二十二条军规》耗时八年才写完。「（下班后）我每天晚上写两三个小时。我曾经放弃过，停笔去和太太一起看电视，但电视却让我回头写作。我不能想象美国人如果不写小说，晚上有什么事可做。」辞去工作后，他全身心投入到第二本小说的写作，每天早上写两三个小时，然后去健身、吃午餐，回来再工作一阵。就算错过一天没写，他也不着急：「这是每天都要做的工作，但我绝不会因为没做而感到歉疚。我并没有非写不可的感觉，而且从来就没有。」在这样的摆烂精神指引下，他的第二本小说《出了毛病》终于在《第二十二条军规》十三年之后完稿了。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajhepdb34tcvr93tujg.png" alt>约瑟夫*海勒。<a href="https://commons.wikimedia.org/wiki/File:Joseph_Heller1986_crop.jpg" target="_blank" rel="noopener">图源</a></p>
<p>富兰克林堪称自我管理的先驱。他为自己制定了精确的时间表，开列了养成十三项美德的清单，计划每周养成一项美德。先前
<a href="https://sspai.com/post/73453" target="_blank" rel="noopener">少数派文章</a> 提到，他的清单还被用于证明 GTD
工具的历史。这样精致的自我管理总体上是有效的，但并非完美：他的印刷业务总是干扰时间表的执行；一周养成一样美德的计划落空了，后来改为一年养成一样，再后来改为几年养成一样，但「秩序」这项美德最终也未能养成。他天生难以保持物品的整齐，认为整理东西这事儿非常烦人。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajheplb34tcvgn49fvg.png" alt>富兰克林的时间表，引自他的自传</p>
<h3 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h3>
<p>柳比歇夫的日程管理法对时间的控制力堪称极致，很多日程管理软件以他的理论为宗。但当人们亲身实践这一方法时，就会被它的表象所迷惑，追求日程管理上的「完美」，认为日程管理在于充实生活，延长工作时间，并为由此产生的意义感而欣喜。最终，我们无奈发现，「完美」并不存在：实践时我们生怕浪费一点时间在与工作无关的事情上，但工作时还分心想着自己在管理时间，终于身心俱疲，难以为继。从前面的故事里我们能够得到一点慰藉：即使自我管理的推崇者威廉*詹姆斯和富兰克林都难以保证完美地落实日程安排。</p>
<p>失败的实践源于误解：日程管理的目的不应该是「延长工作时间」，或者说追求完美而充实的生活内容。大脑的生理条件决定了人一天中能集中精力的时间有限，在此基础上片面延长工作时间，以至于超过了大脑的极限，不可避免地会带来效率的下降。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajheptb34tcve3bs7m0.jpeg" alt><a href="https://unsplash.com/photos/uo_llXeqgQY" target="_blank" rel="noopener">图源</a></p>
<p>史蒂芬<em>金和威廉</em>詹姆斯有相似的观点：日程管理的目的在于「集中精力」：尽量无脑地、「自动化」地完成各类生活琐事，从而将宝贵的精力留在需要它的工作之中。换言之，要给琐事安排上固定的时间，或者事先解决掉，不要让大脑在工作时还要考虑它们。从这一点来说，任务管理的目的也是类似的：将日常琐事存储于清单中，忘掉它们，只在需要或它提醒时去读取内容。</p>
<p>集中精力的重要条件之一是工作的时间不应该过长。但不幸的是，我们的工作时间并不由自己决定，甚至在休息时还不得不担心工作。此时日程管理尚有一点可怜的作用，就是给工作和生活一点界限感，欺骗大脑在安排好的时段就别想那些烦心事（此外，也可以换个环境来营造界限感）。如果你的大脑足够聪明，或者足够笨，它应该会上当的。</p>
<h2 id="关于睡眠"><a class="header-anchor" href="#关于睡眠">¶</a>关于睡眠</h2>
<p>睡眠是每天的结束和新一天的开始，关于伟大人物的睡眠，历来有很多煞有介事的传说。</p>
<p>我们常听说，早睡早起是很多伟大人物成功的秘诀，事实的确如此吗？</p>
<p>还有人说，只睡四个小时、甚至放弃长睡眠，有间隔地小睡有利于工作，这样不走寻常路的睡眠法会有神奇的效用吗？</p>
<p>我们还将看到创作者们如何面临失眠的困扰，或许你能和他们产生共鸣。</p>
<h3 id="早起是创作者们成功的秘诀吗？"><a class="header-anchor" href="#早起是创作者们成功的秘诀吗？">¶</a>早起是创作者们成功的秘诀吗？</h3>
<p>想必细心的读者已在上文「创作者们的时间表」中发现，创作者们大多起得很早。我们开头提到的作者梅森也有类似的发现，这估计让五点半起床的他欣慰不已：「在研究创作者们的日常生活的过程中，我看到一位又一位的创作者在清晨完成他们一天中最重要的、甚至是唯一一段工作。这本书记录的
161
位创作者中，约有三分之一于早上七点或更早起床。如果问我从这本书中学到了什么，那应该是：起床直接工作；如果你喜欢可以泡杯咖啡，但别做太多其他事；好好利用这段日常琐事找上门之前的时间。」</p>
<p>歌德：「我人生曾有一度可以每天轻轻松松写满满一张纸，但现在（说这话时他 79
岁）只能在早上。在我睡饱后，还没被日常生活的俗务烦扰前，觉得心旷神怡的时候，撰写《浮士德》的第二部。」</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajheq5b34tcvr93tuk0.png" alt>歌德像，Joseph Karl
Stieler
绘。<a href="https://commons.wikimedia.org/wiki/File:Joseph_Karl_Stieler_portrait_de_Johann_Wolfgang_von_Goethe.jpg" target="_blank" rel="noopener">图源</a></p>
<p>很多创作者早起并非刻意为之，只是习惯而已：睡醒了，起床，就是这样的简单。他们所处的时代无需工作到深夜，也没有电子设备的干扰，早睡并非难事，早起也就顺理成章。</p>
<p>在权威们的先例下，我们也会想尝试养成早起的习惯，似乎依葫芦画瓢就能取得成功。早起是个好习惯，但「早起 =
成功」就是成功学逻辑了。如果很多成功者早起即能证明这一点，按照同样的逻辑，我们也能够举例说明「晚起 = 成功」。于是便可知道，早起晚起和成功并无必然关系。</p>
<p>毛泽东习惯清晨入睡，下午三点起床。1949 年 10 月 1
日这天情况比较特殊，他特意叮嘱警卫「下午一点钟叫我起床。」下午一点，警卫走进卧室轻轻喊他。毛泽东听到叫声，立刻坐起来，揉揉眼睛说：「这么快呀！」</p>
<p>笛卡尔习惯晚起。他每天睡十个小时，日上三竿时起床，还要赖在床上直到十一点多。「我的心灵在睡梦漫游过森林、花园和魔宫，体验过各种想象得到的愉悦之后，我醒来把夜里的梦境和白天的绮想融合在一起。」这一切于
1649
年后期突然终止，他接受了瑞典女王的授课邀请。这年冬天的瑞典极冷，他抵达时才得知，和女王的课程安排在清晨五点。采取新作息才一个月，笛卡尔就因不适应气候和作息病倒了，十天后溘然长逝。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajheqdb34tcvb1j9peg.png" alt>笛卡尔像，Frans
Franchoisz Hals 绘。[图源](<a href="https://commons.wikimedia.org/wiki/File:Frans_Hals_-" target="_blank" rel="noopener">https://commons.wikimedia.org/wiki/File:Frans_Hals_-</a>
_Portret_van_Ren%C3%A9_Descartes.jpg)</p>
<h3 id="一天只睡四小时真的可能吗？"><a class="header-anchor" href="#一天只睡四小时真的可能吗？">¶</a>一天只睡四小时真的可能吗？</h3>
<p>在睡眠时长这一话题上，人与人之间的体质差异尤为明显。宾夕法尼亚大学心理学教授大卫*丁格斯认为，大多数人每天都需要 8 个小时的睡眠以确保发挥出应有的能力。
但他也承认，有不到 5% 的人天生短睡，他们确实可以每天晚上只睡四五个小时，甚至更少。</p>
<p>牛顿很少在凌晨两三点前睡觉，有时候到清晨五六点了还没睡。但一到早上他就精力充沛，似乎睡了个长觉。</p>
<p>海明威每天五点半或六点就起床，即使前一晚烂醉如泥亦如此。他说：「当我在写书和故事时，我总是一见黎明，就立刻振笔疾书。」他的儿子说他似乎不受宿醉的影响：「我父亲总是神清气爽，仿佛刚在隔音室里戴上眼罩睡了一个好觉。」</p>
<h3 id="达芬奇会按照「达芬奇睡眠法」睡觉吗？"><a class="header-anchor" href="#达芬奇会按照「达芬奇睡眠法」睡觉吗？">¶</a>达芬奇会按照「达芬奇睡眠法」睡觉吗？</h3>
<p>「达芬奇睡眠法」据说是达芬奇提出的一种睡眠法，也称「多相睡眠法」。「达芬奇睡眠法」抛弃了睡一整个八小时（被称作「单相睡眠」）的观念，认为应该间隔式地小睡，例如每隔
4 小时睡 15 分钟，这样一天能睡一个半小时左右。</p>
<p>美国建筑师富勒亲身验证过这一方法，似乎效果还很不错。富勒乐于把自己当作实验对象。1932 和 1933
年的一系列实验让他认定，觉得疲惫或者困乏代表他的身心已经过度疲劳，亟需休息。经过多次试验，他发现了一种最适合他的作息：每工作六小时，小睡三十分钟；如果走神，就更早些休息。这种作息制度对他很有效，他可以连续授课十小时依然神采奕奕，很多与他共事的年轻人的精力都比不上他。虽然高效率睡眠实验十分成功，但他没有一直坚持下去，因为妻子抱怨他的作息太古怪了。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajheqlb34tcvr93tukg.png" alt>富勒设计的 1967
年蒙特利尔世博会美国馆，被称作「富勒球」。[图源](<a href="https://commons.wikimedia.org/wiki/File:Expo_67" target="_blank" rel="noopener">https://commons.wikimedia.org/wiki/File:Expo_67</a>,<em>pavillon_des</em>%C3%89tats-
Unis.jpg)</p>
<p>但是，并无确切证据证明达芬奇采用了这种睡眠法。他的助手如此描述他的工作状态，其中并未提到间隔式小睡的习惯：</p>
<p>达芬奇作画时总会早早到达，爬上脚手架，开始工作。有时他从黎明一直呆到日落，从不放下画笔，不吃不喝，不停地作画。也有时，他会连续两三四天不碰画笔，每天在作品前花上几个小时，抱着胳膊，自己检查这些画作。</p>
<p>关于睡眠的科学研究也并不支持这种睡眠方法。人类睡眠存在一个约 90 分钟的睡眠周期，粗略地说包含入睡、浅睡、深睡、做梦等阶段，而 15～30
分钟的时长打断了这一周期，很难达到完全的休息效果。网上也有很多人亲身试验了「达芬奇睡眠法」，就像短睡四个小时一样，这并非是大多数人适合的睡眠方式。如果你习惯在睡觉前玩一个小时手机，达芬奇睡眠法下的时间表将会非常「精彩」。</p>
<h3 id="失眠者的治愈沙龙"><a class="header-anchor" href="#失眠者的治愈沙龙">¶</a>失眠者的治愈沙龙</h3>
<p>同是天涯失眠人，相逢何必曾相识。这里是失眠者的治愈沙龙，本次请来的失眠嘉宾有达尔文、马克吐温和卡夫卡。</p>
<p>达尔文大约晚上十点结束与家人的娱乐，半小时内上床。不过他睡不太着，往往过了几个小时还醒着，忙着思考白天没解决的问题。</p>
<p>马克吐温的好友记述他失眠的情况：起初他在临睡前喝香槟，我们就给他香槟。后来他从波士顿回来，腋下夹了几瓶窖藏啤酒，说现在这种啤酒才能让他睡得着，我们便提供窖藏啤酒。更后来，我去哈特福德拜访他，才得知他又认为热威士忌是唯一的助眠良方。又过了很久，我问他还喝不喝热威士忌助眠，他说他现在什么也不喝了。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajher5b34tcvgn49g00.png" alt>马克吐温。<a href="https://commons.wikimedia.org/wiki/File:Mark_Twain_reading_c1900s.jpeg" target="_blank" rel="noopener">图源</a></p>
<p>卡夫卡：「我挖空心思想入睡，但那是不可能的任务，因为我们不可能一边睡觉，一边又惦记着自己的工作，并且还想解决明明就无法解决的问题。」</p>
<h3 id="小结-2"><a class="header-anchor" href="#小结-2">¶</a>小结</h3>
<p>睡眠是非常私人的话题，它与每个人的身体素质、生活节奏、心理状态密切相关。当我们看到牛顿、海明威、富勒的「高效率睡眠」时，也该明白自己的身体绝大概率并不能适应这样的短睡。我们很难不付代价地从睡眠中省出时间：如果你的睡眠没有达到身体的要求，它终究会报复你的。</p>
<p>荣格（所谓荣格十六型人格就是用了他的名字，但它并不是荣格发明的）每天要花八九个小时接待病人。尽管他明白很多病人都非常依赖他，但他仍然毫不避讳地去度假。他说：「如果累了，需要休息了，还依旧去工作的人是傻瓜。」在推崇牺牲睡眠努力工作的论调之下，我们应该大大方方地睡足觉，没有什么比睡个好觉更重要，是它让我们精神抖擞地醒着。「那个时候我年轻想办好事，差不多一个月大病一场。为什么呢？老熬夜。经常是通宵达旦干。后来最后感觉到不行，这么干也长不了。先把自己的心态摆顺了，内在有激情，外在还是要从容不迫。后来我就想了一个，今天做到
12 点就不做了，睡大觉，第二天重新来过。」</p>
<h2 id="关于工作"><a class="header-anchor" href="#关于工作">¶</a>关于工作</h2>
<p>伟大创作者的威名完全源于他们的作品。这些作品历久弥新，传诵至今，以至于今天的人们还难免好奇它们创作者的工作细节。他们的工作真如传说中那般勤奋吗？如果是，他们是如何保持这种勤奋的？他们会用目标管理的手段督促自己的创作吗？他们作品的灵感是从哪里找到的？他们会在工作累的时候摸鱼吗？他们的工作室是如何布置的？他们会面临如今这样信息轰炸的挑战吗？以下便是他们给出的回答。</p>
<h3 id="工作的激情源于热爱"><a class="header-anchor" href="#工作的激情源于热爱">¶</a>工作的激情源于热爱</h3>
<p>英国作家普里切特曾感叹：「这些伟大的人物迟早都会变成一个模样，他们从不停止工作，绝不浪费一分钟，这真让人沮丧。」而从他们自己的讲述来看，这一勤奋并非源于自我管理或
KPI，而是对这份工作发自内心的热爱。</p>
<p>梵高：「今天我又从早上七点一直工作到晚上六点，除了走一两步之外的距离去取食物之外，一动也不动。我一点没感觉到疲惫，今天晚上我会再画一幅画，而且要把它完成。」「我们的日子都花在工作上，时时都在工作。到晚上我们已经筋疲力竭，于是就去咖啡馆，之后早早上床！这就是我们的生活。」</p>
<p>贝尔年轻时总是日以继夜地工作，每天只睡三四个小时。等他妻子怀孕之后，他的作息总算正常一些。妻子强迫他晚餐后休息，他还会在十点后回书房工作。当产生新点子时，他恳求妻子免去他的家务，连续工作
22 小时不眠不休。他自述，「当我的脑袋塞满了各种新想法，教我兴奋莫名，急于一试，无法自拔，这是我焦躁不安的时刻。」</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajherdb34tcvr93tul0.png" alt>贝尔和他的妻子，1903
年。<a href="https://commons.wikimedia.org/wiki/File:Alexander_Graham_Bell_and_Mabel_Hubbard_Gardiner_Bell_kissing.gif" target="_blank" rel="noopener">图源</a></p>
<p>福楼拜：「有时候我不明白为什么我的手臂不会因为疲惫而由身体掉落，为什么我的脑袋不会溶化。我过的是苦行的生活，剥除了所有外在的娱乐，只靠一种永恒的狂热支撑，而这有时也让我流出无能的眼泪，但这种狂热却从不消退。我爱我的工作，那种爱痴狂而病态，就像苦行的人爱折磨他肚子的刚毛衬衣（一种旧时苦修者所穿的粗糙衣衫）。」</p>
<p>海明威：「当我在写书和故事时，我总是一见黎明，就立刻振笔疾书。那时没有任何人会打扰你，天气可能或凉或冷，而你开始工作，边写就边暖和起来。你读读自己写了些什么，而由于你在停笔时总知道接下来会发生什么，因此你就由那里接着写，写到你还有灵感，而且知道接下来会发生什么之后停笔，然后去过你的日子，直到第二天你再拿起稿子来为止。你早上六点已经起身，可能一直写到中午，或者更早就结束。等你停笔时，你一方面是空虚的，但另一方面却又一点也不空虚，而是实在的，就仿佛你已经和你所爱的恋人行了鱼水之欢一样。没有任何事物可以伤害你，没有任何事会发生，没有任何事有任何意义，直到第二天你再做一次。难以度过的是在来到第二天之前的等待。」</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajherlb34tcvb1j9pf0.png" alt>海明威在写作，Look
Magazine 摄，约 1953
年。[图源](<a href="https://commons.wikimedia.org/wiki/File:Ernest_Hemingway_Writing_at_Campsite_in_Kenya_-" target="_blank" rel="noopener">https://commons.wikimedia.org/wiki/File:Ernest_Hemingway_Writing_at_Campsite_in_Kenya_-</a>
<em>NARA</em>-_192655.jpg)</p>
<h3 id="为自己设立目标"><a class="header-anchor" href="#为自己设立目标">¶</a>为自己设立目标</h3>
<p>热爱是对工作巨大的推动力，但创作者们也会采取自我管理的手段。最常见的是「目标管理」，方式也很简单粗暴，设定产量目标和工作时长目标。他们的工作时长目标都小于八个小时，有的甚至还不到四个小时。</p>
<p>诗人叶芝规定自己无论是否愿意，每天都必须至少写两个小时。这样的日常纪律对他非常重要，因为要是没有常规，他的注意力就会涣散----「每一点改变都会扰乱我原本就不太坚决的生活习惯」。叶芝写得非常慢，他一天内的产量从未超过五六行，写一首八十行以上的抒情诗估计要三个月。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajhertb34tcvgn49g0g.png" alt>叶芝像，其父绘。<a href="https://commons.wikimedia.org/wiki/File:William_Butler_Yeats_by_John_Butler_Yeats_1900.jpg" target="_blank" rel="noopener">图源</a></p>
<p>海明威在图表上跟踪自己每天的产量，「这样才不会欺骗自己。」</p>
<p>毛姆每天早上写作三四个小时，规定自己每天要写一千至一千五百字。中午结束工作时，也往往会不耐烦，急着要再次开始。他说：「在你写作，在你创作一个角色的时候，他一直跟着你，你一心一意都想着他，他是活生生的。」毛姆的传记中如此评价他的写作：「这与其说是职业，不如说是上瘾。」</p>
<p>史蒂芬*金一年三百六十五天天天写作，从不休息。他为自己设立了每天两千字的目标，不写完不罢休。他早上大约八点或八点半开始写作，有时在十一点半就已经写完，但通常要到下午一点半才达到目标字数。接下来整个下午和晚上就可以自由支配：午睡、写信、看书、看电视、与家人娱乐。</p>
<h3 id="灵感的诞生"><a class="header-anchor" href="#灵感的诞生">¶</a>灵感的诞生</h3>
<p>创作者永远渴求灵感，而灵感的诞生需要灵感之神的眷顾。这一过程电光石火，充满神奇和兴奋。</p>
<p>法国小说家乔治*桑记录了肖邦的生活习惯：「他的创作自然而神奇，无需费心，不必预想，就这样自然而然涌现，由他的指尖流泻，突如其来、完整而崇高，或者在散步时，它会浮现在他的脑海，让他迫不及待要试行演奏。」</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajhes5b34tcve3bs7mg.png" alt>肖邦（铅笔画），George
Sand
绘。<a href="https://commons.wikimedia.org/wiki/File:Frederic_Chopin_by_George_Sand_in_pencil,_1841.jpg" target="_blank" rel="noopener">图源</a></p>
<p>福楼拜：「有时，当我脑袋空空洞洞，文思枯竭之际，当我发现自己画了整页却没有写出一个句子之时，我倒在长榻上，躺在那里茫然若失，陷入绝望的深渊，动弹不得，痛恨我自己，并且为驱使我追求妄想的疯狂骄傲而责怪自己。十五分钟之后，一切都变了，我的心因欢喜而砰砰直跳。」</p>
<p>柴可夫斯基：「未来作品的种子往往以最意想不到的方式，突如其来地出现。如果土壤够肥沃，也就是说，如果我有工作的情绪，这颗种子就会以难以想像的力量和速度生根，冒出土壤，伸出根、叶、枝，最后开花结果，我无法描绘这创造的过程，只能用这样的比喻说明。所有的困难都在于种子必须出现，必须处在有利的环境之下。其他的都是自动自发。我无法以言词向你说明在主要的想法出现、成形之后，笼罩你全身那无尽的喜悦感受。你忘怀一切，几乎丧失理智，你心中的一切都颤抖而翻腾，思绪奔腾，几乎无法用笔记下来。」</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajheslb34tcvr93tulg.png" alt>柴可夫斯基纪念碑。<a href="https://commons.wikimedia.org/wiki/File:Monument_to_Tchaikovsky,_Klin.JPG" target="_blank" rel="noopener">图源</a></p>
<p>上面的灵感来源颇有些玄学，教人完全无法模仿。当然，伟大的创作者必有一些天赋是我们学不来的。不过，也有一些创作者透露了他们获取灵感的方法，只是这些方法看上去都平平无奇，全无神秘可言。</p>
<p>下午两点左右，狄更斯准时离开书桌，在乡间或伦敦街头散步三小时，一边思索的故事，一边如他所描述的，「搜寻我想要编织故事的画面。」他的妹夫记得他「神采奕奕回到家，全身充满活力，仿佛来自某个看不见的蓄水池。」</p>
<p>伍迪*艾伦：「这些年来我发现，只要有短暂的改变，就能刺激心灵，提供新鲜的能量。因此如果我人在这个房间，然后走到另一个房间，就能帮助到我；如果我走到外面的街上，帮助更大。如果我在客厅觉得陷入死胡同，上楼淋个浴就能有所帮助，它使一切分解，让我松弛。」</p>
<p>「史努比之父」舒尔茨送完孩子上学后开始一天的工作。他坐在画板前，先用铅笔漫不经心地乱涂乱画，让自己的心思四处漫游。他最常用的方法是「就坐在那里，回想过去，有点像挖掘丑恶的记忆之类的东西。」不过，一旦有了点子，就会迅速工作，极其专注地把它画在纸上，以免灵感枯竭。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajhet5b34tcvr93tum0.png" alt>舒尔茨。<a href="https://commons.wikimedia.org/wiki/File:Charles_Schulz_NYWTS.jpg" target="_blank" rel="noopener">图源</a></p>
<h3 id="如果工作没进展，那就去摸鱼吧！"><a class="header-anchor" href="#如果工作没进展，那就去摸鱼吧！">¶</a>如果工作没进展，那就去摸鱼吧！</h3>
<p>即使是伟大的创作者，灵感之神也并不会永远眷顾，灵感枯竭之际就是摸鱼开始之时。</p>
<p>歌德：「我们不该勉强，工作没有进展，宁可虚掷光阴，或者睡觉度过，而不要勉强自己去做让自己日后也得不到满足的事物。」</p>
<p>海明威如果写作得不顺利，就会放下书稿，先去回信，这让他能够休息一下，暂时摆脱「可怕的写作责任」。</p>
<p>威廉*詹姆斯：「我认识一个人，他每天早上搬动椅子、捡拾尘土、摆弄桌子、翻阅报纸书籍、剪指甲，反正就是浪费早上的时间，而且不假思索。他这样做，只是因为他唯一该做的事是准备中午的形式逻辑课，而这偏偏正是他讨厌的。」这个人说的就是他自己。</p>
<h3 id="创作者们的工作室"><a class="header-anchor" href="#创作者们的工作室">¶</a>创作者们的工作室</h3>
<p>居家办公越发普及的今天，合适的工作间显得更加必要。创作者们大多也拥有自己的工作室，这些工作室条件各异，是他们性格的外化表现。</p>
<p>狄更斯对于写作环境有着苛刻的要求。首先，他需要绝对的安静。他家的书房要多装一扇门以阻隔噪音。另外，他的书房必须精心安排：书桌要放在窗户前，桌上需要备齐全套写作用具、鲜花、裁纸刀、两个铜制小塑像。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajhetdb34tcvgn49g10.png" alt>狄更斯，John &amp;
Charles Watkins
摄。<a href="https://commons.wikimedia.org/wiki/File:Charles_Dickens_by_Watkins_c1860.jpg" target="_blank" rel="noopener">图源</a></p>
<p>托尔斯泰在写作时把自己隔离起来，没有人可以进他的书房，邻近房间的门都被锁上，以确保他不受干扰。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajhettb34tcvr93tumg.png" alt>工作中的托尔斯泰。[图源](<a href="https://commons.wikimedia.org/wiki/File:Leo_Tolstoy_-" target="_blank" rel="noopener">https://commons.wikimedia.org/wiki/File:Leo_Tolstoy_-</a>
_portrait.jpg)</p>
<p>史蒂芬*金把写小说比作「创意的睡眠」。「像卧室一样，你写作的房间也该隐密，是你可以做梦的地方。」</p>
<p>毛姆的书桌永远是面对光秃秃的墙壁，他认为如果眼前有美景可看，就不可能写作。</p>
<p>特斯拉在黑暗中效率最高，他的办公室即使是中午也拉着百叶窗。只有在电闪雷鸣时，他才会拉开百叶窗，坐在自己的沙发上，欣赏闪电打在城市上方的景象。</p>
<p>阿加莎*克里斯蒂没有自己的书房。她只需稳固的桌面和打字机，「大理石洗手台就是个写作的好地方，不是吃饭时间的饭桌也很合适。」</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajheu5b34tcvr93tun0.png" alt>打字中的阿加莎*克里斯蒂。[图源](<a href="https://www.britannica.com/biography/Agatha-" target="_blank" rel="noopener">https://www.britannica.com/biography/Agatha-</a>
Christie)</p>
<p>画家培根的画室一片混乱，油彩乱七八糟地抹在墙上，地上堆着齐膝高的书本、画笔、纸、坏家具，以及其他破烂。他说如果屋里清爽宜人会扼杀他的创造力。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajheulb34tcvgn49g1g.png" alt>培根的工作室。<a href="https://commons.wikimedia.org/w/index.php?curid=112551712" target="_blank" rel="noopener">图源</a></p>
<h3 id="如何面对信息轰炸"><a class="header-anchor" href="#如何面对信息轰炸">¶</a>如何面对信息轰炸</h3>
<p>今天的工作过程经常被消息打断，我们经常在各种设备间切来切去，大脑也为此疲于奔命。本文的创作者们大多在数字时代之前生活，但他们也有信息焦虑：信件、杂务、邀约，作为著名人物，这些信息经常堆积如山。</p>
<p>柴可夫斯基每天总是在处理完书信和校样后才开始在钢琴前作曲。他的弟弟写道：「在开始愉快的工作之前，彼得总是先忙着把不愉快的工作做完。」</p>
<p>午餐后是达尔文的写信时间。他通常自己写信，但如果有很多信要写，他会简单写个草稿后口述找人听写。达尔文非常坚持每一封收到的信都要回，即使是非常愚笨或古怪的人写来的亦然。要是有信没回，他就会觉得良心不安，甚至整晚辗转反侧。</p>
<p>村上春树的时间表一成不变：凌晨四点起床，工作五六个小时，下午跑步或游泳、处理杂务、阅读、听音乐，晚上九点上床。这样的作息有一个缺点，那就是没留多少社交的时间。他在
2008
年的一篇文章中写道，「你一再拒绝别人的邀请，结果冒犯了他们。」但村上春树认为，与读者的关系比维系社交更为重要，他努力想让每一个新作品都比上一个有进步。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajhev5b34tcvgn49g20.png" alt>村上春树的工作台。<a href="https://www.harukimurakami.com/author" target="_blank" rel="noopener">图源</a></p>
<h3 id="小结-3"><a class="header-anchor" href="#小结-3">¶</a>小结</h3>
<h2 id="伟大的创作者大多相似：他们怀有对自己从事的事业发自内心的狂热，并有着常人难以企及的才华，极为专注地投入到每天的创作中去。这样的狂热对我们其实是一份奢求。大部分人并不知道自己热爱什么，也不知道如何寻找它，对于现在的工作心生厌倦却没有勇气告别。库克曾说：「我以前的老板乔布斯曾说过一句很深刻的话，『当你找到自己的热情所在，你的心会告诉你。如果你还没有找到，应该继续寻找。』因为你期望感受到这份热情，找到工作的意义"><a class="header-anchor" href="#伟大的创作者大多相似：他们怀有对自己从事的事业发自内心的狂热，并有着常人难以企及的才华，极为专注地投入到每天的创作中去。这样的狂热对我们其实是一份奢求。大部分人并不知道自己热爱什么，也不知道如何寻找它，对于现在的工作心生厌倦却没有勇气告别。库克曾说：「我以前的老板乔布斯曾说过一句很深刻的话，『当你找到自己的热情所在，你的心会告诉你。如果你还没有找到，应该继续寻找。』因为你期望感受到这份热情，找到工作的意义">¶</a>伟大的创作者大多相似：他们怀有对自己从事的事业发自内心的狂热，并有着常人难以企及的才华，极为专注地投入到每天的创作中去。这样的狂热对我们其实是一份奢求。大部分人并不知道自己热爱什么，也不知道如何寻找它，对于现在的工作心生厌倦却没有勇气告别。库克曾说：「我以前的老板乔布斯曾说过一句很深刻的话，『当你找到自己的热情所在，你的心会告诉你。如果你还没有找到，应该继续寻找。』因为你期望感受到这份热情，找到工作的意义</h2>
<p>你所做的对这个世界是有意义的，能够让世界有所不同。如果你找到了，一切都会变得不同。你的心会告诉你，因为你能真切地感受到每天早上起床，精神焕发、充满动力；否则就不会有这种感觉。所以如果大家还没有找到自己的热情所在，我鼓励大家继续寻找，我相信会找到的。」只有少数有能力和条件的幸运儿能够寻得这处活力的源泉，如果你愿意寻找，那就趁早出发，即使没有找到也不虚此生。</p>
<p>除了这份理想的狂热，也有一些更实际的经验值得参考：</p>
<ul>
<li>设立简明的目标并坚持执行；</li>
<li>为自己安排一个舒适的工作环境；</li>
<li>在散步、洗澡等休闲中获得新鲜感，促进思考；</li>
<li>不在失去工作动力时勉强自己；</li>
<li>集中处理消息杂务，或者全部屏蔽掉。</li>
</ul>
<h2 id="关于休闲"><a class="header-anchor" href="#关于休闲">¶</a>关于休闲</h2>
<p>本文提到的很多创作者经常只在上午工作，整个下午和夜晚用于休息娱乐。他们的休闲方式与今天相比并不丰富：聊天、玩牌、看报、读书、健身、散步、洗澡、烟酒、与家人共度。对他们来说，休闲不仅不是可有可无的东西，而且至为必要。</p>
<h3 id="散步能给我提供创意"><a class="header-anchor" href="#散步能给我提供创意">¶</a>散步能给我提供创意</h3>
<p>柴可夫斯基午餐后会去散个长步。他的弟弟吐槽说：「他不知道什么时候在哪里听来说，为了健康该散步两小时，因此非常古板、迷信地遵守这个规则，仿佛只要早五分钟回来，就会生病，难以相信的厄运会接踵而至一样。」但是，柴可夫斯基的迷信或许有他的理由：散步对他的创作力很有必要，而且他常在途中停步记下他的想法，日后再在钢琴上谱写成曲。</p>
<p>伍迪*艾伦认为出门散步能给他提供创意，只是他不可能在大街上散步而不被人认出来搭讪。这让他难以专心。作为替代，他经常在自己的公寓阳台上走来走去。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajhevdb34tcvb1j9pfg.png" alt>伍迪*艾伦于 2011
年戛纳电影节。<a href="https://commons.wikimedia.org/wiki/File:Le_cin%C3%A9aste_Woody_Allen.jpg" target="_blank" rel="noopener">图源</a></p>
<h3 id="「我发现在冷空气中沐浴对我的身体更好」"><a class="header-anchor" href="#「我发现在冷空气中沐浴对我的身体更好」">¶</a>「我发现在冷空气中沐浴对我的身体更好」</h3>
<p>据贝多芬的学生兼秘书说，贝多芬一天起码沐浴五次。他会穿着衣服站在盥洗台前，把大罐大罐的水倒在双手上，音调一阵高一阵低地吼叫，还有时对着自己大声哼唱。接着他一边瞪大眼睛东张西望，一边在屋子里大步流星，一下记东西，一下又恢复倒水和大声唱的仪式。房东抱怨他在地上洒了太多水，渗到楼下去了。</p>
<p>1851
年，雨果在根西岛安顿下来，买下了一块「闹鬼」的旧居，在屋顶上建设了全玻璃的「瞭望台」。他每天从清晨写到十一点，然后在全玻璃的瞭望台中洗冷水澡，并用马毛手套摩擦全身。凡是经过的居民都可以由街上看到这幅景象。</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajhevtb34tcve3bs7n0.png" alt>雨果在根西岛上的房子。[图源](<a href="https://commons.wikimedia.org/wiki/File:Victor_Hugo_%C3%A0_Hauteville_House_-" target="_blank" rel="noopener">https://commons.wikimedia.org/wiki/File:Victor_Hugo_à_Hauteville_House_-</a>
_Guernesey.jpg#)</p>
<p>伍迪*艾伦认为淋浴能够给自己的创造力一点刺激。「我会站在那里，在热气弥漫中冲个三十分钟、三十五分钟，光是想想点子，揣摩情节，然后我出来，擦干、穿衣，扑通一声倒在床上继续想。」</p>
<p>富兰克林：「我发现在冷空气中沐浴对我的身体更好。为此，我几乎每天早上都早起，脱光衣服，坐在我的房间里，读书或写作半个或一个小时，时间长短视季节而定。这样做一点也不会痛苦，反而很舒服，而且有时候，如果我在穿衣之前再回到床上，可以补眠，再睡一两个小时你所能想象最舒服的觉。」</p>
<h3 id="「吸烟是人生中最快乐也最便宜的享受」"><a class="header-anchor" href="#「吸烟是人生中最快乐也最便宜的享受」">¶</a>「吸烟是人生中最快乐也最便宜的享受」</h3>
<p>佛洛依德酷爱雪茄，自二十几岁到去世，尽管医生再三警告和暮年身体问题愈发严重，他也坚持抽雪茄，每天可达二十支。他声称，「吸烟是人生中最快乐也最便宜的享受。」</p>
<p><img src="https://cdn.sspai.com/editor/u_/cajhf05b34tcvr93tung.png" alt>佛洛依德最著名的照片中就在抽雪茄。<a href="https://commons.wikimedia.org/wiki/File:Sigmund_Freud,_by_Max_Halberstadt_(cropped).jpg" target="_blank" rel="noopener">图源</a></p>
<p>马克思每晚七点从大英博物馆阅览室离开后，开始整夜的长时间工作，不停地抽烟。抽烟已经从奢侈的习惯变成了不可或缺的镇静剂，这对他的健康造成了永久损伤。他经常受肝病折磨，有时还有脓肿和眼睛发炎，这使他感到疲惫易怒。</p>
<p>康德给自己定的准则是一天只抽一管烟。但据说多年下来，他的烟斗尺寸大了不少。</p>
<p>巴尔扎克每天凌晨一点起身工作，一连写七个小时。早上八点，他小睡一个半小时，然后继续工作到下午四点。期间他灌下一杯又一杯的黑咖啡，据估计每天可以喝五十杯。</p>
<h3 id="小结-4"><a class="header-anchor" href="#小结-4">¶</a>小结</h3>
<p>正如每个人的生活习惯不尽相同一样，每个人喜欢的休闲方式也不同。篇幅所限，我们只列举了散步、洗澡、烟酒三类，但创作者们的休闲方式其实多姿多彩：有的创作者喜欢夜夜笙歌；有的热衷于打牌，没人陪也要一个人打；有的人喜欢与家人聊天（福楼拜工作前都要找他老妈聊到尽兴为止）。以上种种，读者也不必照单全收，例如吸烟酗酒夜夜笙歌就不是什么好习惯。每个人都应该找到一种适合自己大脑的休闲方式，让休闲能够充分地放松大脑，为工作助力。</p>
<p>创作者们的休闲并不是可有可无的，而是像睡眠一样，是大脑的必要调剂。有的创作者还把休闲作为自己创作的活力源泉。很多人想当然地认为伟大人物必定把一切能利用的时间都花在工作上，进而限制甚至消灭他们自己（或者他们子女）的休闲时间。休闲和睡眠同样重要，我们应当正视大脑休闲娱乐的需求，劳逸结合方能更好工作。</p>
<h2 id="结语：勿在浮沙筑高台"><a class="header-anchor" href="#结语：勿在浮沙筑高台">¶</a>结语：勿在浮沙筑高台</h2>
<p>读者不难发现：本文的核心与其说是在讨论「创作者」，不如说是在讨论「大脑」。有研究表明，人类的大脑基因已经有约 5800
年没有升级了，它所适应的环境还在新石器时代。本质上，我们和创作者们的大脑没有区别，这是我们在如此巨大的时代差异下，仍能参考他们日常生活经验的最大基础。</p>
<p>数字时代的洪流裹挟着爆炸的信息流而来，众多效率工具、高效方法论和工作流方案应运而生。我们用这些华丽的工具建起辉煌的效率大厦，却忽视了它的地基其实并不坚实。人类的大脑并非精准的机器，想让它专注地工作，发挥出最大效率，需要苛刻的条件：</p>
<ul>
<li>对工作内容的热爱；</li>
<li>尽量少的干扰，它们可能来自电子设备、生活琐事或环境；</li>
<li>有一定规律性的安排；</li>
<li>足够的休息和玩耍。</li>
</ul>
<p>在这样的浮沙之上，我们需要慎重地选择效率工具，而不是被它们的外表所迷惑。</p>
<ul>
<li>它是核心事务必需的吗？</li>
<li>它能帮助大脑专注，还是使大脑分心？</li>
</ul>
<p>我们必须承认：大脑每天能够专注和高效的时间是有限的。我们所能做的是尽可能保证这些时间的高质量，发挥其最大效用。至于其余的时间段，我们应当给予它充分的休息或娱乐。</p>
<p>当你困的时候，睡吧！</p>
<p>当你工作不下去的时候，摸吧！</p>
<p>当你无所事事的时候，玩吧！</p>
<p>愿所有伟大的创作者保佑你，脑门！</p>
<p><strong>关 联阅读</strong></p>
<ol>
<li><a href="https://dailyroutines.typepad.com/" target="_blank" rel="noopener">博客「日常作息」</a></li>
<li>根据博客「日常作息」整理的著作：原版：Mason Currey. Daily Rituals: How Artists Work[M]. New York: Knopf, 2013.台版：[美]梅森<em>柯瑞. 創作者的日常生活[M]. 台北: 聯經出版, 2014.陆版：[美]梅森</em>柯里. 创作者的一天世界[M]. 上海: 上海文艺出版社, 2021.</li>
</ol>
<p>两岸版本的译者均为庄安祺。文中大部分引言以台版《創作者的日常生活》为本，考虑到两岸用语习惯的差异以及篇幅，在保留原意的基础上有少许删改。</p>
<ol start="3">
<li>格拉宁. 奇特的一生[M]. 北京: 外国文学出版社, 1979.</li>
<li>陈也辰, 王钦双. 毛泽东的1949[M]. 北京: 东方出版社, 2007.</li>
</ol>
<blockquote>
<p>下载 <a href="https://sspai.com/page/client" target="_blank" rel="noopener">少数派 2.0 客户端</a>、关注
<a href="https://sspai.com/s/J71e" target="_blank" rel="noopener">少数派公众号</a>，解锁全新阅读体验 📰</p>
</blockquote>
<blockquote>
<p>实用、好用的 <a href="https://sspai.com/mall" target="_blank" rel="noopener">正版软件</a>，少数派为你呈现 🚀</p>
</blockquote>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu完全教程</title>
    <url>/public/2022/04/01/linux/ubuntu_tour/</url>
    <content><![CDATA[<blockquote>
<p>ref:<a href="http://www.cnblogs.com/dutlei/archive/2012/11/20/2778327.html" target="_blank" rel="noopener">Ubuntu完全教程，让你成为Ubuntu高手！</a>
todo整理</p>
</blockquote>
<h2 id="Ubuntu的发音"><a class="header-anchor" href="#Ubuntu的发音">¶</a>Ubuntu的发音</h2>
<p>Ubuntu，源于非洲祖鲁人和科萨人的语言，发作 oo-boon-too 的音。了解发音是有意义的，您不是第一个为此困惑的人，当然，也不会是最后一个：）</p>
<p>大多数的美国人读 ubuntu 时，将 u 作为元音发音，类似单词 who 或者 boo ，重音在第二个音节即 u'buntu ，oo-boon-too 。</p>
<p>如果您喜欢撒哈拉，喜欢它令人窒息的温柔、梦幻般的寂寥还有张扬恣肆的旷远，您大可在第一个 u，后面带些嗡嗡声： oom-boon-too。</p>
<p>Ubuntu的中文发音大约为： 乌班图</p>
<h3 id="Ubuntu的涵义"><a class="header-anchor" href="#Ubuntu的涵义">¶</a>Ubuntu的涵义</h3>
<p>Ubuntu这个单词源自非洲，意谓“班图精神”────谁都不是一座孤岛，自成一体。每个人都包孕于人类，因他人存在而存在，因他人幸福而幸福。</p>
<h3 id="Ubuntu当前版本"><a class="header-anchor" href="#Ubuntu当前版本">¶</a>Ubuntu当前版本</h3>
<p>Ubuntu Linux v6.06 LTS (Dapper Drake)</p>
<p>LTS：Long Term Support</p>
<p>Dapper Drake：当前版本的开发代号</p>
<h3 id="Ubuntu的特点"><a class="header-anchor" href="#Ubuntu的特点">¶</a>Ubuntu的特点</h3>
<p>Ubuntu 完全基于 Linux 操作系统， 可以免费得到社区及专业机构的支持。庞大的社区是它成长的沃土，请向这片动人的热忱敞开心扉。</p>
<p>Ubuntu 社区恪守 Ubuntu 理念：自由！软件应是自由的，应尊重人类的自由意志，它与人类之间不应有任何隔膜。本地语种，功能限制，自主改进的权利……都不应成为使用的障碍或负担。</p>
<p>自由，让 Ubuntu 与传统的私有软件从根本上不同: 免费不能用来遮羞，您有权修正它，直到满意为止。</p>
<p>Ubuntu 适合桌面和服务器。当前 Ubuntu 发布版支持 PC (Intel x86), 64-bit PC (AMD64) 和 PowerPC (Apple iBook 和 Powerbook, G4 和 G5) 架构。</p>
<p>Ubuntu 包涵了超过 16,000 种软件， 核心的桌面系统却只有一张光盘， Ubuntu 覆盖了所有的桌面应用程序,</p>
<p>从文字处理，电子表格到 web 服务器和开发设计环境一应俱全。 详情查看 Ubuntu 桌面 和 Ubuntu 服务器的介绍。</p>
<h3 id="Ubuntu相对其它Linux发行版的主要特点"><a class="header-anchor" href="#Ubuntu相对其它Linux发行版的主要特点">¶</a>Ubuntu相对其它Linux发行版的主要特点</h3>
<ul>
<li>
<p>基于Debian/Linux，使用 APT 包管理系统。</p>
</li>
<li>
<p>相对于Fedora Code： APT 包管理系统优雅地解决了依赖问题，并且可以从容的在线安装升级</p>
</li>
<li>
<p>相对于Debian：软件更新积极，而Debian较保守。</p>
</li>
<li>
<p>相对于Gentoo：基本无需编译，省力、省时、省心。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="基本操作"><a class="header-anchor" href="#基本操作">¶</a>基本操作</h3>
<p><strong>进入系统</strong></p>
<p>在登录界面中输入您的用户名，然后系统将提问您的密码</p>
<p>输入您的密码后，回车，稍事等待，您便可以进入Ubuntu系统</p>
<p>点击桌面左上角的图标，您可以打开一个菜单（或者使用 Alt+F1 组合键）</p>
<p>如果您想退出系统，可以点击该图标</p>
<p>在桌面上方启动栏中，包含了一些常用程序的启动图标这些图标也可以在开始菜单中找到</p>
<p>现在点击FireFox图标，您便可以使用FireFox浏览器冲浪</p>
<p>或者按下 Alt+F2 组合键，弹出一个运行命令对话框。输入 firefox 后回车，同样可以启动FireFox</p>
<p>在菜单中找到 终端</p>
<p>点击它便开启了一个终端窗口，您可以在终端窗口中运行命令</p>
<p>也可以在控制台中输入命令。使用 Ctrl+Alt+[F1~F6] ，您可以切换到1~6号控制台</p>
<p>使用 Ctrl+Alt+F7 可以返回图形界面（您可以使用 Ctrl+Alt+BackSpace 将图形界面关闭）</p>
<p>命令行提示符</p>
<p>user@ubuntu:~$ 为命令提示符， @ 之前的部分为当前用户ID， @ 与 : 之间的部分，为您的主机名称， : 与 $ 之间的部分，为当前的路径。</p>
<p><strong>退出系统</strong></p>
<p>您可以点击这一个图标来退出系统</p>
<p>也可以在终端或者控制台中输入命令</p>
<p>sudo halt</p>
<p>系统会提问您密码，输入正确密码，便可以退出系统</p>
<p>在以后的章节中，如果我们提示您输入命令，那么您即可以在终端中输入，也可以在控制台中输入。如果只是启动应用程序，还可以使用 Alt+F2 组合键。</p>
<h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2>
<h3 id="分区概念"><a class="header-anchor" href="#分区概念">¶</a>分区概念</h3>
<p>首先我们需要知道，硬盘分区的存在，是由硬盘的物理特性决定的，并不会因为不同的操作系统而有所改变。</p>
<p>请您把一块硬盘想象为一本书……即便您不喜欢读书，您也一定非常熟悉它，所有的书都是相同的，包括我们使用的课本……您肯定非常熟悉</p>
<p>一本完整的书，通常包括书名、索引和正文。</p>
<p>如果您需要Linux，您首先需要找到一本书名为《linux》的书，书名相当于硬盘中的MBR，也就是主引导纪录。不同的是，MBR可以是几个书名合在一起，类似于《XX合订本》。这部分内容暂时还没有什么实用价值，您只需要大概的了解。</p>
<p>而正文，就是硬盘中纪录的数据，这也非常容易理解，且对于安装系统并没有什么影响，所以现在我们来了解索引</p>
<p>索引相当于硬盘中的分区表，书中的每一个章节，相当于硬盘中的一个分区，它起始和结束的页次，都可以在索引中找到。试想，如果阅读一本撕掉索引的书，您将很难找到您想阅读的部分。同样，如果没有分区表，操作系统也不能够在硬盘上定位数据的位置。</p>
<p>由于历史的原因，硬盘中的分区表大小受到了限制，最多只可以容纳四个分区（主分区）。如果一本书，它的索引最多只能有四个章节，那不是太可怕了么？很多书的内容远远不止四个章节啊！</p>
<p>于是聪明的人们想到了一个变通的办法，就是利用其中的一个章节，来存储其它部分的索引。比如第一章是前言，第二章是其它部分的索引，我们翻到第二章，呵呵，这里是第二个索引，因为只有第一个索引受四个章节的限制，所以这个索引的内容可以非常的详尽。第二个索引就是分区表中的扩展分区了，其中定义的章节，就是硬盘中的逻辑分区，不是很难理解吧？</p>
<p>明白了这一点，我们来看看Linux和Windows对于分区不同的表示方法：</p>
<p>可能您已经很熟悉Windows了，它使用盘符来表示分区，比如 C: D: E:，每一个分区使用一个盘符来标识，而且顺序可以颠倒， D:并不一定就是您系统中的第二个分区。（如果您给第二个分区分配最后一个硬盘盘符，把所有的盘符按顺序排列好，并且重装一次系统，您就会理解什么叫作“头疼”了：）</p>
<p>而在Linux中，分区是这样表示的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/hda        /dev/hda1      /dev/hda2       /dev/hda5/      dev/sdb1</span><br></pre></td></tr></table></figure>
<p>以 /dev/hda5 为例:</p>
<p>因为在Linux中，每一个设备都是用 /dev/ 文件夹下的一个文件来表示，所以 /dev/hda5 中， /dev/ 表示的是根目录下的dev目录，我们来看剩下的部分 hda5 。</p>
<p>前两位的字母 hd 表示这是一块IDE硬盘，如果是 sd ，则代表SATA硬盘，或者闪存等外设。</p>
<p>第三位的字母 a 表示这是该类型接口上的第一个设备。同理， b、c、d…… 分别代表该类型接口上的第二三四……个设备。例如 hdc 表示第二个IDE接口上的主硬盘（每个IDE接口上允许一个主设备和一个从设备）。</p>
<p>第四位的数字 5，并不表示这是该硬盘中的第5个分区，而是第一个逻辑分区。因为在Linux中，为了避免不必要的混乱，分区的顺序是不能改变的，分区标识则由它们在硬盘中的位置决定。系统又要为所有可能的主分区预留标识，所以 1-4 一定不会是逻辑分区， 5 则是第一个逻辑分区，以此类推。</p>
<h3 id="安装中的注意事项"><a class="header-anchor" href="#安装中的注意事项">¶</a>安装中的注意事项</h3>
<p>在Ubuntu系统的安装过程中，您需要选择系统目录的挂载点。</p>
<p>我们知道，安装Windows时，我们可以选择把系统安装在哪一个分区，把系统挂载到分区上。而在ubuntu/Linux中则相反，我们要把分区挂载到系统中。当我们使用Windows的安装方式，把系统挂载到分区上，我们就不可能把Windows目录放在C盘，而把<code>MyDocuments</code>目录放到其它分区。您或者出于习惯，或者出于数据安全方面的考虑，通常把文档放到其它分区中。但是Windows下很多软件保存文件的默认目录就是<code>MyDocument</code>目录，这就比较不方便。</p>
<p>在系统安装完成后，我们还是可以将<code>MyDocuments</code>目录转移到其它分区中，不过有点麻烦，可能许多朋友还不知道怎么去作……而任何一种Linux系统时，当然包括<code>Ubuntu</code>，我们可以在系统安装时就把分区挂载到目录下， <code>/home</code> 目录相当于Windows的<code>MyDocuments</code> ，我们可以把 <code>/dev/hda5</code> 挂载到此目录下，这样我们往 <code>/home</code>目录里存东西的时候，其实保存在第一个扩展分区中。如果再一次安装系统，只要把这个分区挂载到 <code>/home</code>目录下，那么进入新系统就像回家一样，真是太棒了。</p>
<p>理论上来讲，您可以将分区挂载到任何目录下面，您可以自定义挂载的路径。但是我们并不推荐您这么作，因为那没有任何意义。系统安装程序向您建议的挂载目录，通常也是我们向您建议的，现在我们来了解一下，这些目录通常都是用来作什么的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/    根目录，唯一必须挂载的目录。不要有任何的犹豫，选一个分区，挂载它！（在绝大多数情况下，有2G的容量应该是够用了。当然了，很多东西都是多多益善的：）</span><br><span class="line"></span><br><span class="line">Swap     交换分区，可能不是必须的，不过按照传统，并且照顾到您的安全感，还是挂载它吧。它的容量只要大于您的物理内存就可以了，如果超过了您物理内存两倍的容量，那绝对是一种浪费。</span><br><span class="line"></span><br><span class="line">/home    前面已经介绍过了，这是您的家目录，通常您自己创建的文件，都保存在这里，您最好给它分配一个分区</span><br><span class="line"></span><br><span class="line">/usr  应用程序目录。大部分的软件都安装在这里。如果您计划安装许多软件，建议您也给它分配一个分区</span><br><span class="line"></span><br><span class="line">/var      如果您要作一些服务器方面的应用，可以考虑给它分配一个较大的分区</span><br><span class="line"></span><br><span class="line">/boot     如果您的硬盘不支持LBA模式（我想那不太可能:），您最好挂载它，如果挂载硬盘的第一个分区，应该比较稳妥。一般来说，挂载的分区只要100M大小就足够了</span><br></pre></td></tr></table></figure>
<p>在文件系统这一环节中，我们建议您选择： <code>ReiserFS</code></p>
<p>也许您注意到了，Windows中，盘符既用于表示硬件（硬盘上的分区）,又用于表示系统中的路径。而Linux中，硬件就是硬件，路径就是路径，不会混淆在一起，简单直接！</p>
<h2 id="Linux基础"><a class="header-anchor" href="#Linux基础">¶</a>Linux基础</h2>
<h3 id="Shell"><a class="header-anchor" href="#Shell">¶</a>Shell</h3>
<p>可能您早已能够熟练的使用GUI（图形用户界面），例如您可以使用鼠标双击一个图标，来打开或者执行它。</p>
<p>我们来看这个过程: 您使用鼠标定位桌面上的一个程序图标，按下左键两次。系统读取鼠标指针的位置，并且判断该位置下图标的涵义，根据预设的双击动作，运行程序或者打开文件。</p>
<p>这一套GUI系统，便是一种Shell，它的作用是实现人机交互。如果我们不能够控制电脑，那么电脑还不如电视机好玩，不是么？电视机也可以选择频道（电视机的遥控器，也是一种人机交互的界面，不过相对于电脑，确实是相当简单了：）</p>
<p>易于上手、界面直观是GUI的优点，但是GUI为不意味着简单！或许您有类似经历: 桌面上有几十个程序的启动图标，也知道它们的名字，但是翻出一个来，并不是一件轻松的事情。</p>
<p>我的Windows系统中，桌面上摆满了各种图标，每当启动一个程序的时候，我都很是困扰。后来尝试了 音速启动 这类的程序启动管理器，效果还是差强人意。</p>
<p>在我的不懈努力下，这个难道最终得到了解决： 将快捷方式名称简化，放到特定目录下，使用 Win+R 组合键呼出 运行对话框，键入快捷方式的名称来运行该程序。比如 反恐精英 的快捷方式为 cs ，我把它放在 Windows 目录下; 运行 cs命令，就可以去维护世界和平了。</p>
<p>这么多快捷方式，统统放到 Windows 目录下，非常混乱。因此，我在D盘建立了一个名为 path的目录，并把它的路径加入到环境变量的 path 项中，快捷方式放在 <code>D:\path</code>目录中。即便重装系统，只要在环境变量中重新加入此路径，原来的程序大多可以直接以命令来运行……我的许多朋友强烈要示我帮他们设定这种启动方式，因为这确实很方便：）</p>
<p>其实在Linux下，所有的程序都可以通过命令运行。虽然Linux也有GUI，但是它并不比Windows的GUI更优秀！上面只是简单的介绍了CLI（命令行界面）相对GUI的优越之处，使用CLI还有更多的好处，您会慢慢体会到的。</p>
<p>当然了，在您的印象中，CLI一定非常的不友善，缺少亲和力，冷漠而拒人于千里之外……您和CLI之间甚至有代沟的存在：）</p>
<h4 id="命令"><a class="header-anchor" href="#命令">¶</a>命令</h4>
<p>坦白的说，冷不丁见到那么老长的一串命令，谁都会毛骨悚然。</p>
<p>也许您使用过DOS，留下这种印象：命令先放一边，光是正确的输入目录、文件名都够瞧的。而且DOS不区分大小写，要是像Linux一样区分大小写，那多恐怖啊！！！</p>
<p>其实Linux命令行具有补全功能，非常实用。假设有这样一个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> path/file</span><br></pre></td></tr></table></figure>
<p>如果只有一个以 c 起始的命令，键入 c ，再按一次 tab 键，系统将自动补全该命令余下的部分。 只要 c tab 两次按键，就可以完成 command 的输入。</p>
<p>如果不只一个 c 起始的命令，那么您可以按两次 tab 键，系统会列出所有符合条件的选项，也就是以 c 起始的所有命令。进一步输入 o ，如果只有一个以 co 起始的命令（一直输入，直到项符合条件的选项唯一），再按一次 tab ，命令就被补全完整。</p>
<p>路径和文件名也可以通过 tab 键来补全。还有一种 遍历补全 的方式，如果您的文件名是中文，而您不想切换输入法；甚至您的文件名中出现乱码，无法输入，这时 遍历补全 就可以大显身手了。这部分内容我们稍后再谈：）</p>
<p>现在我们来了解命令的语法结构，这一部分相当重要，您可得看仔细。</p>
<p>我们知道，任何语言都有特定的语法结构，以我们的中文为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们郑重地推荐您Ubuntu/Linux！</span><br></pre></td></tr></table></figure>
<p>这个句子的语法尽管简单，却是大部分的命令行采用的句型。让我们看一下，这个句子里都有些什么：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们</span><br></pre></td></tr></table></figure>
<p>主语，Linux命令的执行者只有一个，所以主语一概省略。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推荐</span><br></pre></td></tr></table></figure>
<p>一个动词，作为谓语而存在。Linux命令中，这一部分是必须的。这一部分也是不同命令之间最根本的区别方式，所以它通常作为命令名，写在最前面。键入 date 命令，您可以查看当前的时间日期。（ 应用程序-&gt;附件-&gt;终端 ）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">郑重的</span><br></pre></td></tr></table></figure>
<p>状语，用来修饰谓语。与之相对应，Linux命令可以使用参数来精细调节程序的行为。为了与命令的操作对象相区别，参数前通常要加 - 或者 -- 符号。原则上，在命令名之后，参数的位置可以随意，但是为了养成一个良好的习惯，我们建议您在命令名后直接跟参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">您 Ubuntu/linux</span><br></pre></td></tr></table></figure>
<p>这两个部分都是宾语，它们是命令的操作对象。大部分的命令只有一个操作对象，也有一些命令是双宾语结构的，具有一个直接宾语和一个间接宾语。比如 拷贝 这个命令 cp (copy)</p>
<h4 id="分隔符"><a class="header-anchor" href="#分隔符">¶</a>分隔符</h4>
<p>我们的汉语是象形文字，没有分隔符。但是所有的拼音文字中都有分隔符，来分隔单词。Linux命令中同样使用空格作分隔符。</p>
<p>cp a /home 表示把当前目录下的 a 文件，拷贝到 /home 目录下。（命令的不同部分使用空格分隔，连续的空格视为一个空格）</p>
<p>上面的那句话，翻译成Linux的命令，应该是这个样子的：</p>
<p>推荐 --郑重的 您 Ubuntu/Linux （按照传统，“-”后跟简写为单个字母的参数，“--”后跟完整单词的参数。不过也有例外：）</p>
<p>哈，Linux的命令也蛮简单吧？</p>
<h3 id="Linux程序、进程"><a class="header-anchor" href="#Linux程序、进程">¶</a>Linux程序、进程</h3>
<p>或许您会这样想，Linux命令的句型确实不难，但是那么多命令，我怎么知道它们都是作什么的呢？而且不同的系统中，可以使用的命令似乎也不太一样，这真让人困惑……</p>
<p>其实Linux的命令，运行的是Linux系统中的程序。只要您已安装了程序，您就可以通过命令来运行它，并且可以使用参数来精细的调整它的运行状态。也可以通过点击启动图标来运行，不过启动图标不能够方便的调整参数，并不是很方便。</p>
<p>举一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mplayer -shuffle -loop 3 -playlist mymp3.list</span><br></pre></td></tr></table></figure>
<p>可能您运行上面命令，系统会提示您 无法找到命令，那是因为您没有安装mplayer这个程序。mplayer是我见过的支持格式最多的播放器，几乎任何已知格式的多媒体文件，都可以使用mplayer来播放。它包含一个图形界面的前端，您可以在菜单中找到它，鼠标点击运行;也可以通过执行命令来运行它的命令行版本。</p>
<p>如果您的系统中没有mplayer播放器，我们建议您安装一个。关于程序的安装，请参阅 软件安装 。</p>
<p>上面命令中， mplayer 调用了mplayer播放器程序。参数 -shuffle 表示随机播放， -loop 表示循环播放，后面的3 为循环的次数，如果为 0 ,则一直播放。 -playlist 表示播放列表中的曲目。我们可以把mp3的路径放到 mymp3.list文件中，让mplayer来播放它们。</p>
<p><strong>进程</strong> 为运行中的程序，是程序在内存中的镜像。</p>
<p>好了，现在您已经了解了 Shell 、 命令 、 程序 、 进程 的概念，您基本上也就了解了Linux（Linux系统真是非常简洁，而且容易理解：）。</p>
<p>但只知道这些，您并不能顺畅使用。接下来的章节中，我们来进一步介绍它的细节。</p>
<h2 id="Linux系统简介"><a class="header-anchor" href="#Linux系统简介">¶</a>Linux系统简介</h2>
<h3 id="路径"><a class="header-anchor" href="#路径">¶</a>路径</h3>
<p>路径分为绝对路径和相对路径。</p>
<p><strong>绝对路径</strong>的起始点为根目录 <code>/</code> ，例如 <code>/usr/local/bin</code> 就是绝对路径，它指向系统中一个绝对的位置，不受其它因素影响。</p>
<p><strong>相对路径</strong>的起始点为当前目录，如果您现在位于 /usr 目录，那么相对路径 local/bin 所指示的位置为 <code>/usr/local/bin</code></p>
<p>也就是说，相对路径所指示的位置，除了相对路径本身，还受到当前位置的影响。例如Linux系统中常见的目录 <code>/bin</code> 、 <code>/usr/bin</code>、 <code>/usr/local/bin</code>，如果只有一个相对路径 bin，那么它指示的位置可能上面三个目录中的任意一个，也可能是其它目录。</p>
<p>如果我告诉您到 <code>bin</code> 目录寻找一个文件，您可能搞不清楚是哪一个 <code>bin</code> 目录。只有当前位置确定，相对路径指示的位置才能够确定。</p>
<p>现在我说， <code>/usr/local</code> 目录下，它的相对路径 <code>bin</code> 中有某个文件，这样就比较明确了。</p>
<p>在相对路径中 . 表示当前目录， .. 表示当前目录的上一级目录。</p>
<p>假设您安装了一个程序，它的主程序没有被放置到上面三个 bin 目录中的任何一个，或者其它系统能够找到的地方，您就得告诉系统，它的可执行文件在哪里。</p>
<blockquote>
<p>可以使用绝对路径，例如： <code>/home/user/bin/</code>可执行文件</p>
</blockquote>
<p>或者定位到 <code>/home/user/bin</code> 目录，使用相对目录来定位它 ./可执行文件</p>
<p>如果您定位到了它的子目录，比如 <code>/home/user/bin/gui</code>，您可以使用 <code>..</code> 来表示它的上级目录 <code>../</code>可执行文件</p>
<p>路径相关命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> (change directory) 更改目录。</span><br><span class="line"><span class="built_in">pwd</span> (<span class="built_in">print</span> working directory)显示当前路径。</span><br><span class="line">ls (list) 显示当前目录中的文件列表。</span><br></pre></td></tr></table></figure>
<p>请尝试以下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc 进入“/etc”目录，这里使用的是绝对路径</span><br><span class="line"></span><br><span class="line"><span class="built_in">pwd</span> 显示当前路径，这个命令返回结果“/etc”</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> init.d 进入“/etc”目录的子目录“init.d”，这里使用的是相对路径</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> .. 进入上一级目录“/etc”</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ../home “/etc” 目录的上一级目录为“/”，它的子目录“home”为“/home”</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> - 回到上一次的目录，我们在“/etc”目录跳转到“/home”目录，所以这次是回到“/etc”目录</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~ “~”代表当前用户的“<span class="variable">$HOME</span>”目录，也就是“/home/&#123;用户名&#125;”目录。</span><br><span class="line"></span><br><span class="line">ls 在任何时候，您都可以使用“ls”命令，来了解当前目录下都有哪些文件。</span><br></pre></td></tr></table></figure>
<p>远程路径：</p>
<p>远程路径的表示方法为 <code>协议://用户名:密码@位置/路径:端口</code></p>
<p>大多数的远程路径可以使用默认端口匿名访问，由此用户名、密码、端口通常不需要填写。例如：</p>
<p><code>http://www.ubuntu.org.cn/.../index.html</code></p>
<p>要求身份验证的远程路径，您可以使用下面的方式访问:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ftp://user:passwd@ftp.ubuntu.org.cn:21</span><br></pre></td></tr></table></figure>
<h3 id="软件"><a class="header-anchor" href="#软件">¶</a>软件</h3>
<p>Linux中没有***注册表***这个概念。安装软件，理论上讲，只要拷贝所有相关文件，并运行它的主程序就可以了。</p>
<p>按照传统，一个软件通常分别拷贝到同级目录下的 bin、etc、lib、share等文件夹。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Bin      可执行文件，程序的可执行文件通常在这个目录下。在环境变量中设定搜索路径，就可以直接执行，而不需要定位其路径。</span><br><span class="line"></span><br><span class="line">Etc       配置文件，大部分系统程序的配置文件保存于 /etc 目录，便于集中修改。</span><br><span class="line"></span><br><span class="line">Lib      库文件，集中在一起，方便共享给不同程序。相较不同的软件单独保存库文件，能够节约一些磁盘空间。</span><br><span class="line"></span><br><span class="line">Share    程序运行所需要的其它资源，例如图标、文本。这部分文件是专有的，不需要共享；而且目录结构相对复杂，混放在一起比较混乱，所以单独存放。</span><br></pre></td></tr></table></figure>
<p>还有一些软件，占用一个单独的目录，所有的资源都在这个目录中。类似于Windows下的绿色软件，不推荐在Linux系统下这样作。</p>
<ul>
<li>
<p>执行时，系统找不到可执行文件（搜索所有路径，资源开销过大，是不现实的），需要定位其位置，像这样 /home/user/bin/可执行文件 ，不够方便。</p>
</li>
<li>
<p>许多系统软件需要协作运行，配置文件分别保存，定位它们非常麻烦</p>
</li>
<li>
<p>如果程序使用的库文件，像图形库文件，都单独存放，那么磁盘空间的浪费会非常严重。</p>
</li>
</ul>
<p>有一些大型软件，或者您布署的重要应用，您可以将它们单独安装在一个文件夹下。（通常源码安装支持这种方式，将在 <a href="#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85">软件安装</a> 部分介绍）</p>
<h4 id="配置方式"><a class="header-anchor" href="#配置方式">¶</a>配置方式</h4>
<p>Linux下没有类似 注册表 的系统，系统和软件都可以通过纯文本的配置文件进行设置。</p>
<p>事实上，图形界面的配置工具，通常就是以图形界面的方式修改配置文件，适合设置一些比较简单的程序。如果软件有几千个可以配置的选项，全部作成菜单，想象一下……开始发抖吧……</p>
<p>图形界面的配置工具，可以看作特定配置文件专用编辑器。您一样可以使用通用文本编辑器来编辑配置文件，比如 Nano、Gedit、Knote、Vim或者Emacs等等。不考虑阅读、修改配置文本占用的时间，直接修改配置文件甚至更迅速。</p>
<p>如果只是要修改某一常用选项，而且时常修改，比如主机的IP地址。使用文本编辑器，您要找到相应的配置文件，还要在配置文件中找到相应的选项，会浪费掉您的时间和耐性。</p>
<p>图形配置工具经常会受各种因素制约，比如网络服务器中不提供图形服务，图形界面不够稳定……这时，您可以使用命令行的配置工具来完成这些工作。</p>
<p>例如： 修改主机IP地址，可以使用ifconfig这个程序，执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 192.168.0.1</span><br></pre></td></tr></table></figure>
<p>在以后的章节中，如果我们提示您修改某一文件，例如 /etc/fstab ，您可以使用任何顺手的文本编辑器打开它。</p>
<h3 id="隐藏文件"><a class="header-anchor" href="#隐藏文件">¶</a>隐藏文件</h3>
<p>Linux下，名称中第一个字符为 . 的文件或者文件夹，系统默认情况下将它们隐藏起来，</p>
<p>您可以尝试以下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ 进入您的用户目录</span><br><span class="line">ls 查看当前目录下的文件列表</span><br><span class="line">ls -a 查看所有文件的文件列表（包括隐藏文件）。</span><br></pre></td></tr></table></figure>
<p>现在，您可以看到许多文件名以 . 起始的文件或者文件夹了吧？使用 ls 命令无法显示它们</p>
<ul>
<li>
<p>如果您只想查看隐藏文件，而不包括这两个特殊目录，您可以使用 ls 命令的参数 -A （ls -A）</p>
</li>
<li>
<p>每个目录下都包含两个特殊目录 . 和 .. 。您也许猜到了， . 代表当前目录， .. 代表上一级目录。目录是一种特殊类型的文件！</p>
</li>
</ul>
<p>文件类型</p>
<p>Linux系统主要根据文件头信息来判断文件类型，扩展名并非决定因素。</p>
<p>现在使用 ls -l 命令，查看详细信息格式的文件列表，您将会看到如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">total 5</span><br><span class="line">drwxr-x--- 4 user group 4096 Mar 10 00:37 filename</span><br><span class="line">drwxr-xr-x 21 user group 4096 Mar 10 20:16 文件名</span><br><span class="line">-rw------- 1 user group 524 Mar 10 00:40 a</span><br><span class="line">-rw-r--r-- 1 user group 24 Jun 11 2000 b</span><br><span class="line">drwx------ 2 user group 4096 Mar 9 11:06 c</span><br></pre></td></tr></table></figure>
<p>共显示了七列信息，从左至右依次为：权限、文件数、归属用户、归属群组、文件大小、创建日期、文件名称</p>
<p>其中要特别留意的是第一列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x</span><br></pre></td></tr></table></figure>
<p>一共有10个位置，可以分为4组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d    rwx  r-x  r-x</span><br></pre></td></tr></table></figure>
<p>第一组只有一个字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">** d* *文件夹*     ** -* *普通文件*        ** l* *链接*       ** b* *块设备文件*     ** c* *字符设备文件。*</span><br></pre></td></tr></table></figure>
<p>剩下的3组分别为归属用户、归属群组、其它用户或群组对于该文件的权限。我们看它的格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rwx rwx  rwx</span><br><span class="line"></span><br><span class="line">** r* *可读*       ** w* *可写*      ** x* *可执行*</span><br></pre></td></tr></table></figure>
<p>它们的顺便不能颠倒，某一位置为空(-)，则表示不具有相应的权限。</p>
<p>说明：Linux下的可执行文件并不是由扩展名（例如 .exe ）决定的，而是由其可执行权限位决定。</p>
<p>权限</p>
<p>我们已经知道了，文件的权限分为 <code>r</code> （可读）、 <code>w</code> （可写）、 <code>x </code>（可执行）三种类型，而一个文件可以针对归属用户，归属群组，其它用户用户或群组分别设定权限。</p>
<p>这种权限管理的方式灵活、简单、严密、明晰。尽管如此，在最初的阶段，可能会有一点小小的不适。因为它无所不在，而您习惯了的Windows的权限管理却不是这样（非常混乱，大多数时间形同虚设，偶尔用到却让人伤透脑筋）。</p>
<p>使用 <code>chmod</code> 命令更改文件的权限，使用 <code>chown</code> 来更改文件的归属。例如：</p>
<p>chmod 755 xxx</p>
<p>chmod a+x xxx</p>
<p>chown user:group xxx 用来更改文件的归属用户，也可以同时更改其归属群组</p>
<p>chgrp group xxx 用来更改文件的归属群组</p>
<p>上面命令中的 755 和 a+x 是两种类型的表达式</p>
<p>我们将后面章节中详细介绍 权限管理 用户管理</p>
<p>执行命令的权限</p>
<p>有一些命令，普通用户也可以执行，但是只有root用户才能执行成功，这是为什么呢？</p>
<p>例如在系统中增加一个新用户 useradd</p>
<p>ls -l /usr/sbin/useradd</p>
<p>可以看到：</p>
<p>-rwxr-xr-x 1 root root 56156 2006-04-03 21:37 /usr/sbin/useradd</p>
<p>明明所有的用户都可以执行嘛？</p>
<p>这是因为， useradd 命令是修改 /etc/passwd 文件的一个工具，来看看这个文件：</p>
<p>ls -l /etc/passwd</p>
<p>-rw-r--r-- 1 root root 1835 2006-06-24 17:58 /etc/passwd</p>
<p>原来只有root用户才能写入修改结果，非root用户执行 useradd 命令当然不会有结果。</p>
<p>执行命令的身份</p>
<p>默认情况下，您的命令提示符末位为 $ ，这表示您将以普通用户的身份执行命令。</p>
<p>您可以使用 su （switch user）这个命令来切换其它用户。</p>
<p>例如 su root ，切换到root用户，如果 su 命令后面没有切换目标，那么这个命令默认切换到root用户。</p>
<p>现在您执行 su 这个命令，系统会提示您输入密码，请输入管理员的密码。这个时候，您会发现命令提示符末位变成了 # ，您将以root用户的身份执行命令。</p>
<p>Ubuntu系统默认会随机设定系统的root密码，这样会更安全一些，这个时候您可以执行“sudo”命令，输入当前用户密码后，暂时以root</p>
<p>用户的身份执行命令。（前提是sudoer列表中要包含您的ID。您在安装Ubuntu系统时创建的用户，默认具有“sudo”权限）</p>
<p>如果您能够执行“sudo”命令，那么您也就拥有了root权限。在后面的章节中，如果我们提到了“root权限”，那么您可以通过以上两种方式来实现</p>
<h3 id="命令行"><a class="header-anchor" href="#命令行">¶</a>命令行</h3>
<p>Shell、Console、Terminal</p>
<p>在前面的章节中，我们曾提到，电视机的遥控器，也是一种人机交互的界面，算是一种Shell。</p>
<p>但是这个概念并不准确，遥控器只是向Shell发送指令的工具，Shell接收到遥控器发出指令后，将指令转换为系统命令，由系统来执行。</p>
<p>例如我们按的遥控器上的 数字键1 ,遥控器将 切换为1频道 的指令发送到Shell，Shell将指令转换为系统可以识别的 频道1 ，系统执行它，您就可以观看1频道的电视节目了。</p>
<p>通常每台电视机只有一种Shell，比如有的电视机系统具有“画中画”的功能，那么Shell中便有相应的功能定义，您可以通过遥控器上的“画中画”功能键来开启它。假设您的电视机没有此功能，Shell中也就没有相应的功能定义。拥有一个带“画中画”功能控制键的遥控器，即便信号兼容，您还是不能够使用这一功能：）</p>
<p>不用遥控器也可以控制电视机，假设您的遥控器丢了，您还可以走到电视机前，使用机身上的控制面板来控制它（相当于使用Linux的控制台）。但是您一定不喜欢这种方式，除非您想锻炼身体：）</p>
<p>在Linux系统中，由于图形界面和控制台的分辨率通常不一致，所以切换时要有一个延时。对于我们中文用户来讲，控制台下中文的显示也比较麻烦。而且控制台显示内容通常不如终端显示的全面。</p>
<p>所以我们推荐您使用终端来执行命令，它使用起来感觉很像遥控器：）</p>
<p>rxvt-unicode</p>
<p>通常情况下，您买一台电视机，只能获得一个遥控器。虽然它为您的电视机量身定作，能够最大限度发挥电视机的能力，但您却不一定喜欢它。说不定这个遥控器体形太大，持握不方便;或者它体形太小，容易失踪;又或者它的按键要么太硬，要么太软;它的键盘要么太大，要么太小……您一般也可以容忍，毕竟遥控器使用频率并不算高：）</p>
<p>如果您的终端有些地方不讨您喜欢，比如说响应太慢，或者不能正常显示中文……那就难以忍受了，您应该换一个其它的试试。</p>
<p>在前面的章节，我们介绍您使用的终端为Gnome-Termianl，它是系统默认使用的终端，显示中文不错，不过响应比较慢，您可能已经处于水深火热之中了。。。</p>
<p>我们推荐您使用urxvt（mlterm也是不错的选择）</p>
<p>您可以使用 <code>sudo apt-get install rxvt-unicode</code> 命令来安装它。</p>
<p>urxvt 启动它 （urxvt不支持控制台，您得在图形界面下启动它。终端、Alt+F2，建议您在启动栏里新建一个启动图标）</p>
<p>rxvt-unicode还支持“服务器/客户端”的运行模式：</p>
<p>urxvtd 启动一个守护进程daemon（支持控制台）</p>
<p>urxvtc 启动客户端client。多个客户端可以同时连接到一个urxvtd，以达到节省系统资源的目的。</p>
<p>或许您对rxvt的默认设置不满意，您可以修改用户配置文件 ~/.Xresources 来设定它。修改全局配置文件 /etc/X11/Xresources/Xresources ，则对所有用户生效，只有root才可以修改此文件。</p>
<p>这里有一些简单的选项：（以 ! 起始的行是注释，您可以直接拷贝此文件的内容）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!!=============================================================================</span><br><span class="line">!! RXVT-unicode setting</span><br><span class="line">!!=============================================================================</span><br><span class="line">!设置字体分辨率</span><br><span class="line">Xft.dpi:96</span><br><span class="line"></span><br><span class="line">!窗口大小</span><br><span class="line">Rxvt.geometry: 80x40+80+80</span><br><span class="line"></span><br><span class="line">!颜色</span><br><span class="line">Rxvt.background:#333333</span><br><span class="line">Rxvt.foreground:antiquewhite</span><br><span class="line">Rxvt.inheritPixmap:False</span><br><span class="line">Rxvt.colorBD:yellow</span><br><span class="line">Rxvt.colorUL:antiquewhite</span><br><span class="line"></span><br><span class="line">!滚动条</span><br><span class="line">Rxvt.scrollBar:True</span><br><span class="line">Rxvt.scrollBar_left:True</span><br><span class="line">Rxvt.scrollBar_floating:False</span><br><span class="line">Rxvt.scrollstyle:next</span><br><span class="line">Rxvt.scrollColor:#999999</span><br><span class="line"></span><br><span class="line">!屏幕缓冲</span><br><span class="line">Rxvt.saveLines:30000</span><br><span class="line">Rxvt.color12:DodgerBlue</span><br><span class="line">Rxvt.font:7x14,xft:AR PL New Sung</span><br><span class="line"></span><br><span class="line">!输入法一般设置为xim</span><br><span class="line">!inputMethod:xim;Scim除外</span><br><span class="line">!输入法样式可选:Root(置底) OverTheSpot(跟随) OffTheSpot OnTheSpot，后两种不是所有的都支持</span><br><span class="line">Rxvt.preeditType:Root</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip：右键点击启动栏， 添加自启动器 ， 自定义程序 ，便可以在添加自己的启动图标。</p>
</blockquote>
<h3 id="在线帮助系统"><a class="header-anchor" href="#在线帮助系统">¶</a>在线帮助系统</h3>
<p>您可以使用命令 man 或者 info 来阅读Linux命令的在线文档。命令的格式非常简单：</p>
<p>man xxx</p>
<p>大部分命令手册为英文版，如果您的英文不太好，或许有些困难。在后面的 系统管理 章节中，我们会尽力向您介绍命令的使用方法。</p>
<p>说明：在使用“man”浏览器的时候，一些快捷键您可能会用到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl+f(orward) 向下翻一页 Ctrl+d(own) 向下翻半页</span><br><span class="line">Ctrl+b(ackward) 向上翻一页 Ctrl+u(p) 向上翻半页</span><br><span class="line">/ 查找 q(uit) 退出</span><br></pre></td></tr></table></figure>
<p>以上为VI风格的键绑定。您也可以使用Emacs风格的键绑定</p>
<h3 id="bash"><a class="header-anchor" href="#bash">¶</a>bash</h3>
<p>好了，现在我们换了一个遥控器，感觉顺手多了。现在来操练一下，下载一首mp3：</p>
<p>我们使用 wget 这个程序，它非常可靠，完全值得您信赖。</p>
<p>首先找到一个可以下载的地址，复制链接，在终端窗口内点击鼠标中键，把它粘贴进去。</p>
<p>现在终端中大概是这种情形：</p>
<p><a href="http://www.download.net/xxx.mp3" target="_blank" rel="noopener">http://www.download.net/xxx.mp3</a></p>
<p>按下 Ctrl+a 组合键，我们发现光标移动到了行首。输入 wget 和 空格</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://www.download.net/xxx.mp3</span><br></pre></td></tr></table></figure>
<p>回车后，终端中出现一些信息，不一会儿工夫，mp3便下载完成。</p>
<p>使用 Ctrl+a 组合键，我们就不需要使用方向键来移动光标，方向键每次只能移动一个字符，没有效率</p>
<p>您还可以使用 Ctrl+f 向前移动光标， Ctrl+b 向后移动光标， Ctrl+e 将光标移动到行末……………… （键绑定）</p>
<h3 id="Note"><a class="header-anchor" href="#Note">¶</a>Note</h3>
<p>Linux的图形界面中，鼠标中键通常执行“粘贴”的操作，如果您的鼠标没有中键，您可以左右键同时按下。</p>
<p>中止正在运行的程序</p>
<p>如果一个命令持续时间很长，以致于不能够进行其它操作，可以使用 Ctrl+c 来强行中止它。</p>
<p>Ctrl+s</p>
<p>出于意外，有时您会按下 Ctrl+s 这个组合键，Shell便被冻结。尝试使用 Ctrl+q 组合键，看能否恢复正常。</p>
<h3 id="键绑定"><a class="header-anchor" href="#键绑定">¶</a>键绑定</h3>
<p>等等，有必要记这么多快捷键么？都这么复杂！</p>
<p>我们强烈建议您记住，以大幅度的提高操作效率。而且这是readline控件的键绑定，在任何使用readline控件的程序中，您都可以使用它们。例如bash、lftp、gdb等程序;同时，Linux下最著名的Emacs编辑器，也是这种风格的键绑定（其实是readline使用了Emacs风格的键绑定才对），甚至FireFox中，也可以使用类似风格的快捷键！（Linux下主要有两种风格的键绑定，一种是VI风格，另一种是Emacs风格，我们会在 简明VIM教程中介绍）</p>
<p>现在列举一些ReadLine的键绑定，您可以自行尝试。（运行 man readline 命令，来查看ReadLine手册）</p>
<p>先来了解一些约定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\C<span class="_">-a</span> 表示 Ctrl+a</span><br><span class="line">\M<span class="_">-a</span> 表示 Meta+a Meta键在PC中通常为ALT键</span><br><span class="line"></span><br><span class="line">A 表示 Shift+a</span><br><span class="line">（下面括号中的\A代表Alt，\S代表Shift）</span><br><span class="line"></span><br><span class="line">移动命令：</span><br><span class="line"></span><br><span class="line"> \C<span class="_">-a</span>  移动到行首  Aheah        \C<span class="_">-e</span>  移动到行末  End          \C<span class="_">-f</span>  向前移动一个字符  Forward </span><br><span class="line"></span><br><span class="line">*\C-b* *向后移动一个字符* *Backward        \M<span class="_">-f</span>* *向前移动一个单词*        *\M-b* *向后移动一个单词*</span><br><span class="line"></span><br><span class="line">*\C<span class="_">-l</span>* *清空屏幕* *cLear*      *这两个命令也可以理解为移动命令*        *\C-p* *上翻，前一条命令* *Previous*</span><br><span class="line"></span><br><span class="line">*\C-n* *下翻，后一条命令* *Next*        *编辑命令：*</span><br><span class="line"></span><br><span class="line">*\C<span class="_">-d</span>* *删除光标后的一个字符* *\M<span class="_">-d</span>* *删除光标后的一个单词* *Delete*</span><br><span class="line"></span><br><span class="line">*\BackSpace* *删除光标前的一个字符* *\M-BackSpace* *删除光标前的一个单词*</span><br><span class="line"></span><br><span class="line">*\C-k* *删除光标至行末的部分* *Kill         \C-u* *删除光标至行首的部分* *Unix-line-discard*</span><br><span class="line"></span><br><span class="line">*\C-w* *删除光标前的一个单词* *Word       \C-y* *粘贴（最后删除的对象）* *Yank      \C--* *撤消*</span><br><span class="line"></span><br><span class="line">搜索历史纪录：</span><br><span class="line"></span><br><span class="line">*\C-r* *连续使用* *``C-r``* *可以查找下一个*        *\M-p      \M-n*</span><br><span class="line"></span><br><span class="line">补全：</span><br><span class="line"></span><br><span class="line">*\Tab* *使用频率最高的功能！*        *\C-o* *遍历补全* *（未定义）*</span><br><span class="line"></span><br><span class="line">*\M-? M-=* *列出所有可能选项，相当于按两次**Tab**键（**M-**？* *实际按键为**\A+\S+/**）*</span><br><span class="line"></span><br><span class="line">*\M-<span class="comment">#* *注释掉当前命令，用于将当前命令暂存于历史纪录列表（**\A+\S+3**）*</span></span><br><span class="line"></span><br><span class="line">*\M-!* *补全命令，通常用来补全子命令，例如* *``sudo``* *的子命令（**\A+\S+1**）*</span><br><span class="line"></span><br><span class="line">*\M-~* *补全用户名（**\A+\S+`**）*       *\M-@* *补全主机名（**\A+\S+2**）*</span><br><span class="line"></span><br><span class="line">*\M-$* *补全变量（**\A+\S+4**）*         *\M-_* *补全历史纪录中的纪录（**\A+\S+-**）*</span><br><span class="line"></span><br><span class="line">*\M-** *将所有可能选项放到命令行中（**\A+\S+8**）*</span><br></pre></td></tr></table></figure>
<h4 id="自定义键绑定"><a class="header-anchor" href="#自定义键绑定">¶</a>自定义键绑定</h4>
<p>通过修改 <code>/etc/inputrc</code> 文件，可以更改键绑定。建议您使用默认的键绑定，以避免不必要的烦恼。当然了，Emacs风格的键绑定是通用的，随时都有可能用到。</p>
<p>在文件中添加该行，可以将ReadLine的键绑定设为VI风格。（Bash、Lftp等使用ReadLine的软件同时生效）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set editing-mode vi</span><br></pre></td></tr></table></figure>
<p>找到这一行：</p>
<p>$if mode=emacs</p>
<p>在它的下面添加如下内容</p>
<p>&quot;\C-o&quot;: menu-complete</p>
<p>###这两行不是必须的，视情况而定###</p>
<p>&quot;\c-p&quot;: non-incremental-reverse-search-history</p>
<p>&quot;\c-n&quot;: non-incremental-forward-search-history</p>
<p>重新登录Shell，您就可以使用 \C-o （Ctrl+o）来遍历补全。假如您的文件名为中文，或者出现乱码时，您可以使用 \M-*</p>
<p>将所有文件名放入命令行，再删除多余的，这真是麻烦极了！所以您可以使用 \C-o 遍历补全，将所有可能的选项轮流放入命令行。</p>
<p>或者使用Vim编辑器编辑 /etc/inputrc 文件，在插入模式下使用 Ctrl+v 组合键。按下 Ctrl+o ，这时编辑区新增一个 ^O 字符，等价于 \C-o</p>
<h3 id="通配符"><a class="header-anchor" href="#通配符">¶</a>通配符</h3>
<p>使用 <code>?</code> 代表任意单个字符。例如 <code>???lo</code> ，表示 <code>lo</code> 前有三个字符，它可以匹配 <code>Hello</code></p>
<p>使用 <code>*</code> 代表随意几个任意字符。例如<code>*.iso</code>，代表所有 <code>iso</code> 格式的文件。</p>
<p>说明：您可以将遍历补全和通配符结合使用，以提高效率。</p>
<p>例如：</p>
<p>cd */ 则遍历补全只补全文件夹</p>
<p>chmview *.chm 则遍历补全只补全chm文件</p>
<h3 id="任务管理"><a class="header-anchor" href="#任务管理">¶</a>任务管理</h3>
<p><code>&amp;</code> 在命令的末尾加上一个 <code>&amp;</code> 符号，表示背景任务，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://www.download.net/xxx/mp3 &amp;</span><br></pre></td></tr></table></figure>
<p><code>;</code> 使用 <code>;</code> 将多个命令连结起来，则表示任务按顺序执行</p>
<p><code>&amp;&amp;</code> 使用 <code>&amp;&amp;</code> 将多个命令连结起来，则表示只有前面的命令执行成功，后面的命令才能得以执行</p>
<p>`` `&lt;命令&gt;` ，如果一个命令中包含以 `` （Esc键下方的按键）括起来的子命令，那么子命令将被优先执行，执行结果被代入上一级命令继续执行，例如创建一个以当前时间命名的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch `date +%m.%d_%H:%M:%S`</span><br></pre></td></tr></table></figure>
<p><code>touch</code> 命令能够创建一个文件，它的操作对象，为 <code>date +%m%d%H%M%S 命令的输出 06.06_06:06:60</code></p>
<p>这样，我们创建了一个名为 <code>06.06_06:06:60</code> 的文件（六月六日六时六分刚过六十秒-_-!）</p>
<p>Ctrl+z</p>
<p>将当前Shell中的任务挂起</p>
<p>这个时候任务的状态为</p>
<p>[1]+ Stopped xxx</p>
<p>Bg-------------------------------------------------将挂起的任务背景运行。这时它的状态为[1]+ xxx &amp;</p>
<p>Fg-------------------------------------------------将背景任务调到前台执行jobs</p>
<p>方括号中的数字为命令的任务编号，您可以使用 jobs 命令来查看所有背景任务</p>
<p>如果后台运行多个任务，您可以在 bg 或者 fg 后跟任务编号，作为操作对象，例如：bg 2</p>
<p>管道、重定向</p>
<p>&gt;-----------------------重定向符号，它的作用是将命令的输出重定向到一个文件中。比如我们想把命令 ls 的结果保存为 FileList 文件，作一个清单，我们可以使用重定向符号来完成它：</p>
<p>ls -l &gt; FileList</p>
<p>&gt;&gt;----------------------作用与 &gt; 基本相同，不同点在于， &gt;&gt; 以追加的方式，将命令的输出写入文件的末尾。</p>
<p>&lt;-----------------------是从文件到命令的重定向，将文件的内容作为命令的输入。</p>
<p>|------------------------为管道符号，它的作用是将前一个命令的输出，作为下一个命令的输入。假设一个目录下的文件太多，使用 ls命令不能够在屏幕中完全显示，这个时候您可以将 ls 命令的输出，通过管道符号，作为浏览器 less 的输入。就可以使用浏览器的功能翻页、查找：ls -al | less</p>
<p>说明： less 浏览器的键绑定几乎与 man 相同，请参阅 在线帮助系统</p>
<h3 id="脱字符"><a class="header-anchor" href="#脱字符">¶</a>脱字符</h3>
<p>Shell中的一些功能是通过特殊符号作为控制字符来实现的，上面已经介绍了很多了。这产生一个问题，如果一个文件名中，刚好包含了这些字符，比如 ; ，就很难对它进行操作。使用 less 浏览这个文件</p>
<p>less ;xxx</p>
<p>less 会很快返回一个错误信息，因为并没有一个文件名作为操作对象。接着，Shell会报告，系统中没有 xxx 这个命令。</p>
<p>这是因为Shell将文件名中的 ; 解析为按顺序执行命令。</p>
<p>或者您的文件名以空白起始，而在Shell中，无论多少个空格，都将被解析为一个分隔符。您甚至不是使用命令重命名此文件。</p>
<p>这个时候就要用到脱字符 \ 了，它能够将一个具有特殊涵义的字符转换普通字符。上面的两个任务，可以在文件名中每个特殊字符前加一个 \ ，像这样</p>
<p>less ;xxx</p>
<p>less \ \xxx</p>
<p>less ;\ &amp;\xxx</p>
<p>说明：也可以使用 &quot; 将文件名括起来，例如 less &quot;; &amp;xxx&quot; ，在很多情况下，这样甚至更方便。</p>
<p>脱字符在Shell中也可以作为换行符，在一个命令的末尾添加一个 \ ，然后回车，在下一行继续输入命令剩余的部分，将一个命令拆分为多行且不影响它的执行（如果执行一个很长的命令，请将它拆分为多行以便于阅读）</p>
<p>事实上换行符也符合脱字符的定义。回车键有两个涵义，一个是 执行 （Enter），另一个 换行 （折线箭头）。在Shell中它作为控制字符 执行 ，使用脱字符后，它便代表排版字符 换行 了。</p>
<h3 id="Fish"><a class="header-anchor" href="#Fish">¶</a>Fish</h3>
<p>the friendly interactive shell</p>
<p>正如它的名字，Fish是一款非常友好的Shell，大力推荐！使用命令 sudo apt-get install fish 安装它。完成后，运行命令 fish 切换到fish， exit 返回bash。</p>
<p>简单介绍一下它的优点：</p>
<h4 id="1-自动补全、语法高亮"><a class="header-anchor" href="#1-自动补全、语法高亮">¶</a>1.自动补全、语法高亮</h4>
<p>bash的自动补全默认只是补全命令、路径，如果想补全变量、参数等，通常需要使用复杂的组合键（见上面bash的介绍），即便您能够记住它们，快</p>
<p>速准确的按下这些组合键，也是一种严峻的考验。而FISH的自动补全可以自动识别语法，补全正确的内容。并且具有语法高亮的功能，比如用MPLAYER放</p>
<p>MP3：</p>
<p>mpl<tab>(ayer) -l<tab>(oop) <tab>(0)</tab></tab></tab></p>
<p>-sh<tab>(uffle) -pl<tab>(aylist) <tab>(mp3_playlist)</tab></tab></tab></p>
<p>一阵猛按 <tab> 键，一个蛮长的命令就完成了。</tab></p>
<p>补全结果不唯一时给出的提示中含有简短的说明，这样通常也不用看帮助了：）比如：</p>
<p>mplayer -l</p>
<p><tab> 后，自动将参数补全为 -lo 然后给出提示</tab></p>
<p>-{lo}adidx (Load index from file) -{lo}op (Loop playback) {花括号中为青色文字}</p>
<p>它的语法高亮功能十分有用，如果你输入的命令是正确的，则用青色显示，正确的参数用白色显示，错误的则一律用红色。</p>
<h4 id="2-方便的历史纪录搜索"><a class="header-anchor" href="#2-方便的历史纪录搜索">¶</a>2.方便的历史纪录搜索</h4>
<p>还是上面的那个命令</p>
<p>mplayer -loop 0 -shuffle -playlist mp3_playlist</p>
<p>用上翻配合下翻浏览命令历史，直到找到这个命令，当然那样太慢了。</p>
<p>还可以输入以上命令中的某一部分，如 uffle 只要翻一次就可以找到了</p>
<p>（还可以META＋上翻在已输入部分中插入某一历史单词）</p>
<h4 id="3-文件夹历史纪录"><a class="header-anchor" href="#3-文件夹历史纪录">¶</a>3.文件夹历史纪录</h4>
<p>dirh （dir history）就可以显示当前会话中进入的文件夹纪录</p>
<p>使用 prevd 和 nextd 跳转</p>
<p>假如曾进入过1 2 3 4 5 这几个文件夹， prevd 4 可以让你在 5 中直接跳到 1</p>
<h4 id="4-其它的功能"><a class="header-anchor" href="#4-其它的功能">¶</a>4.其它的功能</h4>
<p>fish基本是兼容bash的。键绑定也非常的相似，少数的键绑定不尽一致，例如：</p>
<p>\C-h 删除光标前的一个字符（bash为退格键，不方便）</p>
<p>修改 /etc/fish_inputrc 这个文件，增加以下行：</p>
<p>&quot;\C-n&quot;: history-search-forward</p>
<p>&quot;\C-p&quot;: history-search-backward</p>
<p>现在使用Ctrl+p上翻，使用Ctrl+n下翻。如果已经在命令行中输入字符，那么Ctrl+p就是在历史纪录向上查找您输入的字符，Ctrl+n为向下查找，非常的方便。</p>
<p>设定您的默认Shell</p>
<p>如果能够拥有root权限，可以直接修改 /etc/passwd 文件。找到您用户ID起始的行</p>
<p>user:x:1000:112:user,,,:/home/user:/bin/bash</p>
<p>最后一个字段为登录后的默认Shell， /bin/bash 是程序 bash 的主程序路径。 fish 主程序的路径通常为 /usr/bin/fish 。</p>
<p>/etc/shells 中列出系统中所有可用Shell（ /bin/false 代表禁用Shell）</p>
<p>也可以使用如下命令更改您的默认Shell</p>
<p>chsh -s /usr/bin/fish</p>
<p>（需要输入您的密码）</p>
<p>Tip：可以使用 whereis xxx 命令，来查找 xxx 程序的安装位置，详见搜索</p>
<p>设定命令的搜索路径</p>
<p>使用 echo $PATH ，可以显示 $PATH 变量，输出如下：</p>
<p>/usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin /usr/bin/X11 /usr/games /usr/X11R6/bin</p>
<p>它是一个环境变量，代表执行命令时，Shell的搜索路径。</p>
<p>执行一个命令时，Shell会到 $PATH 变量定义的路径去搜索，并运行与命令同名的可执行文件。如果程序、脚本等可执行文件并不在上面的路径中，就必须使用绝对路径或者相对路径定位可执行文件。</p>
<p>例如：</p>
<p>/usr/local/mplayer -menu xxx.rmvb</p>
<p>/etc/init.d/powernowd start</p>
<p>cd /usr/local/ &amp;&amp; ./mplayer -menu xxx.rmvb</p>
<p>可以修改 /etc/environment 文件来设定您的命令搜索路径，找到 PATH 起始的行</p>
<p>PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin&quot;</p>
<p>在双引号中添加您的自定义路径，并以 : 分隔。</p>
<h2 id="Ubuntu系统简介"><a class="header-anchor" href="#Ubuntu系统简介">¶</a>Ubuntu系统简介</h2>
<h3 id="Ubuntu系统目录结构"><a class="header-anchor" href="#Ubuntu系统目录结构">¶</a>Ubuntu系统目录结构</h3>
<p>以下为Ubuntu目录的主要目录结构，您稍微了解它们都包含了哪些文件就可以了，不需要记忆。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ 根目录</span><br><span class="line">│</span><br><span class="line">├boot/ 启动文件。所有与系统启动有关的文件都保存在这里</span><br><span class="line">│ └grub/ Grub引导器相关的文件</span><br><span class="line">│</span><br><span class="line">├dev/ 设备文件</span><br><span class="line">├proc/ 内核与进程镜像</span><br><span class="line">│</span><br><span class="line">├mnt/ 临时挂载</span><br><span class="line">├media/ 挂载媒体设备</span><br><span class="line">│</span><br><span class="line">├root/ root用户的<span class="variable">$HOME</span>目录</span><br><span class="line">├home/</span><br><span class="line">│ ├user/ 普通用户的<span class="variable">$HOME</span>目录</span><br><span class="line">│ └.../</span><br><span class="line">│</span><br><span class="line">├bin/ 系统程序</span><br><span class="line">├sbin/ 管理员系统程序</span><br><span class="line">├lib/ 系统程序库文件</span><br><span class="line">├etc/ 系统程序和大部分应用程序的全局配置文件</span><br><span class="line">│ ├init.d/ SystemV风格的启动脚本</span><br><span class="line">│ ├rcX.d/ 启动脚本的链接，定义运行级别</span><br><span class="line">│ ├network/ 网络配置文件</span><br><span class="line">│ ├X11/ 图形界面配置文件</span><br><span class="line">├usr/</span><br><span class="line">│ ├bin/ 应用程序</span><br><span class="line">│ ├sbin/ 管理员应用程序</span><br><span class="line">│ ├lib/ 应用程序库文件</span><br><span class="line">│ ├share/ 应用程序资源文件</span><br><span class="line">│ ├src/ 应用程序源代码</span><br><span class="line">│ ├<span class="built_in">local</span>/</span><br><span class="line">│ │ ├soft/ 用户程序</span><br><span class="line">│ │ └.../ 通常使用单独文件夹</span><br><span class="line">│ ├X11R6/ 图形界面系统</span><br><span class="line">│</span><br><span class="line">├var/ 动态数据</span><br><span class="line">│</span><br><span class="line">├temp/ 临时文件</span><br><span class="line">├lost+found/ 磁盘修复文件</span><br></pre></td></tr></table></figure>
<h3 id="启动流程"><a class="header-anchor" href="#启动流程">¶</a>启动流程</h3>
<p>Linux系统主要通过以下步骤启动：</p>
<h4 id="1-读取MBR的信息，启动Boot-Manager"><a class="header-anchor" href="#1-读取MBR的信息，启动Boot-Manager">¶</a>1.读取MBR的信息，启动Boot Manager</h4>
<p>Windows使用NTLDR作为Boot</p>
<p>Manager，如果您的系统中安装多个版本的Windows，您就需要在NTLDR中选择您要进入的系统。</p>
<p>Linux通常使用功能强大，配置灵活的GRUB作为Boot Manager，我们将在启动管理章节中向您介绍它的使用方式。</p>
<h4 id="2-加载系统内核，启动init进程"><a class="header-anchor" href="#2-加载系统内核，启动init进程">¶</a>2.加载系统内核，启动init进程</h4>
<p>init进程是Linux的根进程，所有的系统进程都是它的子进程。</p>
<h4 id="3-init进程读取-etc-inittab文件中的信息，并进入预设的运行级别，按顺序运行该运行级别对应文件夹下的脚本。脚本通常以-start-参数启动，并指向一个系统中的程序。"><a class="header-anchor" href="#3-init进程读取-etc-inittab文件中的信息，并进入预设的运行级别，按顺序运行该运行级别对应文件夹下的脚本。脚本通常以-start-参数启动，并指向一个系统中的程序。">¶</a>3.init进程读取 /etc/inittab文件中的信息，并进入预设的运行级别，按顺序运行该运行级别对应文件夹下的脚本。脚本通常以 start 参数启动，并指向一个系统中的程序。</h4>
<p>通常情况下， <code>/etc/rcS.d/</code> 目录下的启动脚本首先被执行，然后是 <code>/etc/rcN.d/</code> 目录。例如您设定的运行级别为<code>3</code>,那么它对应的启动目录为 <code>/etc/rc3.d/</code> 。</p>
<h4 id="4-根据-etc-rcS-d-文件夹中对应的脚本启动-Xwindow服务器-xorg"><a class="header-anchor" href="#4-根据-etc-rcS-d-文件夹中对应的脚本启动-Xwindow服务器-xorg">¶</a>4.根据 /etc/rcS.d/文件夹中对应的脚本启动 Xwindow服务器 xorg</h4>
<p>Xwindow为Linux下的图形用户界面系统。</p>
<h4 id="5-启动登录管理器，等待用户登录"><a class="header-anchor" href="#5-启动登录管理器，等待用户登录">¶</a>5.启动登录管理器，等待用户登录</h4>
<p>Ubuntu系统默认使用GDM作为登录管理器，您在登录管理器界面中输入用户名和密码后，便可以登录系统。（您可以在 <code>/etc/rc3.d/</code> 文件夹中找到一个名为 <code>S13gdm</code> 的链接）</p>
<h3 id="更改运行级别"><a class="header-anchor" href="#更改运行级别">¶</a>更改运行级别</h3>
<p>在 /etc/inittab 文件中找到如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The default runlevel.</span></span><br><span class="line">id:2:initdefault:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一行中的数字 2 ,为系统的运行级别，默认的运行级别涵义如下：</span></span><br><span class="line"><span class="comment"># 0 关机    1 单用户维护模式   2~5 多用户模式  6 重启</span></span><br></pre></td></tr></table></figure>
<h3 id="服务管理"><a class="header-anchor" href="#服务管理">¶</a>服务管理</h3>
<p>更改启动服务</p>
<p>在运行级别对应的文件夹中，您可以看到许多文件名以 <code>S##</code> 和 <code>K##</code> 起始的启动脚本链接。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/rcS.d/S35mountall.sh 挂载文件系统</span><br><span class="line">/etc/rcS.d/S40networking 启用网络支持</span><br><span class="line">/etc/rc2.d/S13gdm 启动登录管理器</span><br><span class="line">/etc/rc2.d/S20makedev 创建设备文件</span><br><span class="line">/etc/rc2.d/S23xinetd 启动超级进程</span><br></pre></td></tr></table></figure>
<p>init进程将以 start 为参数，按文件名顺序执行所有以 S## 起始的脚本。脚本名称中的数字越小，它将被越早执行。例如在</p>
<p>/etc/rc2.d/ 文件夹中， S13gdm 文件名中的数字小于 S23xinetd , S13gdm 将比 S23xinetd 先执行。</p>
<p>如果一个脚本链接，以 K## 起始，表示它将以 stop 参数被执行。如果相应服务没有启动，则不执行该脚本。例如：</p>
<p>/etc/rc2.d/K20powernowd 针对某种硬件的电源管理支持</p>
<p>如果您想禁止某一服务在启动时自动运行，您可以将相应运行级别中的脚本由 S##xxx 重命名为 K##xxx 。</p>
<p>手动控制服务</p>
<p>您也可以手动运行带有以下参数的启动脚本，来控制系统服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- start 启动    - stop 停止    - restart 重启</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/rc2.d/K20powernowd start</span><br></pre></td></tr></table></figure>
<p>有时您并不清楚当前运行级别，该运行级别下未必有相应脚本；而且此类脚本的前三位字符并不固定，不便于记忆。这时，可以直接使用</p>
<p>/etc/init.d/ 文件夹中的启动脚本（ /etc/rcX.d/ 中的启动脚本链接到 /etc/init.d/</p>
<p>文件夹下相应脚本），这也是推荐的方式。</p>
<p>例如：</p>
<p>/etc/init.d/powernowd start</p>
<blockquote>
<p>Note：以上命令的位置并没有包含在环境变量的搜索路径中，所以要输入完整路径。</p>
</blockquote>
<h3 id="常用系统服务"><a class="header-anchor" href="#常用系统服务">¶</a>常用系统服务</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">acpi-support 高级电源管理支持     acpid acpi守护程序.这两个用于电源管理，非常重要</span><br><span class="line"></span><br><span class="line">alsa 声音子系统          alsa-utils</span><br><span class="line"></span><br><span class="line">anacron cron的子系统，将系统关闭期间的计划任务，在下一次系统运行时执行。</span><br><span class="line"></span><br><span class="line">apmd acpi的扩展         atd 类似于cron的任务调度系统。建议关闭</span><br><span class="line"></span><br><span class="line">binfmt-support 核心支持其他二进制的文件格式。建议开启         bluez-utiles 蓝牙设备支持</span><br><span class="line"></span><br><span class="line">bootlogd 启动日志。开启它         cron 任务调度系统，建议开启</span><br><span class="line"></span><br><span class="line">cupsys 打印机子系统。       dbus 消息总线系统(message bus system)。非常重要</span><br><span class="line"></span><br><span class="line">dns-clean 使用拨号连接时，清除dns信息。        </span><br><span class="line"></span><br><span class="line">evms 企业卷管理系统（Enterprise Volumn Management system）</span><br><span class="line"></span><br><span class="line">fetchmail 邮件用户代理守护进程，用于收取邮件         gdm gnome登录和桌面管理器。</span><br><span class="line"></span><br><span class="line">Gdomap       gpm 终端中的鼠标支持。      halt 别动它。</span><br><span class="line"></span><br><span class="line">hdparm 调整硬盘的脚本，配置文件为 /etc/hdparm.conf。       hibernate 系统休眠</span><br><span class="line"></span><br><span class="line">hotkey-setup 笔记本功能键支持。支持类型包括： HP, Acer, ASUS, Sony, Dell, 和IBM</span><br><span class="line"></span><br><span class="line">hotplug and hotplug-net 即插即用支持，比较复杂，建议不要动它</span><br><span class="line"></span><br><span class="line">hplip HP打印机和图形子系统       ifrename 网络接口重命名脚本。如果您有十块网卡，您应该开启它</span><br><span class="line"></span><br><span class="line">inetd 在文件 /etc/inetd.conf 中，注释掉所有你不需要的服务。如果该文件不包含任何服务，那关闭它是很安全的。       klogd 重要。</span><br><span class="line"></span><br><span class="line">linux-restricted-modules-common 受限模块支持。 /lib/linux-restricted-modules/ 文件夹中的模块为受限模块。例如某些驱动程序，如果您没有使用受限模块，就不需要开启它。</span><br><span class="line"></span><br><span class="line">lvm 逻辑卷管理系统支持。         makedev 创建设备文件，非常重要。      mdamd 磁盘阵列</span><br><span class="line"></span><br><span class="line">module-init-tools 从/etc/modules加载扩展模块，建议开启。</span><br><span class="line"></span><br><span class="line">networking 网络支持。按 /etc/network/interfaces 文件预设激活网络，非常重要。</span><br><span class="line"></span><br><span class="line">ntpdate 时间同步服务，建议关闭。      pcmcia pcmcia设备支持。      powernowd 移动CPU节能支持</span><br><span class="line"></span><br><span class="line">ppp and ppp-dns 拨号连接          readahead 预加载库文件。     reboot 别动它      </span><br><span class="line"></span><br><span class="line">resolvconf 自动配置DNS      rmnologin 清除nologin         rsync rsync守护程序</span><br><span class="line"></span><br><span class="line">sendsigs 在重启和关机期间发送信号      single 激活单用户模式         ssh ssh守护程序。建议开启</span><br><span class="line"></span><br><span class="line">stop-bootlogd 在2，3，4，5运行级别中停止bootlogd服务          sudo 检查sudo状态。重要</span><br><span class="line"></span><br><span class="line">sysklogd 系统日志       udev &amp; udev-mab 用户空间dev文件系统（userspace dev filesystem）。重要</span><br><span class="line"></span><br><span class="line">umountfs 卸载文件系统        urandom 随机数生成器        usplash 开机画面支持</span><br><span class="line"></span><br><span class="line">vbesave 显卡BIOS配置工具。保存显卡的状态      xorg-common 设置X服务ICE socket。</span><br><span class="line"></span><br><span class="line">adjtimex 调整核心时钟的工具       dirmngr 证书列表管理工具,和gnupg一起工作。</span><br><span class="line"></span><br><span class="line">hwtools irqs优化工具          libpam-devperm 系统崩溃之后，用于修理设备文件许可的守护程序。</span><br><span class="line"></span><br><span class="line">lm-sensors 板载传感器支持         mdadm-raid 磁盘陈列管理器        </span><br><span class="line"></span><br><span class="line">screen-cleanup 清除开机屏幕的脚本       xinetd 管理其他守护进程的一个inetd超级守护程序</span><br></pre></td></tr></table></figure>
<h3 id="重要配置文件"><a class="header-anchor" href="#重要配置文件">¶</a>重要配置文件</h3>
<blockquote>
<p>无论任何情况下，修改配置文件之前，先备份它！</p>
</blockquote>
<p>建议使用这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp xxx xxx_`date +%y%m%d_%H:%M`</span><br></pre></td></tr></table></figure>
<p>当然这很麻烦，您可以新建一个名为 bak 的文件，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">sudo cp <span class="variable">$1</span> <span class="variable">$1_</span>`date +%y%m%d_%H:%M`</span><br></pre></td></tr></table></figure>
<p>把它放在您能够记住的目录下，比如 <code>/home</code> ，执行命令 <code>sh /home/bak xxx</code> ，就可以将当前文件夹下的文件 <code>xxx</code> 另存为 <code>xxx_yymmdd_HH:MM</code> 的格式了</p>
<p>全局配置文件</p>
<p>系统初始化</p>
<p>/etc/inittab 运行级别、控制台数量        /etc/timezone 时区        /etc/inetd.conf 超级进程</p>
<p>文件系统</p>
<p>/etc/fstab 开机时挂载的文件系统         /etc/mtab 当前挂载的文件系统</p>
<p>用户系统</p>
<p>/etc/passwd 用户信息          /etc/shadow 用户密码          /etc/group 群组信息</p>
<p>/etc/gshadow 群组密码         /etc/sudoers Sudoer列表（请使用“visudo”命令修改此文件，而不要直接编辑）</p>
<p>Shell</p>
<p>/etc/shell 可用Shell列表       /etc/inputrc ReadLine控件设定       /etc/profile 用户首选项</p>
<p>/etc/bash.bashrc bash配置文件</p>
<p>系统环境</p>
<p>/etc/environment 环境变量      /etc/updatedb.conf 文件检索数据库配置信息         /etc/issue 发行信息</p>
<p>/etc/issue.net         /etc/screenrc 屏幕设定</p>
<p>网络</p>
<p>/etc/iftab 网卡MAC地址绑定       /etc/hosts 主机列表       /etc/hostname 主机名</p>
<p>/etc/resolv.conf 域名解析服务器地址       /etc/network/interfaces 网卡配置文件</p>
<p>用户配置文件</p>
<p>/etc/ 目录下的文件，只有root用户才有权修改。应用软件的全局配置文件，通常普通用户也不能够修改，如果要通过配置软件，来适应特殊需求，您可以修改用户配置文件。</p>
<p>用户配置文件通常为全局配置文件的同名隐藏文件，放在$HOME目录下，例如：</p>
<p>/etc/inputrc /home/user/.inputrc</p>
<p>/etc/vim/vimrc /home/user/.vim/vimrc</p>
<p>也有少数例外，通常是系统程序</p>
<h3 id="软件安装"><a class="header-anchor" href="#软件安装">¶</a>软件安装</h3>
<h4 id="DPKG"><a class="header-anchor" href="#DPKG">¶</a>DPKG</h4>
<p>Linux系统中，软件通常以源代码或者预编译包的形式提供。</p>
<p>软件源代码需要编译为二进制的机器代码才能够使用，安装比较耗时，不过您可以自行调节编译选项，决定需要的功能或组件，或者针对硬件平台作一些优化。</p>
<p>预编译的软件包，通常是由软件的发布者进行编译，您只要将软件拷贝到系统中就可以了。考虑到预编译软件包的适用性，预编译软件包通常不会针对某种硬件平台优化。它所包含的功能和组件也是通用的组合。</p>
<p>Ubuntu系统中，软件通常以 deb 格式的包文件发布，它是一种预编译软件包。deb包中除了包含已编译的软件，通常还包括软件的拷贝路径、对其它软件包的依赖关系纪录、比较通用的配置文件以及软件的描述、版本、作者、类别、占用空间等信息。</p>
<p>deb软件包命令遵行如下约定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">soft_ver-rev_arch.deb</span><br><span class="line">soft 软件包名称   ver 软件版本号    revUbuntu 修订版本号   arch 目标架构名称</span><br></pre></td></tr></table></figure>
<p>例如： azureus_2.4.0.2-0ubuntu2_all.deb</p>
<p>您需要使用 <code>dpkg</code> 命令来管理deb软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -i | --install xxx.deb 安装deb软件包</span><br><span class="line"></span><br><span class="line">dpkg -r | --remove xxx.deb 删除软件包</span><br><span class="line"></span><br><span class="line">dpkg -r -P | --purge xxx.deb 连同配置文件一起删除</span><br><span class="line"></span><br><span class="line">dpkg -I | -info xxx.deb 查看软件包信息</span><br><span class="line"></span><br><span class="line">dpkg -L xxx.deb 查看包内文件</span><br><span class="line"></span><br><span class="line">dpkg -l 查看系统中已安装软件包信息</span><br><span class="line"></span><br><span class="line">dpkg-reconfigure xxx 重新配置软件包</span><br></pre></td></tr></table></figure>
<p>有些时候，您使用 dpkg 安装一个软件包，系统会提示您该软件包依赖其它软件包。这时，您先安装其它软件包，直到满足依赖关系为止。或者同时安装多个软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg -i aaa.deb bbb.deb ccc.deb</span><br></pre></td></tr></table></figure>
<h4 id="APT"><a class="header-anchor" href="#APT">¶</a>APT</h4>
<p>如果一个软件依赖关系过于复杂，使用 <code>dpkg</code></p>
<p>来安装它，并不是一个明智的选择，这个时候您就需要用到APT软件包管理系统。APT可以自动的检查依赖关系，通过您预设的方式来获得相关软件包，并自动</p>
<p>安装配置它。事实上，在多数情况下，我们推荐您使用APT软件包管理系统。</p>
<p>APT系统需要一个软件信息数据库和至少一个存放着大量deb包的软件仓库，我们称之为 <code>源</code> 。 <code>源</code> 可以是网络服务器，安装CD或者本地软件仓库。您需要修改 <code>/etc/apt/sources.list</code> 文件，使APT系统能够连接到 <code>源</code>。</p>
<p>从以下页面中获得网络安装源的列表，并且根据您的网络环境，选择速度较快的源。</p>
<p><a href="http://wiki.ubuntu.org.cn/%E5%BF%AB%E9%80%9F%25E" target="_blank" rel="noopener">http://wiki.ubuntu.org.cn/快速%E</a>......%97/DapperDrake</p>
<p>APT系统主要包括 <code>apt-get</code> 和 <code>apt-cache</code> 等命令。通常是复合命令，包含若干个子命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install xxx 安装xxx</span><br><span class="line"> -d 仅下载       -f  强制安装 </span><br><span class="line"></span><br><span class="line">apt-get remove xxx 卸载xxx</span><br><span class="line"></span><br><span class="line">apt-get update 更新软件信息数据库</span><br><span class="line"></span><br><span class="line">apt-get upgrade 进行系统升级</span><br><span class="line"></span><br><span class="line">apt-cache search 搜索软件包</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：建议您经常使用 sudo apt-get update 命令来更新您的软件信息数据库</p>
</blockquote>
<blockquote>
<p>APT系统修复
由于各种意外，APT系统可能会出现问题，使用如下命令，尝试进行修复：apt-get -f install</p>
</blockquote>
<h3 id="源码包"><a class="header-anchor" href="#源码包">¶</a>源码包</h3>
<p>对于绝大多数软件，我们建议您使用APT系统来安装它。在少数情况下，例如某软件没有以deb包的格式发布，或者需要定制适合自己的软件，您可以通过编译源代码的方式安装它。</p>
<p>首先需要下载软件的源码包，并且将它解包为一些源代码文件。并了便于管理，建议将下载的源码包移动到 <code>/usr/local/src/</code> 目录下，并在这里解包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv xxx.tar.gz /usr/<span class="built_in">local</span>/src 移动源码包</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src 进入“/usr/<span class="built_in">local</span>/src/”目录</span><br><span class="line">sudo tar -xzvf xxx.tar.gz 解包源码</span><br><span class="line"><span class="built_in">cd</span> xxx_ver/ 进行解包后的源码目录</span><br></pre></td></tr></table></figure>
<p>源码目录中通常有一个 <code>configure</code> 脚本，用来配置即将开始的编译过程。您可以执行它</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./configure [--prefix=/usr/loca/xxx ......]</span><br></pre></td></tr></table></figure>
<p>它会自动检测软件的编译环境和依赖关系，并且生成 <code>Makefile</code> 文件。</p>
<p>使用带参数的命令 <code>./configure --help</code> ，或者阅读 <code>INSTALL</code> 文件，查看该脚本允许的参数。例如使用</p>
<p><code>--prefix=/usr/local/xxx</code> 参数，将软件的安装目录设定为 <code>/usr/local/xxx/</code>。（如果一定要将软件安装在单独目录下，建议您安装在这里）</p>
<p>现在执行 <code>make</code> 命令，系统会根据 <code>Makefile</code> 文件中的设定，通过 make 工具调用编译器和所需资源文件，将源代码编译成目标文件。</p>
<p>sudo make</p>
<p>执行 <code>make install</code> 命令， <code>make</code> 工具会自动连接目标文件和库文件，将最终生成的文件拷贝到 <code>Makefile</code> 文件设定的路径中，并且完成更改文件的属性，删除残留文件等活动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>现在，编译安装已经完成，为了更方便的使用它，需要给程序的可执行文件作一个符号链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ln -sf /usr/<span class="built_in">local</span>/xxx/可执行文件 /usr/<span class="built_in">local</span>/bin/可执行文件</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip:为了顺利的进行编译，至少需要安装 build-essential 软件包。
<code>sudo apt-get install build-essential</code></p>
</blockquote>
<h3 id="Xwindow简介"><a class="header-anchor" href="#Xwindow简介">¶</a>Xwindow简介</h3>
<p>Xwindow是工作站图形系统的工业标准，它有多种不同的实现，Ubuntu系统中使用的为Xorg。</p>
<p>（比较前卫的图形界面系统XGL，实际代替X服务器的作用，另外还有与之配套的窗口管理器）</p>
<h4 id="历史"><a class="header-anchor" href="#历史">¶</a>历史</h4>
<p>当然，Xwindow有悠久的历史和传统，不过那不在我们讨论的范围。您要注意的有两点：</p>
<ul>
<li>
<p>Xwindow 和 Xbox 中的“X”本意是不同的， X 只是 W 后的一个字母，差不多应该这样理解，Xwindow 是 Window 的接班人 （注意，Window不是Windows）</p>
</li>
<li>
<p>同样，也不要把 Xwindow 说成是 Xwindows，那是一种亵渎！一切伟大的创造，都应得到应有的理解和尊重。</p>
</li>
</ul>
<h4 id="架构及原理"><a class="header-anchor" href="#架构及原理">¶</a>架构及原理</h4>
<p>Xwindow使用服务器－客户端架构。无论本地图形界面，还是远程图形界面，都以同样的流程工作。这样便不需要分别进行设计和维护，极大的提高了网络透明性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">本地X客户端 ┐ ┌ 键盘</span><br><span class="line">远程X客户端 ┼ X协议 ─ X服务器 ─ 硬件规范 ┼ 鼠标</span><br><span class="line">远程X客户端 ┘ └ 显示器</span><br></pre></td></tr></table></figure>
<h4 id="Xserver"><a class="header-anchor" href="#Xserver">¶</a>Xserver</h4>
<p>Xwindow系统服务器端，通过驱动程序（硬件规范）来管理硬件资源。</p>
<p>例如：当我们移动鼠标时，通过驱动程序，向 Xserver 发送信息：</p>
<p>“向右移动200点，向上移动100点”（向右上移动）；“按下左键”……</p>
<p>Xserver作出如下响应：</p>
<p>1、上一次鼠标停止的坐标为600,500</p>
<p>2、向右200，向上100。现在鼠标位于坐标800,600</p>
<p>3、坐标800,600处，为窗口Firefox的“关闭”按钮</p>
<p>4、根据预设动作，将 “点击Firefox窗口的关闭按钮” 翻译为 “关闭窗口Firefox”</p>
<p>5、向X客户端Firefox发送一个“退出”消息</p>
<p>6、Xserver通过显示子系统（显卡、显示器），全程显示鼠标的位置和移动</p>
<p>* 事实上，向程序发送“退出”信号，通常窗口管理器完成……为了描述方便，这里暂不区分。稍后，我们将向您介绍 窗口管理器 的其它一些细节。</p>
<p>大多数的鼠标不需要专门的驱动程序，因为它们符合某一硬件规范，例如：有四个移动方向和三个键</p>
<h4 id="Xclient"><a class="header-anchor" href="#Xclient">¶</a>Xclient</h4>
<p>Xwindow系统客户端，通过X协议，实现与Xserver 的交互。</p>
<p>例如：</p>
<p>1、Xclient （假设Firefox） 接收Xserver的消息： 输入焦点在地址栏的范围内，“<a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”，回车</p>
<p>2、Firefox根据预设动作，将这些消息识别为 “打开链接 <a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”</p>
<p>3、Firefox向域名服务器请求 链接 “<a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”。域名服务器将这个请求转换为 “<a href="http://ubuntu.org.cn/%E2%80%9D" target="_blank" rel="noopener">http://ubuntu.org.cn/”</a> 和 IP地址211.148.131.7，发送回 Firefox</p>
<p>4、Firefox将 “<a href="http://ubuntu.org.cn/%E2%80%9D%E6%98%BE%E7%A4%BA%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%EF%BC%88%E5%90%91Xserver%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%BD%8D%E7%BD%AE%E6%98%BE%E7%A4%BA%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%EF%BC%89" target="_blank" rel="noopener">http://ubuntu.org.cn/”显示在地址栏（向Xserver发送请求，在地址栏位置显示这个地址）</a></p>
<p>5、Firefox向地址 211.148.131.7 请示显示页面。</p>
<p>6、Firefox将服务器发送回的页面显示在主窗口中</p>
<h4 id="Xprotocol"><a class="header-anchor" href="#Xprotocol">¶</a>Xprotocol</h4>
<p>Xwindow系统协议，Xserver和Xclient之间进行通信的规则</p>
<h4 id="窗口管理器"><a class="header-anchor" href="#窗口管理器">¶</a>窗口管理器</h4>
<p>Window Manager，一种特殊的Xclient。</p>
<p>使用窗口管理器时，Xserver并不直接与其它Xclient通信，而是通过WM中转，当一些消息被定义为WM指令时，它们会被拦截。例如Alt+F4关闭窗口、拖动标题栏……</p>
<p>消息“打开链接 <a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”，具体内容如下：</p>
<p>输入焦点在地址栏的范围内，“<a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”，回车</p>
<p>Xserver并不能直接判断焦点，而是这样：</p>
<p>1、Xserver向WM发送位置和点击的信息，WM根据当前的“焦点策略”确定激活（最上层）的窗口为Firefox</p>
<p>2、Xserver将Firefox显示在最上层，高亮显示它的标题栏</p>
<p>3、在窗口Firefox内点击地址栏，或者 Ctrl+L，Xserver将位置信息发送给WM，WM再发送给Firefox</p>
<p>4、Firefox判断当前焦点后，显示一个闪动的文字输入光标</p>
<p>5、Firefox将输入光标通过WM发送给Xserver，Xserver在屏幕相应位置进行显示</p>
<p>那么，“窗口管理器”到底能作些什么呢？其实它所作的一切都是管理窗口。例如：</p>
<p>1.最上层的窗口会把其它窗口挡住</p>
<p>2.它通常是一个“已激活窗口”，根据不同的“焦点策略”，窗口管理器确定被激活的窗口。</p>
<p>激活窗口标题栏高亮显示，接收大部分的键盘消息和窗口内的鼠标点击消息。</p>
<p>3.为了美观和容易分辨，大多数窗口都要有标题栏和边框。</p>
<p>为了方便，标题栏上还要有一些按钮，比如：最小化，最大化，关闭（这些按钮是窗口管理器请求的小窗口）</p>
<p>4.一个窗口可以在另一个窗口旁边显示，而不一定完全被遮挡。为了实现这一点，就要控制窗口显示的位置</p>
<p>5.为了控制窗口的显示位置，需要将整个屏幕用座标描述，最好的办法是绘制一个填充整个屏幕的窗口，也就是根窗口。</p>
<p>6.因为根窗口是最大的，所以它可以严严实实的遮挡任何窗口，为了避免这一点，根窗口永远在最底层。</p>
<p>这很形象的说明了为什么它叫作“根窗口” ……root</p>
<p>7.根窗口不一定只有一个，大多数的窗口管理器可以使用 “工作区” ，来切换显示多个根窗口</p>
<p>8.根窗口固定位置上通常放置一些其它Xclient的窗口，例如底部面板，顶部面板，侧面板，程序启动图标</p>
<p>9.面板上又可以放一些其它的Xclient窗口，如任务条，启动栏，菜单……</p>
<p>任务条可以以图标显示正在运行的任务，还可以作其它的杂活，像自动挂载USB设备……</p>
<p>启动流程</p>
<p>我们知道 init 是linux的根进程，是所有进程的父进程。同样， xinit是所有Xwindow进程的根进程</p>
<p>Startx</p>
<p>startx 命令可以在命令行下启动图形界面。执行startx 命令时，实际执行这一命令：</p>
<p>xinit /etc/X11/xinit/xinitrc -- /etc/X11/xinit/xserverrc</p>
<p>根据脚本 /etc/X11/xinit/xserverrc 启动Xserver，同时根据脚本 /etc/X11/xinit/xinitrc 启动指定Xclient进程，例如窗口管理器</p>
<p>脚本 /etc/X11/xinit/xserverrc 以预设的参数运行程序 /usr/bin/X11/X</p>
<p>/etc/X11/xinit/xinitrc 脚本则指向 /etc/X11/Xsession ，依次启动 /etc/X11/Xsession.d 目录中的脚本</p>
<p>* 您可以在用户配置文件 ~/.Xsession 中定义使用的WM，它的优先级高于全局配置文件(对于GDM会话不起作用)</p>
<p>* startx启动时，并不会再进行身份认证。因为它启动的是 /etc/X11/Xsession.d/gnome-session ，而不是 GDM会话</p>
<p>GDM会话</p>
<p>Ubuntu系统启动时自动进入图形界面，不需要运行 startx 命令</p>
<p>在某些启动级别中，包含了gdm的启动脚本，例如 ： /etc/rc2.d/S13gdm</p>
<p>\1. 指向 /etc/gdm/gdm-cdd.conf 文件，加载预设视觉主题，启动 /usr/lib/gdm/gdmgreeter（登录屏幕）</p>
<p>\2. 用户身份认证完成后，启动 /etc/X11/default-display-manager 这个文件中设定的默认窗口管理器 /usr/sbin/gdm</p>
<p>gdm在启动时，会要求用户名和密码，也就是我们看到的登录屏幕（gdmgreeter）</p>
<p>* /usr/share/xsessions 目录下为所有可用登录会话的脚本</p>
<p>配置文件</p>
<p>X服务器</p>
<p>X服务器的主要配置文件为 /etc/X11/xorg.conf</p>
<p>布局</p>
<p>Section &quot;ServerLayout&quot;</p>
<p>Identifier &quot;Default Layout&quot;</p>
<p>Screen &quot;Default Screen&quot; 0 0</p>
<p>InputDevice &quot;Generic Keyboard&quot;</p>
<p>InputDevice &quot;Configured Mouse&quot;</p>
<p>EndSection</p>
<p>* 定义了 布局标识 、 屏幕标识 、 键盘标识 、 鼠标标识</p>
<p>模块</p>
<p>Section &quot;Module&quot;</p>
<p>Load &quot;i2c&quot;</p>
<p>Load &quot;bitmap&quot;</p>
<p>Load &quot;ddc&quot;</p>
<p>Load &quot;dri&quot;</p>
<p>Load &quot;extmod&quot;</p>
<p>Load &quot;freetype&quot;</p>
<p>Load &quot;glx&quot;</p>
<p>Load &quot;int10&quot;</p>
<p>Load &quot;type1&quot;</p>
<p>Load &quot;vbe&quot;</p>
<p>EndSection</p>
<p>X核心字体路径</p>
<p>Section &quot;Files&quot;</p>
<p>FontPath &quot;/usr/share/X11/fonts/75dpi&quot;</p>
<p>FontPath &quot;/usr/share/X11/fonts/100dpi&quot;</p>
<p>FontPath &quot;/usr/share/X11/fonts/misc&quot;</p>
<p>FontPath &quot;/usr/share/X11/fonts/cyrillic&quot;</p>
<p>FontPath &quot;/usr/share/X11/fonts/100dpi/:unscaled&quot;</p>
<p>FontPath &quot;/usr/share/X11/fonts/75dpi/:unscaled&quot;</p>
<p>FontPath &quot;/usr/share/X11/fonts/Type1&quot;</p>
<p>FontPath &quot;/usr/share/fonts/Chinese/wqy-bitmapfont&quot;</p>
<p>EndSection</p>
<p>屏幕</p>
<p>Section &quot;Screen&quot;</p>
<p>Identifier &quot;Default Screen&quot;</p>
<p>Device &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;</p>
<p>Monitor &quot;DELL E176FP&quot;</p>
<p>DefaultDepth 24</p>
<p>SubSection &quot;Display&quot;</p>
<p>Depth 1</p>
<p>Modes &quot;1280x1024&quot; &quot;1152x864&quot; &quot;1024x768&quot; &quot;800x600&quot; &quot;720x400&quot; &quot;640x480&quot;</p>
<p>………………</p>
<p>EndSubSection</p>
<p>EndSection</p>
<p>* DefaultDepth 24 默认色深</p>
<p>* SubSection 可用色深及分辨率</p>
<p>显卡</p>
<p>Section &quot;Device&quot;</p>
<p>Identifier &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;</p>
<p>Driver &quot;fglrx&quot;</p>
<p>Option &quot;KernelModuleParm&quot; &quot;agplock=0&quot;</p>
<p>VideoRam 131072</p>
<p>EndSection</p>
<p>* Identifier 显卡标识</p>
<p>* Driver 显卡驱动（如不同正常启用图形界面，首先尝试&quot;vesa&quot;）</p>
<p>* Option 显卡参数</p>
<p>* VideoRam 显存大小</p>
<p>显示器</p>
<p>Section &quot;Device&quot;</p>
<p>Identifier &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;</p>
<p>Driver &quot;fglrx&quot;</p>
<p>Option &quot;KernelModuleParm&quot; &quot;agplock=0&quot;</p>
<p>VideoRam 131072</p>
<p>EndSection</p>
<p>配置文件内部结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/</span><br><span class="line">├/ <span class="string">"ServerLayout"</span> 布局</span><br><span class="line">│├ <span class="string">"InputDevice"</span> keyboard 键盘</span><br><span class="line">│├ <span class="string">"InputDevice"</span> mouse 鼠标</span><br><span class="line">││</span><br><span class="line">│└/ <span class="string">"Screen"</span> 显示子系统</span><br><span class="line">│ ├ <span class="string">"Monitor"</span> 显示器</span><br><span class="line">│ ├ <span class="string">"Device"</span> videocard 显卡</span><br><span class="line">│</span><br><span class="line">│</span><br><span class="line">├ <span class="string">"Files"</span> 字体</span><br><span class="line">└ <span class="string">"Module"</span> 模块</span><br></pre></td></tr></table></figure>
<p>X客户端</p>
<p>在 /etc/X11/Xsession 文件中可以发现下列内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OPTIONFILE=/etc/X11/Xsession.options</span><br><span class="line">SYSRESOURCES=/etc/X11/Xresources</span><br><span class="line">USRRESOURCES=<span class="variable">$HOME</span>/.Xresources</span><br><span class="line">SYSSESSIONDIR=/etc/X11/Xsession.d</span><br><span class="line">USERXSESSION=<span class="variable">$HOME</span>/.xsession</span><br><span class="line">ALTUSERXSESSION=<span class="variable">$HOME</span>/.Xsession</span><br><span class="line">ERRFILE=<span class="variable">$HOME</span>/.xsession-errors</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>OPTIONFILE=/etc/X11/Xsession.options</code> 设定X进程的启动参数。例如允许用户进程<code>allow-user-xsession</code></p>
</li>
<li>
<p><code>Xresources X</code>资源文件。许多程序保留了X接口，允许X服务器管理一些视觉选项，例如窗口内的字体，配色等</p>
</li>
<li>
<p><code>xsession X</code>进程。可以设置一些启动时自动运行的程序，也可以用来设定自己的窗口管理器（窗口管理器和桌面环境或者登录管理器是无关的）</p>
</li>
</ul>
<p>字体</p>
<p>freetype渲染引擎</p>
<p>作为Xorg服务器的一个模块，freetype的功能包括读取Truetype字体信息，如大小、分辨率、编码等，并以之为依据渲染字体 -</p>
<p>freetype2.x相对于freetype1.x 增加了抗锯齿等功能 - ( /etc/X11/xorg/conf 的 Module</p>
<p>字段中，可以选择字体渲染模块，建议使用默认的 freetype )</p>
<p>freetype只负责渲染字体。而查找字体，则可以由X服务器、X客户端或者字体服务器来完成。找到字体后，使用freetype引擎就地渲染</p>
<p>X核心字体</p>
<p>X服务器根据X客户端的请求（字符编码），查找字体并进行渲染，然后显示，我们称之为</p>
<p>Xft字体</p>
<p>X客户端自行查找字体并进行渲染，X服务器只负责显示</p>
<p>由于Xft字体的渲染在客户端完成，所以它可以动态的加载，而不需要随同X服务器一同启动</p>
<p>字体服务器</p>
<p>另外还有一种字体服务器模式，例如 XFT字体：当客户端请求字体时，X服务器将请求转发到字体服务器，由字体服务器查找字体，并使用freetype引擎渲染，将结果传回X服务器，X服务器进行显示……</p>
<p>X核心字体</p>
<p>/etc/X11/xorg.conf 中可以配置X核心字体的搜索路径</p>
<p>Section &quot;Files&quot;</p>
<p>FontPath &quot;/usr/X11R6/lib/X11/fonts/misc/&quot;</p>
<p>FontPath &quot;/usr/X11R6/lib/X11/fonts/Type1/&quot;</p>
<p>FontPath &quot;/usr/X11R6/lib/X11/fonts/Speedo/&quot;</p>
<p>FontPath &quot;/usr/X11R6/lib/X11/fonts/100dpi/&quot;</p>
<p>FontPath &quot;/usr/X11R6/lib/X11/fonts/75dpi/&quot;</p>
<p>EndSection</p>
<ul>
<li></li>
</ul>
<p>当X客户端向X服务器请求显示文字的时候，X服务器会按上面列表的先后顺序查找字体</p>
<p>例如显示中文时，如果第一个路径中的字体不包含中文，则查找下面的路径，直到发现中文字体</p>
<ul>
<li></li>
</ul>
<p>请将您偏好的字体放在靠前的位置</p>
<p>要使安装的字体能够作为X核心字体使用，将字体的安装路径添加到上面的列表中，使用 mkfontscale 、 mkfontdir</p>
<p>扫瞄文件夹中的字体，并生成索引，就可以了（建议使用 ttmkfdir 生成 fonts.scale ，将其复制为 fonts.dir ）</p>
<p>字体的选择及显示风格，可以修改GTK1的配置文件，或者在Xresources文件中对程序单独进行定义</p>
<p>事实上，在我们的日常应用中，X核心字体环境并不常见，使用GTK1图形库的程序、某些类型的终端……</p>
<p>* Emacs也是这样一个老派的程序……不过Emacs23中刚刚加入了xft字体的支持</p>
<p>XFT字体</p>
<p>Xft字体相关选项在 /etc/fonts/fonts.conf 文件中配置</p>
<p>可以使用 fc-cache 命令，递归扫瞄以下目录中的字体（包括子文件夹中的字体），建立字体缓存</p>
<p>/usr/share/X11/fonts</p>
<p>/usr/share/fonts</p>
<p>/usr/local/share/fonts</p>
<p>~/.fonts</p>
<p>* /etc/fonts/fonts.conf 文件的 <dir> 字段</dir></p>
<p>多数支持GTK2或者Qt图形库的X客户端能够使用Xft字体渲染技术</p>
<p>* GTK2为Gnome使用的图形库，Qt为KDE使用的图形库。相对来说，GTK2图形库在程序的GUI设计中更加通用</p>
<p>安装字体，只要将字体拷贝到以上任意目录， fc-cache -fv 刷新字体缓存即可 （参数: -f 强制刷新; -v 显示过程）</p>
<p>使用命令 fc-list 列出所有可用字体</p>
<p>字体的选择及显示风格，可以修改GTK2或者Qt的配置文件，建议使用图形界面配置</p>
<p>* 一般情况下，桌面环境中附带了相关程序，例如 gnome-font-properties</p>
<h3 id="系统管理"><a class="header-anchor" href="#系统管理">¶</a>系统管理</h3>
<h4 id="一些细节"><a class="header-anchor" href="#一些细节">¶</a>一些细节</h4>
<ul>
<li>
<p>Linux是大小写敏感的系统，所有的命令、路径、参数、变量……都区分大小写</p>
</li>
<li>
<p>使用 <code>TAB</code> 键补全命令，无论任何时候，多按几次TAB总会有所帮助</p>
</li>
<li>
<p>Shell的功能键能够协助您更高效的编辑命令，请熟悉其键绑定，尽量使用它</p>
</li>
<li>
<p>命令由 <code>命令名</code> 、 <code>分隔符</code> 、 <code>参数</code> 、 <code>操作对象</code> 构成</p>
</li>
</ul>
<h4 id="命令名"><a class="header-anchor" href="#命令名">¶</a>命令名</h4>
<p>标识命令的功能，例如cp(copy)、mv(move)、rm(remove)……</p>
<p>有些命令包含一些子命令，您可以认为它的命令名由两个单词构成，例如<code>apt</code>软件包管理系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install <span class="comment"># 安装一个软件</span></span><br><span class="line">apt-get remove  <span class="comment"># 删除一个软件</span></span><br></pre></td></tr></table></figure>
<h4 id="分隔符-2"><a class="header-anchor" href="#分隔符-2">¶</a>分隔符</h4>
<p>通常为空格，<code>多个连续的空格视为一个空格</code>，下面两个命令相同：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp a b</span><br><span class="line">cp   a   b</span><br></pre></td></tr></table></figure>
<p>有一些特殊符号也属于分隔符，例如 <code>管道 | 、重定向 &gt; 、 &gt;&gt; 、 &lt; 、后台运行 &amp; 、序列执行 &amp;&amp; 、 ; </code>。使用这些符号时，您不需要再使用<code>空格作为分隔符</code>，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -al|less</span><br></pre></td></tr></table></figure>
<p>写为以下形式，是为了让您更容易的阅读它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -al | less</span><br></pre></td></tr></table></figure>
<h4 id="参数"><a class="header-anchor" href="#参数">¶</a>参数</h4>
<p>精细调节命令的行为，以 <code>-</code> 引导，通常为参数名的首字母。许多软件都可以使用 <code>-h</code> 参数来阅读使用说明，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get -h</span><br></pre></td></tr></table></figure>
<p>也可以使用参数的全名，一般以 -- 引导，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>多数命令中，使用 - 引导多个字符，将会被视为多个参数，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get -<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>系统会解读为以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get -h -e -l -p</span><br></pre></td></tr></table></figure>
<p>少数命令的参数，不需要以 <code>-</code> 引导，或者使用 <code>-</code> 引导参数全名，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux</span><br><span class="line">/etc/init.d/gdm start</span><br><span class="line">mplayer -loop xxx</span><br></pre></td></tr></table></figure>
<p>需要对多个对象进行操作时，可以使用空格分隔符将它们隔开：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch 1 2 3 4 5 6</span><br></pre></td></tr></table></figure>
<p>使用空格分隔的多个对象，视为一个整体，作为命令的一个操作对象：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv 1 2 3 4 5 6 /home/</span><br></pre></td></tr></table></figure>
<p>这个命令把<code>1 2 3 4 5 6</code>作为一个操作对象，移动到另一个操作对象，<code>/home/</code>目录</p>
<p>递归 表示在子层次中重复相同操作。例如递归复制某目录，不但复制当前目录及其下的所有文件；而且对当前目录的子目录，也进行递归复制的操作。</p>
<h4 id="格式约定"><a class="header-anchor" href="#格式约定">¶</a>格式约定</h4>
<p>使用 <code>[]</code> 表示可选项，实际输入为方括号中的内容，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls [-al]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>ls</code>是必须的，参数不需要以方括号括起来。</p>
</li>
<li>
<p>使用 <code>&lt;&gt;</code> 表示必需项，实际输入为尖括号中的内容</p>
</li>
<li>
<p>使用 | 表示 或 ，以 | 分隔的项目不能同时使用，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar [-z|j c|x vf] &lt;归档文件&gt; [源文件]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参数通常紧跟命令名，除非必要，在命令格式中，我们通常省略它们</p>
<h3 id="系统信息"><a class="header-anchor" href="#系统信息">¶</a>系统信息</h3>
<h4 id="uptime"><a class="header-anchor" href="#uptime">¶</a>uptime</h4>
<p>联机信息-时间，显示如下</p>
<p>11:27pm up 9 days, 7:12, 3 user, load average: 0.07, 0.12, 0.14</p>
<p>当前系统时间 系统运行时间 当前在线用户数 系统负荷 1分钟前 5分钟前 15分钟前</p>
<h4 id="w"><a class="header-anchor" href="#w">¶</a>w</h4>
<p>联机信息-已登录用户，显示如下</p>
<p>01:04:10 up 1:34, 2 users, load average: 0.25, 0.16, 0.11</p>
<p>uptime 信息</p>
<p>USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT</p>
<p>user tty1 192.168.0.1 23:30 1:33 0.14s 0.12s -bash</p>
<p>用户名 登录方式 来源地址 登录时间 发呆时间 资源占用 当前任务</p>
<p>Tip：w [用户名称] : 显示某一用户相关信息</p>
<h4 id="who"><a class="header-anchor" href="#who">¶</a>who</h4>
<p>联机信息，常用参数</p>
<p>-r 运行级别</p>
<h4 id="whoami"><a class="header-anchor" href="#whoami">¶</a>whoami</h4>
<p>显示当前用户名</p>
<h4 id="last"><a class="header-anchor" href="#last">¶</a>last</h4>
<p>最近用户登录信息
-&lt;数字&gt; 使用数字作为参数，控制显示条目。例如
last -10 显示10条纪录</p>
<h4 id="uname"><a class="header-anchor" href="#uname">¶</a>uname</h4>
<p>系统信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-s 内核名称（默认参数）    -a 全部        -p CPU 信息       -n 主机名     </span><br><span class="line">-r 内核发行信息（版本号）  -v 内核版本信息</span><br></pre></td></tr></table></figure>
<h4 id="date"><a class="header-anchor" href="#date">¶</a>date</h4>
<p>显示、设定系统时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-u 显示格林尼洛时间（UTC）</span><br><span class="line"></span><br><span class="line">MMDDhhmm[[CC]YY][.ss] 设定时间，需要管理员权限。例如： date 12292359</span><br><span class="line"></span><br><span class="line">MM 月份 DD 天数 hh 小时 mm 分钟 CC 年份前两位 YY 年份后两位 ss 秒钟</span><br><span class="line"></span><br><span class="line">秒钟、年份为可选，例如： date 122923592006.59</span><br><span class="line"></span><br><span class="line">+[%X]设定显示格式，以下为date默认输出格式：</span><br><span class="line"></span><br><span class="line">date +%Y年%m月%d日%A%H:%M:%S%Z</span><br><span class="line"></span><br><span class="line">格式控制      %n 换行       %t 制表符</span><br><span class="line"></span><br><span class="line">小时          %H(00~23) %I(01~12) %k(0~23) %l(1~12) %p(AM|PM)</span><br><span class="line"></span><br><span class="line">分、秒        %M分钟(00~59)         %S秒(00..61)       %T(hh:mm:ss) %r(hh:mm:ss [AM|PM])</span><br><span class="line"></span><br><span class="line">%s 从1970年1月1日00:00:00 UTC到目前为止的秒数       %X(%H:%M:%S)         %Z时区</span><br><span class="line"></span><br><span class="line">星期          %a(Sun~Sat) %A(Sunday~Saturday) %w : 一周中的第几天 (0..6)</span><br><span class="line"></span><br><span class="line">年份          %Y(0000~9999) %y(00~99)</span><br><span class="line"></span><br><span class="line">月份          %m(01~12) %b %h(Jan~Dec) %B(January~December)</span><br><span class="line"></span><br><span class="line">日期          %d(01~31) %j(001~366)</span><br><span class="line"></span><br><span class="line">%x(本地格式mm/dd/yy) %D(mm/dd/yy) %c</span><br><span class="line"></span><br><span class="line">一年中的第几周</span><br><span class="line"></span><br><span class="line">%U(00~53)以Sunday为一周的第一天 %W(00~53)以Monday为一周的第一天</span><br></pre></td></tr></table></figure>
<h4 id="cal"><a class="header-anchor" href="#cal">¶</a>cal</h4>
<p>显示日历</p>
<h3 id="文件管理"><a class="header-anchor" href="#文件管理">¶</a>文件管理</h3>
<p>一些细节</p>
<p><code>/</code> 目录为文件系统根目录，所有目录都是它的子目录</p>
<p>绝对路径以 <code>/</code> 起始，相对路径以当前所在目录起始</p>
<p>目录是一种特殊类型的文件，如果没有特别指明， 文件 包括文件和目录</p>
<p><code>..</code> 表示上一级目录， <code>.</code> 表示当前目录，它们是两个特殊目录</p>
<h4 id="链接"><a class="header-anchor" href="#链接">¶</a>链接</h4>
<p>为当前文件建立在其它路径中的访问方法。例如将系统中其它位置的可执行文件，链接到 <code>/usr/local/bin</code> 目录下，使用命令调用。</p>
<p>ls [路径]</p>
<p>显示当前目录文件列表</p>
<p>--color 不同属性以不同颜色显示（默认参数）</p>
<p><em>-a</em> <em>全部显示</em>        <em>-i</em> <em>显示<strong>inode</strong>值</em>     <em>-l</em> <em>详细信息</em></p>
<p><em>-F</em> <em>显示文件类型后缀</em> <em>目录</em>*/* <em>链接</em>*@* <em>可执行文件</em>*** <em>端口文件</em>*=* <em>管道文件</em>*| &gt;*</p>
<p><em>-A</em> <em>显示隐藏文件</em>         <em>-R</em> <em>递归显示子目录文件列表</em>        <em>-S</em> <em>按文件大小排序</em></p>
<p><em>-t</em> <em>按修改时间排序</em>       <em>-u</em> <em>按访问时间排序</em>       <em>-d</em> <em>只显示目录，不递归显示目录下的文件</em></p>
<p>cd [目录路径] | [特殊路径]</p>
<p>切换目录</p>
<p>目录路径可以使用绝对路径或者相对路径特殊路径：</p>
<p><em>~ $HOME**目录（默认值）</em>     <em>-</em> <em>上一次目录</em>       <em>..</em> <em>上一级目录</em>       <em>.</em> <em>当前目录</em></p>
<p>说明：您可以通过修改 /etc/environment 文件，来定义 $CDPATH 变量，设定“cd”命令的搜索路径。</p>
<p>pwd</p>
<p>显示当前路径</p>
<p>file &lt;文件名&gt;</p>
<p>显示文件类型</p>
<p>*<strong>-i*</strong> ***显示mime****<strong>类型*</strong></p>
<p>du [路径]</p>
<p>计算文件或目录空间占用</p>
<p><em>-h</em> <em>人性化显示。自动以<strong>G</strong>、<strong>M</strong>、<strong>K</strong>为单位显示占用空间大小</em>         <em>-l</em> <em>重复计算硬链接文件大小</em></p>
<p><em>-L</em> <em>计算符号链接文件大小</em>     <em>-a</em> <em>显示当前目录子目录中的文件</em>         <em>-c</em> <em>显示文件数</em></p>
<p>less &lt;文件名&gt;</p>
<p>浏览文件，使用VI和Emacs两种风格的键绑定。以下为VI风格键绑定</p>
<p><em>Ctrl+f(orward)</em> <em>向下翻一页</em> <em>Ctrl+d(own)</em> <em>向下翻半页</em></p>
<p><em>Ctrl+b(ackward)</em> <em>向上翻一页</em> <em>Ctrl+u(p)</em> <em>向上翻半页</em>       <em>/</em> <em>查找</em> <em>q(uit)</em> <em>退出</em></p>
<p>touch &lt;目标文件&gt;</p>
<p>触碰，在不修改文件的前提下，更改其时间属性。通常用来创建一个空文件</p>
<p>mkdir &lt;文件夹&gt;</p>
<p>创建文件夹</p>
<p><em>-p &lt;<strong>多级目录</strong>&gt;</em> <em>按路径创建多级目录</em>      <em>-m &lt;<strong>数字权限值</strong>&gt;</em> <em>设定权限</em></p>
<p>cp &lt;源文件&gt; &lt;目标目录|文件&gt;</p>
<p>将源文件复制为目录文件，或者将源文件复制到目标目录。多个源文件使用空格分隔</p>
<p>cp &lt;源目录&gt; &lt;目标目录&gt;</p>
<p>将源目录复制到目标目录中，如果复制多个源目录，需要使用 -R 参数</p>
<p><em>-a</em> <em>相当于</em>*-dpr**参数*       <em>-d</em> <em>保留链接</em>        <em>-f</em> <em>强制复制，覆盖目标文件</em>         <em>-i</em> <em>覆盖时询问用户</em></p>
<p><em>-p</em> <em>保留修改时间和访问权限</em>        <em>-r -R</em> <em>递归复制（目录</em>*=&gt;*<em>目录）</em>     <em>-l</em> <em>创建链接</em></p>
<p><em>-v</em> <em>显示过程</em></p>
<p>rm &lt;目标目录|文件&gt;</p>
<p>删除</p>
<p><em>-r -R</em> <em>递归删除</em>      <em>-f</em> <em>强制删除（无需确认，直接删除。慎用！）</em>        <em>-i</em> <em>交互式删除（询问用户）</em></p>
<p>rmdir &lt;目标目录&gt;</p>
<p>删除目录时，建议您使用“rm -r”命令</p>
<p>mv &lt;源文件&gt; &lt;目标目录|文件&gt;</p>
<p>相当于cp后删除源文件，也可以作为“重命名”使用。</p>
<p>mv &lt;源目录&gt; &lt;目标目录&gt;</p>
<p><em>-r -R</em> <em>递归</em></p>
<p>ln &lt;源文件&gt; &lt;链接&gt;</p>
<p>链接</p>
<p><em>-s</em> <em>符号链接</em>        <em>-f</em> <em>强制链接，覆盖目标文件</em>         <em>-i</em> <em>覆盖前询问用户</em></p>
<h3 id="文件操作"><a class="header-anchor" href="#文件操作">¶</a>文件操作</h3>
<p>nano</p>
<p>一个简单轻便的文本编辑器，使用Emacs风格的键绑定。</p>
<p>split &lt;源文件&gt; [目标文件名前缀]</p>
<p>将源文件按一定规则分割成若干个目标文件。默认文件名前缀为 x</p>
<p><em>-&lt;<strong>行数</strong>&gt;</em> <em>按行数分割文件</em>      <em>-l &lt;<strong>行数</strong>&gt;</em> <em>同上</em></p>
<p><em>-b &lt;<strong>字节</strong>&gt;</em> <em>按大小分割文件。可以使用<strong>b</strong>、<strong>k</strong>、<strong>m</strong>作单位，不指定单位的情况下，默认单位为**b</em></p>
<p><em>-C &lt;<strong>字节</strong>&gt;</em> <em>按大小分割文件，并尽量保持每行的完整</em></p>
<p>示例：split -C 100k file.split x</p>
<p>cat &lt;文件名&gt;</p>
<p>输出文件内容。用空格分隔多个文件名，可以将多个文件内容连接到一起输出。使用重定向合并为一个文件</p>
<p><em>-n</em> <em>在输出中添加行号</em>          <em>-b</em> <em>在输出中添加行号，空行不编号</em></p>
<p><em>-s</em> <em>将两行或以上的空行，合并为一个空行</em></p>
<p>示例：cat xaa xab xac &gt; file.split</p>
<p>sort [-o &lt;输出文件&gt;] [-t &lt;分隔字符&gt;] [+&lt;起始字段&gt; - &lt;结束字段&gt;] [文件]</p>
<p>对文本内容排序</p>
<p><em>-m</em> <em>合并文件</em>        <em>-c</em> <em>检查文件是否已按规则排序</em>      <em>-b</em> <em>忽略行首空格字符</em></p>
<p><em>-u</em> <em>忽略内容重复行</em>       <em>-f</em> <em>忽略大小写</em>       <em>-l</em> <em>忽略非打印字符</em>       <em>-M</em> <em>作为月份比较</em></p>
<p><em>-d</em> <em>按字典顺序排序，按照字母、数字、空格、制表符排序</em>      <em>-r</em> <em>逆序输出</em></p>
<p>more</p>
<p>查看文件内容，我们建议您使用 less</p>
<p>diff &lt;文件名&gt;</p>
<p>比较文件</p>
<p>cksum [文件名]</p>
<p>计算文件的CRC值。不指定文件名则从标准输入设备读入数据，例如：</p>
<p>echo xxx | cksum</p>
<p>md5sum [文件名] 计算文件的md5值。同上</p>
<h3 id="权限管理"><a class="header-anchor" href="#权限管理">¶</a>权限管理</h3>
<p>一些细节</p>
<p>一个文件主要包含下列属性， ls -l</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- rwx rwx rwx user group date filename</span><br><span class="line"></span><br><span class="line">111 101 101</span><br></pre></td></tr></table></figure>
<p>其中，第一组为归属用户的权限，第二组为归属群组的权限，第三组为其它用户群组的权限。user为文件的归属用户，group为文件的归属群组，date为日期信息，filename为文件名。</p>
<p>对于文件夹，必须拥有它的可执行权限，才能够使用 cd 命令进入该文件夹；拥有可读权限，才能够使用 ls 命令查看该文件夹的文件列表。</p>
<p>root用户拥有最高权限。</p>
<p>可以使用3位的二进制数字来描述一组权限，某一权限对应的数字为1,则表示具有该种权限，为0,则不具有该种权限。</p>
<p>使用二进制数字来描述一组权限，虽然非常直观，但是3组权限需要用9位数来表示，使用不够方便。因此我们将三组权限使用3位8进制数字来表示。它们的对应关系为：</p>
<p>r 100 4</p>
<p>w 010 2</p>
<p>x 001 1</p>
<p>将这三位8进制数字相加的结果，就可以表示该组权限的具体内容，例如：</p>
<p>7=4+2+1=rwx</p>
<p>5=4+1=rx</p>
<p>755=4+2+1 4+1 4+1=rwx r-x r-x</p>
<p>还可以使用 a 、 u 、 g 、 o 表示归属关系，使用 = 、 + 、 - 表示权限变化，使用 r 、 w 、 x 表示权限内容，</p>
<p>a 所有用户 u 归属用户 g 归属群组 o 其它用户</p>
<p>= 具有权限 + 增加权限 - 去除权限</p>
<p>r 可读权限 w 可写权限 x 可执行权限</p>
<p>例如：</p>
<p>a+x 给所有用户增加可执行权限</p>
<p>go-wx 将归属群组和其它用户的可写、可执行权限去掉</p>
<p>u=rwx 归属用户具有可读、可写、可执行权限</p>
<p>chmod &lt;权限表达式&gt; &lt;文件|目录&gt;</p>
<p>更改文件的权限。权限的表达式可以使用三位8进制数字表示，或者使用 augo +-= rxw-s 来表示</p>
<p>-R 递归</p>
<p>-v 显示过程</p>
<p>-c 类似“-v”，仅显示更改部分</p>
<p>--reference=&lt;参考文件或目录&gt; 以指定文件为参考更改权限</p>
<p>示例：</p>
<p>chmod -R a+x path</p>
<p>chmod -Rv 755 path</p>
<p>chown &lt;归属用户&gt;[:归属群组] &lt;文件|目录&gt;</p>
<p>更改文件的归属用户。可以使用用户名或者UID</p>
<p><em>-R</em> <em>递归</em>       <em>-v</em> <em>显示过程</em>        <em>-c</em> <em>类似</em> <em>-v</em> <em>，仅显示更改部分</em></p>
<p>--reference=&lt;参考文件或目录&gt; 以指定文件为参考更改权限</p>
<p>示例：</p>
<p>chown user:admin path          chown -R user.admin path       chown user path</p>
<p>chgrp &lt;归属群组&gt; &lt;文件|目录&gt;</p>
<p>更改文件的归属群组。可以使用群组名或者GID</p>
<p>参数同上</p>
<p>SUID、SGID、Sticky bit</p>
<p>某些情况下，需要以可执行文件归属用户的身份执行该文件，可以为该文件设置SUID。同样，设置SGID能够以该文件归属群组的身份执行它。</p>
<p>例如：用户自行设定密码。出于安全方面的考虑， /etc/shadow 只能由root用户直接修改。</p>
<p>-rw------- root root /etc/shadow</p>
<p>这个时候，可以为程序 /usr/bin/passwd</p>
<p>设置SUID，当普通用户执行“passwd”命令时，便能够以该程序归属用户root的身份修改 /etc/shadow</p>
<p>文件。而“passwd”程序自身带有身份验证机制，不能通过验证时拒绝执行，从而保证了安全。</p>
<p>ls -l /usr/bin/passwd</p>
<p>-r-s--x--x root root /usr/bin/passwd</p>
<p>我们发现，归属用户的可执行权限位使用 s ，表示SUID。同样，归属群组的可执行权限位使用 s ，表示SGID。任何用户或群组都拥有</p>
<p>其它用户 的权限，所以不需要以 其它用户 身份执行文件，其它用户的可执行权限位便不会出现 s 。该权限位可能出现的属性为 t</p>
<p>，也就是粘着位Sticky bit。</p>
<p>ls -ld /tmp</p>
<p>drwxrwxrwt root root /tmp</p>
<p>粘着位表示任何用户都可能具有写权限，但只有该归属用户或root用户才能够删除</p>
<p>SUID、SGID、Sticky bit也可以像权限一样，使用一个八进制数表示，如下：</p>
<p>4 SUID</p>
<p>2 SGID</p>
<p>1 Sticky bit</p>
<p>通过在“chmod”命令中使用4个八进制数的表达式，如 4755 ，用第一位表示SUID、SGID、或Sticky bit，便能够为文件设置这些特殊权限。示例：</p>
<p>chmod -R 4755 path</p>
<p>lsattr [路径]</p>
<p>查看文件的特殊属性</p>
<p><em>-a</em> <em>全部显示</em>        <em>-d</em> <em>只显示目录</em>      <em>-R</em> <em>递归</em></p>
<p>特殊属性包括：</p>
<p><em>a</em>*：仅供附加用途*         <em>b</em>*：不更新最后存取时间*       <em>c</em>*：压缩后存放*      <em>d</em>*：排除在倾倒操作之外*</p>
<p><em>i</em>*：不得任意更动文件或目录*        <em>s</em>*：保密性删除文件或目录*     <em>S</em>*：即时更新文件或目录*</p>
<p><em>u</em>*：预防以外删除*</p>
<p>chattr +|-|=&lt;属性&gt; &lt;路径&gt;</p>
<p>更改文件特殊属性</p>
<p><em>-R</em> <em>递归</em>       <em>-V</em> <em>显示过程</em></p>
<h3 id="压缩解压"><a class="header-anchor" href="#压缩解压">¶</a>压缩解压</h3>
<p>tar -c|x|u|r|t[z|j][v] -f &lt;归档文件&gt; [未打包文件]</p>
<p>将多个文件打包为一个归档文件，可以在打包的同时进行压缩。支持的格式为tar（归档）、gz（压缩）、bz2（压缩率更高，比较耗时）</p>
<p><em>-c</em> <em>创建</em>        <em>-x</em> <em>解包</em>        <em>-u</em> <em>更新</em>        <em>-r</em> <em>添加</em>        <em>-t</em> <em>查看</em></p>
<p><em>-d</em> <em>比较压缩包内文件和文件</em>        <em>-A</em> <em>将<strong>tar</strong>文件添加到归档文件中</em>         <em>-z</em> <em>使用<strong>gz</strong>压缩格式</em></p>
<p><em>-j</em> <em>使用<strong>bz2</strong>压缩格式</em>      <em>-v</em> <em>显示过程</em>        <em>-f &lt;<strong>文件名</strong>&gt;</em> <em>归档文件的文件名</em></p>
<p><em>-C &lt;<strong>解压路径</strong>&gt;</em> <em>将压缩包中的文件解压到指定目录</em></p>
<p>[未打包文件] 创建、更新时必须填写</p>
<p>示例：</p>
<p>tar -zcvf xxx.tar.gz xxx/ xxx1 xxx2 xxx3 多个待打包文件以空格分隔</p>
<p>tar -zcvf xxx.tar.gz /home/user/xxx/ 使用绝对路径打包，解包也使用绝对路径</p>
<p>tar -zxvf xxx.tar.gz 按相对路径解包到当前目录下，或按绝对路径解包</p>
<p>tar -zcvf xxx.tar.gz xxx | split -b 1m 打包后，使用split分割为1m大小的多个文件</p>
<p>其它参数</p>
<p><em>-P</em> <em>使用绝对路径压缩时，保留根目录</em>*“/”       -W* <em>校验</em>       <em>-p</em> <em>还原文件权限</em></p>
<p><em>-w</em> <em>询问用户</em>        <em>--totals</em> <em>统计</em>        <em>-T &lt;<strong>表达式</strong>&gt;</em> <em>处理符合条件的文件</em></p>
<p><em>-X &lt;<strong>表达式</strong>&gt;</em> <em>排除符合条件的文件</em></p>
<p>zip [参数] &lt;压缩包&gt; &lt;源文件&gt;</p>
<p>使用zip格式打包文件</p>
<p><em>-r</em> <em>递归，将指定目录下的所有文件和子目录一并处理</em>          <em>-S</em> <em>包含系统和隐藏文件</em></p>
<p><em>-y</em> <em>直接保存符号连接，而非该连接所指向的文件</em>         <em>-X</em> <em>不保存额外的文件属性</em></p>
<p><em>-m</em> <em>将文件压缩并加入压缩文件后，删除源文件</em></p>
<p>-&lt;压缩级别&gt; 1~9，数字越大，压缩率越高</p>
<p><em>-F</em> <em>尝试修复已损坏的压缩文件</em>      <em>-T</em> <em>检查备份文件内的每个文件是否正确无误</em></p>
<p><em>-q</em> <em>不显示指令执行过程</em>        <em>-g</em> <em>将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件</em></p>
<p><em>-u</em> <em>更新压缩包内文件</em></p>
<p><em>-f</em> <em>更新压缩包内文件。如果符合条件的文件没有包含在压缩包中，则压缩后添加</em></p>
<p><em>-$</em> <em>保存第一个被压缩文件所在磁盘的卷标</em>      <em>-j</em> <em>只保存文件名称及其内容</em></p>
<p><em>-D</em> <em>压缩文件内不建立目录名称</em>      <em>-i &lt;<strong>表达式</strong>&gt;</em> <em>压缩目录时，只压缩符合条件的文件</em></p>
<p><em>-x &lt;<strong>表达式</strong>&gt;</em> <em>排除符合条件的文件</em>        <em>-n &lt;<strong>文件名后缀</strong>&gt;</em> <em>排除指定文件名后缀的文件</em></p>
<p><em>-b &lt;<strong>缓存路径</strong>&gt;</em> <em>指定临时文件目录</em>        <em>-d &lt;<strong>表达式</strong>&gt;</em> <em>从压缩文件内删除指定的文件</em></p>
<p><em>-t &lt;<strong>日期时间</strong>&gt;</em> <em>把压缩文件的日期设成指定的日期</em></p>
<p><em>-o</em> <em>以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同</em></p>
<p><em>-A</em> <em>调整可执行的自动解压缩文件</em>         <em>-c</em> <em>替每个被压缩的文件加上注释</em></p>
<p><em>-z</em> <em>替压缩文件加上注释</em>        <em>-k</em> <em>使用<strong>MS-DOS</strong>兼容格式的文件名称。</em></p>
<p><em>-l</em> <em>压缩文件时，把<strong>LF</strong>字符置换成<strong>LF+CR</strong>字符。</em>         <em>-ll</em> <em>压缩文件时，把<strong>LF+CR</strong>字符置换成<strong>LF</strong>字符。</em></p>
<p>unzip [参数] &lt;压缩文件&gt; [压缩包中将被释放的文件]</p>
<p>解压zip压缩包文件</p>
<p><em>-P &lt;<strong>密码</strong>&gt; zip**压缩包的密码</em>         <em>-d &lt;<strong>路径</strong>&gt;</em> <em>指定解压路径</em>      <em>-n</em> <em>解压缩时不覆盖原有文件</em></p>
<p><em>-f</em> <em>覆盖原有文件</em>         <em>-o</em> <em>不经询问，直接覆盖原有文件</em></p>
<p><em>-u</em> <em>覆盖原有文件，并将压缩文件中的其他文件解压缩到目录中</em></p>
<p><em>-l</em> <em>显示压缩文件内所包含的文件</em>         <em>-t</em> <em>检查压缩文件是否正确</em>      <em>-z</em> <em>显示压缩包注释</em></p>
<p><em>-Z unzip -Z<strong>等于执行</strong>zipinfo**指令</em>          <em>-j</em> <em>不处理压缩文件中原有的目录路径</em></p>
<p><em>-C</em> <em>压缩文件中的文件名称区分大小写</em>         <em>-L</em> <em>将压缩文件中的全部文件名改为小写</em></p>
<p><em>-s</em> <em>将文件名中的空格转换下划线</em>         <em>-X</em> <em>解压缩时保留文件原来的**UID/GID</em></p>
<p><em>-q</em> <em>执行时不显示任何信息</em>               <em>-v</em> <em>执行是时显示详细的信息</em></p>
<p><em>-c</em> <em>将解压缩的结果显示到屏幕上，并对字符做适当的转换</em></p>
<p><em>-p</em> <em>与</em>*-c**参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换*</p>
<p><em>-a</em> <em>对文本文件进行必要的字符转换</em>            <em>-b</em> <em>不要对文本文件进行字符转换</em></p>
<p><em>-x &lt;<strong>表达式</strong>&gt;</em> <em>处理里排除压缩包中的指定文件</em>            <em>-M</em> <em>将输出结果送到<strong>more</strong>程序处理</em></p>
<p>7z|7za &lt;子命令&gt; [参数] &lt;压缩包&gt; [文件]</p>
<p>子命令</p>
<p><em>a</em> <em>添加</em>    <em>d</em> <em>删除</em>    <em>e</em> <em>解压</em>    <em>x</em> <em>带路径解压</em>  <em>l</em> <em>列表查看</em>     <em>t</em> <em>测试</em>    <em>u</em> <em>更新</em></p>
<p>参数</p>
<p><em>-m&lt;<strong>压缩方式</strong>&gt;      -m0=&lt;<strong>压缩算法</strong>&gt;</em> <em>默认使用**lzma         -mx=&lt;1~9&gt;</em> <em>压缩级别</em></p>
<p><em>-mfb=64 number of fast bytes for LZMA = 64      -md=&lt;<strong>字典大小</strong>&gt;</em> <em>设置字典大小，例如</em> <em>-md=32m</em></p>
<p><em>-ms=&lt;on|off&gt;</em> <em>是否固实压缩</em>        <em>-o&lt;<strong>输出目录</strong>&gt;</em> <em>设置输出目录</em>        <em>-p[<strong>密码</strong>]</em> <em>使用密码</em></p>
<p><em>-r[<strong>数字</strong>]</em> <em>递归，使用数字定义递归子目录的深度</em>          <em>-sfx[&lt;<strong>模块名称</strong>&gt;]</em> <em>使用自解压模块</em></p>
<p><em>-si</em> <em>从标准输入设备读入数据</em>        <em>-so</em> <em>将数据写入标准输出设备</em>       <em>-y</em> <em>所有询问均回答**Yes</em></p>
<p><em>-w&lt;<strong>工作目录</strong>&gt;</em></p>
<p>rar &lt;子命令&gt; [参数] &lt;压缩包&gt; [文件|文件列表|路径]</p>
<p>子命令</p>
<p><em>x</em> <em>带路径解压</em>       <em>e</em> <em>解压到当前目录</em>        <em>a</em> <em>将文件添加到压缩包内</em>      <em>d</em> <em>从压缩包中删除文件</em></p>
<p><em>u</em> <em>更新压缩包内文件</em>      <em>f</em> <em>更新压缩包内文件，并添加压缩包内不存在的文件</em>      <em>m</em> <em>添加并删除源文件</em></p>
<p><em>r</em> <em>修复</em>        <em>l</em> <em>列表查看压缩包内文件信息</em> <em>lt</em> <em>更详细信息</em> <em>lb</em> <em>简短信息</em>      <em>c</em> <em>添加压缩包注释</em></p>
<p>cf &lt;文件名&gt; 将文件内容添加为注释</p>
<p>cw &lt;文件名&gt; 将注释保存为文件</p>
<p>t 测试压缩包       rr 添加恢复纪录         rv 恢复到文件</p>
<p>参数</p>
<p>-p&lt;密码&gt; 设置密码</p>
<p>-m&lt;0~5&gt; 设置压缩级别，数字越大，压缩级别越高</p>
<h3 id="搜索"><a class="header-anchor" href="#搜索">¶</a>搜索</h3>
<p>whereis &lt;程序名称&gt;</p>
<p>查找软件的安装路径</p>
<p><em>-b</em> <em>只查找二进制文件</em>          <em>-m</em> <em>只查找帮助文件</em>      <em>-s</em> <em>只查找源代码</em>    <em>-u</em> <em>排除指定类型文件</em></p>
<p><em>-f</em> <em>只显示文件名</em>         <em>-B &lt;<strong>目录</strong>&gt;</em> <em>在指定目录下查找二进制文件</em></p>
<p><em>-M &lt;<strong>目录</strong>&gt;</em> <em>在指定目录下查找帮助文件</em>        <em>-S &lt;<strong>目录</strong>&gt;</em> <em>在指定目录下查找源代码</em></p>
<p>locate &lt;文件名称&gt;</p>
<p>在文件索引数据库中搜索文件</p>
<p>-d &lt;数据库路径&gt; 搜索指定数据库</p>
<p>updatedb 更新文件索引数据库</p>
<p>find [路径] &lt;表达式&gt;</p>
<p>查找文件</p>
<p>-name &lt;表达式&gt; 根据文件名查找文件</p>
<p>-iname &lt;表达式&gt; 根据文件名查找文件，忽略大小写</p>
<p>-path &lt;表达式&gt; 根据路径查找文件</p>
<p>-ipath &lt;表达式&gt; 根据路径查找文件，忽略大小写</p>
<p>-amin &lt;分钟&gt; 过去N分钟内访问过的文件</p>
<p>-atime &lt;天数&gt; 过去N天内访问过的文件</p>
<p>-cmin &lt;分钟&gt; 过去N分钟内修改过的文件</p>
<p>-ctime &lt;天数&gt; 过去N天内修改过的文件</p>
<p>-anewer &lt;参照文件&gt; 比参照文件更晚被读取过的文件</p>
<p>-cnewer &lt;参照文件&gt; 比参照文件更晚被修改过的文件</p>
<p>-size &lt;大小&gt; 根据文件大小查找文件，单位b c w k M G</p>
<p>-type &lt;文件类型&gt; 根据文件类型查找文件。b 块设备 c 字符设备 d 目录 p 管道文件 f 普通文件 l 链接 s 端口文件</p>
<p>-user &lt;用户名&gt; 按归属用户查找文件</p>
<p>-uid <uid> 按UID查找文件</uid></p>
<p>-group &lt;群组名&gt; 按归属群组查找文件</p>
<p>-gid <gid> 按GID查找文件</gid></p>
<p>-empty 查找空文件</p>
<p>grep &lt;字符串&gt;|&quot;&lt;正则表达式&gt;&quot; [文件名]</p>
<h3 id="其它"><a class="header-anchor" href="#其它">¶</a>其它</h3>
<p>echo &lt;字符串&gt;</p>
<p>回显。较复杂的字符串，可以使用 &quot; 括起来。</p>
<p><em>-n</em> <em>输出内容不换行</em>       <em>-E</em> <em>不解析脱字符</em>         <em>-e</em> <em>解析脱字符</em></p>
<p>控制字符</p>
<p>** <em>反斜线</em>       <em>a</em> <em>警告</em>        <em>b</em> <em>退格</em>        <em>n</em> <em>换行</em>        <em>r</em> <em>回车</em>        <em>t</em> <em>水平制表符</em></p>
<p>clear</p>
<p>消除屏幕</p>
<p>alias &lt;输入内容&gt; &lt;实际内容&gt;</p>
<p>别名，为命令指定一个别名，以简化输入。例如：</p>
<p>alias ls='ls --color=auto'</p>
<p>alias ls=&quot;l -CF&quot;</p>
<p>可以将您的定义保存在 ~/.bashrc 文件中。</p>
<p>export &lt;变量名称&gt;</p>
<p>将变量导出为环境变量，常写变量赋值一同使用，例如：</p>
<p>export PATH=&quot;$PATH:xxx&quot;</p>
<p>其中 $PATH 表示变量 PATH 原值</p>
<p>shutdown</p>
<p>关闭计算机，向根进程 init 发送信号，更改 runlevel 为 0 (halt)</p>
<p><em>-h</em> <em>关闭电源</em>        <em>-r</em> <em>重启</em>        <em>-n</em> <em>强行关机，不向</em> <em>init**进程</em> <em>发送信号</em></p>
<p><em>-k</em> <em>模拟关机，向登录者发送关机警告</em>          <em>-t &lt;<strong>秒</strong>&gt; N**秒后关机</em>       <em>time &lt;<strong>时间</strong>&gt;</em> <em>定时关机</em></p>
<p><em>-c [<strong>说明信息</strong>]</em> <em>取消关机</em>        <em>-f</em> <em>重启时忽略检测文件系统</em>         <em>-F</em> <em>重启时强制检测文件系统</em></p>
<p>halt</p>
<p>关闭计算机。 调用 shutdown -h ，结束系统进程，同步文件系统，停止内核。</p>
<p><em>-n</em> <em>不同步文件系统</em>       <em>-w</em> <em>模拟关机，写</em> <em>/var/log/wtmp</em> <em>纪录</em>     <em>-f</em> <em>不调用</em> *shutdown ,*<em>强行关机</em></p>
<p><em>-p</em> <em>默认选项，关机时调用</em> <em>poweroff       -i</em> <em>关机前断开网络</em></p>
<p>reboot</p>
<p>重新启动计算机。参数与 halt 相似</p>
<p>chroot &lt;路径&gt;</p>
<p>Change Root 更改根目录，重新定义会话的运行环境。</p>
<h3 id="用户管理"><a class="header-anchor" href="#用户管理">¶</a>用户管理</h3>
<p>一些细节</p>
<p>root 用户为根用户，也就是 系统管理员 拥有全部权限</p>
<p>一个用户只能拥有一个 GID ，但是还可以归属于其它附加群组</p>
<p>用户管理的重要配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/passwd 用户名 密码位 UID 归属GID 姓名 $HOME目录 登录Shell</span><br><span class="line">/etc/shadow 用户名 已加密密码 密码改动信息 密码策略</span><br><span class="line">/etc/group 群组名 密码位 GID 组内用户</span><br><span class="line">/etc/gshadow 群组密码相关文件，不重要</span><br><span class="line">/etc/sudoers 用户名 权限定义 权限</span><br></pre></td></tr></table></figure>
<p>可以使用 pwconv 命令创建影子密码，将 /etc/passwd 文件中的密码转换到 /etc/shadow 文件</p>
<p>su [用户名]</p>
<p>切换到其它用户，默认切换到root用户。提示密码为将切换用户密码</p>
<p><em>-f</em> <em>快速切换，忽略配置文件</em>         <em>-l</em> <em>重新登录</em>         <em>-m</em> <em>，**-p</em> <em>不更改环境变量</em></p>
<p><em>-c &lt;<strong>命令</strong>&gt;</em> <em>切换后执行命令，并退出切换</em></p>
<p>sudo [命令]</p>
<p>以其它用户的身份执行命令，默认以root的身份执行。提示密码为当前用户密码</p>
<p><em>-s</em> <em>切换为**root shell       -i</em> <em>切换为<strong>root shell</strong>，并初始化</em>       <em>-u &lt;<strong>用户名</strong>|UID&gt;</em> <em>执行命令的身份</em></p>
<p><em>-l</em> <em>显示自己的权限</em></p>
<p>passwd [用户名]</p>
<p>设定用户密码</p>
<p><em>-d</em> <em>清除密码</em>        <em>-l</em> <em>锁定用户</em>         <em>-e</em> <em>使密码过期，在下次登录时更改密码</em></p>
<p><em>-S</em> <em>显示密码认证信息</em>          <em>-x &lt;<strong>天数</strong>&gt;</em> <em>密码过期，最大使用时间</em></p>
<p><em>-n &lt;<strong>天数</strong>&gt;</em> <em>冻结密码，最小使用时间</em>      <em>-s</em> <em>更改登录**Shell         -f</em> <em>更改用户信息</em></p>
<p>示例：</p>
<p>$passwd</p>
<p>Changing password for user</p>
<p>(current) UNIX password: 原密码</p>
<p>Enter new UNIX password: 新密码</p>
<p>Retype new UNIX password: 确认新密码</p>
<p>chsh [-s <shell>] [用户名]</shell></p>
<p>更改登录Shell</p>
<p>usermod &lt;用户名&gt;</p>
<p>修改用户账号</p>
<p><em>-d &lt;<strong>目录</strong>&gt;</em> <em>设定</em>*$HOME<em><em>目录*        <em>-m</em> <em>设定</em></em>$HOME</em>*目录时自动建立*</p>
<p><em>-s <shell></shell></em> <em>修改用户登录**Shell       -l &lt;<strong>新用户名</strong>&gt;</em> <em>修改为新用户名</em></p>
<p><em>-u <uid></uid></em> <em>修改用户**UID           -g &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属群组</em></p>
<p><em>-G &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属附加群组</em>     <em>-L</em> <em>锁定帐户</em>        <em>-U</em> <em>解除锁定</em></p>
<p><em>-e &lt;<strong>过期时间</strong>&gt;</em> <em>设定用户账号过期时间</em>         <em>-f &lt;<strong>缓冲天数</strong>&gt;</em> <em>设定密码过期后多长时间关闭账号</em></p>
<p><em>-c &lt;<strong>字符串</strong>&gt;</em> <em>修改用户备注</em></p>
<p>useradd &lt;用户名&gt;</p>
<p>新建用户</p>
<p><em>-d &lt;<strong>目录</strong>&gt;</em> <em>设定</em>*$HOME<em><em>目录*        <em>-m</em> <em>自动建立</em></em>$HOME</em><em>目录*      <em>-M</em> <em>不自动建立</em></em>$HOME**目录*</p>
<p><em>-s <shell></shell></em> <em>修改用户登录**Shell       -l &lt;<strong>用户名</strong>&gt;</em> <em>修改为新用户名</em>        <em>-u <uid></uid></em> <em>修改用户**UID</em></p>
<p><em>-g &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属群组</em>          <em>-G &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属附加群组</em></p>
<p><em>-n</em> <em>不建立以用户名为名称的群组</em>         <em>-e &lt;<strong>过期时间</strong>&gt;</em> <em>设定用户账号过期时间</em></p>
<p><em>-f &lt;<strong>缓冲天数</strong>&gt;</em> <em>设定密码过期后多长时间关闭账号</em>        <em>-c &lt;<strong>字符串</strong>&gt;</em> <em>修改用户备注</em></p>
<p><em>-D [<strong>表达式</strong>]</em> <em>更改预设值</em> <em>（预设值保存于</em> <em>/etc/default/useradd</em> <em>文件中）</em></p>
<p>新建用户规则保存于 /etc/login.defs 文件中</p>
<p>新建用户默认文件保存于 /etc/skel/ 目录中。新建用户时，系统自动拷贝此目录下的文件至新建用户的 $HOME 目录</p>
<p>userdel &lt;用户名&gt;</p>
<p>删除用户</p>
<p><em>-r</em> <em>删除用户相关文件和目录</em></p>
<p>id [用户名]</p>
<p>显示用户 UID GID 归属附加群组</p>
<p>finger [用户名]</p>
<p>显示用户信息</p>
<h3 id="进程管理"><a class="header-anchor" href="#进程管理">¶</a>进程管理</h3>
<p>一些细节</p>
<p>进程一般分为交互进程、批处理进程和守护进程三类。</p>
<p>守护进程总是活跃，在系统启动时通过脚本自动启动，或由root启动，通常在后台运行。</p>
<p>一个进程可以拥有子进程。当父进程终止时，它的子进程也随之终止；而子进程终止时，父进程通常可以继续运行。</p>
<p>init 进程为根进程，所有进程都是它的子进程</p>
<p>ps</p>
<p>显示进程信息，参数可省略 -</p>
<p><em>aux</em> <em>以<strong>BSD</strong>风格显示进程**(<strong>常用</strong>)          -efH</em> <em>以<strong>System V</strong>风格显示进程</em></p>
<p><em>-e , -A</em> <em>显示所有进程</em>      <em>a</em> <em>显示终端上所有用户的进程</em>       <em>x</em> <em>显示无终端进程</em></p>
<p><em>u</em> <em>显示详细信息</em>          <em>f</em> <em>树状显示</em>         <em>w</em> <em>完整显示信息</em>         <em>l</em> <em>显示长列表</em></p>
<p>示例：</p>
<p>ps alx 另一种常用输出格式</p>
<p>ps aux | less 将输出通过管道，使用 less 查看</p>
<p>ps aux | grep &lt;关键字&gt; 通过关键字查找进程</p>
<p>输出字段</p>
<p>USER 进程所有者        PID 进程ID        PPID 父进程       %CPU CPU占用率</p>
<p>%MEM 内存占用率      NI 进程优先级。数值越大，占用CPU时间越少         VSZ 进程虚拟大小</p>
<p>RSS 页面文件占用       TTY 终端ID       STAT 进程状态</p>
<p>D 不可中断 Uninterruptible sleep (usually IO)        R 正在运行，或在队列中的进程</p>
<p>S 处于休眠状态          T 停止或被追踪         Z 僵尸进程</p>
<p>W 进入内存交换（从内核2.6开始无效）      X 死掉的进程      &lt; 高优先级         N 低优先级</p>
<p>L 有些页被锁进内存     s 包含子进程       + 位于后台的进程组；</p>
<p>l 多线程，克隆线程 multi-threaded (using CLONE_THREAD, like NPTL pthreads do)</p>
<p>pstree</p>
<p>树状显示进程信息</p>
<p><em>-a</em> <em>显示完整命令及参数</em>        <em>-c</em> <em>重复进程分别显示</em>          <em>-c</em> <em>显示进程**ID PID  -n</em> <em>按</em> <em>PID</em> <em>排列进程</em></p>
<p>pgrep &lt;进程名&gt;</p>
<p>显示进程的PID</p>
<p><em>-l</em> <em>显示进程名和进程**PID      -o</em> <em>进程起始**ID      -n</em> <em>进程终止**ID</em></p>
<p>xkill</p>
<p>在图形界面中点杀进程。执行此命令后，鼠标指针变为骷髅图案（一定看过《加勒比海盗》吧）。在窗口中点击左键杀死进程，右键取消</p>
<p>pkill &lt;进程名&gt;</p>
<p>结束进程族。如果结束单个进程，请用 kill</p>
<p>kill [信号代码] &lt;进程PID&gt;</p>
<p>根据PID向进程发送信号，常用来结束进程，默认信号为 -9</p>
<p>-l [信号数字] 显示、翻译信号代码</p>
<p>-9 , -KILL 发送 kill 信号退出</p>
<p>-6 , -ABRT 发送 abort 信号退出</p>
<p>-15 , -TERM 发送 Termination 信号</p>
<p>-1 , -HUP 挂起</p>
<p>-2 , -INT 从键盘中断，相当于 Ctrl+c</p>
<p>-3 , -QUIT 从键盘退出，相当于 Ctrl+d</p>
<p>-4 , -ILL 非法指令</p>
<p>-11 , -SEGV 内存错误</p>
<p>-13 , -PIPE 破坏管道</p>
<p>-14 , -ALRM</p>
<p>-STOP 停止进程，但不结束</p>
<p>-CONT 继续运行已停止的进程</p>
<p>-9 -1 结束当前用户的所有进程</p>
<p>renice &lt;优先级表达式&gt; &lt;进程表达式&gt;</p>
<p>重新设定进程优先级（无此必要）</p>
<p>优先级表达式：</p>
<p>+|-|= &lt;nice值&gt;</p>
<p>nice取值范围： -20~19</p>
<p>进程表达式：</p>
<p>-p <pid> 通过进程ID进行设定</pid></p>
<p>-g <pgid> 通过进程群组ID</pgid></p>
<p>-u <uid> 通过进程拥有者UID设定</uid></p>
<p>top</p>
<p>动态、交互式进程管理器</p>
<p>-c 显示进程启动状态，包括参数、操作对象等；而不只是进程名</p>
<p>-d &lt;秒&gt; 刷新频率。 -d 5，表示5秒刷新一次</p>
<p>-n &lt;次&gt; 刷新次数，然后退出。 -n 5，表示刷新5次后退出；</p>
<p>-b 以批量模式运行，让输出能够使用管道或重定向。但不能进行交互，最好和 -n &lt;次&gt; 参数一同使用</p>
<p>-i 禁止显示空闲进程或僵尸进程；</p>
<p>-p PID 仅监视指定进程的ID；PID是一个数值；</p>
<p>-s 安全模式运行，禁用一些效互指令；</p>
<p>-S 累积模式，输出每个进程的总的CPU时间，包括已死的子进程；</p>
<p>交互命令：</p>
<p><space> 立即刷新</space></p>
<p>k 交互式杀死进程，提示输入进程 PID （默认发送信号15）</p>
<p>r 设定renice，提示输入PID和renice值</p>
<p>s 改变两次刷新时间间隔，以秒为单位</p>
<p>n 设定显示进程数， 0 为不作限制</p>
<p>i 隐藏空闲进程和僵尸进程</p>
<p>S 切换到累积时间模式</p>
<p>l 开关，在顶部显示 uptime 信息</p>
<p>t 开关，在顶部显示 进程和CPU状态</p>
<p>m 开关，在顶部显示 free 信息</p>
<p>c 显示方式切换： 进程名/进程启动状态</p>
<p>A 按进程启动顺序进行排序。由新到旧</p>
<p>M 按内存占用排序。由大到小</p>
<p>N 以进程ID排序。由大到小</p>
<p>P 按CPU占用排序。由大到小</p>
<p>T 按时间／累积时间排序</p>
<p>f ，F 设定显示字段。设定完成后空格退出</p>
<p>o,O 设定显示字段的排序。大写向前移动，小写向后移动，空格退出</p>
<p>h,? 显示有关安全模式和累积模式的帮助信息</p>
<p>W 把当前的配置写到~/.toprc中；</p>
<p>nohup &lt;命令&gt;</p>
<p>将任务提交到后台，输出附加到 ~/nohup.out 文件。即便用户退出登录，提交的命令仍继续执行。</p>
<p>&lt;命令&gt; &amp;</p>
<p>背景执行此命令，如果用户退出登录，则命令停止执行</p>
<p>&lt;命令1&gt; ; &lt;命令2&gt; ; ......</p>
<p>命令队列，从左向右，依次执行以 ; 分隔的命令</p>
<p>&lt;命令1&gt; &amp;&amp; &lt;命令2&gt; &amp;&amp; ......</p>
<p>命令队列，从左向右，依次执行以 &amp;&amp; 分隔的命令。前一个命令执行成功，后一个命令才能执行</p>
<p>&lt;命令&gt; &lt;Ctrl+z&gt;</p>
<p>&lt;Ctrl+z&gt; 挂起当前Shell中的任务</p>
<p>jobs</p>
<p>显示背景任务</p>
<p>bg [任务编号]</p>
<p>将挂起的任务背景执行</p>
<p>fg [任务编号]</p>
<p>将背景任务调到前台执行</p>
<p>计划任务</p>
<h3 id="磁盘和内存管理"><a class="header-anchor" href="#磁盘和内存管理">¶</a>磁盘和内存管理</h3>
<p>一些细节</p>
<p>Linux中，设备用/dev/目录下的文件表示。例如</p>
<p>/dev/hda1 第一块硬盘的第一主分区</p>
<p>/dev/hdb5 第二块硬盘的第一逻辑分区</p>
<p>/dev/sda4 第一块SATA硬盘的第四主分区，或者扩展分区</p>
<p>/dev/null 黑洞设备</p>
<p>关于磁盘设备，详见 分区概念</p>
<p>mount &lt;设备文件&gt; [挂载路径]</p>
<p>挂载文件系统</p>
<p>-t 指定文件系统的类型。通常不必指定，mount自动检测。下面是常用的格式</p>
<p>reiserfs ReiserFS 3.6版</p>
<p>jfs IBM技术</p>
<p>xfs SGI技术(适合高级服务器，桌面用户慎用)</p>
<p>ext3 Linux传统文件系统</p>
<p>vfat fat fat32</p>
<p>ext2 不带日志的ext3</p>
<p>ntfs WINNT</p>
<p>iso9660 光盘</p>
<p>smbfs Windows文件共享</p>
<p>-o [选项1] [选项2] ......</p>
<p>loop 环设备。光盘、ISO镜像等</p>
<p>ro | rw 只读readonly；可读写read-write</p>
<p>sync | async 同步模式|异步模式。决定修改是否立即写入文件系统</p>
<p>atime | noattime 读取时是否修改访问时间。对于写入敏感设备，例如闪存、软盘，建议使用 <em>noatime</em></p>
<p>auto | noauto 自动挂载模式</p>
<p>exec | noexec 是否允许可执行权限</p>
<p>defaults 使用预设的选项 rw, suid, dev, exec, auto, nouser, async</p>
<p>iocharset=UTF-8 指定字符集，可简写为 utf8</p>
<p>codepage=936 指定代码页，可简写为 cp936 西文系统代码页为 437</p>
<p>umask=&lt;权限掩码&gt; 设定权限掩码</p>
<p>uid=<uid> 设定归属用户</uid></p>
<p>gid=<gid> 设定归属群组</gid></p>
<p>remount 以不同选项重新挂载</p>
<p>-L &lt;卷标&gt; 将带有特殊卷标的分区</p>
<p>Tip</p>
<p>权限掩码</p>
<p>权限=777-权限掩码（三位） | 7777-权限掩码（四位）</p>
<p>假如权限掩码为 022 ，则新建对象权限为 755 rwxr-xr-x</p>
<p>可以使用 umask 命令设置权限掩码</p>
<p>mount -a</p>
<p>挂载 /etc/fstab 文件中定义的所有设备</p>
<p>示例：</p>
<p>sudo mount -t iso9660 -o loop /dev/cdrom0 /media/cdrom</p>
<p>sudo mount -t vfat -o remount iocharset=utf8,codepage=cp936 /dev/hda5 /media/hda5</p>
<p>umount &lt;设备文件&gt; | &lt;挂载路径&gt;</p>
<p>卸载已挂载文件系统</p>
<p>df</p>
<p>查看已挂载文件系统的磁盘空间占用</p>
<p>-a 显示所有文件系统的磁盘使用情况，包括0块（block）的文件系统，如/proc文件系统</p>
<p>-T 显示文件系统类型         -k 以k字节为单位显示        -i 显示i节点信息，而不是磁盘块</p>
<p>-t &lt;文件系统类型&gt; 显示指定类型的文件系统的磁盘空间使用情况</p>
<p>-x &lt;文件系统类型&gt; 列出不是某一指定类型文件系统的磁盘空间使用情况（与t选项相反）。</p>
<p>-l 只显示本地文件系统</p>
<p>free</p>
<p>查看内存、缓冲区、交换空间的占用</p>
<p>-b 以字节为单位显示数值      -k 以千字节为单位显示数值        -m 以兆字节为单位显示数值</p>
<p>-g 以吉字节为单位显示数值        -l 显示内存占用峰值     -o 不显示缓冲区占用          -t 统计结果</p>
<p>-s &lt;秒&gt; 刷新频率</p>
<p>sync</p>
<p>同步文件系统。将缓冲区中的数据写入文件系统</p>
<p>fdisk &lt;磁盘设备文件&gt;</p>
<p>分区表修改工具</p>
<p>交互命令：</p>
<p>m 使用帮助        l 查看已知文件系统类型       p 显示分区信息</p>
<p>n 新建分区 （p:主分区 l:扩展分区 参见 分区概念 )     d 删除分区         t 改变分区类型</p>
<p>w 将改动写入分区表          q 放弃改动并退出</p>
<p>* 磁盘设备名称为整块磁盘，而不是磁盘中的分区。例如 /dev/hda ，而不是 /dev/hda1</p>
<p><strong>fdisk -l</strong></p>
<p>查看所有磁盘分区信息</p>
<p>cfdisk</p>
<p>更加友善的分区表修改工具</p>
<p>mkfs.&lt;文件系统类型&gt; &lt;分区设备文件&gt;</p>
<p>将分区格式化为文件系统。 文件系统类型</p>
<p>示例：</p>
<p>sudo mkfs.reiserfs /dev/hda1</p>
<p>mkfs &lt;分区设备文件&gt;</p>
<p>-t &lt;文件系统类型&gt; 指定文件系统类型         -c 格式化前检查磁盘</p>
<p><strong>mkisofs -o &lt;<strong><strong>镜像文件</strong></strong>&gt; [<strong><strong>源文件目录</strong></strong>]</strong></p>
<p>用光盘或者文件制作iso镜像</p>
<p>-b 可启动镜像</p>
<p>hdparm &lt;磁盘设备文件&gt;</p>
<p>设置硬盘参数</p>
<p>-d &lt;0|1&gt; DMA模式开关       -a &lt;0|1&gt; 预计模式开关         -t 性能测试         -T 缓存性能测试</p>
<p>-c &lt;0|1|3&gt; 32位传输模式开关        -g 显示柱面，扇区等信息      -i -I 显示磁盘信息</p>
<h3 id="网络和硬件管理"><a class="header-anchor" href="#网络和硬件管理">¶</a>网络和硬件管理</h3>
<p>ifconfig</p>
<p>配置网络接口</p>
<p>-a 显示所有网络接口</p>
<p>ifconfig &lt;网卡&gt; up|down</p>
<p>激活|禁用网卡</p>
<p>示例： ::</p>
<p>sudo ifconfig eth0 up</p>
<p>ifconfig &lt;网卡&gt; add &lt;IP地址&gt; [ netmask &lt;子网掩码&gt; ]</p>
<p>给网卡指定IP地址或子网掩码</p>
<p>route</p>
<p>配置路由及网关</p>
<p>route add -net &lt;路由地址&gt; gw &lt;网关地址&gt; [ netmask &lt;子网掩码&gt; ] dev &lt;网卡&gt;</p>
<p>指定路由及网关</p>
<p>route del -net &lt;网关地址&gt; gw &lt;网关地址&gt; [ netmask &lt;子网掩码&gt; ]</p>
<p>删除路由及网关</p>
<p>ip</p>
<p>配置网络</p>
<p>子命令：</p>
<p>link 网卡配置       address 配置地址。相当于 ifconfig        route 配置路由。相当于 route</p>
<p>参数：</p>
<p>show 显示(默认)         set 设置       add 添加      del 删除</p>
<p>示例：</p>
<p>ip link show 显示网卡配置</p>
<p>ip link set eth0 name xxx 重命名网络接口</p>
<p>ping &lt;IP地址&gt;</p>
<p>向目标地址发送ICMP封包，常用来测试网络</p>
<p>-b &lt;广播地址&gt; ping整个网段        -c 发送封包次数         -s &lt;封包大小&gt; 默认为64字节</p>
<p>netstat</p>
<p>网络连接状态</p>
<p>-r 显示路由表，同 route       -a 所有连接        -t 只显示TCP协议      -U 只显示UDP协议</p>
<p>-l 只显示正在监听的端口      -p 显示PID和进程名         -c &lt;秒&gt; 刷新频率</p>
<p>* http/ftp/ssh…… 为应用层协议         * TCP/UDP为传输层协议      * IP/ICMP为网络层协议</p>
<p>lspci</p>
<p>查看PCI总线连接的设备</p>
<p>lsusb</p>
<p>查看USB接口连接的设备</p>
<p>lsmod</p>
<p>查看已加载模块</p>
<p>* /lib/modules/uname -r 目录下为所有可用模块</p>
<p>modprobe &lt;模块名称&gt;</p>
<h2 id="简明VIM教程"><a class="header-anchor" href="#简明VIM教程">¶</a>简明VIM教程</h2>
<h3 id="VIM简介"><a class="header-anchor" href="#VIM简介">¶</a>VIM简介</h3>
<p>我们使用的大多数编辑器，都可以直接在编辑区输入字符，并且能够通过一些快捷键来完成一些控制功能，比如使用方向键移动光标，使用</p>
<p>BackSpack 或者 Delete 键删除文字，使用 PgUp 和 PgDn 翻页，使用 Home 和 End 来定位行首和行末……</p>
<p>而Vim是一个带模式的编辑器，同样的按键，在不同模式下，具有不同的功能定义。例如 h j k l 在 编辑模式 下输入相应的字符，在 普通模式 下却相当于方向键的作用。</p>
<p>由于需要切换模式，Vim的使用起来略显繁琐。不过优点也显而易见：您只要把手安安稳稳的放在打字区就可以了，而不需要使用诸如方向键、排版键、小键盘等</p>
<p>需要挪开双手的键位，从而提高了您的效率和专注程度。事实上，Vim的前身Vi诞生的时候，键盘上还没有方向键、排版键和小键盘：）</p>
<h3 id="命令-2"><a class="header-anchor" href="#命令-2">¶</a>命令</h3>
<p>使用Vim编辑文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi [文件名]</span><br><span class="line">vim [文件名]</span><br></pre></td></tr></table></figure>
<p>教学模式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vimtutor [语言]</span><br></pre></td></tr></table></figure>
<p>vim教程，相当于使用Vim编辑器以只读模式打开教程文件。您无论对这个文件作了什么，都会在退出后恢复原来的样貌。与只读模式的区别在于，它不会没有眼色的提醒您，现在的状态为只读模式。您可以使用它作一些练习</p>
<p>您可以指定教程文件的语言，如果使用本地语言(ZH_cn)出现乱码，您可以尝试使用英语</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vimtutor en</span><br></pre></td></tr></table></figure>
<h3 id="使用Vim比较文件区别"><a class="header-anchor" href="#使用Vim比较文件区别">¶</a>使用Vim比较文件区别</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vimdiff [文件1] [文件2] [其它文件]……</span><br></pre></td></tr></table></figure>
<h3 id="配置文件"><a class="header-anchor" href="#配置文件">¶</a>配置文件</h3>
<p>Vim的全局配置文件为 /etc/vim/vimrc ，用户配置文件为 ~/.vimrc ， &quot; 起始的行为注释行。我们提供的配置项，您直接加入配置文件就可以了</p>
<p>您可以先对Vim进行一些简单的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;设定文件编码</span><br><span class="line">set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span><br><span class="line"></span><br><span class="line">&quot;开启语法加亮</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">&quot;配色风格</span><br><span class="line">colorscheme pablo</span><br><span class="line"></span><br><span class="line">&quot;设定行距 GUI界面中生效</span><br><span class="line">set linespace=4</span><br><span class="line"></span><br><span class="line">&quot;设定GUI选项</span><br><span class="line">&quot;set guioptions=gmrLtT m:菜单 T:工具栏</span><br><span class="line">set guioptions=gmrLt</span><br><span class="line"></span><br><span class="line">&quot;设定Tab键缩进的空格数</span><br><span class="line">set tabstop=4</span><br><span class="line"></span><br><span class="line">&quot;设定编辑器将多少空格视为一个缩进</span><br><span class="line">set shiftwidth=4</span><br><span class="line"></span><br><span class="line">&quot;将缩进转换为空格</span><br><span class="line">&quot;set expandtab</span><br><span class="line"></span><br><span class="line">&quot;设定折叠方式</span><br><span class="line">&quot;set foldmethod=indent</span><br><span class="line"></span><br><span class="line">&quot;以下字符将被视为单词的一部分 (ASCII)：</span><br><span class="line">&quot;set iskeyword+=33-47,58-64,91-96,123-128</span><br></pre></td></tr></table></figure>
<h3 id="模式介绍"><a class="header-anchor" href="#模式介绍">¶</a>模式介绍</h3>
<p>Vim常见的模式有： <code>普通模式</code> 、 <code>插入模式</code> 、 <code>命令模式</code> ，另外我们也会经常用到 <code>可视模式</code> 。</p>
<p>Vim启动时进入 <code>普通模式</code> ；或者在其它模式下，按下 Esc 键，便可以回到<code>普通模式</code>。</p>
<p>使用 <code>vimtutor en</code> 命令进入教程，现在是普通模式。随便按几下 j 、 k 、 l 、 h 键，您会发现光标的位置发生改变。</p>
<p>按下 i 键，编辑器底部出现了 -- 插入 -- 或者 -- insert -- ，您进入了插入模式。随便按几下 j 、 k 、 l、 h，您会发现相应的字符出现在编辑区，现在还可以通过方向键来移动光标。可能您觉得使用方向键移动光标不是什么问题，但是习惯了Vim后，您会认为方向键太麻烦了，简直不能容忍！好了，现在按下 <code>Esc</code> 键回到普通模式，我们又可以使用 j 、 k 、 l 、 h 来移动光标了。</p>
<p>在<code>普通模式</code>下，按下 : 键（也就是 Shift+; ），在编辑器底部出现了一个 : ，您进入了命令模式。在 : 后输入一个命令 new ，回车后，编辑器被分割为上下两栏。为了方便起见，我们在命令前加一个 : 来表示命令模式下输入的命令，像这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:vnew</span><br></pre></td></tr></table></figure>
<p>一个命令能够以一些规则简化，上面的命令也可以写为这种形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:vne</span><br></pre></td></tr></table></figure>
<p>现在您的编辑区一定弄的四分五裂，您可以使用命令<code>:quit</code>来关闭当前栏，直接用简写就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></table></figure>
<p>这个命令是退出编辑器，如果编辑区被分成多栏，则是退出当前栏。</p>
<p>执行完一个命令（按下回车后），编辑器会自动回到普通模式。如果您想不执行当前命令，直接回到普通模式，您可以按下Esc键。</p>
<p>按下 v 键，您进入了可视模式，可以使用 j 、 k 、 l 、 h 移动光标，高亮选取文本 。</p>
<p>事实上，可视模式相当于高亮选取文本后的普通模式。</p>
<p>可视模式具有子模式，以行为单位进行选取的可视行模式，使用 V 键进入（也就是 Shift+v ）；和以块为单位进行选取的可视块模式，使用 Ctrl+v 键进入。</p>
<h3 id="模式切换"><a class="header-anchor" href="#模式切换">¶</a>模式切换</h3>
<p>好了，现在我们总结一下模式间切换的方法</p>
<p>其它模式==&gt;普通模式</p>
<p>Esc</p>
<p>普通模式==&gt;插入模式</p>
<p>i 在光标前插入 I 在行首插入           a 在光标后插入 A 在行末插入</p>
<p>o 在当前行之下新建行 O 在当前行之上新建行          r 替换当前字符 R 从当前字符开始替换</p>
<p>普通模式==&gt;命令模式         普通模式==&gt;可视模式         v 可视模式         V 可视块模式</p>
<p>&lt;Ctrl+v&gt; 可视块模式</p>
<h3 id="移动"><a class="header-anchor" href="#移动">¶</a>移动</h3>
<p>在普通模式中，您可以使用以下方式移动光标</p>
<p>j 向下         k 向上        l 向右 h l      h 向左 j</p>
<p>您可以使用其它更有效率的方式移动光标</p>
<p>w 下一个单词词首 W 将特殊符号视为单词的一部分           b 上一个单词词首 B 同上</p>
<p>e 单词末尾 E 同上       0 行首 ^ 行首文字（行首空格之后）         $ 行末</p>
<p>H 页面顶部        M 页面中部        L 页面底部</p>
<p>在其它模式中，您可以使用方向键移动光标，不过我们不推荐您那样作，您可以在配置文件中绑定插入模式下的功能键</p>
<p>noremap! <m-j> <down></down></m-j></p>
<p>noremap! <m-k> <up></up></m-k></p>
<p>noremap! <m-h> <left></left></m-h></p>
<p>noremap! <m-l> <right></right></m-l></p>
<p>………………</p>
<p>&lt;作用范围&gt; &lt;键位&gt; &lt;功能&gt;</p>
<p>其中，map!绑定的键盘映射，作用于所有模式；inoremap!绑定的映射，仅作用于插入模式。</p>
<h3 id="数字参数"><a class="header-anchor" href="#数字参数">¶</a>数字参数</h3>
<p>您也可以使用数字参数，来重复执行。例如</p>
<p>100j 执行100次j键，向下100行</p>
<p>或者作为跳转的行号、百分比。见下面的浏览部分</p>
<p>&lt;行号&gt; Ctrl+g 按行号跳转</p>
<h3 id="标记"><a class="header-anchor" href="#标记">¶</a>标记</h3>
<p>您可以在当前光标处作一个标记，以便快速返回</p>
<p>m&lt;标记名称&gt; 定义标记。标记名称为一个字符</p>
<p>`&lt;标记名称&gt; 返回标记</p>
<p>mx 将当前光标处定义为标记 x</p>
<p>`x 返回标记 x</p>
<h3 id="浏览"><a class="header-anchor" href="#浏览">¶</a>浏览</h3>
<p>&lt;Ctrl+f&gt; 下翻一页 &lt;Ctrl+d&gt; 下翻半页        &lt;Ctrl+b&gt; 上翻一页 &lt;Ctrl+u&gt; 上翻半页</p>
<p>gg 文件首行        G 文件末行        &lt;行号&gt;G 按行号转到相应行</p>
<p>&lt;1~100&gt;% 按百分比转到相应的行数      zz 将光标所在行调整至页面中间</p>
<p>&lt;Ctrl+e&gt; 下卷一行       &lt;Ctrl+y&gt; 上卷一行</p>
<p>说明：gg 定位到文件首行， V 进入可视行模式， G 定位到文件末行，实现类似“全选”的功能。依次按下 g g V(Shift+v) G(Shift+g)</p>
<h3 id="编辑"><a class="header-anchor" href="#编辑">¶</a>编辑</h3>
<p>x 剪切当前字符              dd 剪切当前行      y 复制可视模式选取字符      yy 复制当前行</p>
<p>p 在光标后粘贴 P 在光标前粘贴        u 撤消        &lt;trl+r&gt; 重做</p>
<p>&lt;Ctrl+y&gt; 逐字克隆上一行内容           &lt;Ctrl+e&gt; 逐字克隆下一行内容</p>
<h3 id="寄存器操作"><a class="header-anchor" href="#寄存器操作">¶</a>寄存器操作</h3>
<p>Vim可以将不同字段剪切或复制到不同寄存器中，您可以从不同寄存器中取出内容后粘贴</p>
<p>&quot;&lt;寄存器名称&gt; 按下“&quot;”键和另一个字符键，便可以定义一个寄存器。例如：</p>
<p>&quot;a &quot;1</p>
<p>定义寄存器后直接进行操作</p>
<p>&quot;ayy 将当前行复制到寄存器 a 中</p>
<p>&quot;ap 将寄存器 a 中的内容粘贴到光标之后</p>
<p>* 通常情况下，寄存器 + ( &quot; + Shift+= )对应X下的剪贴板。您在其它程序中复制的内容，可以使用 &quot;+p 粘贴到Vim中；您在Vim中，可以使用 &quot;+y 将内容复制到剪贴板，再粘贴到其它程序中</p>
<p>* 没有指定寄存器时，Vim使用“无名寄存器”存储内容</p>
<h3 id="搜索和替换"><a class="header-anchor" href="#搜索和替换">¶</a>搜索和替换</h3>
<p>按下 / 键，编辑器底部会出现 / 符号，接着输入字符串，便可以进行搜索</p>
<p>/ 向下搜索 ? 向上搜索</p>
<p>n 搜索下一个</p>
<p>N 搜索上一个</p>
<p>:s/&lt;源字符串&gt;/&lt;目标字符串&gt; 将源字符串替换为目标字符串</p>
<p>:s/&lt;源字符串&gt;/&lt;目标字符串&gt;/g 替换当前行中所有符合条件的字符串</p>
<p>:&lt;行号1&gt;,&lt;行号2&gt;s/&lt;源字符串&gt;/&lt;目标字符串&gt;/g 在指定行中进行替换</p>
<p>:%s/&lt;源字符串&gt;/&lt;目标字符串&gt;/g 全文替换</p>
<h3 id="正则表达式"><a class="header-anchor" href="#正则表达式">¶</a>正则表达式</h3>
<p>在搜索和替换时，可以使用正则表达式进行匹配</p>
<h3 id="宏"><a class="header-anchor" href="#宏">¶</a>宏</h3>
<p>您可以将一系列的操作录制为一个宏，然后执行它</p>
<p>q&lt;宏名称&gt; 开始录制宏。宏名称为一个字符</p>
<p>q 录制中按下“q”键，结束录制</p>
<p>@&lt;宏名称&gt; 执行宏</p>
<p>插入模式下的快捷键</p>
<p>&lt;Ctrl+r&gt;&lt;寄存器名称&gt; 输入指定寄存器内容</p>
<p>&lt;Ctrl+k&gt;&lt;2个字符&gt; 输入二合字符</p>
<p>&lt;Ctrl+v&gt;&lt;数字&gt; 通过数字编码输入字符</p>
<p>&lt;Ctrl+v&gt;&lt;键位&gt; 输入键位的名称</p>
<h3 id="键绑定、缩写"><a class="header-anchor" href="#键绑定、缩写">¶</a>键绑定、缩写</h3>
<p>前面我们已经向您介绍了键绑定，</p>
<p>map! <m-j> <down></down></m-j></p>
<p>尖括号及其中的内容，为Vim配置文件的约定，分别描述了按键和功能，表示将功能编写到按键上。如果绑定的只是普通字符，例如：</p>
<p>map! xxx XXXXX</p>
<p>表示将 fXXXXX 绑定到 xxx 上。当您键入 xxx 时，编辑器会自动替换为 XXXXX 。</p>
<p>如果您只是想将字符串绑定为缩写，方便输入，我们建议您使用 iabbrev 来绑定。例如：</p>
<p>iabbrev ubt Ubuntu</p>
<p>在插入模式下键入 ubt ，编辑器会自动替换为 Ubuntu 。您可以将 iabbrev 命令缩写为 iab ，例如：</p>
<p>iab ubt Ubuntu</p>
<p>以上命令，您可以直接在命令模式下输入，临时启用。也可以写入配置文件，永久启用。</p>
<h3 id="单词补全"><a class="header-anchor" href="#单词补全">¶</a>单词补全</h3>
<p>&lt;Ctrl+n&gt; 下一个匹配项</p>
<p>&lt;Ctrl+p&gt; 上一个匹配项</p>
<p>您可以在配置文件中定义补全的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;自动补全方式：(使用逗号分隔)</span><br><span class="line">set complete=k,.</span><br><span class="line"></span><br><span class="line">&quot; . 当前文件</span><br><span class="line">&quot; b 已被装缓冲区,但是没有在窗口内的文件</span><br><span class="line">&quot; d 在当前的文件中定义和由#include包含进来的文件</span><br><span class="line">&quot; i 由#include包含进来的文件</span><br><span class="line">&quot; k 由dictionary选项定义的文件</span><br><span class="line">&quot; kfile 名为&#123;file&#125;的文件</span><br><span class="line">&quot; t 标记(tags)文件</span><br><span class="line">&quot; u 没有载入的缓冲区</span><br><span class="line">&quot; w 在其他窗口中的文件</span><br><span class="line">&quot;设定自动补全字典 ：</span><br><span class="line">set dictionary=path</span><br></pre></td></tr></table></figure>
<h3 id="命令模式"><a class="header-anchor" href="#命令模式">¶</a>命令模式</h3>
<p>前面介绍了普通模式和插入模式。我们发现，普通模式主要用来浏览和修改文本内容，而插入模式则用来向文本中添加内容。</p>
<p>而命令模式则多用于操作文本文件（而不是操作文本文件的内容），例如保存文件；或者用来更改编辑器本身的状态，例如设定多栏窗口、标签或者退出编辑器……</p>
<p>w(rote) 将更改写入文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:w</span><br></pre></td></tr></table></figure>
<p>q(uit) 退出编辑器:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></table></figure>
<p>某些情况下，编辑器会阻止命令的执行。例如您修改了文件，而没有保存，那么您使用 :q 命令退出时，编辑器就不会执行这条命令，而是提醒您保存文件。</p>
<p>这个时候，您可以在命令末尾追加 ! 来强制执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:&lt;命令&gt;!</span><br></pre></td></tr></table></figure>
<p>例如 <code>:q!</code> ，即便您没有保存已修改的文件，使用此命令，编辑器也会放弃修改而强行退出</p>
<p>以 ! 引导一个Shell命令，则可以从Vim临时切换到Shell中，执行一个Shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:!&lt;命令&gt;</span><br></pre></td></tr></table></figure>
<p>例如 :<code>!ls</code></p>
<h3 id="多栏窗口"><a class="header-anchor" href="#多栏窗口">¶</a>多栏窗口</h3>
<p>您可以使用以下命令，将当前窗口水平分为两栏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:new</span><br></pre></td></tr></table></figure>
<p>新建一栏空白窗口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:split</span><br></pre></td></tr></table></figure>
<p>将当前文件分两栏显示</p>
<p>同理，您可以使用下列命令，将当前窗口垂直分为两栏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:vnew</span><br><span class="line"></span><br><span class="line">:vsplit</span><br></pre></td></tr></table></figure>
<p>先按下 &lt;ctrl+w&gt; 键，再按下方向键 j 、 k 、 l 、 h ，您可以切换到其它栏；在当前栏中使用 :q 命令，可以退出当前栏，也可以使用其它命令，对当前栏作出修改</p>
<p>如果您希望当前命令在所有栏中生效，您可以在命令的末尾追加 all</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:&lt;命令&gt;all</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:qall</span><br></pre></td></tr></table></figure>
<p>如果您希望这条命令强制执行，那么 ! 位于命令的最末</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:&lt;命令&gt;all!</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:qall! 强行退出所有栏窗口</span><br></pre></td></tr></table></figure>
<h3 id="标签页"><a class="header-anchor" href="#标签页">¶</a>标签页</h3>
<p>Vim在7以后的版本，开始支持标签页的功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:tabnew 新建一个标签</span><br><span class="line">:tabnext 转到下一个标签</span><br><span class="line">:tabprevious 转到上一个标签</span><br></pre></td></tr></table></figure>
<p>多数情况下，您可以使用鼠标点击标签进行切换。</p>
<h2 id="引导管理器Grub"><a class="header-anchor" href="#引导管理器Grub">¶</a>引导管理器Grub</h2>
<h3 id="硬件基础"><a class="header-anchor" href="#硬件基础">¶</a>硬件基础</h3>
<p>一块硬盘，它起始的一部分扇区为主引导扇区，包括MBR（主引导纪录）和DPT（分区表，您可以阅读分区概念章节中相关内容）</p>
<p>每个分区起始的一部分扇区，为分区引导扇区。</p>
<p>在分区引导扇区之后的部分，为文件系统的索引，文件系统通过它定位文件在硬盘上的位置。不同的文件系统采用不同的索引，例如FAT文件系统使用文件分配表和目录区。</p>
<p>绝大多数操作系统，对硬盘的读写操作，通过文件系统来完成，因此引导扇区中的内容，我们不能够在文件系统中进行操作，而需要专用软件，比如引导管理器。</p>
<p>我们对文件进行修改后，操作系统会将文件系统索引中的内容同步。</p>
<h3 id="系统引导流程"><a class="header-anchor" href="#系统引导流程">¶</a>系统引导流程</h3>
<p>1.系统启动时，首先引导至MBR，将控制权移交安装在MBR中的引导管理器</p>
<p>（Windows使用NTLDR，Linux通常用Grub）</p>
<p>2.引导管理器读取分区表</p>
<p>3.引导管理器读取分区中的配置文件，并按配置文件中预设的参数运行</p>
<p>例如，Grub读取“/boot/grub/menu.lst”文件中内容，将可引导系统通过菜单显示</p>
<p>4.引导管理器根据您的选择，可能会有如下活动</p>
<p>加载内核，启动Linux系统检查活动分区，并引导它（单一Windows系统）读取相应分区的引导扇区，将控制权移交该扇区中的引导管理器，Ubuntu系统在安装Grub时，会提问您安装在MBR或者分区引导扇区中。如果将Grub安装在分区引导纪录中，您必须确保MBR中的引导管理器能够正确的引导至分区引导扇区。</p>
<p>如果您在MBR中使用的是Windows的引导管理器NTLDR，完成这件工作会非常困难，因而我们推荐您使用Grub。</p>
<h3 id="Grub介绍"><a class="header-anchor" href="#Grub介绍">¶</a>Grub介绍</h3>
<p>Grub主要有以下功能：</p>
<ul>
<li>菜单式选择</li>
<li>命令行模式</li>
<li>支持开机画面</li>
<li>支持大硬盘</li>
</ul>
<p>其它的功能还有很多，就不一一介绍了。</p>
<p>您可以运行命令 grub 启动它。会显示一些版本信息和使用提示，当然还有命令提示符，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GNU GRUB version 0.97 (640K lower / 3072K upper memory)</span><br><span class="line">[ Minimal BASH-like line editing is supported. For the first word, TAB lists possible <span class="built_in">command</span> completions. Anywhere <span class="keyword">else</span> TAB lists the possible completions of a device/filename. ]</span><br><span class="line">grub&gt;</span><br></pre></td></tr></table></figure>
<p>您可以使用 TAB 键补全命令和路径，这非常重要，因为Grub中路径表示方式与操作系统是不同的，您可能比较陌生，所以尽量用TAB补全它，既方便，也不容易出错。</p>
<p>您可以在 grub&gt; 提示符后按 TAB 键，会将所有可用的命令显示出来。</p>
<p>呵呵，是不是有点晕，命令可真不少啊！！！</p>
<p>其实我们会用到的命令只有两个，</p>
<p>root</p>
<p>setup</p>
<h3 id="Grub术语"><a class="header-anchor" href="#Grub术语">¶</a>Grub术语</h3>
<p>在分区概念章节里，我们已经介绍了Linux系统中表示分区的方法 /dev/hda5</p>
<p>/dev/hdMN M为a起始的小写字母，表示硬盘序号；N为1起始的数字，表示分区序号</p>
<p>Grub中使用的表示方法为 hd0,1</p>
<p>hdX,Y X为0起始的数字，表示硬盘序号；Y为0起始的数字，表示分区序号</p>
<p>您得留意它们之间的区别：</p>
<p>N从1开始计数，X和Y从0开始计数</p>
<p>N为1~4，它是一个主分区；N为5或大于5，它是第(N-4)个逻辑分区。Y按分区在硬盘上排列的顺序排列，无论它表示的是主分区还是逻辑分区。</p>
<p>举例来说：</p>
<p>主 主 逻 逻 主</p>
<p>/dev/hdMN hda1 hda2 hda5 hda6 hda3</p>
<p>hdX,Y hd0,0 hd0,1 hd0,2 hd0,3 hd0,4</p>
<p>现在我们来看 root 和 setup 命令的使用：</p>
<p>grub&gt;root (hd0,1)</p>
<p>这个命令将Grub的根分区定位为 “(hd0,1)”</p>
<p>grub&gt;setup (hd0)</p>
<p>这个命令表示将Grub安装在“(hd0)”，因为没有指定安装的分区，所以安装位置为MBR</p>
<p>Grub的根分区 为Grub配置文件 /boot/grub/menu.lst 所在分区。假如您单独为 /boot 目录挂载了一个分区，那么Grub的根分区通常为您系统中 /boot 目录所在的分区。</p>
<p>搞错了根分区，Grub就不能正确读取配置文件，自然不能正确引导。</p>
<p>引导分区 ，Windows等系统的引导分区为它的安装分区，Linux系统的引导分区为它的 /boot 目录所在的分区</p>
<p>系统根目录所在分区 ，Linux根目录 / 的挂载分区。Linux系统的分区挂载信息保存在文件系统分配表 /etc/fstab 文件中</p>
<p>Grub首先读取根分区中的 /boot/grub/menu.lst</p>
<p>文件，并转到引导分区，如果是Windows等系统，则将控制权移动分区引导扇区中的启动管理器。如果是Linux系统，则加载内核和设备，并根据</p>
<p>/etc/fstab 文件的内容挂载文件系统。</p>
<p>看这个例子：（假设Grub安装在MBR中）</p>
<p>title Ubuntu</p>
<p>root (hd0,0)</p>
<p>kernel (hd0,1)/boot/vmlinuz-2.6.15-25-686 root=/dev/sda3 ro splash vga=0x31b</p>
<p>initrd (hd0,1)/boot/initrd.img-2.6.15-25-686</p>
<p>boot</p>
<p>Grub的安装位置为 (hd0)</p>
<p>root (hd0,0) ，这一行表示Grub的根分区为第一块硬盘的第一个分区 (hd0,0) ，它读取该分区中的配置文件 grub/menu.lst</p>
<p>kernel 和 initrd 行中的 (hd0,1) ，表示当前系统的 /boot 目录挂载到第一块硬盘的第二个分区 (hd0,1)</p>
<p>kernel 行的 root=/dev/sda3 ，表示当前系统的 / 目录挂载到第一块硬盘的第三个分区 (hd0,2) ，内核根据该分区中的 /etc/fstab 文件来挂载文件系统</p>
<h3 id="Grub配置文件"><a class="header-anchor" href="#Grub配置文件">¶</a>Grub配置文件</h3>
<p>/boot/grub/menu.lst 文件，主要由一些下面这样的块构成的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title Ubuntu</span><br><span class="line">root (hd0,2)</span><br><span class="line">kernel (hd0,2)/boot/vmlinuz-2.6.15-25-686 root=/dev/sda3 ro splash vga=0x31b</span><br><span class="line">initrd (hd0,2)/boot/initrd.img-2.6.15-25-686</span><br><span class="line">boot</span><br><span class="line">title Windows xp</span><br><span class="line">root (hd0,0)</span><br><span class="line">makeactive</span><br><span class="line">chainloader +1</span><br></pre></td></tr></table></figure>
<p>每一块代表一个操作系统，包含下面里几个部分</p>
<p>title xxx 标题，title和分隔符后的内容为Grub菜单中显示的条目</p>
<p>root (hdX,Y) 引导分区，可以留空，默认为 grub/menu.lst 所在分区（根分区），可以使用 grub&gt;root (hdX,Y) 命令设置，或者在您安装系统时自动设置</p>
<p>如果您计划引导至分区引导扇区，如Windows或者Unix系统（Unix和Linux系统，您需要选择将引导管理器安装到分区中），那么需要这样配置</p>
<p>makeactive 设置活动分区，系统默认设置，可以删除</p>
<p>chainloader +1 链式引导，不要动它。</p>
<p>如果以这种方式引导系统，上面 root (hdX,Y) 这一行通常需要配置， (hdX,Y) 为您的系统所在的分区。假如您的Windows在第一块硬盘的第一个分区，则这样写 root (hd0,0)</p>
<p>如果您引导的是Linux系统（没有在分区中安装引导管理器，而是安装到MBR），则需要这样配置</p>
<p>kernel (hd0,2)/boot/vmlinuz-2.6.15-25-686 root=/dev/sda2 ro splash vga=0x31b</p>
<p>initrd (hd0,2)/boot/initrd.img-2.6.15-25-686 设备镜像文件，与上一行保持一致</p>
<p>boot 不要动它</p>
<p>kernel 这一行最关键，它控制系统内核的加载。行末以 ro 起始的部分为参数（ro只读，splash显示启动画面，vga设定启动屏幕分辨率）</p>
<p>之前的部分可以写为这种形式：</p>
<p>kernel (hdX,Y)/boot/vmlinuz root=/dev/sdMN</p>
<p>(hdX,Y) 通常不是必须的，如果您安装了多个Linux系统，或者 /boot<code>目录与根目录 </code>/ 不在一个分区，则应把它写为 /boot 目录所在分区。而后面的 root=/dev/sdMN 为系统根目录 / 所在的分区。</p>
<p>initrd 这一行的 (hdX,Y) 与上一行保持一致。</p>
<h3 id="Grub安装"><a class="header-anchor" href="#Grub安装">¶</a>Grub安装</h3>
<p>上面已经向您介绍了Grub的安装，不过更多的侧重理论。现在我们来实践一下，假设您的系统不能引导，您可以尝试下面的方法：）</p>
<ol>
<li></li>
</ol>
<ul>
<li>找一张Ubuntu的LiveCD （Knoppix也是不错的选择）</li>
<li>也可以使用安装光盘，启动后在 boot 提示符后输入 linux rescue ，回车进入救援模式。</li>
<li>如果您拥有root权限，命令行提示符为 # ，如果是普通用户，则为 $ 。</li>
</ul>
<blockquote>
<p>在救援模式下，通常你已经具有了root权限</p>
</blockquote>
<blockquote>
<p>如果是LiveCD且没有root权限，请在终端中输入 su命令切换到root，会提问你root的密码。如果不知道root密码，可以使用这个命令 sudo su，只要你知道自己的密码，并且你在ID在sudoer列表中就可以了。</p>
</blockquote>
<ol start="2">
<li>在终端中输入 grub ，会进入到Grub的提示符界面</li>
</ol>
<p>a. 输入命令 root (hd 后按 Tab 键，屏幕上就会列出所有可用选项。比如我的是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Possible disks are: hd0 hd1</span><br></pre></td></tr></table></figure>
<p>这表示我装了两块硬盘，如果你只有一块硬盘的话，那么一定是hd0。</p>
<p>在 root(hd 后输入 0 ,按 Tab ，会自动补上一个 , ，现在你输入的内容成为这样：</p>
<p>root(hd0,</p>
<p>再按 Tab 键，会列出所有可用选项，我的是这样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Possible partitions are:</span><br><span class="line">Partition num: 0, Filesystem type unknown, partition type 0x7</span><br><span class="line">Partition num: 1, Filesystem type is fat, partition type 0xc</span><br><span class="line">Partition num: 2, Filesystem type is reiserfs, partition type 0x83</span><br><span class="line">Partition num: 4, Filesystem type is reiserfs, partition type 0x83</span><br><span class="line">Partition num: 5, Filesystem type unknown, partition type 0x82</span><br><span class="line">Partition num: 6, Filesystem type unknown, partition type 0x7</span><br><span class="line">Partition num: 7, Filesystem type is fat, partition type 0xc</span><br></pre></td></tr></table></figure>
<p>输入你的选择，比如为 1 ， Tab 一次后，结果是这样的：</p>
<p>root (hd1,1)</p>
<p>现在回车</p>
<p>输入命令</p>
<p>setup (hd0)</p>
<p>将grub安装在mbr中</p>
<p>最后，quit 命令退出GRUB</p>
<h3 id="Grub使用"><a class="header-anchor" href="#Grub使用">¶</a>Grub使用</h3>
<p>命令行</p>
<p>在Grub启动菜单中，您可以选择您要的选项，按下 e 键，进入到命令行模式</p>
<p>修改您的启动参数，完成后回车</p>
<p>按 b 键，Grub将以您修改后的参数引导系统。</p>
<h3 id="其它-2"><a class="header-anchor" href="#其它-2">¶</a>其它</h3>
<p>在Grub启动菜单中，按下 c 进入命令行模式</p>
<p>按下 d 删除当前选中的项</p>
<h2 id="FAQ"><a class="header-anchor" href="#FAQ">¶</a>FAQ</h2>
<h3 id="我的D盘到哪里去了？"><a class="header-anchor" href="#我的D盘到哪里去了？">¶</a>我的D盘到哪里去了？</h3>
<p>在使用Linux最初的几天里，我感到有些不安。</p>
<p>Windows下，我可以把系统装在C盘，软件放在D盘，音乐放在E盘……如果系统出现问题，我只要重装系统就可以了，大部分软件都可以直接使用（养成使</p>
<p>用绿色软件是一种好习惯：），而我辛辛苦苦收集起来的电影和音乐，我总是把它们放在一个安全的地方，以免引发失眠的严重后果。</p>
<p>其实Linux下硬盘也具有分区的概念，这一点和Windows没有什么不同（分区的概念是由硬盘的物理特性产生的，而不是操作系统）。不同的是，Linux可以将分区挂载到任意的目录下，而不像Windows，您的分区只能够在“我的电脑”里面：）</p>
<p>那么这么作有什么好处么？</p>
<p>我们来看看Linux和Windows下路径的表示方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows C:\Documents and Settings\Users\Documents\MyDocument</span><br><span class="line"></span><br><span class="line">Linux /home/User/MyDocument</span><br></pre></td></tr></table></figure>
<p>您一定注意到了，在Windows下面，路径中含有盘符“C:”，它通常代表您硬盘上的第一个分区。也就是说，在使用这些文件时，您需要知道它们在硬盘上</p>
<p>存储的相关物理细节。而在Linux下，您不需要知道这些，或者说，只要您设定好了分区挂载的目录，您就不需要再去理会什么分区。</p>
<p>Windows下的路径包含有分区、目录和文件三部分内容;而Linux下的路径则只有目录和文件，不包含任何分区信息，它的硬件抽象度更高！</p>
<p>Linux下的目录用“/”表示，这不标准吧？？</p>
<p>完全相反，这才是标准的体现。您只是习惯了Windows的目录符号，但是那并不意味着它是标准的。</p>
<p>看看Winodws下，各种位置、路径的表示方法：</p>
<p><a href="http://www.ubuntu.org.cn" target="_blank" rel="noopener">http://www.ubuntu.org.cn</a></p>
<p><a href="ftp://192.168.0.1" target="_blank" rel="noopener">ftp://192.168.0.1</a></p>
<p>c:\Windows\</p>
<p>file:///C:/Windows/</p>
<p>\127.0.0.1$C</p>
<h3 id="操作系统是一种非常精密的高科技产品，怎么可能如此混乱！！！他们是怎么作到的？？？"><a class="header-anchor" href="#操作系统是一种非常精密的高科技产品，怎么可能如此混乱！！！他们是怎么作到的？？？">¶</a>操作系统是一种非常精密的高科技产品，怎么可能如此混乱！！！他们是怎么作到的？？？</h3>
<p>Linux下的病毒少，是因为Linux的使用者少，骇客显然不愿意浪费气力去攻击没有人使用的操作系统。</p>
<p>您可能已经知道了，互联网上用作重要用途的服务器，其中很大一部分是Linux系统，另外的一部分是Unix系统：）如果骇客能够搞掉Linux系统的话，那么整个互联网就会陷于瘫痪！效果似乎更好一些。</p>
<p>当然了，您一定会想：骇客也是人，他们也喜欢上网，兔子还不吃窝边草呢……兔子那么笨，连乌龟都跑不过……骇客们可比兔子要聪明的多了！</p>
<p>是的，我承认这一点……不过他们也不一定非得把互联网干掉。很多骇客作梦都想入侵美国军方的服务器，美军服务器中的绝密数据，只要1kb，应该就可以买一台顶级的个人电脑了：）</p>
<p>如果可以的话，骇客为什么不去入侵美军的服务器，而要入侵您的电脑呢？</p>
<p>这是一个很有意思的观点，与之相映成趣，另一种论调也使人侧目：Windows服务器占到了服务器操作系统xx%的份额。</p>
<p>或许这个现象可以用80：20法则来解释：）</p>
<p>占服务器总数80%的Windows提供了服务总量的20%！</p>
<p>请您务必注意，这只是举一个例子，Windows服务器可能永远也不会占到服务器总数的80%！它提供的服务，以我个人的角度，我不认为可以达到20%，而且永远不会有那一天。</p>
<h3 id="软件安装繁琐"><a class="header-anchor" href="#软件安装繁琐">¶</a>软件安装繁琐</h3>
<p>或许您已经看过一些关于Linux软件安装的文章，但是您也不要忽略，此类文章的数量，是不能够和同类Windows文章相比的。</p>
<p>当然，使用源码包安装软件确实有点麻烦，但却不一定比Windows下的某些软件复杂。特别要提到，Ubuntu的包管理系统，为您提供了一种高效快捷的</p>
<p>软件管理方式，您只要知道您需要什么软件就可以了，甚至不需要关心它存放在网络上的哪一台服务器中，而且绝大多数的软件都可以使用这种方式来安装。</p>
<p>详情请参阅 APT</p>
<p>如果您有如下需求，您也可以尝试以源码的形式安装软件：</p>
<p>您需要某些软件的技术预览版本</p>
<p>您想测试您的机器的运算能力</p>
<p>您找不到一种比安装软件更好的方式来消磨时间 | （试图通过编译源码安装来大幅提高系统性能，其结果很可能会让您失望）</p>
<h3 id="源码保密性不强，存在安全隐患"><a class="header-anchor" href="#源码保密性不强，存在安全隐患">¶</a>源码保密性不强，存在安全隐患</h3>
<p>既然Linux下软件都开放源代码，那么会不会造成一些安全隐患呢？比如说一名骇客会发现其中的漏洞，并利用它？</p>
<p>事实刚好相反，一个软件，即便它不开放源码，骇客一样可以找到其中的漏洞，雷蒙德的软件巨头就是最好的佐证。就像一把锁，无论如何坚固，它总是能被撬开！它的作用无外乎“聊备一格，以防君子”：）</p>
<p>而这把锁，防住的恰恰是能够改进它的工程师！工程师知道了它的漏洞，却不能够去改进它;骇客知道了它的漏洞，却可以利用它……这把锁正是封闭源码！</p>
<p>这岂不是不妙？</p>
<h3 id="软件功能不够强"><a class="header-anchor" href="#软件功能不够强">¶</a>软件功能不够强</h3>
<p>虽然您很愿意使用Linux系统，但是它的软件并不能使您满意，甚至使您多愁善感的心灵又蒙上了一层阴影，“长太息以掩涕……”</p>
<p>首先您别忘了，《泰坦尼克》的特效就是在Linux系统下完成的，连业界巨头SGI都在向Linux迁移（尽管SGI的IRIX本来就是一种Unix系统）。如果您不知道SoftImage，那么Maya您总听说过吧？它最初就是多平台的。</p>
<p>对于电影特效处理时需要的高吞吐量的数据（以TB计）和运算能力，Windows系统恐怕连崩溃的机会都没有=_=#(最新统计资料显示，Top500计算机中，使用Linux的占到73.4%，包括最快的前两名。其中Linux系统367部，Unix系统98部，混合操作系统24部，AppleMacOS系统5部,BSD系统4部，Windows系统，2部）类似于大气模拟、基因解码等等真正的科学运算……Windows……前几天我还在verycd.com上看到一套欧洲某天文台的天文学软件，只有Linux版！</p>
<p>当然了，Linux下功能强大的软件大多是命令行的，图形界面的程序只能视觉上强大，外强中干！建议您多使用man这个命令来查询各类软件的使用方法，它排版美观，格式工整，语法简明，意韵流畅，实在是学习英语难得的教材。</p>
<h3 id="界面不友好"><a class="header-anchor" href="#界面不友好">¶</a>界面不友好</h3>
<p>如果您指的是系统的美观程度。Gnome默认效果我认为与Windows处于同一水平线，而KDE的效果就要略好一点，很多高手用FVWM可以作出让人眼花瞭乱的效果来……而Novell的XGL，更是可以用“惊艳”来形容。</p>
<p>如果您指的是操作，这属于“易于上手难于精通”与“难于上手易于精通”两种理念的冲撞。</p>
<p>当然了，我指的精通主要针对效率而言。如果您经常玩Blizzard出品的游戏，您对于“易于上手难于精通”这种理念或许相当了解，甚至非常欣赏。</p>
<p>不过这一理念只适用于竞技游戏！竞技游戏要球能够吸引大量的玩家，所以要易于上手。但是竞技游戏是为竞技而生的，所以不可能人人是高手 ────事实上高手只是一小部分人！</p>
<p>而操作系统是给人们来用的，最好人人都成为高手，所以易于精通是很重要的……当然最好也能够易于上手。但是考虑到效率的问题，这很难解决……</p>
<h3 id="Linux怎么占用这么多内存？"><a class="header-anchor" href="#Linux怎么占用这么多内存？">¶</a>Linux怎么占用这么多内存？</h3>
<p>Linux会最大程度的利用物理内存，避免使用交换空间;而不是尽量的回收内存，使用页面文件。</p>
<p>又因为Linux系统的内存管理非常优秀，程序退出时可以高效的回收内存，所以更加没有必要在程序运行时就回收内存！</p>
<p>因此，Linux系统表面看来内存开销很大，实际上系统运行是很稳定的──Linux不会时而流畅，时而瘫痪。事实上，在正常情况下，它运行是非常流畅的。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
</search>
