<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>征服14座高峰：凡事皆有可能</title>
    <url>/public/2022/01/09/14peak/</url>
    <content><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2>
<p>14 Peaks: Nothing Is Impossible (2021)</p>
<p>无畏的尼泊尔登山运动员尼姆斯·普贾开始了一项看似不可能完成的任务：在7个月内登顶全球14座8000米高峰。（2019年度完成的Possible plan）</p>
<p>最近，我看完了该记录片，摘录了些语句，鼓励自己不断进取，征服人生的一座座高峰，追寻梦想，不忘初心！</p>
<p><img src="/public/2022/01/09/14peak/2022-01-09-16-49-12.png" alt></p>
<a id="more"></a>
<h2 id="追寻梦想"><a class="header-anchor" href="#追寻梦想">¶</a>追寻梦想</h2>
<p><img src="/public/2022/01/09/14peak/2022-01-09-17-20-35.JPG" alt></p>
<h2 id="不忘初心"><a class="header-anchor" href="#不忘初心">¶</a>不忘初心</h2>
<p><img src="/public/2022/01/09/14peak/20220109_hello.JPG" alt></p>
<h2 id="最后"><a class="header-anchor" href="#最后">¶</a>最后</h2>
<p>山不向我走来，我便向他走去！</p>
]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>记录片</tag>
      </tags>
  </entry>
  <entry>
    <title>2021 年科隆游戏展奖项提名名单</title>
    <url>/public/2021/09/01/2021games/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>帝国时代3，现在帝国4！<br>
2021 年科隆游戏展奖项提名名单正式公布</p>
<a id="more"></a>
<p>8 月 23 日，2021 年科隆游戏展的奖项提名名单已经全部揭晓，本次直接涉及游戏的奖项有 21 个，其中获得提名的游戏分别为：</p>
<p>最佳微软 Xbox 游戏：《艾尔登法环》（万代南梦宫娱乐）；《孤岛惊魂 6》（育碧）；《光环无限》（微软）</p>
<p>最佳任天堂 Switch 游戏：《舞力全开 2022》（育碧）；《马里奥 + 疯狂兔子星耀之愿》 (育碧)</p>
<p>最佳 PC 游戏：《帝国时代 4》(微软)；《艾尔登法环》（万代南梦宫娱乐）；《塞伯利亚之谜: 世界之前》 (Astragon Entertainment)</p>
<p>最佳索尼 PlayStation 游戏：《艾尔登法环》（万代南梦宫娱乐）；《破晓传说》（万代南梦宫娱乐）；《黑相集：灰冥界》 (万代南梦宫娱乐)</p>
<p>最佳动作冒险游戏：《艾尔登法环》（万代南梦宫娱乐）；《马里奥 + 疯狂兔子星耀之愿》 (育碧)；《塞伯利亚之谜: 世界之前》 (Astragon Entertainment)</p>
<p>最佳动作游戏：《孤岛惊魂 6》（育碧）；《光环：无限》（微软）；《彩虹六号：异种》（育碧）</p>
<p>最佳家庭游戏：《舞力全开 2022》（育碧）；《Run Prop, Run!》（PlayTogether Studio）；《Super Dungeon Maker》 (Rokaplay)</p>
<p>最佳独立游戏：《Dorfromantik》（Toukana Interactive）；《Inua》（Arte France）；《Lost in Random》（EA）</p>
<p>最佳角色扮演游戏：《艾尔登法环》（万代南梦宫娱乐）；《Encased》（科赫传媒）；《破晓传说》（万代南梦宫娱乐）</p>
<p>最佳模拟游戏：《攀登者：天空是极限》(Art Games Studio)；《模拟农场 22》 (Astragon Entertainment)</p>
<p>最佳体育游戏：《攀登者：天空是极限》(Art Games Studio)；《FIFA22》（EA）；《Riders Republic》（育碧）</p>
<p>最佳策略游戏：《帝国时代 4》 (微软)；《英雄连 3》 (世嘉)；《马里奥 + 疯狂兔子星耀之愿》 (育碧)</p>
<p>最佳多人游戏：《光环无限》（微软）；《Riders Republic》（育碧）；《黑相集：灰冥界》 (万代南梦宫娱乐)</p>
<p>持续时间最长游戏：《Apex 游戏》（EA）；《黑色沙漠》 (Pearl Abyss Corp.)；《末日地带: 隔离的世界》 (Assemble Entertainment)</p>
<p>最具原创性的游戏：《骰子遗产》（科赫传媒/Destinybit）；《Riders Republic》（育碧）；《Terrorbane》 (轻语互动)</p>
<p>2021 年科隆游戏展将会于 8 月 25 日至 8 月 29 日举办，将保留现场展览的形式，同时线上数字展形式也将同步举行。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>日常杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>序言</title>
    <url>/public/2015/01/01/About/</url>
    <content><![CDATA[<p>欢迎来到这里，送你个东西 ~</p>
<p><img src="/public/2015/01/01/About/london.jpeg" alt="london"></p>
<a id="more"></a>
<p>博客算是一种有趣的玩物，体现出一个人很多个性的东西。书籍基本都有个引人入胜的序，我想为我的博客也写个序，如能引人入胜那便是赚到了。开博明意，本博客主要记录学习工作中自然科学、人文社科的芝麻知识点，以及生活的休闲杂记。记忆这东西很神奇，莫名其妙地记住一些事，但也不知不觉丢了些东西。在互联网或者说移动互联网之前，人们的记事方式更多的是纸质的，学习也是按照课本一页页去掌握，如今竞争的压力，信息的爆炸，技术信息发布平台多样，信息短快乱，工作与学习所用的知识点越来越多，越来越细，碎片化地学习无法避免的。</p>
<p>如何去记录这些碎片的知识，整理归纳的方法论需求已经迫在眉睫。在Github上搭建一个带版本控制和评论功能的博客，我认为是个不错的想法。利用Markdown写文档比较方便，不需涉及很多格式设置的问题，风格想换就换，各个博客平台也支持这种语法格式。git对文本的版本控制比较舒服，我可以在多个终端进行编写，同步也方便，合并后利用hexo框架就可以发布。hexo的主题也比较多样，选用的Next主题有很多差价。Next主题在评论支持方面以前使用的是网易云跟帖，但这个功能网易关了，现在使用的Gitment，利用github的isuue功能的评论框架，现在仅支持github用户登录评论，但就用户面来说，我觉得够了，我写的这些博客主要是给自己看的。</p>
<p>对我博客的寄语。希望利用博客建立个人有效的知识体系，锻炼写文章的水平，留下生活中有趣的事物，同时传递出有趣的想法，有效的和各位大牛交流相关领域的经验，在互联网村里共同成长与进步。</p>
<p><a href="build_blog.md">笔者的hexo搭建的过程</a></p>
<p>人是一棵会思考的芦苇，并有一个有趣的灵魂。</p>
<p>不忘初心，活波严谨。</p>
<p><strong>感谢</strong>
The Internet And The World.</p>
<h2 id="联系方式"><a class="header-anchor" href="#联系方式">¶</a>联系方式</h2>
<ul>
<li>
<p>QQmail: <a href="mailto:tianchenggu@qq.com" target="_blank" rel="noopener">tianchenggu@qq.com</a></p>
</li>
<li>
<p>Gmail:  <a href="mailto:talenapp@gmail.com" target="_blank" rel="noopener">talenapp@gmail.com</a></p>
</li>
<li>
<p>wechat QR</p>
<img src="/public/2015/01/01/About/WechatIMG151.jpeg" alt="WechatIMG151" style="zoom:50%;">
</li>
</ul>
<p>Keep It Simple Stupid.</p>
<p>Standing on Shoulders of Giants.
Thank you !!!</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>序言</tag>
      </tags>
  </entry>
  <entry>
    <title>知识记忆软件anki的使用</title>
    <url>/public/2022/04/14/anki_tips/</url>
    <content><![CDATA[<h2 id="anki使用-自建-anki-server"><a class="header-anchor" href="#anki使用-自建-anki-server">¶</a>anki使用 - 自建 anki  server</h2>
<p>当初想设计好用的英语背诵软件，现在发现了anki人家功能全部实现，还要啥自行车。</p>
<p>我当时设计的单词勇士开源Android软件：
<a href="https://github.com/talengu/WordWarrior" target="_blank" rel="noopener">https://github.com/talengu/WordWarrior</a>
现在已弃坑。</p>
<p>我们当然选用docker compose 来安装，相当丝滑。</p>
<p>在使用Anki过程中，主要工作是制作卡组，我们可以只关心内容而不关心技术。</p>
<a id="more"></a>
<h2 id="docker-compose"><a class="header-anchor" href="#docker-compose">¶</a>docker compose</h2>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker-compose.yml</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">service.anki:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">kuklinistvan/anki-sync-server</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">anki-container</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8121</span><span class="string">:27701</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/anki-sync-server:/app/data</span> <span class="comment"># anki data</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<h3 id="登陆container"><a class="header-anchor" href="#登陆container">¶</a>登陆container</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it anki-container /bin/sh</span><br><span class="line"></span><br><span class="line">./ankisyncctl.py lsuser             - list users</span><br><span class="line">./ankisyncctl.py adduser &lt;username&gt; - add a new user</span><br><span class="line">./ankisyncctl.py deluser &lt;username&gt; - delete a user</span><br><span class="line">./ankisyncctl.py passwd &lt;username&gt;  - change password of a user</span><br></pre></td></tr></table></figure>
<h2 id="客户端"><a class="header-anchor" href="#客户端">¶</a>客户端</h2>
<img src="/public/2022/04/14/anki_tips/image-20200424005627732.png" alt="image-20200424005627732" style="zoom:33%;">
<h3 id="mac-win-客户端"><a class="header-anchor" href="#mac-win-客户端">¶</a>mac/win 客户端</h3>
<p>从官网下载 anki mac版本 2.1.21 (f1734a47) / Windows PC 客户端</p>
<p>中文网：<a href="http://www.ankichina.net/" target="_blank" rel="noopener">http://www.ankichina.net/</a></p>
<p>工具-&gt;附加组件-&gt;<code>获取插件</code>，输入 代码：2124817646</p>
<img src="/public/2022/04/14/anki_tips/add_server.png" alt="add_server" style="zoom:30%;">
<img src="/public/2022/04/14/anki_tips/add_on1.png" alt="add_on1" style="zoom:30%;">
<p>插件下载完成后设置ip地址，点击<code>设置</code>。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"msyncUrl"</span>: <span class="string">"http://127.0.0.1:27701/msync/"</span>,</span><br><span class="line">    <span class="attr">"syncUrl"</span>: <span class="string">"http://127.0.0.1:27701/sync/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/public/2022/04/14/anki_tips/addon_2.png" alt="addon_2" style="zoom:30%;">
<p>重启anki，同步并输入输入自定义服务器中配置的账户</p>
<h3 id="Android客户端-AnkiDroid"><a class="header-anchor" href="#Android客户端-AnkiDroid">¶</a>Android客户端 - AnkiDroid</h3>
<p>首先配置服务器地址信息，打开<code>设置-&gt;高级设置-&gt;自定义同步服务器</code>，输入同步地址 和 媒体文件同步地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 同步地址</span><br><span class="line">http://127.0.0.1:27701/</span><br><span class="line"># 媒体文件同步地址</span><br><span class="line">http://127.0.0.1:27701/msync/</span><br></pre></td></tr></table></figure>
<p>然后打开 <code>设置-&gt;AnkiDroid常用设置-&gt;AnkiWeb账户</code>，输入在服务器里面设置的账户和密码。PS：可在服务器重置密码。</p>
<table><tr>
<td><center><img src="/public/2022/04/14/anki_tips/IMG_20200424_010047.jpg">图1    </center></td>
<td><center><img src="/public/2022/04/14/anki_tips/IMG_20200424_011338.jpg">图2      </center></td>
</tr></table>
<p>coco20000 anki 包 <a href="https://www.dazhuanlan.com/2019/11/20/5dd54a6571f01/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/11/20/5dd54a6571f01/</a></p>
<h2 id="使用-Docker-安装"><a class="header-anchor" href="#使用-Docker-安装">¶</a>使用 Docker 安装</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ANKI_SYNC_DATA_DIR=<span class="variable">$HOME</span>/anki-sync-server</span><br><span class="line"><span class="built_in">export</span> HOST_PORT=27701</span><br><span class="line"></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$ANKI_SYNC_DATA_DIR</span>"</span></span><br><span class="line"><span class="comment">#export DOCKER_USER=root</span></span><br><span class="line"><span class="comment">#chown "$DOCKER_USER" "$ANKI_SYNC_DATA_DIR"</span></span><br><span class="line">chmod 700 <span class="string">"<span class="variable">$ANKI_SYNC_DATA_DIR</span>"</span></span><br><span class="line"></span><br><span class="line">docker run -itd \</span><br><span class="line">   -v <span class="string">"<span class="variable">$ANKI_SYNC_DATA_DIR</span>"</span>:/app/data \</span><br><span class="line">   -p <span class="string">"<span class="variable">$HOST_PORT</span>"</span>:27701 \</span><br><span class="line">   --name anki-container \</span><br><span class="line">   --restart always \</span><br><span class="line">   kuklinistvan/anki-sync-server:latest</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>知识管理</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>anki</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>c结构体对齐</title>
    <url>/public/2022/12/15/c_struct/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>c语言的字节对齐，机器的大小段模式的理解。</p>
<p>计算机存储的基础知识。</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;TM;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hp</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> b;</span><br><span class="line">	TM *t;</span><br><span class="line">	<span class="keyword">unsigned</span> short c;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> d;</span><br><span class="line">&#125;HP;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HP hp=&#123;</span><br><span class="line">		.a=<span class="number">0xa1</span>,</span><br><span class="line">		.b=<span class="number">0xb1</span>,</span><br><span class="line">		.c=<span class="number">0xc1c2</span>,</span><br><span class="line">		.d=<span class="number">0x1</span>,</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> *p=&amp;hp;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sizeof(HP) = %lu\n"</span>,<span class="keyword">sizeof</span>(HP) );	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(HP); ++i) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%02x "</span>,p[i] );	</span><br><span class="line">		<span class="keyword">if</span>((i+<span class="number">1</span>)%<span class="number">8</span>==<span class="number">0</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> d=hp.d;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,d);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//OUT</span><br><span class="line">|| sizeof(HP) = 32</span><br><span class="line">|| a1 b1 00 00 00 00 00 00 </span><br><span class="line">|| 00 00 00 00 00 00 00 00 </span><br><span class="line">|| c2 c1 00 00 00 00 00 00 </span><br><span class="line">|| 01 00 00 00 00 00 00 00 </span><br><span class="line">|| 1</span><br></pre></td></tr></table></figure>
<h2 id="存储方式"><a class="header-anchor" href="#存储方式">¶</a>存储方式</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HP hp=&#123;</span><br><span class="line">	.a=<span class="number">0xa1</span>,</span><br><span class="line">	.b=<span class="number">0xb1</span>,</span><br><span class="line">	.c=<span class="number">0xc1c2</span>,</span><br><span class="line">	.d=<span class="number">0xd1d2d3d4</span>,<span class="comment">//&lt;-0x1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//OUT</span><br><span class="line">|| sizeof(HP) = 32</span><br><span class="line">|| a1 b1 00 00 00 00 00 00 </span><br><span class="line">|| 00 00 00 00 00 00 00 00 </span><br><span class="line">|| c2 c1 00 00 00 00 00 00 </span><br><span class="line">|| d4 d3 d2 d1 00 00 00 00 </span><br><span class="line">|| 3520254932</span><br></pre></td></tr></table></figure>
<h2 id="字节对齐"><a class="header-anchor" href="#字节对齐">¶</a>字节对齐</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将 d 改为 d:1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hp</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> a;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> b;</span><br><span class="line">	TM *t;</span><br><span class="line">	<span class="keyword">unsigned</span> short c;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> d:<span class="number">1</span>; <span class="comment">//&lt;--- unsigned long d;</span></span><br><span class="line">&#125;HP;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//OUT</span><br><span class="line">|| 1 warning generated.</span><br><span class="line">|| sizeof(HP) = 24</span><br><span class="line">|| a1 b1 00 00 00 00 00 00 </span><br><span class="line">|| 00 00 00 00 00 00 00 00 </span><br><span class="line">|| c2 c1 01 00 00 00 00 00 </span><br><span class="line">|| 1</span><br></pre></td></tr></table></figure>
<p>少占用了一个8字节。</p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」在 C/C++ 程序中打印当前函数调用栈</title>
    <url>/public/2021/08/25/c_debug/</url>
    <content><![CDATA[<h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2>
<p>2011 年 6 月 11 日 <a href="http://www.wuzesheng.com/?author=2" title="由 小武哥 发布" target="_blank" rel="noopener">小武哥</a></p>
<p>前几天帮同事跟踪的一个程序莫名退出，没有 core dump(当然 ulimit 是打开的) 的问题。我们知道，正常情况下，如果程序因为某种异常条件退出的话，应该会产生 core dump，而如果程序正常退出的话，应该是直接或者间接的调用了 exit() 相关的函数。基于这个事实，我想到了这样一个办法，在程序开始时，通过系统提供的 atexit()，向系统注册一个回调函数，在程序调用 exit() 退出的时候，这个回调函数就会被调用，然后我们在回调函数中打印出当前的函数调用栈，由此便可以知道 exit() 是在哪里调用，从而上述问题便迎刃而解了。上述方法用来解决类似问题是非常行之有效的。在上面，我提到了在 “回调函数中打印出当前的函数调用栈”，相信细心的朋友应该注意到这个了，本文的主要内容就是详细介绍，如何在程序中打印中当前的函数调用栈。</p>
<a id="more"></a>
<p>我之前写过一篇题目为《<a href="http://www.wuzesheng.com/?p=1123" target="_blank" rel="noopener">介绍几个关于 C/C++ 程序调试的函数</a>》的文章，看到这里，请读者朋友先看一下前面这篇，因为本文是以前面这篇文章为基础的。我正是用了 backtrace() 和 backtrace_symbols() 这两个函数实现的，下面是一个简单的例子，通过这个例子我们来介绍具体的方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo .h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio .h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib .h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stacktrace</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun3();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stackstrace begin:\n"</span>);</span><br><span class="line">    print_stacktrace();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun1();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fun2();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stacktrace</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">void</span> * <span class="built_in">array</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">int</span> stack_num = backtrace(<span class="built_in">array</span>, size);</span><br><span class="line">    <span class="keyword">char</span> ** stacktrace = backtrace_symbols(<span class="built_in">array</span>, stack_num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stack_num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, stacktrace[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(stacktrace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（说明：下面的介绍采用的环境是 ubuntu 11.04, x86_64, gcc-4.5.2）</p>
<ol>
<li>通过下面的方式编译运行：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ gcc test.cc -o test1</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ ./test1</span><br><span class="line">stackstrace begin:</span><br><span class="line">./test1() [0x400645]</span><br><span class="line">./test1() [0x400607]</span><br><span class="line">./test1() [0x400612]</span><br><span class="line">./test1() [0x40061d]</span><br><span class="line">./test1() [0x4005ed]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xff) [0x7f5c59a91eff]</span><br><span class="line">./test1() [0x400529]</span><br></pre></td></tr></table></figure>
<p>从上面的运行结果中，我们的确看到了函数的调用栈，但是都是 16 进制的地址，会有点小小的不爽。当然我们可以通过反汇编得到每个地址对应的函数，但这个还是有点麻烦了。不急，且听我慢慢道来，看第 2 步。</p>
<ol start="2">
<li>通过下面的方式编译运行：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ gcc test.cc -rdynamic -o test2</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ ./test2</span><br><span class="line">stackstrace begin:</span><br><span class="line">./test2(_Z16print_stacktracev+0x26) [0x4008e5]</span><br><span class="line">./test2(_Z4fun1v+0x13) [0x4008a7]</span><br><span class="line">./test2(_Z4fun2v+0x9) [0x4008b2]</span><br><span class="line">./test2(_Z4fun3v+0x9) [0x4008bd]</span><br><span class="line">./test2(main+0x9) [0x40088d]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xff) [0x7f9370186eff]</span><br><span class="line">./test2() [0x4007c9]</span><br></pre></td></tr></table></figure>
<p>这下终于可以看到函数的名字了，对比一下 2 和 1 的编译过程，2 比 1 多了一个 <strong>- rdynamic</strong> 的选项，让我们来看看这个选项是干什么的 (来自 gcc mannual 的说明):</p>
<pre><code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-rdynamic</span><br><span class="line">  Pass the flag -export-dynamic to the ELF linker, on targets that support it. This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. This option is needed for some uses of "dlopen" or to allow obtaining backtraces from within a program.</span><br></pre></td></tr></table></figure>
</code></pre>
<p>从上面的说明可以看出，它的主要作用是让链接器把所有的符号都加入到动态符号表中，这下明白了吧。不过这里还有一个问题，这里的函数名都是 mangle 过的，需要 demangle 才能看到原始的函数。关于 c++ 的 mangle/demangle 机制，不了解的朋友可以在搜索引擎上搜一下，我这里就不多就介绍了。这里介绍如何用命令来 demangle，通过 c++filt 命令便可以:</p>
<pre><code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ c++filt &lt; &lt;&lt; "_Z16print_stacktracev"</span><br><span class="line">print_stacktrace()</span><br></pre></td></tr></table></figure>
</code></pre>
<p>写到这里，大部分工作就 ok 了。不过不知道大家有没有想过这样一个问题，同一个函数可以在代码中多个地方调用，如果我们只是知道函数，而不知道在哪里调用的，有时候还是不够方便，bingo，这个也是有办法的，可以通过 address2line 命令来完成，我们用第 2 步中编译出来的 test2 来做实验 (address2line 的 - f 选项可以打出函数名, -C 选项也可以 demangle)：</p>
<pre><code><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ addr2line -a 0x4008a7 -e test2 -f</span><br><span class="line">0x00000000004008a7</span><br><span class="line">_Z4fun1v</span><br><span class="line">??:0</span><br></pre></td></tr></table></figure>
</code></pre>
<p>Oh no，怎么打出来的位置信息是乱码呢？不急，且看我们的第 3 步。</p>
<ol start="3">
<li>
<p>通过下面的方式编译运行：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wuzesheng@ubuntu:~/work/test$ gcc test.cc -rdynamic -g -o test3</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ ./test3</span><br><span class="line">stackstrace begin:</span><br><span class="line">./test3(_Z16print_stacktracev+0x26) [0x4008e5]</span><br><span class="line">./test3(_Z4fun1v+0x13) [0x4008a7]</span><br><span class="line">./test3(_Z4fun2v+0x9) [0x4008b2]</span><br><span class="line">./test3(_Z4fun3v+0x9) [0x4008bd]</span><br><span class="line">./test3(main+0x9) [0x40088d]</span><br><span class="line">/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xff) [0x7fa9558c1eff]</span><br><span class="line">./test3() [0x4007c9]</span><br><span class="line">wuzesheng@ubuntu:~/work/test$ addr2line -a 0x4008a7 -e test3 -f -C</span><br><span class="line">0x00000000004008a7</span><br><span class="line">fun1()</span><br><span class="line">/home/wuzesheng/work/test/test.cc:20</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>看上面的结果，我们不仅得到了调用栈，而且可以得到每个函数的名字，以及被调用的位置，大功告成。在这里需要说明一下的是，第 3 步比第 2 步多了一个 - g 选项，-g 选项的主要作用是生成调试信息，位置信息就属于调试信息的范畴，经常用 gdb 的朋友相信不会对这个选项感到陌生。</p>
<h3 id="在-C-C-程序里打印调用栈信息"><a class="header-anchor" href="#在-C-C-程序里打印调用栈信息">¶</a>在 C/C++ 程序里打印调用栈信息</h3>
<p>我们知道，GDB 的 backtrace 命令可以查看堆栈信息。但很多时候，GDB 根本用不上。比如说，在线上环境中可能没有 GDB，即使有，也不太可能让我们直接在上面调试。如果能让程序自己输出调用栈，那是最好不过了。本文介绍和调用椎栈相关的几个函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">    backtrace, backtrace_symbols, backtrace_symbols_fd - support <span class="keyword">for</span> application self-debugging</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">void</span> **buffer, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">char</span> **<span class="title">backtrace_symbols</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">const</span> *buffer, <span class="keyword">int</span> size)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">backtrace_symbols_fd</span><span class="params">(<span class="keyword">void</span> *<span class="keyword">const</span> *buffer, <span class="keyword">int</span> size, <span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>
<p>以上内容源自这几个函数的 man 手册。</p>
<p>先简单介绍一下这几个函数的功能：
<strong>backtrace</strong>：获取当前的调用栈信息，结果存储在 buffer 中，返回值为栈的深度，参数 size 限制栈的最大深度，即最大取 size 步的栈信息。
<strong>backtrace_symbols</strong>：把 backtrace 获取的栈信息转化为字符串，以字符指针数组的形式返回，参数 size 限定转换的深度，一般用 backtrace 调用的返回值。
<strong>backtrace_symbols_fd</strong>：它的功能和 backtrace_symbols 差不多，只不过它不把转换结果返回给调用方，而是写入 fd 指定的文件描述符。</p>
<p>Man 手册里，给出了一个简单的实例，我们看一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  SIZE 100 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, nptrs;</span><br><span class="line">    <span class="keyword">void</span> *buffer[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span> **strings;</span><br><span class="line">    nptrs = backtrace(buffer, SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"backtrace() returned %d addresses\n"</span>, nptrs);</span><br><span class="line">      </span><br><span class="line"> <span class="comment">/* The call backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)  </span></span><br><span class="line"><span class="comment">  *  would produce similar output to the following: */</span></span><br><span class="line">        strings = backtrace_symbols(buffer, nptrs);</span><br><span class="line">    <span class="keyword">if</span> (strings == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"backtrace_symbols"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nptrs; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, strings[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(strings);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* "static" means don't export the symbol... */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">myfunc2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myfunc3();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(<span class="keyword">int</span> ncalls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ncalls &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        myfunc(ncalls - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        myfunc2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     </span><br><span class="line">  <span class="keyword">if</span>  (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s num-calls\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);  </span><br><span class="line">    &#125;</span><br><span class="line">    myfunc(atoi(argv[<span class="number">1</span>]));</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cc prog.c -o prog</span></span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./prog 0</span></span><br><span class="line">backtrace() returned 6 addresses</span><br><span class="line">./prog() [0x80485a3]</span><br><span class="line">./prog() [0x8048630]</span><br><span class="line">./prog() [0x8048653]</span><br><span class="line">./prog() [0x80486a7]</span><br></pre></td></tr></table></figure>
<p>这样，是输出了调用栈，不过只是以十六进制输出函数地址而已，可读性很差。仔细看下 man 手册，原来很简单，编译时加上个参数：</p>
<p>重新编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cc -rdynamic  prog.c -o prog</span></span><br></pre></td></tr></table></figure>
<p>通过 gcc 手册，我们可以也解下参数的说明:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-rdynamic</span><br><span class="line">        Pass the flag -export-dynamic to the ELF linker, on targets that support it. This instructs the linker to add all symbols, not only used ones, to the dynamic symbol table. This option is needed for some uses of "dlopen" or to allow obtaining backtraces from within a program.</span><br></pre></td></tr></table></figure>
<p>再执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ./prog 0</span></span><br><span class="line">backtrace() returned 6 addresses</span><br><span class="line">./prog(myfunc3+0x1f) [0x8048763]</span><br><span class="line">./prog() [0x80487f0]</span><br><span class="line">./prog(myfunc+0x21) [0x8048813]</span><br><span class="line">./prog(main+0x52) [0x8048867]</span><br><span class="line">/lib/libc.so.6(__libc_start_main+0xe6) [0xaf9cc6]</span><br><span class="line">./prog() [0x80486b1]</span><br></pre></td></tr></table></figure>
<p>这回，可以看到函数名了。是不是很酷呢？把它封装到你的调试代码中吧。</p>
]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title>地表最强大的还有这 14 位程序员</title>
    <url>/public/2020/04/09/cs_fonters/</url>
    <content><![CDATA[<p>原标题：除了 Linus，地表最强大的还有这 14 位程序员，速来膜拜！</p>
<p>导语：IT world 曾经做过一次调查，这个世界上最强大的 15 位程序员，到底是？</p>
<blockquote>
<p>文 / IT world</p>
</blockquote>
<blockquote>
<p>译 / 优达菌</p>
<p>转自 / 优达学城 2018</p>
<p>原文地址 <a href="https://www.sohu.com/a/223302790_700886" target="_blank" rel="noopener">https://www.sohu.com/a/223302790_700886</a></p>
</blockquote>
<p>当和技术基友谈论起 “谁是世界上最顶级的程序员” 的话题时，总是分分钟能引发骂战，优秀的程序员太多了，要评出最优秀的，貌似真的不容易。</p>
<p>IT world 曾经就做过一次调查，当说到谁是世界上健在且最顶级的程序员时，这 15 个人的名字总是能浮现出来，是公认的还是有争议的，是真 · 大神还是伪 · 大神？一起来看看吧~</p>
<img src="/public/2020/04/09/cs_fonters/3e28c4606b644378b652dc9c3716da02.jpeg" style="zoom:33%;">
<a id="more"></a>
<h2 id="Margaret-Hamilton"><a class="header-anchor" href="#Margaret-Hamilton">¶</a>Margaret Hamilton</h2>
<img src="/public/2020/04/09/cs_fonters/264f0ac3e2254ea8b1f91eac42632e1c.jpeg" style="zoom:33%;">
<p>作为 15 位上榜者中唯一女性，玛格丽特被誉为是 “<strong>阿波罗飞行控制软件背后的大脑</strong>”。</p>
<p>作为查尔斯 · 斯塔克 · 德雷珀实验室（Charles Stark Draper Laboratory）软件工程部的老大，她组建了一个团队，负责设计和制造阿波罗舰载飞行控制器软件和空间实验室。</p>
<p>基于这段经历，她开发了通用系统语言（Universal Systems Language）和开发先于事实（ Development Before the Fact）的范例，首先提出异步软件、优先调度和高可信度的软件设计理念。“软件工程（ software engineering）” 这个名字，公认是由她首先发明的。</p>
<p>1986 年，玛格丽特获得了奥古斯塔 · 埃达 · 洛夫莱斯奖，2003 年获得 NASA 卓越太空行动奖。</p>
<p><strong>世人评价：</strong></p>
<p>“她发明了测试，很大程度上规范了美国的计算机工程” —— ford_beeblebrox</p>
<p>“在她之前，计算机编程只是个数学分支。然而这个宇宙空间的飞行控制系统，清晰地将编程引入到一个截然不同的领域。” —— Dan Allen</p>
<p>“... 她发明了‘软件工程’这个词，并作出了最好的示范。” —— David Hamilton</p>
<h2 id="Donald-Knuth"><a class="header-anchor" href="#Donald-Knuth">¶</a>Donald Knuth</h2>
<img src="/public/2020/04/09/cs_fonters/e964fa2bfe7d4e0784b4d1dcc84dd883.jpeg" style="zoom:33%;">
<p>唐纳德 · 克努斯的中文名叫 “高德纳”，几乎是中国程序员永远的偶像之一。他最主要的成就，<strong>就是《计算机编程艺术》的作者。</strong></p>
<p>高德纳写出了计算机编程领域的红宝书，发明了 Tex 数字排版系统，获得了无数的荣耀。1971 年，他获得了第一届葛丽丝 · 穆雷 · 霍普奖（Grace Murray Hopper Award） 奖。1974 年获得了图灵奖，当时他才 36 岁....1979 年又获得了美国国家科学奖章，95 年解锁 IEEE 约翰 · 冯 · 诺依曼奖章，98 年，他入选为计算机历史博物馆名人堂的成员之一。</p>
<p><strong>世人评价：</strong></p>
<p>“... 《计算机编程艺术》这本书，估计是有史以来关于计算机编程最牛逼的贡献。”—— 匿名</p>
<p>“他发明的 TeX ，是我所用过的唯一一个几乎没有 bug 的计算机软件，真让人心悦诚服”—— Jaap Weel</p>
<p>“如果你要问我的话，他简直是前无古人后无来者！” —— Mitch Rees-Jones</p>
<h2 id="Ken-Thompson"><a class="header-anchor" href="#Ken-Thompson">¶</a>Ken Thompson</h2>
<img src="/public/2020/04/09/cs_fonters/71e925e1580c419fbae8df0829706e92.jpeg" style="zoom:33%;">
<p><strong>作为 “Unix 之父”，肯 · 汤普森足够在这个榜单占据一席之地。</strong></p>
<p>他与丹尼斯 · 里奇（Dennis Ritchie）共同创造了 Unix 操作系统。此外，他还发明了 B 语言、UTF-8 字符编码规范、ed 文本编辑器，同时也是 Go 语言的共同开发者之一。</p>
<p>肯 · 汤普森获奖无数，1983 年他获得图灵奖，1994 年获得 IEEE 计算机先锋奖，1998 年获颁美国国家科技奖章。在 1997 年入选成为计算机历史博物馆名人堂的一员。</p>
<p><strong>世人评论：</strong></p>
<p>“... 他可能是有史以来最具成就的程序员了。Unix 内核，Unix 工具，国际象棋程序世界冠军 Belle，Plan 9，Go 语言，无人可比” —— Pete Prokopowicz</p>
<p>“他所做出的贡献影响深刻，而且经得住时间的考验，时至今日，我们还在享受着他的智慧成果。” —— Jan Jannink</p>
<h2 id="Richard-Stallman"><a class="header-anchor" href="#Richard-Stallman">¶</a>Richard Stallman</h2>
<img src="/public/2020/04/09/cs_fonters/efe61b0807d541e3b1c3e8c77210d977.jpeg" style="zoom:33%;">
<p><strong>作为 Emacs 和 GCC 的缔造者，是他最大的成就之一。</strong></p>
<p>理查德是 GNU 项目的创立者，为其开发了很多核心工具，如 Emacs、GCC、GDB 和 GNU Make 等等。他还创办了自由软件基金会。1990 年荣获葛丽丝 · 穆雷 · 霍普奖，1998 年获得 EFF 先锋奖.</p>
<p><strong>世人评论：</strong></p>
<p>“他在编程上的造诣和思想，形成了一整套计算机编程的亚文化。” —— Dan Dunay</p>
<p>“我并不百分百认同他，但不可否认，他的确是足够载入史册的伟大的程序员。” —— Marko Poutiainen</p>
<p>“假设 Linux 写出来的时候，如果没有 GNU 工程的前期工作会怎么样。多亏了他！” —— John Burnette</p>
<h2 id="Anders-Hejlsberg"><a class="header-anchor" href="#Anders-Hejlsberg">¶</a>Anders Hejlsberg</h2>
<img src="/public/2020/04/09/cs_fonters/a1a41004e6af4e9390d7a6aa0b85acf6.jpeg" style="zoom:33%;">
<p>身为 <strong>Turbo Pascal 的缔造者兼 C# 之父</strong>，安德斯也是非常牛逼的！Turbo Pascl 可谓是历史上最受欢迎的编译器之一，也是首个集成开发环境（IDE）。他还主导开发了 Turbo Pascal 的继任者 Delphi ，他还是 C# 的首席架构师。</p>
<p>2001 年，他荣获了 Dr. Dobb 的杰出编程奖</p>
<p>生平： Turbo Pascal 的原作者，是最流行的 Pascal 编译器和第一个集成开发环境。而后，领导了 Turbo Pascal 的继任者 Delphi 的构建。C# 的主要设计师和架构师。2001 年荣获 Dr. Dobb’s 杂志颁发的 “杰出编程奖”。</p>
<p><strong>世人评论：</strong></p>
<p>“他用汇编语言写了 Pascal 编译器，支持当时 PC 端的两种主流操作系统（DOS 和 CP/M）。用它来编译链接程序并运行的时间，从几分钟减少到了几秒钟。” —— Steve Wood</p>
<h2 id="Doug-Cutting"><a class="header-anchor" href="#Doug-Cutting">¶</a>Doug Cutting</h2>
<img src="/public/2020/04/09/cs_fonters/239b715dcfaf4c4e9800dbdbd68009b2.jpeg" style="zoom:33%;">
<p>康婷开发了 Lucene 搜索引擎、 网络爬虫 Nutch 和分布式大型数据处理工具 Hadoop。此外，他还是一位坚定而热情的开源支持者（Lucene、Nutch 以及 Hadoop 都是开源的）。他还担任过前 Apache 软件基金的理事。</p>
<p><strong>世人评论：</strong></p>
<p>“... 他写出了杰出的搜索引擎框架（Lucene/solr），为世界开启大数据之门（Hadoop）。” —— Rajesh Rao</p>
<h2 id="Sanjay-Ghemawat"><a class="header-anchor" href="#Sanjay-Ghemawat">¶</a>Sanjay Ghemawat</h2>
<img src="/public/2020/04/09/cs_fonters/b9ba05338ce64e1e893af0cb86e8af6e.jpeg" style="zoom:33%;">
<p>这位谷歌核心架构师，参与设计和实现了一些谷歌大型分布式系统的功能，包括 MapReduce、BigTable、Spanner 和谷歌文件系统。还编写了 Unix 的 ical 日历系统。</p>
<p>他于 2009 年入选美国国家工程院。2012 年荣获 ACM 计算机科学奖。</p>
<p><strong>世人评论：</strong></p>
<p>“Jeff Dean 的左膀右臂。” —— Ahmet Alp Balkan</p>
<h2 id="Jeff-Dean"><a class="header-anchor" href="#Jeff-Dean">¶</a>Jeff Dean</h2>
<img src="/public/2020/04/09/cs_fonters/a2e2f5bed1484e2ea60d7e84f1a9c5de.jpeg" style="zoom:33%;">
<p>身为谷歌搜索索引的大脑，他参与设计和实现了许多谷歌大型分布式系统的功能，包括网页爬虫，索引搜索，AdSense，MapReduce，BigTable 和 Spanner。</p>
<p>2009 年，杰夫获得美国国家工程院奖。2012 年荣获 ACM SIGOPS 马克 · 维瑟奖和 ACM 计算机科学奖。</p>
<p><strong>世人评论：</strong></p>
<p>“... 他在数据挖掘领域（GFS、MapReduce、BigTable）上取得了重大突破。” —— Natu Lauchande</p>
<h2 id="Linus-Torvalds"><a class="header-anchor" href="#Linus-Torvalds">¶</a>Linus Torvalds</h2>
<img src="/public/2020/04/09/cs_fonters/5bc1912d08ad47b3be77809a49a6d532.jpeg" style="zoom:33%;">
<p>他是 Linux 的缔造者，创建了 Linux 内核与开源的版本控制系统 Git。</p>
<p>1998 年，他获得了 EFF 先锋奖，2000 年荣获英国电脑学会授予的洛夫莱斯勋章，2012 年的千禧技术奖，2014 年 IEEE 计算机学会授予的计算机先锋奖。他同样入选了 2008 年的计算机历史博物馆名人堂。</p>
<p><strong>世人评论：</strong></p>
<p>“他只花了几年，就写出了 Linux 内核，而 GNU Hurd（一个 GNU 开发的内核项目）历经 25 年，却还是一个 demo。” —— Erich Ficker</p>
<p>“他是程序员的程序员。” —— Dan Allen</p>
<h2 id="John-Carmack"><a class="header-anchor" href="#John-Carmack">¶</a>John Carmack</h2>
<img src="/public/2020/04/09/cs_fonters/939e4ce41e844230a7481f54271d6969.jpeg" style="zoom:33%;">
<p>他是 《毁灭战士》Doom 之父， ID Software 的联合创始人，开发了一系列极具影响力的 FPS 游戏，比如《德军总部 3D》（Wolfenstein 3D）、《毁灭战士》（Doom）和《雷神之锤》（Quake）等。</p>
<p>他还是计算机图形技术领域的先锋，在图形学上多次取得重要突破：包括自适应性图块刷新（adaptive tile refresh），二叉空间分割（BSP），以及表面缓存技术等等。</p>
<p>他在 2001 年入选交互式艺术与科学学院名人堂，并在 2007 年和 2008 年两次获得艾美奖工程和技术类奖项，并于 2010 年获得游戏开发者选择终身成就奖。</p>
<p><strong>世人评价：</strong></p>
<p>“他写第一个渲染引擎的时候不到 20 岁。真是个天才。” —— Alex Dolinsky</p>
<p>“... 德军总部 3D、毁灭战士还有雷神之锤，这些革命性的游戏，影响了一代游戏设计师。” —— dniblock</p>
<p>“给他一个周末，他可以写出任何东西....” —— Greg Naughton</p>
<p>“他是编程界的莫扎特...” —— Chris Morris</p>
<h2 id="Fabrice-Bellard"><a class="header-anchor" href="#Fabrice-Bellard">¶</a>Fabrice Bellard</h2>
<img src="/public/2020/04/09/cs_fonters/75c0a9b71a5c4209ae5bceeab7a5d7f9.jpeg" style="zoom:33%;">
<p>他是 QEMU 之父，是众多著名开源软件的作者，包括硬件模拟和虚拟化的平台 QEMU，处理多媒体数据的 FFmpeg，还有 Tiny C 编译器和 LZEXE，这是一个执行文件压缩的软件。</p>
<p>他是 2000 年和 2001 年 C 语言混乱代码大赛的冠军，2011 年 荣获 Google-O'Reilly 开源奖。此外，他还解锁了计算圆周率小数点后位数最多的世界纪录成就。</p>
<p><strong>世人评价：</strong></p>
<p>“我觉得他的工作实在是太伟大了。” —— raphinou</p>
<p>“他简直是世界上最高产的程序员...” —— Pavan Yara</p>
<h2 id="Jon-Skeet"><a class="header-anchor" href="#Jon-Skeet">¶</a>Jon Skeet</h2>
<img src="/public/2020/04/09/cs_fonters/35fc5db1746e495da75a89f408d92e3e.jpeg" style="zoom:33%;">
<p>“他根本不需要调试器，他盯下代码，bug 便会羞愧地原形毕露。” 这是世人对他的评价，他作为 Stack Overflow 传说级贡献者，保持着有史以来在 Stack Overflow 上最高的声誉，要知道，他平均每月解答高达 390 个问题！！！</p>
<p>此外，他还是 Google 工程师，《C# in Depth》的作者。</p>
<p>“如果他的代码没有通过编译，那么编译器应该道歉。” —— Dan Dyer</p>
<p>“他根本不需要什么编程规范，他的代码本身就是编程规范。” —— 匿名</p>
<h2 id="Adam-D-Angelo"><a class="header-anchor" href="#Adam-D-Angelo">¶</a>Adam D'Angelo</h2>
<img src="/public/2020/04/09/cs_fonters/8cb005da7eb146e9a32b8ed72c07012d.jpeg" style="zoom:33%;">
<p>他是” 海外知乎 “—— Quora 的创始人之一，他最早是 Facebook 工程师时，为其搭建了 News Feeds 的基础功能，成为了 Facebook 的 CTO 和 工程 VP。后面离职创办了现在的 Quora 。</p>
<p>他的经历很传奇，2001 年以还是一名高中生的他，在美国计算机奥林匹克竞赛排名上第八位。在 2004 年 ACM 国际大学生编程大赛获得银牌。2005 年闯入了 Topcoder 大学生算法编程挑战赛的决赛。</p>
<p>他是马克 · 扎克伯格的所谓的 6 个人之一（不懂请 Google）</p>
<p><strong>世人评论：</strong></p>
<p>“这是一位万能的程序员。” —— 匿名</p>
<h2 id="Petr-Mitrechev"><a class="header-anchor" href="#Petr-Mitrechev">¶</a>Petr Mitrechev</h2>
<img src="/public/2020/04/09/cs_fonters/a526c7c7edc04910bed60b68bb36990f.jpeg" style="zoom:33%;">
<p>他被誉为 <strong>“有史以来最具竞赛能力的程序员”</strong>，的确，看看他的履历就知道了：2000 年和 2002 年，他在国际信息学奥林匹克竞赛中两次获得金牌。2006 年，赢得 Google 代码挑战赛和 TopCoder 公开算法大赛冠军。他还是两次 Facebook 黑客杯的冠军。</p>
<p><strong>世人评价：</strong></p>
<p>“他简直是竞技程序员的偶像，即使是在我们印度” —— Kavish Dwivedi</p>
<h2 id="Gennady-Korotkevich"><a class="header-anchor" href="#Gennady-Korotkevich">¶</a>Gennady Korotkevich</h2>
<img src="/public/2020/04/09/cs_fonters/75da2050fc004f0d84956dc62fdd4dae.jpeg" style="zoom:33%;">
<p>榜单最后一位，是位竞技编程小神童，他是国际信息学奥林匹克竞赛的历史中，年纪最小参赛者（11 岁），并且 6 次获得金牌 (2007~2012)。2013 年，他在 ACM 国际大学生编程大赛获胜，同时还是 2014 Facebook 黑客杯的获胜者。</p>
<p>写这篇文章的时候，他在 Codeforces 榜排名第一 （ID：Tourist）、TopCoder 榜也是第一。</p>
<p><strong>世人评价：</strong></p>
<p>“当之无愧的编程神童！” —— Prateek Joshi</p>
<p><strong>大神级别的程序员太多了！并不是一篇文章就能说明白道清楚，如果你还有推荐的大神，欢迎在本文评论中和大家分享下。</strong></p>
<p>— 完 —</p>
]]></content>
      <categories>
        <category>计算机科学</category>
      </categories>
      <tags>
        <tag>人物</tag>
      </tags>
  </entry>
  <entry>
    <title>使用脚本将英文rss转成中文rss</title>
    <url>/public/2022/05/08/rss_google_translate/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>本文中我们将英文rss 自动转成中文 rss供ttrss使用。（利用谷歌翻译）</p>
<p>方便在手机上进行阅读或者收听。</p>
<center><img src="/public/2022/05/08/rss_google_translate/20220508-22-28-27.png" width="30%">
</center>
<a id="more"></a>
<h2 id="举例"><a class="header-anchor" href="#举例">¶</a>举例</h2>
<p>国外有很多不错的rss源，比如:</p>
<ul>
<li><a href="http://www.mckinsey.com/insights/rss" target="_blank" rel="noopener">McKinsey Insights &amp; Publications</a>  <center><img src="/public/2022/05/08/rss_google_translate/20220508-22-18-23.png" width="50%">
</center></li>
</ul>

    转成中文rss
    <center><img src="/public/2022/05/08/rss_google_translate/20220508-22-20-48.png" width="50%">
</center>
<ul>
<li>
<p><a href="http://rss.acast.com/nature" target="_blank" rel="noopener">Nature Podcast</a></p>
  <center><img src="/public/2022/05/08/rss_google_translate/20220508-22-25-04.png" width="50%">
</center></li>
</ul>

   转成中文rss
       <center><img src="/public/2022/05/08/rss_google_translate/20220508-22-26-36.png" width="50%">
</center>
<h2 id="脚本"><a class="header-anchor" href="#脚本">¶</a>脚本</h2>
<p>使用 Translate 和 BeautifulSoup 项目</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8 </span></span><br><span class="line"><span class="keyword">from</span> pygtrans <span class="keyword">import</span> Translate</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="comment"># pip 安装</span></span><br><span class="line"><span class="comment"># pip install pygtrans BeautifulSoup -i https://pypi.org/simple</span></span><br><span class="line"><span class="comment"># ref:https://zhuanlan.zhihu.com/p/390801784</span></span><br><span class="line"><span class="comment"># ref:https://beautifulsoup.readthedocs.io/zh_CN/latest/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># client = Translate()</span></span><br><span class="line"><span class="comment"># text = client.translate('Google Translate')</span></span><br><span class="line"><span class="comment"># print(text.translatedText)  # 谷歌翻译</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"></span><br><span class="line">args = sys.argv</span><br><span class="line">URL=<span class="string">"http://www.mckinsey.com/insights/rss"</span></span><br><span class="line"></span><br><span class="line">BASE=<span class="string">"/home/xxx/www/"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tran</span><span class="params">(url=URL,out_dir=BASE+<span class="string">"mckinsey_rss.xml"</span>)</span>:</span></span><br><span class="line">    GT = Translate()</span><br><span class="line">    content= request.urlopen(url).read().decode(<span class="string">'utf8'</span>)</span><br><span class="line">    <span class="comment"># 变tag，以使用谷歌翻译</span></span><br><span class="line">    content=content.replace(<span class="string">'title&gt;'</span>, <span class="string">'stitle&gt;'</span>) <span class="comment">#谷歌翻译会将很多titile去掉，所以需要换一个tag</span></span><br><span class="line">    content=content.replace( <span class="string">'&lt;pubDate&gt;'</span>,<span class="string">'&lt;pubDate&gt;&lt;span translate="no"&gt;'</span>) </span><br><span class="line">    <span class="comment"># 谷歌翻译对&lt;span translate="no"&gt; &lt;/span&gt; 不翻译。</span></span><br><span class="line">    content=content.replace( <span class="string">'&lt;/pubDate&gt;'</span>,<span class="string">'&lt;/span&gt;&lt;/pubDate&gt;'</span>)</span><br><span class="line">    <span class="comment">#print(content)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    _text = GT.translate(content)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(out_dir,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        c=_text.translatedText</span><br><span class="line">        <span class="comment"># 还原tag</span></span><br><span class="line">        c=c.replace(<span class="string">'stitle&gt;'</span>, <span class="string">'title&gt;'</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;span translate="no"&gt;'</span>, <span class="string">''</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;/span&gt;&lt;/pubDate&gt;'</span>, <span class="string">'&lt;/pubDate&gt;'</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        f.write(c)</span><br><span class="line">        <span class="comment">#f.write(content)</span></span><br><span class="line">    print(<span class="string">"GT: "</span>+ url +<span class="string">" &gt; "</span>+ out_dir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(args)==<span class="number">1</span>:</span><br><span class="line">    tran()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    tran(args[<span class="number">1</span>],args[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tran_nature</span><span class="params">(url=<span class="string">"http://rss.acast.com/nature"</span>,out_dir=BASE+<span class="string">"nature_rss.xml"</span>)</span>:</span></span><br><span class="line">    GT = Translate()</span><br><span class="line">    </span><br><span class="line">    html_doc=request.urlopen(url).read().decode(<span class="string">'utf8'</span>)</span><br><span class="line">    soup = BeautifulSoup(html_doc)</span><br><span class="line"></span><br><span class="line">    items=soup.find_all(<span class="string">'item'</span>)</span><br><span class="line">    <span class="comment"># nature post内容太多，谷歌api翻译不了，去掉一些</span></span><br><span class="line">    <span class="keyword">for</span> idx,e <span class="keyword">in</span> enumerate(items):</span><br><span class="line">        <span class="keyword">if</span> idx &gt;<span class="number">8</span>:</span><br><span class="line">                e.decompose()</span><br><span class="line">    </span><br><span class="line">    content= str(soup)</span><br><span class="line">    content=content.replace(<span class="string">'title&gt;'</span>, <span class="string">'stitle&gt;'</span>)</span><br><span class="line">    content=content.replace( <span class="string">'&lt;pubdate&gt;'</span>,<span class="string">'&lt;pubDate&gt;&lt;span translate="no"&gt;'</span>)</span><br><span class="line">    content=content.replace( <span class="string">'&lt;/pubdate&gt;'</span>,<span class="string">'&lt;/span&gt;&lt;/pubdate&gt;'</span>)</span><br><span class="line">    <span class="comment">#print(content)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    _text = GT.translate(content)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">with</span> open(out_dir,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        c=_text.translatedText</span><br><span class="line">        c=c.replace(<span class="string">'stitle&gt;'</span>, <span class="string">'title&gt;'</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;span translate="no"&gt;'</span>, <span class="string">''</span>)</span><br><span class="line">        c=c.replace(<span class="string">'&lt;/span&gt;&lt;/pubdate&gt;'</span>, <span class="string">'&lt;/pubDate&gt;'</span>) <span class="comment"># 对于ttrss需要为pubDate才会识别正确</span></span><br><span class="line">        c=c.replace(<span class="string">'&amp;gt'</span>,<span class="string">'&gt;'</span>) <span class="comment"># &amp;gt 会影响识别</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        f.write(c)</span><br><span class="line">        <span class="comment">#f.write(content)</span></span><br><span class="line">    print(<span class="string">"GT: "</span>+ url +<span class="string">" &gt; "</span>+ out_dir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tran_nature()</span><br></pre></td></tr></table></figure>
<h3 id="定时任务"><a class="header-anchor" href="#定时任务">¶</a>定时任务</h3>
<blockquote>
<p>注意激活一下miniconda3 这个命令<code>source /home/xxx/miniconda3/bin/activate</code></p>
</blockquote>
<p>放到 <code>/etc/cron.daily/</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">source</span> /home/xxx/miniconda3/bin/activate</span><br><span class="line">python /home/xxx/txxx.py</span><br></pre></td></tr></table></figure>
<h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2>
<ul>
<li><a href="https://blog.csdn.net/wokuailewozihao/article/details/82021709" target="_blank" rel="noopener">利用Google翻译实现网站国际化——js插件</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>rss</tag>
      </tags>
  </entry>
  <entry>
    <title>本地安装rss</title>
    <url>/public/2022/04/16/rss_local_install/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>在 “<a href="https://zhuanlan.zhihu.com/p/149452085" target="_blank" rel="noopener">二零年RSS杂谈</a>”中说到，我想建立一种信息的获取系统，免受广告和推荐算法的困扰。</p>
<p>我希望其的功能包括：</p>
<ul>
<li>多终端 Web、PC、 mobile的同步</li>
<li>全文获取能力</li>
<li>可自定义过滤规则</li>
<li>RSS源自定义</li>
</ul>
<p>方案：</p>
<ul>
<li>RSS源 rsshub</li>
<li>RSS服务  ttrss</li>
<li>RSS电脑手机软件：Android的Readably、Feedme，mac的reeder等等。windows上我暂时没有发现，我用的是ttrss的web界面。</li>
</ul>
<a id="more"></a>
<p>rsshub 是由 DIYgod 开发的开源RSS源生成工具，RSShub原始的网站可能不稳定，所以我选择了自己搭建。</p>
<p>ttrss 是一个rss源管理配置的工具，可获取全文，可自定义过滤规则。</p>
<p>本教程我们将完成在window电脑通过docker安装，ttrss与全文插件、rsshub的过程。</p>
<p>服务器的成本还是有点小贵的，我们可以在本地搭建整个服务，即利用docker安装这些服务，开机的时候记得启动这些服务。
不爽点：</p>
<ul>
<li>需要后台开启docker服务，使得其自动更新信息</li>
<li>没有公网ip的情况下，无法全网连接服务</li>
</ul>
<h2 id="最终ttrss界面"><a class="header-anchor" href="#最终ttrss界面">¶</a>最终ttrss界面</h2>
<p>在这里我已经添加一些rss源了。</p>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626135803804.png" alt="image-20200626135803804"></p>
<h2 id="docker-windows安装"><a class="header-anchor" href="#docker-windows安装">¶</a>docker windows安装</h2>
<p>从<a href="https://www.docker.com/products/docker-desktop" target="_blank" rel="noopener">docker 官网</a> 下载windows版本安装。完成后，在图标区会有一个鲸鱼船。</p>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626141604658.png" alt="image-20200626141604658"></p>
<p>我们使用docker-compose 来进行下一步 网站服务的安装。将下面的资料保存到s<code>docker-compose.yml</code> 然后利用docker-compose方法安装。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">service.rsshub:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">diygod/rsshub</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">rsshub</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">"1200:1200"</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rsshub_data:/app/lib</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">service.rss:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangqiru/ttrss:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">ttrss</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8118</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">SELF_URL_PATH=http://127.0.0.1:8118/</span> <span class="comment"># please change to your own domain</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_HOST=database.postgres</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PORT=5432</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_NAME=ttrss</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_USER=postgres</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">DB_PASS=ttrss</span> <span class="comment"># please change the password</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ENABLE_PLUGINS=auth_internal,fever</span> <span class="comment"># auth_internal is required. Plugins enabled here will be enabled for all users as system plugins</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FEED_LOG_QUIET=true</span></span><br><span class="line">    <span class="attr">stdin_open:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">'sh /wait-for.sh $$DB_HOST:$$DB_PORT -- php /configure-db.php &amp;&amp; exec s6-svscan /etc/s6/'</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">database.postgres:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">POSTGRES_PASSWORD=ttrss</span> <span class="comment"># please change the password</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgres_data:/var/lib/postgresql/data</span> <span class="comment"># persist postgres data to ~/postgres/data/ on the host</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">service.mercury:</span> <span class="comment"># set Mercury Parser API endpoint to `service.mercury:3000` on TTRSS plugin setting page</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wangqiru/mercury-parser-api:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mercury</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">3000</span><span class="string">:3000</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">postgres_data:</span></span><br><span class="line">  <span class="attr">rsshub_data:</span></span><br></pre></td></tr></table></figure>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626140114783.png" alt="image-20200626140114783"></p>
<p>在地址栏输入<code>cmd</code>，我们就可以打开cmd界面了，然后运行<code>docker-compose up -d</code> ，就可以自动安装全部内容了。</p>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626134626593.png" alt="image-20200626134626593"></p>
<p>在地址栏输入<code>cmd</code> 然后回车，我们就能进入cmd界面，然后使用docker-compose，进行安装，网速好的话，安装很快。</p>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626140147402.png" alt="image-20200626140147402"></p>
<p>安装完毕我们就可以使用了，下面是其资源占用情况。</p>
<table>
<thead>
<tr>
<th></th>
<th>内容</th>
<th>占用内存空间（M）</th>
</tr>
</thead>
<tbody>
<tr>
<td>mercury</td>
<td>全文获取ttrss插件</td>
<td>66.8</td>
</tr>
<tr>
<td>postgres</td>
<td>ttrss数据库</td>
<td>6.8</td>
</tr>
<tr>
<td>ttrss</td>
<td>ttrss工具</td>
<td>30.2</td>
</tr>
<tr>
<td>rsshub</td>
<td>rsshub各种b站源等等</td>
<td>142.4</td>
</tr>
<tr>
<td></td>
<td></td>
<td>246.2</td>
</tr>
</tbody>
</table>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626140407183.png" alt="image-20200626140407183"></p>
<p>打开 <a href="http://127.0.0.1:8118/" target="_blank" rel="noopener">http://127.0.0.1:8118/</a></p>
<p>默认账户：admin 密码：password，请第一时间更改。</p>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626143320968.png" alt="image-20200626143320968"></p>
<h2 id="在chrome安装-rsshub-radar"><a class="header-anchor" href="#在chrome安装-rsshub-radar">¶</a>在chrome安装 rsshub radar</h2>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626144233385.png" alt="image-20200626144233385"></p>
<p>并设置到本机的rsshub地址，ttrss地址，如上。</p>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626144330350.png" alt="image-20200626144330350"></p>
<p>打开bilibili up主的主页就能订阅了，订阅到ttrss。</p>
<p>这里有问题。需要解决。</p>
<p><img src="/public/2022/04/16/rss_local_install/image-20200626145153354.png" alt="image-20200626145153354"></p>
<p>本次安装教程到此结束，下期我们介绍全文获取功能，手机app的联动，即ttrss的设置问题</p>
]]></content>
      <categories>
        <category>信息收集</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>rss</tag>
      </tags>
  </entry>
  <entry>
    <title>二零年RSS杂谈</title>
    <url>/public/2022/01/14/rss_talk2020/</url>
    <content><![CDATA[<p>2020年了，笔者还是使用RSS的原始人。RSS，Really Simple Syndication是一种信息聚合工具。在5G时代信息即将大爆炸之前，我来谈谈rss的杂七杂八吧。我们来打个赌，你不会看完这篇文章。</p>
<a id="more"></a>
<p>软件的交互设计有很多心理学理论的应用。比如微信、QQ的三级页面设计，一般经过3次点击就能到达功能或设置。这符合认知原理，人认知记忆能力一般为3-5个的组合。日常生活中要记电话号码，可以3-4-4这样记。软件交互中还有利用人的习惯奖励机制的提醒红点的设计，吸引你去点击，获取红点消失的奖励。对我来说，较难控制住不受这些设计的影响。在《习惯的力量》一书了解到，直接逃离这些环境可有效解决控制不住的问题。比如工作的时候，把手机关进柜子，工作1个小时，然后再回复信息，当然重要电话还是要立即接的。</p>
<p>铺天盖地的广告，马路上，电视中，手机里，PC页面充斥着各种广告等等。大多数人可能养成了自动过滤的广告的习惯，然而我的情况是一直在用去广告的插件，并没有养成自动忽略广告的习惯。可怜兮兮，难道只有我是有广告洁癖的嘛？广告有点浪费生命。</p>
<p>我饱受广告的困扰。web的去广告方法，我可使用某款chrome插件可以将web界面上的小红点，推荐信息模块全部屏蔽掉的。哪里不看点哪里，贼方便。</p>
<p>移动端的广告去掉太难了，我一生气卸载了知乎 b站等等应用，终于有了一个清爽的手机。</p>
<p>那我还是想获取一些新的内容，根据二八定律，是有20%的网络资料包含了80%的信息，也就是干货，也可能被我这种操作忽略掉了，那一套RSS应用体系应运而生。</p>
<p>谈谈推荐算法，知乎推荐的都是啥呀，程序员都懂的，把我一个屌丝的形象勾勒的这么明显。于是我回答问题，人在美国，刚下飞机，年薪百万，老婆在旁？</p>
<p>很多人会说，RSS一定会获取到有用的信息吗，这取决于信息源的可靠程度。也就是需要你自己去选择，由于它是不含推荐算法的，就不会根据你选择的，再给你推荐一些可能是非常有用的。</p>
<p>再谈谈知识焦虑，每天觉得有大量知识需要吸收。大家都明白mark了也并不会看的，但还是mark很多，但你并不会有时间或者精力去看。既然不会看，那就不mark了，用到啥学啥，或许是个不错的策略。那RSS的即时性还是不错的，最好能当天把信息清理一下，star一些当前重要的东西，然后一周整理一下，像阮一峰老师。吸收完，把它输出出去，与人交流，给人讲明白，能够记得更深。（费曼学习法，把自己当成老师）。</p>
<p>让我们再回到RSS，RSS是个淘汰的东西，和微信的公众号的形式有点像。然后倒霉的我又在微信的公众号上难以自拔，常常花很多时间在这上面。推荐算法厉害呀，就是让你看得爽。自我节制太难，那就改变环境。于是，我去掉了很多公众号，保留一些本地生活工作的公众号，微信上专注与朋友们侃大山。</p>
<p>还有一点难受是，各个平台，相互串在一起，在这个地方看了，在其他地方又换了一个马甲它继续晃悠在眼前。信息源在多平台发布，然后信息重叠。</p>
<p>看来all in one 势在必行，RSS被谷歌放弃后，很多网站傲娇地不提供RSS服务了，毕竟流量至上，钱要赚的，我一直想做一个这种爬的工具，但我不希望有大量使用爬，也就是我们还是要尊重网站的盈利以及持续发展的，这也是仅仅方便个人的信息处理，优化你的自动信息的处理，再也不用一个个打开网站，然后看信息看广告，还要被推荐不重用的信息。这也算我个人的想法。人在于折腾，于是我开始折腾ttrss rsshub等开源软件。</p>
<p>自由软件的好处，在于自由定制，参与发展，利益化会尽量变慢或者没有，方便的同时并不忘隐私保护。</p>
<p>我想说的是，<strong>技术应当给人们带来自由和发展，而非接管人们的注意力，浪费宝贵的时间。</strong></p>
<p>写在5G信息大爆发前，与大家共同反思与成长。</p>
]]></content>
      <categories>
        <category>杂谈</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>RSS</tag>
      </tags>
  </entry>
  <entry>
    <title>rss统计 基于ttrss的PostgresQL数据库</title>
    <url>/public/2022/05/08/rss_ttrss_statics/</url>
    <content><![CDATA[<p><strong>前言</strong>
统计ttrss的使用数据。</p>
<ul>
<li>月度mark文件分析 OK</li>
</ul>
<p>TODO：</p>
<ul>
<li>全年阅读报告 doing</li>
</ul>
<a id="more"></a>
<h2 id="按月保存mark的内容"><a class="header-anchor" href="#按月保存mark的内容">¶</a>按月保存mark的内容</h2>
<p>账号 密码 和你docker文件里面的一致。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按月来保存</span></span><br><span class="line"><span class="keyword">import</span> html2text</span><br><span class="line"><span class="comment"># psycopg2 head</span></span><br><span class="line"><span class="keyword">import</span> psycopg2</span><br><span class="line"><span class="comment"># pip3 install psycopg2-binary</span></span><br><span class="line"><span class="comment"># ref:https://blog.csdn.net/Haiqiang1995/article/details/89069791</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_from_dataset</span><span class="params">(cmd_sql)</span>:</span></span><br><span class="line">    conn = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># read database configuration</span></span><br><span class="line">        params = &#123;</span><br><span class="line">        <span class="string">'host'</span>: <span class="string">"?????"</span>,</span><br><span class="line">        <span class="string">'user'</span>: <span class="string">"????"</span>,</span><br><span class="line">        <span class="string">'password'</span>: <span class="string">"????"</span>,</span><br><span class="line">        <span class="string">'dbname'</span>: <span class="string">"ttrss"</span>,</span><br><span class="line">        'port': ??00</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># connect to the PostgresQL database</span></span><br><span class="line">        conn = psycopg2.connect(**params)</span><br><span class="line">        <span class="comment"># create a new cursor object</span></span><br><span class="line">        cur = conn.cursor()</span><br><span class="line">        <span class="comment"># execute the SELECT statement</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        print(cmd_sql)</span><br><span class="line">        cur.execute(cmd_sql)</span><br><span class="line"></span><br><span class="line">        blob = cur.fetchall()</span><br><span class="line">        <span class="comment"># blob = cur.fetchone()</span></span><br><span class="line">        <span class="comment">#open(path_to_dir + str(blob[0]) + '.jpg', 'wb').write(blob[1])</span></span><br><span class="line">        <span class="comment"># close the communication with the PostgresQL database</span></span><br><span class="line">        cur.close()</span><br><span class="line">    <span class="keyword">except</span> (Exception, psycopg2.DatabaseError) <span class="keyword">as</span> error:</span><br><span class="line">        print(error)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> conn <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            conn.close()</span><br><span class="line">    print(<span class="string">"get_from_dataset success"</span>)</span><br><span class="line">    <span class="keyword">return</span> blob</span><br><span class="line"></span><br><span class="line">_s=<span class="string">"ref_id,feed_id,last_read,last_marked"</span></span><br><span class="line">cmd_sql=<span class="string">"SELECT %s  FROM public.ttrss_user_entries Where marked=TRUE AND last_marked BETWEEN '2022-04-01' And '2022-5-01'"</span> % _s</span><br><span class="line"><span class="comment"># 可以自己改日期</span></span><br><span class="line"></span><br><span class="line">g_content=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> _e <span class="keyword">in</span> sorted(get_from_dataset(cmd_sql),key=<span class="keyword">lambda</span> x:x[<span class="number">3</span>]):</span><br><span class="line">    [ref_id,feed_id,last_read,last_marked] = _e</span><br><span class="line">    _s=<span class="string">"id,title,link,updated,content"</span></span><br><span class="line">    cmd_sql=<span class="string">"SELECT %s FROM public.ttrss_entries WHERE id = %s"</span> % (_s,ref_id)</span><br><span class="line">    [id,title,link,updated,content] =get_from_dataset(cmd_sql)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    g_content += <span class="string">"# [%s](%s)\n"</span>%(title,link)</span><br><span class="line">    g_content +=<span class="string">"pubdata:%s\n"</span>%str(updated)</span><br><span class="line">    g_content +=<span class="string">"markdate:%s\n"</span>%str(last_marked)</span><br><span class="line">    g_content+=html2text.html2text(content)</span><br><span class="line">    </span><br><span class="line">    g_content+=<span class="string">"\n\n"</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">D=<span class="string">"C:\\Users\\talen\\Desktop\\"</span></span><br><span class="line"><span class="keyword">with</span> open(D+<span class="string">"cc.md"</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(g_content)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>rss</tag>
      </tags>
  </entry>
  <entry>
    <title>博客模版</title>
    <url>/public/2019/07/25/template/</url>
    <content><![CDATA[<p>文件head，设置标题、日期、分类、标签、评论、版权、是否使用公式，如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 模版文件</span><br><span class="line">date: 2019-07-25 12:00:00</span><br><span class="line">updated: 2019-07-25 12:00:00</span><br><span class="line">categories:</span><br><span class="line">  - 博客搭建</span><br><span class="line">  - 模版文件</span><br><span class="line">tags:</span><br><span class="line">  - Writing</span><br><span class="line">comments: true</span><br><span class="line">copyright: true</span><br><span class="line">math: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p><strong>摘要</strong></p>
<p>本部分说明文章的写作意图。涉及的背景、主要内容、本文与其他文章关系等。</p>
<p>本文为Hexo博客模版文件，以Markdown语言书写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前言一般放到主页，可利用 &lt;!-- more --&gt; 隔断。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="1-构思与起草"><a class="header-anchor" href="#1-构思与起草">¶</a>1 构思与起草</h2>
<ul>
<li>对文章的阅读群体、写作意图和反馈（Audience Intention Response AIR）要有一个清楚的认识。照顾沟通对象的需要、你的意图（信息）以及希望的反馈。</li>
<li>在思维导图上，放上你需要的关键名词，然后依次在它基础上添加动词，在加上形容词。最后以一定顺序组织你将要阐述的信息。比如重要性排序，对比优势劣势，方案的不同层面，时间上逻辑上的因果性等等。</li>
</ul>
<h2 id="2-主体内容"><a class="header-anchor" href="#2-主体内容">¶</a>2 主体内容</h2>
<p>文章的主要内容，包括你对跟进过程或发现成果的描述，以数据、事实证据以及其他的信息支撑主要内容。在你的论说中，你应该把对客观事实的描述和写作者对事情的主管阐述区分开来。</p>
<p>当你在报告中对一个观点进行陈述的时候，你需要记住以下几点：</p>
<ul>
<li>清晰的呈现事实</li>
<li>有逻辑地提出论据</li>
<li>引用相关的语录、简明易懂的事实和例子来支持你的论点</li>
<li>给出支持或反对该行为的理由</li>
<li>始终围绕主要观点进行讨论</li>
<li>处理好重要的假设关系</li>
<li>区分说明（具体阐述）和论证（有理有据）</li>
</ul>
<p>链接：<a href="https://talengu.github.io/">https://talengu.github.io/</a></p>
<h3 id="2-1-图"><a class="header-anchor" href="#2-1-图">¶</a>2.1 图</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![GDP](http://www.stats.gov.cn/tjsj/zxfb/201902/W020190228338754231076_r75.png)</span><br><span class="line">&lt;div align=&apos;center&apos;&gt; &lt;b&gt;图1 2018年国内生产总值及其增速度&lt;/b&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>这两行代码生成下面的图和标题。</p>
<p><img src="http://www.stats.gov.cn/tjsj/zxfb/201902/W020190228338754231076_r75.png" alt="GDP"></p>
<p>图 1 展示的是2014-2018年的GDP和增长速度，来自<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。图中数据反应出国内生产总值在2014-2018年度均平稳增长的情况。</p>
<h3 id="2-2-表"><a class="header-anchor" href="#2-2-表">¶</a>2.2 表</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div align=&apos;center&apos;&gt; &lt;b&gt;表1 2018年年末人口数及其构成&lt;/b&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">| 指标       | 年末数（万人） | 比重（%） |</span><br><span class="line">| ---------- | -------------- | --------- |</span><br><span class="line">| 全国总人口 | 139538         | 100.0     |</span><br><span class="line">| 其中：城镇 | 83137          | 59.58     |</span><br><span class="line">| 乡村       | 56401          | 40.42     |</span><br></pre></td></tr></table></figure>
<p>这两行代码生成下面的表和标题。</p>
<div align="center"> <b>表1 2018年年末人口数及其构成</b></div>
<table>
<thead>
<tr>
<th>指标</th>
<th>年末数（万人）</th>
<th>比重（%）</th>
</tr>
</thead>
<tbody>
<tr>
<td>全国总人口</td>
<td>139538</td>
<td>100.0</td>
</tr>
<tr>
<td>城镇</td>
<td>83137</td>
<td>59.58</td>
</tr>
<tr>
<td>乡村</td>
<td>56401</td>
<td>40.42</td>
</tr>
</tbody>
</table>
<p>从表1中得出，2018年年末城镇人口占总人口的59.58%，乡村人口占总人口的40.42%，城镇人口大比例超过乡村人口。</p>
<h3 id="2-3-公式"><a class="header-anchor" href="#2-3-公式">¶</a>2.3 公式</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">f=w_1 x_1 + w_2 x_2</span><br><span class="line">\tag&#123;1&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>数学Tex代码渲染成下面的公式，见公式（1）。公式可以在网站<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 进行可视化编写。
$$
f=w_1 x_1 + w_2 x_2
\tag{1}
$$</p>
<h4 id="定理证明"><a class="header-anchor" href="#定理证明">¶</a>定理证明</h4>
<p><strong>定理 3.1</strong> 如果时域混合场积分方程是时域电场积分方程与时域磁场积分方程的线性组合……</p>
<p><strong>证明：</strong></p>
<p>首先，由于 ……</p>
<p>……</p>
<p>根据 ……，结论得证。                        ■</p>
<h2 id="3-写作检查"><a class="header-anchor" href="#3-写作检查">¶</a>3 写作检查</h2>
<p>主体内容完成后，要进行写作检查。</p>
<ul>
<li>保证信息的准确性，时间地点等信息的准确。</li>
<li>确保语法规范性</li>
<li>段落写作
<ul>
<li>主题句，核心思想</li>
<li>使用关联词，但勿滥
<ul>
<li>表示转折：虽然，尽管，但是，相反的是，另一方面</li>
<li>对已阐述观点的强调：此外，与此同时，除此以外，再补充一点</li>
<li>阐述结果：结果是，相应的结果是，因此</li>
</ul>
</li>
<li>简单的句子 15-25</li>
</ul>
</li>
<li>精心选择词语
<ul>
<li>同一个意思，换一下说法</li>
<li>少用名词，多用动词。我们想用名词表达意思，采用动名组合，或者一个意群搭配上动词会更有力。</li>
<li>多用主动动词，少用被动动词</li>
</ul>
</li>
<li>核对标点符号，逗号，与分号。英文的话，检查一下拼写</li>
<li>注意行为的语气</li>
<li>保持连贯性，使用一种统一的方式表达。</li>
</ul>
<h2 id="4-总结"><a class="header-anchor" href="#4-总结">¶</a>4 总结</h2>
<p>一个清晰的总结应该概括全部论点。</p>
<h2 id="其他"><a class="header-anchor" href="#其他">¶</a>其他</h2>
<ul>
<li>逻辑清楚，达情切意<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。准备看一些基础的逻辑学。</li>
<li>写完要读两遍，修改错别字，标点，语序连接等等。<sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup></li>
<li>修改可以反着读，正着读对熟悉的材料会有一种连贯性忽略掉错误或者不顺的地方。</li>
</ul>
<hr>
<p><strong>参考</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[^statics_report_2018]: [国家统计局：2018年国民经济和社会发展统计公报](http://www.stats.gov.cn/tjsj/zxfb/201902/t20190228_1651265.html)</span><br><span class="line">[^latex_editor]: [Latex公式在线可视化编辑器](http://latex.codecogs.com/eqneditor/editor.php)</span><br><span class="line">[^hetang]: 美学散步系列书籍 - 朱自清的《荷塘清韵》</span><br></pre></td></tr></table></figure>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="http://www.stats.gov.cn/tjsj/zxfb/201902/t20190228_1651265.html" target="_blank" rel="noopener">国家统计局：2018年国民经济和社会发展统计公报</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="http://latex.codecogs.com/eqneditor/editor.php" target="_blank" rel="noopener">Latex公式在线可视化编辑器</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>美学散步系列书籍 - 朱自清的《荷塘清韵》 <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客模版</tag>
      </tags>
  </entry>
  <entry>
    <title>RSS跟踪github文件更新+某管子更新</title>
    <url>/public/2021/07/24/rss_github_file/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>好久没有更新博客了。RSS这种形式的信息获取方式，似乎又流行起来。</p>
<a id="more"></a>
<h2 id="github文件更新"><a class="header-anchor" href="#github文件更新">¶</a>github文件更新</h2>
<p>github上面有很多不错的资源。我的流程是：github readme文件更新-&gt;svn下载对应文件-&gt;生成rss文件。</p>
<p>这里为什么要这么复杂，因为github仓库更新多了好多不需要的rss信息，而且github文件下载比较慢。</p>
<p>最后效果，获取《经济学人》和《纽约客》的更新～</p>
<p><img src="/public/2021/07/24/rss_github_file/rss_result.png" alt="image-20210724005152399"></p>
<h3 id="下载脚本"><a class="header-anchor" href="#下载脚本">¶</a>下载脚本</h3>
<p>解析readme中的地址，自动下载，并生成rss源。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># /etc/cron.hour </span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> rfeed <span class="keyword">import</span> * <span class="comment"># 为生成rss.xml的库</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line">URL=<span class="string">"https://raw.githubusercontent.com/hehonghui/the-economist-ebooks/master/README.md"</span></span><br><span class="line">BASE_URL=<span class="string">"http://your_vps_host/download/"</span></span><br><span class="line"></span><br><span class="line">SVN_BASE_URL=<span class="string">"https://github.com/hehonghui/the-economist-ebooks/trunk/"</span></span><br><span class="line"></span><br><span class="line">s=<span class="string">"""</span></span><br><span class="line"><span class="string">* [经济学人 - 周刊, 点击这里下载最新一期](01_economist/te_2021.02.27) , 每周五十一点更新</span></span><br><span class="line"><span class="string">* [纽约客 - 周刊, 点击这里下载最新一期](02_new_yorker/2021.03.01) , 每周六上午更新</span></span><br><span class="line"><span class="string">* [卫报 - 每周两期](09_guardian/), 每周三、周日更新</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">s = request.urlopen(URL).read().decode(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">res= re.findall(<span class="string">r"\[.+\]\((0.+)\)"</span>,s)[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># generate xml</span></span><br><span class="line">res_list=[]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">	res_list+=sorted(glob(item.split(<span class="string">'/'</span>)[<span class="number">0</span>]+<span class="string">"/*"</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">item_list=[]</span><br><span class="line">print(item_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> res_list:</span><br><span class="line">    _one = Item(</span><br><span class="line">			title = item[<span class="number">3</span>:],</span><br><span class="line">        link = BASE_URL+item,</span><br><span class="line">		description = <span class="string">'pdf etc. &lt;a href="%s"&gt;link&lt;/a&gt; '</span>% (BASE_URL+item),</span><br><span class="line">        author = <span class="string">"hehonghui"</span>,</span><br><span class="line">        guid = Guid(BASE_URL+item),</span><br><span class="line">        pubDate = datetime.datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>)) <span class="comment"># year, month, date, hh, mm, ss</span></span><br><span class="line">    item_list+=[_one]</span><br><span class="line"></span><br><span class="line">feed = Feed(</span><br><span class="line">        title = <span class="string">"经济学人+纽约客更新"</span>,</span><br><span class="line">        link = <span class="string">"https://www.xxxxx.biz/atom/updated.xml"</span>,</span><br><span class="line">        description = <span class="string">"更新经济学人，纽约客"</span>,</span><br><span class="line">        language = <span class="string">"en-US"</span>,</span><br><span class="line">        lastBuildDate = datetime.datetime.now(),</span><br><span class="line">        items = item_list)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_file</span><span class="params">(file_name, contents)</span>:</span></span><br><span class="line">    fh = open(file_name, <span class="string">'w'</span>)</span><br><span class="line">    fh.write(contents)</span><br><span class="line">    fh.close()</span><br><span class="line"></span><br><span class="line">save_to_file(<span class="string">'test.xml'</span>, feed.rss())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># start downing </span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> res:</span><br><span class="line">    <span class="keyword">if</span> item <span class="keyword">not</span> <span class="keyword">in</span> res_list:</span><br><span class="line">	    print(<span class="string">"downing %s"</span>%item)</span><br><span class="line">	    os.popen(<span class="string">"svn checkout %s %s"</span>%(SVN_BASE_URL+item,item))</span><br><span class="line"></span><br><span class="line">    _now=sorted(glob(item.split(<span class="string">'/'</span>)[<span class="number">0</span>]+<span class="string">"/*"</span>))</span><br><span class="line">    print(_now)</span><br><span class="line">    <span class="keyword">if</span> len(_now)&gt;=<span class="number">5</span>: <span class="comment"># 最多5个，免得服务器下载过多。</span></span><br><span class="line">        <span class="keyword">for</span> _d <span class="keyword">in</span> _now[:<span class="number">-5</span>]:</span><br><span class="line">            os.popen(<span class="string">"rm -rf %s"</span>%_d)</span><br></pre></td></tr></table></figure>
<p>在linux亦可使用<a href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html" target="_blank" rel="noopener">crontab</a>定时启动下载任务。在 <code>/etc/cron.hourly/</code> 设置即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">date &gt;&gt; test.log</span><br><span class="line">python3 down_ecomic.py &gt;&gt;test.log</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<h2 id="下载某管音频，自动转成mp3格式"><a class="header-anchor" href="#下载某管音频，自动转成mp3格式">¶</a>下载某管音频，自动转成mp3格式</h2>
<p>某管自带rss的，所以只要用feedparser解析一下，然后调用youtube_dl下载一哈。
各种码包自行安装。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2020-04-18</span></span><br><span class="line"><span class="comment"># /etc/cron.hour # https://www.runoob.com/w3cnote/linux-crontab-tasks.html</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> rfeed <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line">URL=<span class="string">"https://www.youtube.com/feeds/videos.xml?channel_id=UCFhp6N5z8W9Ann2eyHAzbbA"</span></span><br><span class="line">rss = feedparser.parse(URL)</span><br><span class="line">entries=rss[<span class="string">'entries'</span>][:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">BASE_URL=<span class="string">"http://xxxxx/down_youtube/"</span></span><br><span class="line"></span><br><span class="line">item_list=[]</span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> entries:</span><br><span class="line">    print(entry[<span class="string">'title'</span>])</span><br><span class="line">    print(entry[<span class="string">'published'</span>])</span><br><span class="line">    print(entry[<span class="string">'link'</span>])</span><br><span class="line">    <span class="comment">#print(entry['summary'])</span></span><br><span class="line">    new_link=BASE_URL+<span class="string">"book_audios/%s.mp3"</span>%entry[<span class="string">'yt_videoid'</span>]</span><br><span class="line">    _one = Item(</span><br><span class="line">			title = entry[<span class="string">'title'</span>],</span><br><span class="line">        link = new_link,</span><br><span class="line">		description = <span class="string">'audio: &lt;a href="%s"&gt;mp3&lt;/a&gt; %s'</span>% (new_link,entry[<span class="string">'summary'</span>]),</span><br><span class="line">        author = <span class="string">"Youtube"</span>,</span><br><span class="line">        guid = Guid(new_link),</span><br><span class="line">        pubDate = datetime.datetime(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">0</span>)) <span class="comment"># year, month, date, hh, mm, ss</span></span><br><span class="line">    item_list+=[_one]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">feed = Feed(</span><br><span class="line">        title = <span class="string">"知乎读书会更新"</span>,</span><br><span class="line">        link = <span class="string">"https://www.xxxxx.biz/atom/updated.xml"</span>,</span><br><span class="line">        description = <span class="string">"更新Youtube知乎读书会"</span>,</span><br><span class="line">        language = <span class="string">"en-US"</span>,</span><br><span class="line">        lastBuildDate = datetime.datetime.now(),</span><br><span class="line">        items = item_list)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_file</span><span class="params">(file_name, contents)</span>:</span></span><br><span class="line">    fh = open(file_name, <span class="string">'w'</span>)</span><br><span class="line">    fh.write(contents)</span><br><span class="line">    fh.close()</span><br><span class="line"></span><br><span class="line">save_to_file(<span class="string">'audio.xml'</span>, feed.rss())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> rename</span><br><span class="line"><span class="keyword">import</span> youtube_dl</span><br><span class="line"></span><br><span class="line"><span class="comment"># start downing </span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">"book_audios/"</span>):</span><br><span class="line">    os.makedirs(<span class="string">"book_audios/"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">audio_download</span><span class="params">(youtube_url)</span>:</span></span><br><span class="line">    <span class="comment"># 定义某些下载参数</span></span><br><span class="line">    ydl_opts = &#123;</span><br><span class="line">        <span class="string">'format'</span>: <span class="string">'bestaudio/best'</span>,</span><br><span class="line">     <span class="comment">#   'download_archive': 'downloaded_songs.txt',</span></span><br><span class="line">        <span class="string">'outtmpl'</span>: <span class="string">'book_audios/%(id)s.%(ext)s'</span>,</span><br><span class="line">        <span class="string">'postprocessors'</span>: [&#123;</span><br><span class="line">            <span class="string">'key'</span>: <span class="string">'FFmpegExtractAudio'</span>,</span><br><span class="line">            <span class="string">'preferredcodec'</span>: <span class="string">'mp3'</span>,</span><br><span class="line">            <span class="string">'preferredquality'</span>: <span class="string">'192'</span>,</span><br><span class="line">            &#125;],</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> youtube_dl.YoutubeDL(ydl_opts) <span class="keyword">as</span> ydl:</span><br><span class="line">        ydl.download([youtube_url])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#download('https://www.youtube.com/watch?v=JElpSrsmbTU')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> entry <span class="keyword">in</span> entries:</span><br><span class="line">    <span class="keyword">if</span> entry[<span class="string">'yt_videoid'</span>]+<span class="string">'.mp3'</span> <span class="keyword">not</span> <span class="keyword">in</span> os.listdir(<span class="string">'book_audios'</span>):</span><br><span class="line">        print(<span class="string">"downing %s, %s"</span>%(entry[<span class="string">'title'</span>], entry[<span class="string">'link'</span>]))</span><br><span class="line">        audio_download(entry[<span class="string">'link'</span>])</span><br><span class="line">   </span><br><span class="line">    _now=sorted(glob(<span class="string">"book_audios/*"</span>),key=os.path.getctime)</span><br><span class="line">    print(_now)</span><br><span class="line">    <span class="keyword">if</span> len(_now)&gt;=<span class="number">6</span>: <span class="comment"># 多余删除</span></span><br><span class="line">        <span class="keyword">for</span> _d <span class="keyword">in</span> _now[:<span class="number">-5</span>]:</span><br><span class="line">            os.popen(<span class="string">"rm -rf %s"</span>%_d)</span><br></pre></td></tr></table></figure>
<h2 id="下载某管视频"><a class="header-anchor" href="#下载某管视频">¶</a>下载某管视频</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2020-04-18</span></span><br><span class="line"><span class="comment"># /etc/cron.hour # https://www.runoob.com/w3cnote/linux-crontab-tasks.html</span></span><br><span class="line"><span class="comment"># pip install feedparser youtube_dl</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> rfeed <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> feedparser</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> rename</span><br><span class="line"><span class="keyword">import</span> youtube_dl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_to_file</span><span class="params">(file_name, contents)</span>:</span></span><br><span class="line">    fh = open(file_name, <span class="string">'w'</span>)</span><br><span class="line">    fh.write(contents)</span><br><span class="line">    fh.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">audio_download</span><span class="params">(youtube_url, file_root, only_audio=False)</span>:</span></span><br><span class="line">    <span class="comment"># 定义某些下载参数</span></span><br><span class="line">    ydl_opts = &#123;</span><br><span class="line">        <span class="string">'format'</span>: <span class="string">'best'</span>,</span><br><span class="line">        <span class="string">'outtmpl'</span>: file_root+<span class="string">'/%(id)s.%(ext)s'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment"># 定义某些下载参数</span></span><br><span class="line">    ydl_opts_a = &#123;</span><br><span class="line">        <span class="string">'format'</span>: <span class="string">'bestaudio/best'</span>,</span><br><span class="line">     <span class="comment">#   'download_archive': 'downloaded_songs.txt',</span></span><br><span class="line">        <span class="string">'outtmpl'</span>: file_root+<span class="string">'/%(id)s.%(ext)s'</span>,</span><br><span class="line">        <span class="string">'postprocessors'</span>: [&#123;</span><br><span class="line">            <span class="string">'key'</span>: <span class="string">'FFmpegExtractAudio'</span>,</span><br><span class="line">            <span class="string">'preferredcodec'</span>: <span class="string">'mp3'</span>,</span><br><span class="line">            <span class="string">'preferredquality'</span>: <span class="string">'192'</span>,</span><br><span class="line">            &#125;],</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> only_audio:</span><br><span class="line">        ydl_opts = ydl_opts_a</span><br><span class="line">    <span class="keyword">with</span> youtube_dl.YoutubeDL(ydl_opts) <span class="keyword">as</span> ydl:</span><br><span class="line">        ydl.download([youtube_url])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YoutubeDowner</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, yurl, burl, file_root, feed_title, only_audio=False)</span>:</span></span><br><span class="line">        self.yurl = yurl</span><br><span class="line">        self.burl = burl</span><br><span class="line">        self.file_root = file_root</span><br><span class="line">        self.feed_title = feed_title</span><br><span class="line">        self.feed_des = feed_title</span><br><span class="line">        self.only_audio = only_audio</span><br><span class="line">        self.type_name = <span class="string">"mp4"</span></span><br><span class="line">        <span class="keyword">if</span> only_audio:</span><br><span class="line">            self.type_name = <span class="string">"mp3"</span></span><br><span class="line"></span><br><span class="line">        rss = feedparser.parse(yurl)</span><br><span class="line">        self.entries = rss[<span class="string">'entries'</span>][:<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_root):</span><br><span class="line">            os.makedirs(file_root)</span><br><span class="line">        self.generate_xml()</span><br><span class="line"></span><br><span class="line">        self.down()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_xml</span><span class="params">(self)</span>:</span></span><br><span class="line">        item_list = []</span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> self.entries:</span><br><span class="line">            print(entry[<span class="string">'title'</span>],entry[<span class="string">'published'</span>],entry[<span class="string">'link'</span>])</span><br><span class="line">           <span class="comment"># print(entry['summary'])</span></span><br><span class="line">            date_s = entry[<span class="string">'published'</span>].split(<span class="string">'T'</span>)[<span class="number">0</span>].split(<span class="string">'-'</span>)</span><br><span class="line">            dates = [int(x) <span class="keyword">for</span> x <span class="keyword">in</span> date_s]</span><br><span class="line">            <span class="comment"># print(dates)</span></span><br><span class="line">            new_link = self.burl + <span class="string">"/%s.%s"</span> % (entry[<span class="string">'yt_videoid'</span>],self.type_name) <span class="comment"># 下载的实际地址</span></span><br><span class="line">            print(<span class="string">'%s: &lt;a href="%s"&gt;%s&lt;/a&gt; &lt;pre&gt;%s&lt;/pre&gt;'</span> % (self.type_name,new_link,self.type_name,entry[<span class="string">'summary'</span>]))</span><br><span class="line">            _one = Item(</span><br><span class="line">                    title = entry[<span class="string">'title'</span>],</span><br><span class="line">                link = new_link,</span><br><span class="line">                description = <span class="string">'%s: &lt;a href="%s"&gt;%s&lt;/a&gt; &lt;pre&gt;%s&lt;/pre&gt;'</span> % (self.type_name,new_link,self.type_name,entry[<span class="string">'summary'</span>]),</span><br><span class="line">                author = <span class="string">"Youtube"</span>,</span><br><span class="line">                guid = Guid(new_link),</span><br><span class="line">                pubDate = datetime.datetime(dates[<span class="number">0</span>], dates[<span class="number">1</span>], dates[<span class="number">2</span>], <span class="number">6</span>, <span class="number">0</span>)) <span class="comment"># year, month, date, hh, mm, ss</span></span><br><span class="line">            item_list+=[_one]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        feed = Feed(</span><br><span class="line">                title = self.feed_title,</span><br><span class="line">                link = <span class="string">"https://www.xxxxx.biz/atom/updated.xml"</span>,</span><br><span class="line">                description = self.feed_des,</span><br><span class="line">                language = <span class="string">"en-US"</span>,</span><br><span class="line">                lastBuildDate = datetime.datetime.now(),</span><br><span class="line">                items = item_list)</span><br><span class="line"></span><br><span class="line">        save_to_file(<span class="string">'%s.xml'</span> % self.file_root, feed.rss())</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">down</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> entry <span class="keyword">in</span> self.entries:</span><br><span class="line">            <span class="keyword">if</span> entry[<span class="string">'yt_videoid'</span>]+<span class="string">'.'</span>+self.type_name <span class="keyword">not</span> <span class="keyword">in</span> os.listdir(self.file_root):</span><br><span class="line">                print(<span class="string">"downing %s, %s"</span>%(entry[<span class="string">'title'</span>], entry[<span class="string">'link'</span>]))</span><br><span class="line">                audio_download(entry[<span class="string">'link'</span>], self.file_root, self.only_audio)</span><br><span class="line">    </span><br><span class="line">        _now = sorted(glob(self.file_root + <span class="string">"/*"</span>),key=os.path.getctime)</span><br><span class="line">        print(_now)</span><br><span class="line">        <span class="keyword">if</span> len(_now)&gt;=<span class="number">6</span>: <span class="comment"># 多余删除</span></span><br><span class="line">            <span class="keyword">for</span> _d <span class="keyword">in</span> _now[:<span class="number">-5</span>]:</span><br><span class="line">                os.popen(<span class="string">"rm -rf %s"</span>%_d)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># url_rss = "https://www.youtube.com/feeds/videos.xml?channel_id=UCSs4A6HYKmHA2MG_0z-F0xw"</span></span><br><span class="line"><span class="comment"># url_base="http://xxxxx/"</span></span><br><span class="line"><span class="comment"># root="rss2"</span></span><br><span class="line"><span class="comment"># title="李永乐老师"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># YoutubeDowner(url_rss, url_base, root, title)</span></span><br></pre></td></tr></table></figure>
<p>最后效果如下：</p>
<p><img src="/public/2021/07/24/rss_github_file/20220511-00-35-57.png" alt></p>
<p>祝大家使用愉快！</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>RSS</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」window软件运行时间</title>
    <url>/public/2022/04/15/soft_run_time/</url>
    <content><![CDATA[<h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2>
<p>对关注性能的程序开发人员而言，一个好的计时部件既是益友，也是良师。计时器既可以作为程序组件帮助程序员精确的控制程序进程，又是一件有力的调试武器，在有经验的程序员手里可以尽快的确定程序的性能瓶颈，或者对不同的算法作出有说服力的性能比较。</p>
<a id="more"></a>
<p>在Windows平台下，常用的计时器有两种，一种是<code>timeGetTime</code>多媒体计时器，它可以提供毫秒级的计时。但这个精度对很多应用场合而言还是太粗糙了。另一种是<code>QueryPerformanceCount</code>计数器，随系统的不同可以提供微秒级的计数。对于实时图形处理、多媒体数据流处理、或者实时系统构造的程序员，善用<code>QueryPerformanceCount/QueryPerformanceFrequency</code>是一项基本功。</p>
<p>本文要介绍的，是另一种直接利用<code>Pentium CPU</code>内部时间戳进行计时的高精度计时手段。以下讨论主要得益于<code>《Windows图形编程》</code>一书，第15页－17页，有兴趣的读者可以直接参考该书。关于RDTSC指令的详细讨论，可以参考Intel产品手册。本文仅仅作抛砖之用。</p>
<p>在 <code>Intel Pentium</code>以上级别的CPU中，有一个称为“时间戳（Time   Stamp）”的部件，它以64位无符号整型数的格式，记录了自CPU上电以来所经过的时钟周期数。由于目前的CPU主频都非常高，因此这个部件可以达到纳秒级的计时精度。这个精确性是上述两种方法所无法比拟的。</p>
<p>在Pentium以上的CPU中，提供了一条机器指令RDTSC（Read Time   Stamp Counter）来读取这个时间戳的数字，并将其保存在EDX:EAX寄存器对中。由于<code>EDX:EAX</code>寄存器对恰好是Win32平台下C++语言保存函数返回值的寄存器，所以我们可以把这条指令看成是一个普通的函数调用。像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inline   unsigned   __int64   GetCycleCount()   </span><br><span class="line">&#123;   </span><br><span class="line">  __asm   RDTSC   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是不行，因为RDTSC不被C++的内嵌汇编器直接支持，所以我们要用_emit伪指令直接嵌入该指令的机器码形式<code>0X0F</code>、<code>0X31</code>，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  inline   unsigned   __int64   GetCycleCount()   </span><br><span class="line">  &#123;   </span><br><span class="line">    __asm   _emit   0x0F   </span><br><span class="line">    __asm   _emit   0x31   </span><br><span class="line">  &#125;   </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">以后在需要计数器的场合，可以像使用普通的Win32   API一样，调用两次GetCycleCount函数，比较两个返回值的差，像这样：</span><br></pre></td></tr></table></figure>
<p>unsigned   long   t;<br>
t   =   (unsigned   long)GetCycleCount();<br>
//Do   Something   time-intensive   ...<br>
t   -=   (unsigned   long)GetCycleCount();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">`《Windows图形编程》`第15页编写了一个类，把这个计数器封装起来。有兴趣的读者可以去参考那个类的代码。作者为了更精确的定时，做了一点小小的改进，把执行`RDTSC`指令的时间，通过连续两次调用`GetCycleCount`函数计算出来并保存了起来，以后每次计时结束后，都从实际得到的计数中减掉这一小段时间，以得到更准确的计时数字。但我个人觉得这一点点改进意义不大。在我的机器上实测，这条指令大概花掉了几十到100多个周期，在`Celeron 800MHz`的机器上，这不过是十分之一微秒的时间。对大多数应用来说，这点时间完全可以忽略不计；而对那些确实要精确到纳秒数量级的应用来说，这个补偿也过于粗糙了。   </span><br><span class="line">    </span><br><span class="line">  这个方法的优点是：   </span><br><span class="line">    </span><br><span class="line">  1. 高精度。可以直接达到纳秒级的计时精度（在1GHz的CPU上每个时钟周期就是一纳秒），这是其他计时方法所难以企及的。   </span><br><span class="line">    </span><br><span class="line">  2. 成本低。`timeGetTime`函数需要链接多媒体库 `winmm.lib`，`QueryPerformance*`函数根据MSDN的说明，需要硬件的支持（虽然我还没有见过不支持的机器）和KERNEL库的支持，所以二者都只能在Windows平台下使用（关于DOS平台下的高精度计时问题，可以参考`《图形程序开发人员指南》`，里面有关于控制定时器8253的详细说明）。但`RDTSC`指令是一条CPU指令，凡是i386平台下Pentium以上的机器均支持，甚至没有平台的限制（我相信i386版本UNIX和Linux下这个方法同样适用，但没有条件试验），而且函数调用的开销是最小的。   </span><br><span class="line">    </span><br><span class="line">  3. 具有和CPU主频直接对应的速率关系。一个计数相当于1/(CPU主频Hz数)秒，这样只要知道了CPU的主频，可以直接计算出时间。这和   `QueryPerformanceCount`不同，后者需要通过`QueryPerformanceFrequency`获取当前计数器每秒的计数次数才能换算成时间。   </span><br><span class="line">    </span><br><span class="line">  这个方法的缺点是：   </span><br><span class="line">    </span><br><span class="line">  1. 现有的C/C++编译器多数不直接支持使用RDTSC指令，需要用直接嵌入机器码的方式编程，比较麻烦。   </span><br><span class="line">    </span><br><span class="line">  2. 数据抖动比较厉害。其实对任何计量手段而言，精度和稳定性永远是一对矛盾。如果用低精度的`timeGetTime`来计时，基本上每次计时的结果都是相同的；而`RDTSC`指令每次结果都不一样，经常有几百甚至上千的差距。这是这种方法高精度本身固有的矛盾。   </span><br><span class="line">    </span><br><span class="line">  关于这个方法计时的最大长度，我们可以简单的用下列公式计算：</span><br></pre></td></tr></table></figure>
<p>自CPU上电以来的秒数   =   RDTSC读出的周期数   /   CPU主频速率（Hz）</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">64位无符号整数所能表达的最大数字是`1.8×10^19`，在我的`Celeron   800`上可以计时大约700年（书中说可以在200MHz的Pentium上计时117年，这个数字不知道是怎么得出来的，与我的计算有出入）。无论如何，我们大可不必关心溢出的问题。   </span><br><span class="line">    </span><br><span class="line">下面是几个小例子，简要比较了三种计时方法的用法与精度   </span><br><span class="line"> ```c</span><br><span class="line">//Timer1.cpp   使用了RDTSC指令的Timer类//KTimer类的定义可以参见《Windows图形编程》P15   </span><br><span class="line">//编译行：CL Timer1.cpp   /link   USER32.lib   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">#include   &quot;KTimer.h&quot;   </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  unsigned   t;   </span><br><span class="line">  KTimer   timer;   </span><br><span class="line">  timer.Start();   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  t   =   timer.Stop();   </span><br><span class="line">  printf(&quot;Lasting   Time:   %d\n&quot;,t);   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">//Timer2.cpp   使用了timeGetTime函数   </span><br><span class="line">//需包含&lt;mmsys.h&gt;，但由于Windows头文件错综复杂的关系   </span><br><span class="line">//简单包含&lt;windows.h&gt;比较偷懒：）   </span><br><span class="line">//编译行：CL   timer2.cpp   /link   winmm.lib     </span><br><span class="line">#include   &lt;windows.h&gt;   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">  </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  DWORD   t1,   t2;   </span><br><span class="line">  t1   =   timeGetTime();   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  t2   =   timeGetTime();   </span><br><span class="line">  printf(&quot;Begin   Time:   %u\n&quot;,   t1);   </span><br><span class="line">  printf(&quot;End   Time:   %u\n&quot;,   t2);   </span><br><span class="line">  printf(&quot;Lasting   Time:   %u\n&quot;,(t2-t1));   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">//Timer3.cpp   使用了QueryPerformanceCounter函数   </span><br><span class="line">//编译行：CL   timer3.cpp   /link   KERNEl32.lib   </span><br><span class="line">#include   &lt;windows.h&gt;   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">  </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  LARGE_INTEGER   t1,   t2,   tc;   </span><br><span class="line">  QueryPerformanceFrequency(&amp;tc);   </span><br><span class="line">  printf(&quot;Frequency:   %u\n&quot;,   tc.QuadPart);   </span><br><span class="line">  QueryPerformanceCounter(&amp;t1);   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  QueryPerformanceCounter(&amp;t2);   </span><br><span class="line">  printf(&quot;Begin   Time:   %u\n&quot;,   t1.QuadPart);   </span><br><span class="line">  printf(&quot;End   Time:   %u\n&quot;,   t2.QuadPart);   </span><br><span class="line">  printf(&quot;Lasting   Time:   %u\n&quot;,(   t2.QuadPart-   t1.QuadPart));   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">////////////////////////////////////////////////   </span><br><span class="line">//以上三个示例程序都是测试1秒钟休眠所耗费的时间   </span><br><span class="line">//测试环境：Celeron   800MHz   /   256M   SDRAM       </span><br><span class="line">//         Windows   2000   Professional   SP2   </span><br><span class="line">//         Microsoft   Visual   C++   6.0   SP5   </span><br><span class="line">////////////////////////////////////////////////</span><br></pre></td></tr></table></figure>
<p>以下是Timer1的运行结果，使用的是高精度的<code>RDTSC</code>指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lasting   Time:   804586872</span><br></pre></td></tr></table></figure>
<p>以下是Timer2的运行结果，使用的是最粗糙的<code>timeGetTime API</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Begin   Time:   20254254   </span><br><span class="line">End   Time:   20255255   </span><br><span class="line">Lasting   Time:   1001</span><br></pre></td></tr></table></figure>
<p>以下是Timer3的运行结果，使用的是<code>QueryPerformanceCount API</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Frequency:   3579545   </span><br><span class="line">Begin   Time:   3804729124   </span><br><span class="line">End   Time:   3808298836   </span><br><span class="line">Lasting   Time:   3569712</span><br></pre></td></tr></table></figure>
<p>古人说，触类旁通。从一本介绍图形编程的书上得到一个如此有用的实时处理知识，我感到非常高兴。有美不敢自专，希望大家和我一样喜欢这个轻便有效的计时器。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>软件运行</tag>
      </tags>
  </entry>
  <entry>
    <title>Why Software Should Not Have Owners</title>
    <url>/public/2018/05/11/why_gnu/</url>
    <content><![CDATA[<p><a href="http://www.gnu.org/philosophy/why-free.html" target="_blank" rel="noopener">Why Software Should Not Have Owners</a>
为什么软件不应有主人
作者︰<a href="https://www.stallman.org/" target="_blank" rel="noopener">Richard Stallman</a></p>
<a id="more"></a>
<p>数字资讯科技令大众更容易复制和变更资料。然而不是所有人都希望这样。版权制度容许软件有「主人」。他们主要目的在于从公众夺取软件的潜在利益。他们希望独占这些软件的复制、更改权利。</p>
<p>版权制度随著印刷技术而发展——印刷是一种大量制作副本的技术。版权很适合这项技术，因为它只限制了大规模的复制。它并没有剥夺图书读者的自由。一般读者没有印刷机，他们只能用笔墨抄写作品，所以很少有读者因此而被控告。</p>
<p>数字科技比印刷机更灵活：当信息呈数字形式时，你能很容易把它跟别人分享。这种情况不太配合故有的版权制度，所以现在有越来越多日益严厉的措施用来加强软件版权。看看这些软件出版商协会（Software Publishers Association, SPA）的四种惯常说法：</p>
<ul>
<li>大肆宣传违反版权法去帮助朋友是错误的。</li>
<li>诱使大家告发违返规定的同事和同僚。</li>
<li>如果警察协助突击搜查公司和学校，那里的人们必须证明自己没有非法复制。</li>
<li>因软件出版商协会提出要求，美国政府起诉一些如麻省理工学院的 David LaMacchia的人，不是因为他非法软复制件，而只是因为破解复制工具，从而不能对用户非法复制进行检查。</li>
</ul>
<p>这些惯常说法和前苏联曾用过的做法相似，在每一台影印机前都有一个守卫，以防止那些未经许可复印，同时个人只有秘密地复制信息，并像「秘密出版物」一样在手头传播。不同的是，苏联管制信息是政治原因，而美国则是为了经济利益。无论动机如何，我们都受到影响。不管什么原因，任何人企图阻止信息共享，都导致了相同的后果和同样的不便。</p>
<p>软件所有者用各种理由来控制我们如何使用资讯的权利︰</p>
<ul>
<li>
<p>中伤
软件所有者使用「盗窃」、「剽窃」这类带有污蔑的词语，或者「知识产权」、「损害」之类专业的术语，向公众暗示他们是合理的——其实，他们是将软件和真实物件混为一谈。
我们对「拿取别人的物件」的概念 ，并不能直接套用在复制这件事，然而软件所有者却迫使我们必须接受他们的想法。</p>
</li>
<li>
<p>凭空夸大
软件所有者声称当用户复制他们的程序时，他们受到「伤害」或「经济损失」。但复制并不会对软件所有者造成直接的影响，也没有伤害到任何人。只有在使用复制者不愿意给软件所有者付费时，软件所有者才会受损失。
很明显大多数这样的人不愿意购买这些程序，但是软件所有者会假定所有人都会购买，并以此来计算他们的「损失」。客气点说这就是夸大了专有软件的价值。</p>
</li>
<li>
<p>法律
软件所有者经常引用当今的法律和苛刻的刑罚来威胁我们。这暗示现今的法律反映了一个不容置疑的道德观念，同时怂恿我们视这些刑罚为正常及不能推卸。
这些说词面对严谨的思维是站不住脚的，这做法只是打算利用了人的惯性思维。
显然法律是不能决定错对的。美国人都应该知道，五十年代的黑人在许多州份坐在巴士前座是违法的；但只有种族主义者才会说他们是错误的。</p>
</li>
<li>
<p>自然权利
软件作者常常声称与自己编写的程序有一种特殊联系，因此他们宣称对这个程序的渴望和兴趣是高于世上任何人。（通常是公司持有软件版权，而不是作者，但是我们预期忽略这个差异。)
对那些打算把「作者高于一切」推崇为一种道德的人，本人作为一个著名的软件开发者，只能说这是废话。
但一般人有两个原因对自然权利的说法产生共鸣。
第一个原因是将软件与现实事物过分地类比。当我做意大利面时，如果其他人也要吃，我一定会反感，因为那样的话，我就吃不上了。他的行为对我造成的损失，正如他得到的利益一样。我们中仅有一人可以吃意大利面，问题是谁来吃？我们两者之间最小的分歧也足以打破道德上的平衡。
问题是︰你会否因为运行或修改一个我写的程序而直接影响到你，而对我只会产生一点间接影响？你是否复制我的软件给你的朋友，而对你们的影响远比对我的还要大？我不应有这样的权利去叫你不要这么做。任何人都不该有。
这第二个原因就是，人们被告知作者的自然权利是社会约定俗成的准则。
历史证明，相反的一方才是正确的。当年起草美国宪法时坚决驳回了关于作者自然权利的提议。这就是为什么宪法只是允许版权体系，而并不强制要求；所以说版权体制一定是临时的。宪法也说明版权体制的目的是促进发展，而不是奖励作者。版权确实给作者和出版社带来了更多收益，但这本来只是一种激励他们的手段而已。
事实是我们的社会建立了削弱公众自然权利的版权制度。然而版权只有用于公益事业才是正当的。</p>
</li>
<li>
<p>经济
软件应该有主人的最终辩解理由是，这会提高软件产量。
这个论据至少比以上的更切合主题。它立足于一个合理目标——满足软件用户的需求。以经验看来，人们因为满意的回报而生产更多，是很容易理解的。
但是这个关于经济的论据有瑕疵：它基于这样一个假设，区别仅仅是我们要付多少钱的问题。它假设无论软件是否有其所有者，「软件产品」都是我们想要的。
由于这个假设合乎我们处理真实物件的经验，所以人们很乐意接受。假设你付费与否都能得到一份一样的三明治，这样你付的费用就是唯一的分别。不管你是否购买，三明治有相同的味道和相同的营养，但你只能吃一次。不管你是否从所有者手中得到三明治，它都不能直接影响到你的金钱以外的任何事情。
对任何真实物件，这都是正确的︰不管它是否有主人都不会直接影响它的本质和用途。
如果程序有了主人，这将大大影响它的本质，和你对它的用途。不同之处不仅仅是钱的问题。软件该有主人的体制鼓励软件主人生产，但不一定是社会真正需要的。它导致的道德低落影响我们所有人。
社会需要什么？社会需要对公民真实可用的信息──例如，人们可以解读、修补、使用和改进的程序，而不只是操作。但是软件主人往往会给我们一个不能研究和修改的黑盒子。</p>
</li>
</ul>
<p>社会也需要自由。当程序有了主人，用户就失去了控制他们部分生活的自由。</p>
<p>总之社会需要鼓励公民们自主合作的精神。当软件主人告诉我们用这种自然的方式帮助旁人是剽窃行为时，那他们就是玷污我们的人格。</p>
<p>这正是我们提倡自由软件 事关自由，而并非价格的原因。</p>
<p>支持所有者的经济论据是错误的，但是经济问题确实存在。一些人出于荣誉、认同和博爱，而编写了有用的软件，但是如果我们希望有更多的软件，就需要筹集资金。</p>
<p>自由软件开发者自从八十年代尝试过许多寻求财源的方法，稍有小成。我们不需要让任何人致富，典型的收入，足以吸引人做很多比编程少满足感的工作。</p>
<p>多年以来，我一直靠改进自己编写的自由软件为生，直到获得研究经费。每次改进我都会添加到标準发佈版本，使得大众受益。客户为我付费，这样我就会优先完成他们需求，自己的变成次要。</p>
<p>一些自由软件开发者通过支援服务赚钱。1994年，Cygnus 有近50个员工，估计有大约百分之十五的员工从事自由软件开发︰对一间软件公司而言，这是个了不起的比例。</p>
<p>九十年代，Intel、Motorola、Texas Instruments 和 Analog Devices 等公司联合赞助持续发展的GNU C语言编译器。现在大部份开发GCC的人工作还是受薪的开发者完成的。GNU的Ada语言编译器受美国空军赞助，之后成立专属公司延续过个项目。</p>
<p>自由软件运动的规模还是很小，但是靠听众支持的美国电台的例子说明，不用强迫每个用户付费也可以支撑一个巨大的活动。</p>
<p>今天如果你发现用了专有软件。如果你的朋友问你复制一份，拒绝是不对的。合作比版权更重要。私下传播也不能建立健康的社会。人应当自豪的向往开放而正直的生活，这就意味著应该对专有软件说「不」。</p>
<p>你应该能与其他软件使用者开放、自由地合作，能够学习软件如何运作，并教导学生，能够在软件出问题时请中意的程序员修复它。</p>
<p><strong>欢迎来到自由软件的世界。</strong></p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<p><a href="http://www.gnu.org/philosophy/why-free.html" target="_blank" rel="noopener">http://www.gnu.org/philosophy/why-free.html</a></p>
]]></content>
      <categories>
        <category>技术阅读</category>
      </categories>
      <tags>
        <tag>开源</tag>
        <tag>gnu</tag>
        <tag>linux</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习系列</title>
    <url>/public/2019/07/23/AI/ML_summary/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>路漫漫其修远兮，吾将上下而求索。2013年，大二接触人工智能课，讲逻辑推理，专家系统等等，神经网络只是一部分，打开当时老师的ppt，还能看到BP等算法。接着在2015年，上了模式识别课程，有一些启发式算法，KNN K-means等算法，同时神经网络也已经有了 GoogLeNet 等深层网络，热门的GAN网络也在2014年被提出。后面，机遇巧合，本科毕业时选了人工智能的坑，直到3年后的现在算是明白了一点。接下来的三年的目标还是 <a href="https://talengu.github.io/public/2018/10/01/AI/how_algorithm_engineer/">成为一名优秀的算法工程师</a>。</p>
<p>回望入坑 <strong>机器学习</strong>，没有系统地整理过相关知识。于是想着手整理一份自己笔记系列。本文为序。</p>
<blockquote>
<p>雄关漫道真如铁，而今迈步从头越。</p>
</blockquote>
<p><img src="/public/2019/07/23/AI/ML_summary/1564034058070.png" alt="1564034058070"></p>
<div align="center"> 图1 机器学习知识框架</div>
如图1 所示，整个系列将由五个部分组成。
<a id="more"></a>
<h2 id="一、机器学习基础"><a class="header-anchor" href="#一、机器学习基础">¶</a>一、机器学习基础</h2>
<h2 id="二、监督学习"><a class="header-anchor" href="#二、监督学习">¶</a>二、监督学习</h2>
<img src="/public/2019/07/23/AI/ML_summary/1564034419203.png" alt="1564034419203" style="zoom:67%;">
<div align="center"> 图 监督学习</div>
<h2 id="三、无监督学习"><a class="header-anchor" href="#三、无监督学习">¶</a>三、无监督学习</h2>
<img src="/public/2019/07/23/AI/ML_summary/1564034460034.png" alt="1564034460034" style="zoom:67%;">
<div align="center"> 图 无监督学习</div>
<h2 id="四、学习理论"><a class="header-anchor" href="#四、学习理论">¶</a>四、学习理论</h2>
<img src="/public/2019/07/23/AI/ML_summary/xuexililun.png" alt="xuexililun" style="zoom:67%;">
<div align="center"> 图 学习理论</div>
<h3 id="4-1-正则化"><a class="header-anchor" href="#4-1-正则化">¶</a>4.1 <a href="regulation_baysian.md">正则化</a></h3>
<h2 id="五、强化学习"><a class="header-anchor" href="#五、强化学习">¶</a>五、强化学习</h2>
<h2 id="六、参考与规划"><a class="header-anchor" href="#六、参考与规划">¶</a>六、参考与规划</h2>
<p><strong>目标</strong>
通过阅读以上基本书，打牢自己的理论基础。</p>
<p><strong>书籍</strong></p>
<ul>
<li>PRML Bishop</li>
<li>机器学习 周志华</li>
<li>统计学习 李航</li>
<li>深度学习 Goodfellow</li>
<li>模式识别 张学工</li>
</ul>
<p><strong>课程</strong></p>
<p><a href="https://www.bilibili.com/video/av70839977" target="_blank" rel="noopener">https://www.bilibili.com/video/av70839977</a></p>
<p><strong>博客编写</strong></p>
<ul>
<li>前言介绍，包括作者，背景，原始paper，和以上基本书的对应章节。</li>
<li>原理阐述，算法步骤写出。</li>
<li>案例分析</li>
<li>利用python写出代码，先用scilearn写。</li>
<li>总结，预告。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>DSP滤波程序</title>
    <url>/public/2015/06/14/dsp/dsp_filter/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>通过matlab对数字信号进行滤波器的设计后，我们要将设计好的参数放到嵌入式系统中进行滤波。本文就是一个滤波程序。</p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="comment">//z变换转成差分方程然后迭代</span></span><br><span class="line"><span class="comment">//Talen @UESTC 2015.6.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">float</span> *x,<span class="keyword">int</span> len)</span></span>;</span><br><span class="line"><span class="comment">//取后第1-n个</span></span><br><span class="line"><span class="function"><span class="keyword">float</span>* <span class="title">aminusone</span><span class="params">(<span class="keyword">float</span>* a,<span class="keyword">int</span> ar)</span></span>;</span><br><span class="line"><span class="comment">//差分中间值</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">gtcet</span><span class="params">(<span class="keyword">float</span> *t,<span class="keyword">float</span> *x,<span class="keyword">int</span> xr,<span class="keyword">int</span> s,<span class="keyword">int</span> d)</span></span>;</span><br><span class="line"><span class="comment">//主要滤波函数</span></span><br><span class="line"><span class="function"><span class="keyword">float</span>* <span class="title">gfilter</span><span class="params">(<span class="keyword">float</span> *b,<span class="keyword">int</span> br,<span class="keyword">float</span> *a,<span class="keyword">int</span> ar,<span class="keyword">float</span> *x,<span class="keyword">int</span> xr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">float</span> *x,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;<span class="built_in">printf</span>(<span class="string">"%9.3f "</span>,x[i]);</span><br><span class="line">    <span class="keyword">if</span>((i%<span class="number">7</span>)==<span class="number">6</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span>* <span class="title">aminusone</span><span class="params">(<span class="keyword">float</span>* a,<span class="keyword">int</span> ar)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span>* am = (<span class="keyword">float</span> *)<span class="built_in">malloc</span>((ar<span class="number">-1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ar<span class="number">-1</span>;i++)</span><br><span class="line">        am[i]=a[i+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> am;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">gtcet</span><span class="params">(<span class="keyword">float</span> *t,<span class="keyword">float</span> *x,<span class="keyword">int</span> xr,<span class="keyword">int</span> s,<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//x[]数据源 r数据源长度 s开始点(0开始) d数据长度</span></span></span><br><span class="line"><span class="function">    <span class="comment">//t可以是a[] b[] 长度与d一样</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span>* w = (<span class="keyword">float</span> *)<span class="built_in">malloc</span>(d * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;d;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=s-i;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=<span class="number">0</span>&amp;&amp;temp&lt;xr)</span><br><span class="line">            w[i]=x[temp];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            w[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//核心语句</span></span><br><span class="line">        sum=sum+w[i]*t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span>* <span class="title">gfilter</span><span class="params">(<span class="keyword">float</span> *b,<span class="keyword">int</span> br,<span class="keyword">float</span> *a,<span class="keyword">int</span> ar,<span class="keyword">float</span> *x,<span class="keyword">int</span> xr)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//b a x br b的长度 ar a的长度 xr数据长度</span></span></span><br><span class="line"><span class="function">    <span class="comment">//use本程序定义的gtcet()和aminusone()</span></span></span><br><span class="line"><span class="function">    <span class="comment">//输入数据，b，a，x得出滤波后的y</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span>* y = (<span class="keyword">float</span> *)<span class="built_in">malloc</span>(xr* <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ti=<span class="number">0</span>;ti&lt;xr;ti++)</span><br><span class="line">        y[ti]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;xr;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//最核心语句，此处迭代</span></span><br><span class="line">        y[i]=gtcet(b,x,xr,i,br)-gtcet(aminusone(a,ar),y,xr,i<span class="number">-1</span>,ar<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//input 源数据 可修改</span></span><br><span class="line">    <span class="comment">////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="keyword">float</span> x[<span class="number">120</span>]=&#123;<span class="number">-4</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">-4</span>, <span class="number">-6</span>, <span class="number">-4</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-6</span>, <span class="number">-6</span>, <span class="number">-4</span>, <span class="number">-4</span>,\</span><br><span class="line">        <span class="number">-6</span>, <span class="number">-6</span>, <span class="number">-2</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">-16</span>, <span class="number">-38</span>, <span class="number">-60</span>, <span class="number">-84</span>,\</span><br><span class="line">        <span class="number">-90</span>, <span class="number">-66</span>, <span class="number">-32</span>, <span class="number">-4</span>, <span class="number">2</span>, <span class="number">-4</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">12</span>, <span class="number">10</span>, <span class="number">6</span>,\</span><br><span class="line">        <span class="number">6</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-2</span>,\</span><br><span class="line">        <span class="number">-2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-2</span>, <span class="number">0</span>,\</span><br><span class="line">        <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-2</span>,\</span><br><span class="line">        <span class="number">-4</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-4</span>, <span class="number">-4</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-6</span>, <span class="number">-6</span>,\</span><br><span class="line">        <span class="number">-4</span>, <span class="number">-4</span>, <span class="number">8</span>, <span class="number">-10</span>, <span class="number">-8</span>, <span class="number">-6</span>, <span class="number">-6</span>, <span class="number">-8</span>, <span class="number">-12</span>, <span class="number">-10</span>,\</span><br><span class="line">        <span class="number">-8</span>, <span class="number">-8</span>, <span class="number">-10</span>, <span class="number">-12</span>, <span class="number">-10</span>, <span class="number">-8</span>, <span class="number">-8</span>, <span class="number">-10</span>, <span class="number">-10</span>,\</span><br><span class="line">        <span class="number">-8</span>, <span class="number">-6</span>, <span class="number">-6</span>, <span class="number">-8</span>, <span class="number">-8</span>, <span class="number">-4</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-4</span>, <span class="number">-4</span>,\</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">-4</span>, <span class="number">-2</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">-4</span>&#125;;</span><br><span class="line">    <span class="comment">//参数</span></span><br><span class="line">    <span class="keyword">float</span> b[<span class="number">7</span>]=&#123; <span class="number">0.0007</span>,<span class="number">0.0044</span>,<span class="number">0.0111</span>,<span class="number">0.0148</span>,<span class="number">0.0111</span>,<span class="number">0.0044</span>,<span class="number">0.0007</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> a[<span class="number">7</span>]=&#123; <span class="number">1.0000</span>,<span class="number">-3.1836</span>,<span class="number">4.6222</span>,<span class="number">-3.7795</span>,<span class="number">1.8136</span>,<span class="number">-0.4800</span>,<span class="number">0.0544</span>&#125;;</span><br><span class="line">    <span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line">    <span class="comment">//不要修改</span></span><br><span class="line">    <span class="keyword">int</span> xr=<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">    <span class="keyword">int</span> br=<span class="keyword">sizeof</span>(b)/<span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">    <span class="keyword">int</span> ar=<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line">    <span class="comment">//output 滤波后数据</span></span><br><span class="line">    <span class="keyword">float</span> *y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"参数b：\n"</span>);print(b,br);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"参数a：\n"</span>);print(a,ar);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"原数据：\n"</span>);print(x,xr);</span><br><span class="line"></span><br><span class="line">    y=gfilter(b,br,a,ar,x,xr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"滤波后数据：\n"</span>);print(y,xr);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数字信号处理</category>
      </categories>
      <tags>
        <tag>滤波器</tag>
        <tag>数字信号处理</tag>
      </tags>
  </entry>
  <entry>
    <title>终端中bash、vim、tmux等的配置</title>
    <url>/public/2018/07/12/linux/bash_bashrc/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>使用终端有一段时间了，现在主力的平台是Ubuntu16.04，本文对bash、vim、tmux配置的一些记录。</p>
<a id="more"></a>
<p>在<code>cd ~</code>下建立talen_bashrc文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> HOME_BASHRC=xxxx/talen_bashrc</span><br><span class="line"> alias vimbashrc='vim $HOME_BASHRC &amp;&amp; source $HOME_BASHRC'</span><br><span class="line"><span class="meta">#</span><span class="bash"> files</span></span><br><span class="line"> alias countfiles='echo "total num: " &amp;&amp; ls | wc -l &amp;&amp; du -sh'</span><br><span class="line"> alias ll='ls -htrlF --time-style="+%H:%M %Y/%m/%d"'</span><br><span class="line"> alias dum='du -a -d 1 -m |sort -nr'</span><br><span class="line"> alias dug='df -h /dev/sdbxxx &amp;&amp; du -BG -d 1 --time |sort -nr'</span><br><span class="line"></span><br><span class="line"> alias pi='pip install -i https://pypi.tuna.tsinghua.edu.cn/simple'</span><br><span class="line"> alias gpuwatch='watch -n 1 nvidia-smi'</span><br><span class="line"></span><br><span class="line"> alias gitm='git commit -m'</span><br><span class="line"> alias gits='git status -s'</span><br><span class="line"></span><br><span class="line"> export PYTHONPATH=$PYTHONPATH:xxxxxxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> vimrc</span></span><br><span class="line"> export MYVIMRC=xxxx/.vim/.vimrc</span><br><span class="line"> export VIMINIT="let &amp;rtp='xxxx/.vim,' . &amp;rtp</span><br><span class="line"> so $MYVIMRC"</span><br></pre></td></tr></table></figure>
<p>python环境使用的是anaconda（或者minicoonda）添加激活环境。
在<code>~/.bashrc</code>中加入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias talen='source xxx/talen_bashrc &amp;&amp; source activate xxx/envs'</span><br><span class="line">alias utalen='source deactivate'</span><br></pre></td></tr></table></figure>
<p>github <a href="https://github.com/talengu/vim/blob/master/bashrc" target="_blank" rel="noopener">bashrc</a></p>
<p>其他的vimrc配置见我的github项目<a href="https://github.com/talengu/vim" target="_blank" rel="noopener">vimrc</a></p>
<p><a href="https://github.com/talengu/vim" target="_blank" rel="noopener">vimrc</a></p>
<h2 id="跳转命令-z"><a class="header-anchor" href="#跳转命令-z">¶</a>跳转命令 z</h2>
<p><a href="https://github.com/rupa/z/blob/master/z.sh" target="_blank" rel="noopener">z.sh</a>
终端效率提升：自动路径切换
<a href="https://zhuanlan.zhihu.com/p/50548459" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/50548459</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Bashrc</tag>
        <tag>Vimrc</tag>
        <tag>Tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu引导修复</title>
    <url>/public/2017/06/14/linux/boot_recovery/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>本文记录修复ubuntu引导，并修改ubuntu盘的大小过程。
参考：<a href="http://www.cnblogs.com/jloveu/p/Ubuntu-partition-expansion-record.html" target="_blank" rel="noopener">http://www.cnblogs.com/jloveu/p/Ubuntu-partition-expansion-record.html</a>
工具：Ubuntu 的live U盘，带有gparted分区工具，和grub修复工具</p>
<a id="more"></a>
<h2 id="修复启动"><a class="header-anchor" href="#修复启动">¶</a>修复启动</h2>
<p>对于使用gpt的格式的硬盘，ubuntu不要用uefi来安装。gpt还要生成一个bootgios的分区，很重要。</p>
<p>执行以下命令（以root身份）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /tmp/mydir</span><br><span class="line">mount /dev/sda8 /tmp/mydir  (注：其中的`/dev/sda8`为我的`/`分区标识，根据自己情况修改为自己的`/`分区标识)</span><br><span class="line">mount /dev/sda11 /tmp/mydir/boot  (注：同上，`/dev/sda11`为`/boot`分区标识)</span><br><span class="line">mount --bind /dev /tmp/mydir/dev</span><br><span class="line">mount --bind /proc /tmp/mydir/proc</span><br><span class="line">mount --bind /sys /tmp/mydir/sys</span><br><span class="line">chroot /tmp/mydir  (此步可能输出一些信息，可以无视)</span><br><span class="line">grub-install /dev/sda  (注：其中的`/dev/sda`为`/`分区所在硬盘的标识)</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<h2 id="修改Ubuntu多系统的默认启动顺序"><a class="header-anchor" href="#修改Ubuntu多系统的默认启动顺序">¶</a>修改Ubuntu多系统的默认启动顺序</h2>
<p><a href="http://jingyan.baidu.com/article/f71d60379e16021ab641d1ab.html" target="_blank" rel="noopener">link</a>
打开该配置文件&quot;/etc/default/grub&quot;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/default/grub</span><br><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure>
<p>其中的“GRUB_DEFAULT=0”为设置默认启动项。系统启动菜单Windows10的启动项在第5项，修改为4（GRUB启动项是从0开始的）。<br>
<img src="/public/2017/06/14/linux/boot_recovery/boot_file.png" alt="GRUB修改"></p>
<h2 id="去除多余GRUB启动项（直接）"><a class="header-anchor" href="#去除多余GRUB启动项（直接）">¶</a>去除多余GRUB启动项（直接）</h2>
<p><a href="https://zhidao.baidu.com/question/472571337.html" target="_blank" rel="noopener">link</a><br>
注释掉“/boot/grub/grub.cfg”中对应</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gedit /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
<h2 id="Ubuntu下如何修复Grub引导"><a class="header-anchor" href="#Ubuntu下如何修复Grub引导">¶</a>Ubuntu下如何修复Grub引导</h2>
<p><a href="https://mp.weixin.qq.com/s/NDZPPA-0FhqSzRndQOhNEw" target="_blank" rel="noopener">link</a></p>
<p>本文以 Ubuntu Live CD 修复 Grub 引导为例，已在 /dev/sda3 安装 Fedora。</p>
<p>首先制作 Ubuntu 启动 USB</p>
<p>复制代码代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo dd <span class="keyword">if</span>=ubuntu-13.10-desktop-amd64.iso of=/dev/sdb </span><br><span class="line"><span class="comment">#/dev/sdb 为 USB 盘符</span></span><br></pre></td></tr></table></figure>
<p>1.使用启动 USB 进入 Ubuntu 试用环境</p>
<p>2.查看硬盘分区状况，获取 Linux 系统安装分区编号
代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure>
<p>查看输出结果，然后根据文件类型和分区大小来判定 Linux 系统安装在哪块硬盘和安装的分区。我的电脑是在 /dev/sda3 安装了 Fedora。</p>
<p>或者，打开 Gparted 图形化工具来查看分区信息也可以。</p>
<p>挂载 Fedora 安装分区</p>
<p>3.已知 Fedora 安装在了 /dev/sda3 上，所以我们可以用下面命令来挂载 Fedora 安装分区。你需要将 /dev/sda3 换成自己的 Linux 安装分区。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount /dev/sda3 /mnt</span><br></pre></td></tr></table></figure>
<p>4.挂载其他所需的目录（使用 --bind）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount --<span class="built_in">bind</span> /dev /mnt/dev</span><br><span class="line">sudo mount --<span class="built_in">bind</span> /proc /mnt/proc</span><br><span class="line">sudo mount --<span class="built_in">bind</span> /sys /mnt/sys</span><br></pre></td></tr></table></figure>
<p>5.Chroot 到硬盘上的 Linux 系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chroot /mnt</span><br></pre></td></tr></table></figure>
<p>6.安装&amp;更新 Grub</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub2-install /dev/sda</span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure>
<p>7.Grub 已经修复成功，我们还需要退出 chroot 环境、卸载已经挂载的设备与目录：</p>
<p>exit 退出 chroot 环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo umount /mnt/dev</span><br><span class="line">sudo umount /mnt/proc</span><br><span class="line">sudo umount /mnt/sys</span><br><span class="line">sudo umount /mnt</span><br></pre></td></tr></table></figure>
<p>8.重启！</p>
<p>上面就是使用Ubuntu LiveCD修复grub的方法介绍了，如果你在使用双系统安装windows中出现Grub引导错误，不妨使用该方法进行修复吧。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>BootRecovery</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」tcpdump是在哪儿抓到的包？</title>
    <url>/public/2022/07/01/linux/how_tcpdump/</url>
    <content><![CDATA[<blockquote>
<p>原文地址 <a href="https://cloud.tencent.com/developer/article/1879646" target="_blank" rel="noopener">cloud.tencent.com</a></p>
</blockquote>
<blockquote>
<p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对...</p>
</blockquote>
<p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对这个问题，我进行了一番学习探究。</p>
<p>先说结论：通过 PF_PACKET 这个特殊的套接字协议，直接接收来自链路层的帧。数据包<strong>并非没有</strong>进入内核，而是在进入内核后直接跳过了内核中三层 / 四层的协议栈，直达套接字接口，被应用层的 tcpdump 所使用。实际上，在网卡驱动程序通知内核接受到数据帧的时候，数据包就已经进入了内核处理流程。具体的区别，可以见下图。</p>
<p><img src="/public/2022/07/01/linux/how_tcpdump/1620.png" alt></p>
<p>内核网络协议栈示意图</p>
<a id="more"></a>
<p>先来看看，普通的套接字的收包路径在内核中是怎么样。</p>
<p>以最常见的以太网网卡，当网卡接口接收到了一个帧，那么接受者知道它一定包含了一个 Ethernet 报头。封包在协议栈向上传递过程中，一定会在报头中包含一个字段，指出下一阶段的处理应该使用哪一个协议。 以太网卡拥有特定的 MAC 地址，在监听数据帧的时候，当看到帧的目的 MAC 地址与自己的地址或者链路层广播地址（FF:FF:FF:FF:FF:FF）相匹配，就会通过 DMA 把该帧读取到内存中的 ring buffer。</p>
<p>当一个数据帧被写入到内存后，将产生一个硬件中断请求，以通知 CPU 收到了数据包。操作系统为了减少硬中断产生的次数，会采用一个软中断 (softirq) 唤醒 NAPI 子系统。这样会产生一个单独的线程，调用网卡驱动注册的 poll 方法收包，同时禁止网卡产生新的硬中断，这样的效果便是一次中断可以接收多个包。一旦软终端代码判断有 softirq 处于 pending 状态，便会调用软终端处理函数 net_rx_action。</p>
<p>中断处理函数会在处理循环中调用 NAPI poll 来接收数据包。poll 方法会分配一个 sk_buff 数据结构（include/linux/skbuff.h），表示该数据包的内核视图。然后将数据从缓冲区提取到新建的 sk_buff 中，并对其中的 protocol 字段做初始化，该字段用以识别特定的协议。之后这个字段会被 netif_receive_skb 内核函数查询，用来确定该执行哪个函数来处理三层的封包。字段涉及协议的值都列在了 include/uapi/linux/if_ether.h 中，名字形如 ETH_P_XXX，比如 ip 协议为 ETH_P_IP。而有一种特殊情况，单一封包可以传递给多个处理函数，这就是 tcpdump 等网络嗅探应用会用到的 ETH_P_ALL。</p>
<p>软终端处理循环的最后是通过 netif_receive_skb 函数将将数据交给 TCP/IP 协议栈的。它会从数据包包头中取出协议信息，然后遍历注册在这个协议上的回调函数列表。这里的列表值得一提，分别是 ptype_all 和 ptype_base。他们是 hash table 数据结构，分别对应通用数据包（ETH_P_ALL 类型）和特定协议的数据包（ETH_P_XXX 类型），其中存放着指向对应协议处理函数的指针，当收到该类型的数据包时便调用对应的处理函数。</p>
<p>因此，以 IP 数据包为例，当 ETH_P_IP 类型数据包出队后，软中断处理程序 net_rx_action 最终会在 ptype_base 列表中找到 IP 协议的处理函数 ip_rcv() 并调用它，完成数据包向上提交到协议栈。这里略过 IP 协议栈的处理过程，简而言之，在经过 IP 数据包完整性校验、Netfilter 子系统（iptables 的底层实现）、路由子系统等等一些列流程之后，开始准备送往高层协议。这里的处理和 net_rx_action 很相似，从 IP 数据包头部提取出协议类型后，通过名为 inet_protos 的哈希来寻找高层协议的处理函数，每个高层协议都对应一个处理函数，型如 tcp_v4_rcv(), udp_rcv() 等。</p>
<p>四层协议以较为简单的 UDP 为例，udp_rcv 会对 udp 包进行合法性校验，然后查找是否有愿意接收此数据包的套接字，如果找到，__udp_queue_rcv_skb 会将包放到 socket 的接收队列。最后，所有在这个 socket 上等待数据的进程都会收到通过 sk_data_ready 函数处理的通知。</p>
<p>以上是一个数据包穿越协议栈到达 socket 的简要过程，实际的内核处理过程会复杂的多，这里只是做简要的描述。以引入本文的主角：PF_PACKET 协议数据包在内核中的处理路径。</p>
<p>当创建 PF_PACKET 套接字时，与协议相关的数据包类型将被同时注册进 ptype_all 和 ptype_base，接受函数为 packet_rcb()。此时，net_rx_action 函数会拦截所有进入机器的包，并同样通过 netif_receive_skb 函数遍历 ptype_all 后，传递给 PF_PACKET 接受函数。值得一提的是，tcpdump 依赖的 libpcap 库并非使用原始套接字 + recvfrom 的方式收包，而是在内核空间分配一块内核缓冲区，然后用户空间调用 mmap 系统调用映射到用户空间。</p>
<h2 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h2>
<p><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/" target="_blank" rel="noopener">Monitoring and Tuning the Linux Networking Stack: Receiving Data</a></p>
<p><a href="https://www.linuxjournal.com/article/4852" target="_blank" rel="noopener">Inside the Linux Packet Filter</a></p>
<p><a href="https://km.woa.com/group/17746/articles/show/%E5%9B%BE%E8%A7%A3linux%20tcpdump" target="_blank" rel="noopener">图解 linux tcpdump</a></p>
<p>《深入理解 Linux 网络技术内幕》</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>tcpdump</tag>
      </tags>
  </entry>
  <entry>
    <title>个人主页搭建</title>
    <url>/public/2016/12/22/build_blog/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>本文主要内容为博客搭建的记录与分享，我采用了Hexo博客框架，NexT主题和Gitment评论系统。本文中记录了我博客的安装流程和使用过程中的改进细节。</p>
<p>对Next主题版本的一些说明：我使用的是<code>version: 5.1.0</code>。而使用新版本的NexT v6 主题的同学，有些功能如gitment已经实现，可以直接使用V6。此V6版本对于图片的使用可能会出现问题。仅需看看我下面的2.2小节。</p>
<p>有时间我会将我修改后的hexo Next theme 基于<code>version: 5.1.0</code>主题，给个独立的git仓，放到github 上。</p>
<blockquote>
<p>小技巧：在文章中可以使用<code>&lt;!-- more --&gt;</code>手动进行截断，more上面部分将被放到主页上显示。此为Hexo 提供的方式。</p>
</blockquote>
<p>下面就是用<code>&lt;!-- more --&gt;</code>截断的～～</p>
<a id="more"></a>
<p>在看安装教程的时候，发现怎么要涉及这么多东西，请大家不要担心，一步步来。同时也不用在意会不会nodejs，框架这些东西，人家已经帮我们把东西都写好了，我们做的就是改改配置文件，最多改改里面swig的模版的一些代码。最后，望大家见谅的是，我对js不太熟，有些地方不是很清楚。欢迎大家在下面评论，或者在github上开issue，共同讨论。</p>
<h2 id="1-安装"><a class="header-anchor" href="#1-安装">¶</a>1. 安装</h2>
<h3 id="1-1-简易安装使用"><a class="header-anchor" href="#1-1-简易安装使用">¶</a>1.1 简易安装使用</h3>
<p>使用新版本的 <code>NexT v6</code> 主题即可，有些功能如 <code>gitment</code> 已经实现。对于图片的使用可能会出现问题。仅需看看我下面的2.2小节。我使用的是 <code>version: 5.1.0</code> 。</p>
<h3 id="1-2-从头安装"><a class="header-anchor" href="#1-2-从头安装">¶</a>1.2 从头安装</h3>
<ul>
<li>安装 nodejs，从nodejs 官网下载安装包 <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">download page</a></li>
<li>安装git客户端 <a href="https://git-scm.com/" target="_blank" rel="noopener">git</a></li>
<li>安装Hexo <code>npm install -g hexo-cli</code>
<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo 中文安装文档</a>
<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo中文网站</a></li>
<li>安装NexT ，NexT是一个比较火的主题。
按官网教程NexT安装即可，官网安装和配置教程比较美滋滋。
<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a>
NexT Github  <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a>
另外，NexT开发者的博客（最近Next 变成组织了，祝贺）<a href="http://notes.iissnan.com" target="_blank" rel="noopener">http://notes.iissnan.com</a></li>
</ul>
<blockquote>
<p><strong>Ubuntu安装记录</strong></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for Ubuntu16.04</span></span><br><span class="line">$ sudo apt install npm nodejs-legacy</span><br><span class="line">$ sudo npm install hexo-cli -g</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>ok，安装完的目录结构。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── node_modules  <span class="comment"># nodejs的目录</span></span><br><span class="line">├── public        <span class="comment"># 输出网站目录</span></span><br><span class="line">├── scaffolds     <span class="comment"># hexo 的一些预设模版</span></span><br><span class="line">├── <span class="built_in">source</span>        <span class="comment"># 独立submodule</span></span><br><span class="line">├── themes        <span class="comment"># 主题 里面也有主题的配置文件不要与项目的配置文件搞混</span></span><br><span class="line">├── README.md</span><br><span class="line">├── _config.yml   <span class="comment"># 整个项目配置文件</span></span><br><span class="line">├── db.json</span><br><span class="line">├── index.html。  <span class="comment"># 用于跳转到public下</span></span><br><span class="line">└── package.json</span><br><span class="line"></span><br><span class="line">5 directories, 5 files</span><br></pre></td></tr></table></figure>
<p>我对博客项目的安排是这样的，总共有两个github项目，一个放素材，一个用hexo框架生成html文件。
在上面的文件目录只能够，将source 文件夹作为一个submodule 用 <a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" target="_blank" rel="noopener">git submodule</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对于我来说</span></span><br><span class="line">$ <span class="built_in">cd</span> path/to/your/github.io/project</span><br><span class="line">$ git submodule add https://github.com/talengu/blog_source <span class="built_in">source</span></span><br></pre></td></tr></table></figure>
<p>在生成html，下面操作都在 <code>path/to/your/github.io/project</code>，hexo找不到node_modules</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># clone 项目</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/talengu/talengu.github.io</span><br><span class="line">$ git submodule init</span><br><span class="line">$ git submodule update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到最新的submodule</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">source</span></span><br><span class="line">$ git merge origin/master</span><br><span class="line">$ git submodule update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行npm按照，由于已经生成它会按照package.json文件自动安装</span></span><br><span class="line"><span class="comment"># 没有npm的话 安装 https://nodejs.org/en/download/</span></span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<h2 id="2-配置"><a class="header-anchor" href="#2-配置">¶</a>2. 配置</h2>
<p>对于在NexT主页上介绍的配置我就不写了，请参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a>  。</p>
<img src="/public/2016/12/22/build_blog/image-20181112002650646.png" alt="image-20181112002650646" width="50%">
<p>下面主要对重要的和我自己修改的部分说明没有的进行配置，值得注意的是我的NexT版本是<code>version: 5.1.0</code>。</p>
<h3 id="2-1-NexT官网的设置"><a class="header-anchor" href="#2-1-NexT官网的设置">¶</a>2.1 NexT官网的设置</h3>
<p><strong>MathJax</strong></p>
<p>编辑 <code>主题配置文件</code>， 将 <code>mathjax</code> 下的 <code>enable</code> 设定为 <code>true</code> 即可。 <code>cdn</code> 用于指定 MathJax 的脚本地址，默认是 MathJax 官方提供的 CDN 地址。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cdn:</span> <span class="string">//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure>
<p>下面测试
<code>$\frac{d}{dx}c^n=nx^{n-1}$</code> $\frac{d}{dx}c^n=nx^{n-1}$</p>
<p><strong>Local Search</strong> (推荐)
本地内容搜索引擎。</p>
<ul>
<li>
<p>安装 hexo-generator-searchdb，在站点的根目录下执行以下命令：</p>
<p><code>npm install hexo-generator-searchdb --save</code></p>
</li>
<li>
<p>编辑 站点配置文件，新增以下内容到任意位置：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">   <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">   <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">   <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">   <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编辑 <code>主题配置文件</code>，启用本地搜索功能：</p>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local search</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">   <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-2-markdown图片"><a class="header-anchor" href="#2-2-markdown图片">¶</a>2.2 markdown图片</h3>
<p>网上的图片链接可以直接使用，下面对本地图片使用进行配置。</p>
<p><strong>使用</strong></p>
<p>安装插件<code>npm install https://github.com/CodeFalling/hexo-asset-image --save</code></p>
<p>在 <code>主题配置文件</code>（不是next的_config.yml）中设置<code>permalink: :year/:month/:day/:title/</code>，设置 <code>post_asset_folder: true</code>，这主要将文件拷贝到/public文件夹。其中permalink很关键，只能这样设置。</p>
<blockquote>
<p>图片必须放到和md文件名字一样的同名字文件夹。
如使用Typora软件写md的话，设置一下image保存路径即可，如下。</p>
<img src="/public/2016/12/22/build_blog/typora_image.png" alt="typora_image" width="50%">
</blockquote>
<h3 id="2-3-代码复制"><a class="header-anchor" href="#2-3-代码复制">¶</a>2.3 代码复制</h3>
<p>为了提高博客代码块的用户体验，仅仅代码高亮还不行，最好还能一键复制代码。故此文将讲述 Hexo NexT 主题博客的代码块复制功能配置。转 <a href="https://www.jianshu.com/p/3e9d614c1e77" target="_blank" rel="noopener">Hexo NexT 代码块复制功能</a></p>
<h4 id="2-3-1-下载-clipboard-js"><a class="header-anchor" href="#2-3-1-下载-clipboard-js">¶</a>2.3.1 下载 clipboard.js</h4>
<p>三方插件 clipboardjs ，相关介绍和兼容性<a href="https://clipboardjs.com/" target="_blank" rel="noopener">它主页</a>或 <a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">github</a> 上看。</p>
<p><strong>下载地址：</strong></p>
<ul>
<li><a href="https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.js" target="_blank" rel="noopener">clipboard.js</a></li>
<li><a href="https://raw.githubusercontent.com/zenorocha/clipboard.js/master/dist/clipboard.min.js" target="_blank" rel="noopener">clipboard.min.js</a> <strong>推荐</strong></li>
</ul>
<p>保存文件<code>clipboard.js / clipboard.min.js</code> ，目录如下：
<code>.\themes\next\source\js\src</code></p>
<h4 id="2-3-2-clipboardjs-使用"><a class="header-anchor" href="#2-3-2-clipboardjs-使用">¶</a>2.3.2 clipboardjs 使用</h4>
<p>也是在<code>.\themes\next\source\js\src</code>目录下，创建<code>clipboard-use.js</code>，文件内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*页面载入完成后，创建复制按钮*/</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params">e, t, a</span>) </span>&#123; </span><br><span class="line">  <span class="comment">/* code */</span></span><br><span class="line">  <span class="keyword">var</span> initCopyCode = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> copyHtml = <span class="string">''</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'</span>;</span><br><span class="line">    copyHtml += <span class="string">'  &lt;i class="fa fa-globe"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'</span>;</span><br><span class="line">    copyHtml += <span class="string">'&lt;/button&gt;'</span>;</span><br><span class="line">    $(<span class="string">".highlight .code pre"</span>).before(copyHtml);</span><br><span class="line">    <span class="keyword">new</span> ClipboardJS(<span class="string">'.btn-copy'</span>, &#123;</span><br><span class="line">        target: <span class="function"><span class="keyword">function</span>(<span class="params">trigger</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> trigger.nextElementSibling;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  initCopyCode();</span><br><span class="line">&#125;(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>
<p>在<code>.\themes\next\source\css\_custom\custom.styl</code>样式文件中添加下面代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//代码块复制按钮</span><br><span class="line"><span class="selector-class">.highlight</span>&#123;</span><br><span class="line">  //方便copy代码按钮（btn-copy）的定位</span><br><span class="line">  <span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-copy</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(#fcfcfc,#eee);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#d5d5d5</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-moz-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-ms-user-select</span>: none;</span><br><span class="line">    <span class="attribute">user-select</span>: none;</span><br><span class="line">    <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">13px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">-webkit-transition</span>: opacity .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">-o-transition</span>: opacity .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">transition</span>: opacity .<span class="number">3s</span> ease-in-out;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">5px</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.btn-copy</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.highlight</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.btn-copy</span>&#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-引用"><a class="header-anchor" href="#2-3-3-引用">¶</a>2.3.3 引用</h4>
<p>在<code>.\themes\next\layout\_layout.swig</code>文件中，添加引用（注：在 swig 末尾或 body 结束标签（<code>&lt;/body&gt;</code>）之前添加）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 代码块复制功能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/clipboard.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/clipboard-use.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>想看效果的可以去<a href="https://talengu.github.io/public/2016/12/22/build_blog/">我博客</a>看，截图如下:</p>
<img src="/public/2016/12/22/build_blog/image-20181112004401227.png" alt="image-20181112004401227" width="50%">
<blockquote>
<p>熟悉的也可以将<code>clipboard.min.js</code>和<code>clipboard-use.js</code>合并为一个文件，再在<code>.\themes\next\layout\_layout.swig</code>文件中使用。当然<code>clipboard.min.js</code>也可以直接用三方 cdn 的方式引入也行。</p>
</blockquote>
<h3 id="2-4-Gitment-评论功能"><a class="header-anchor" href="#2-4-Gitment-评论功能">¶</a>2.4 Gitment 评论功能</h3>
<p>集成 giment 评论系统的过程。gitment 把评论放到 github 的 issues 系统里，评论支持 md，比较适合程序员.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装gitment</span></span><br><span class="line">$ npm install gitment --save</span><br></pre></td></tr></table></figure>
<h4 id="2-4-1-注册-OAuth-Application"><a class="header-anchor" href="#2-4-1-注册-OAuth-Application">¶</a>2.4.1 注册 OAuth Application</h4>
<p>点击 <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a> 注册，注意<code>Authorization callback URL</code>填自己的网站 url <code>https://xxxx.github.io/</code>. 记下 <strong>Client ID</strong> 和 <strong>Client Secret</strong>.</p>
<blockquote>
<p>在新版本NexT v6里面已经支持gitment了所以你只要在github上注册一下 OAuth Application ，填上<strong>Client ID</strong> 和 <strong>Client Secret</strong>.即可</p>
</blockquote>
<h4 id="2-4-2-修改themes-next-config-yml"><a class="header-anchor" href="#2-4-2-修改themes-next-config-yml">¶</a>2.4.2 修改<code>themes/next/_config.yml</code></h4>
<p>在其中添加:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># <span class="selector-tag">Gitment</span></span><br><span class="line"># Introduction: https://imsun.net/posts/gitment-introduction/</span><br><span class="line"><span class="selector-tag">gitment</span>:</span><br><span class="line">  <span class="selector-tag">enable</span>: <span class="selector-tag">true</span></span><br><span class="line">  <span class="selector-tag">githubID</span>: <span class="selector-tag">yourid</span></span><br><span class="line">  <span class="selector-tag">repo</span>: <span class="selector-tag">yourrepo</span></span><br><span class="line">  <span class="selector-tag">ClientID</span>: <span class="selector-tag">yourid</span></span><br><span class="line">  <span class="selector-tag">ClientSecret</span>: <span class="selector-tag">yoursecret</span></span><br><span class="line">  <span class="selector-tag">lazy</span>: <span class="selector-tag">true</span></span><br></pre></td></tr></table></figure>
<p><strong>注意: 格式要正确，该空格的一定要空格。所有的 yourXXX 都换成自己的.</strong></p>
<p>在主题的<code>en.yml</code>增加:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">gitmentbutton</span>: <span class="selector-tag">Show</span> <span class="selector-tag">comments</span> <span class="selector-tag">from</span> <span class="selector-tag">Gitment</span></span><br></pre></td></tr></table></figure>
<p><code>zh-Hans.yml</code>增加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitmentbutton: 显示 Gitment 评论</span><br></pre></td></tr></table></figure>
<h4 id="2-4-3-修改主题layout-partials-comments-swig"><a class="header-anchor" href="#2-4-3-修改主题layout-partials-comments-swig">¶</a>2.4.3 修改主题<code>layout/_partials/comments.swig</code></h4>
<p>找到这个文件里的这两行:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"vcomments"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面是最后一个<code>elseif</code>分支，在下面加一个<code>elseif</code>分支:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.gitment.enable %&#125;</span><br><span class="line">   &#123;% if theme.gitment.lazy %&#125;</span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"ShowGitment()"</span> <span class="attr">id</span>=<span class="string">"gitment-display-button"</span>&gt;</span>&#123;&#123;  __('gitmentbutton') &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitment-container"</span> <span class="attr">style</span>=<span class="string">"display:none"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   &#123;% else %&#125;</span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"gitment-container"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>加完之后下面的内容是原来的，保持不变:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-4-增加gitment-swig"><a class="header-anchor" href="#2-4-4-增加gitment-swig">¶</a>2.4.4 增加<code>gitment.swig</code></h4>
<p>在主题下<code>layout/_third-party/comments/</code>目录下中添加文件<code>gitment.swig</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.gitment.enable %&#125;</span><br><span class="line">   &#123;% set owner = theme.gitment.githubID %&#125;</span><br><span class="line">   &#123;% set repo = theme.gitment.repo %&#125;</span><br><span class="line">   &#123;% set cid = theme.gitment.ClientID %&#125;</span><br><span class="line">   &#123;% set cs = theme.gitment.ClientSecret %&#125;</span><br><span class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://imsun.github.io/gitment/style/default.css"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://imsun.github.io/gitment/dist/gitment.browser.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   &#123;% if not theme.gitment.lazy %&#125;</span><br><span class="line">       <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">           <span class="keyword">var</span> gitment = <span class="keyword">new</span> Gitment(&#123;</span></span><br><span class="line"><span class="javascript">               id: <span class="built_in">window</span>.location.pathname, </span></span><br><span class="line"><span class="javascript">               owner: <span class="string">'&#123;&#123;owner&#125;&#125;'</span>,</span></span><br><span class="line"><span class="javascript">               repo: <span class="string">'&#123;&#123;repo&#125;&#125;'</span>,</span></span><br><span class="line">               oauth: &#123;</span><br><span class="line"><span class="javascript">                   client_id: <span class="string">'&#123;&#123;cid&#125;&#125;'</span>,</span></span><br><span class="line"><span class="javascript">                   client_secret: <span class="string">'&#123;&#123;cs&#125;&#125;'</span>,</span></span><br><span class="line">               &#125;&#125;);</span><br><span class="line"><span class="javascript">           gitment.render(<span class="string">'gitment-container'</span>);</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   &#123;% else %&#125;</span><br><span class="line">       <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">           <span class="function"><span class="keyword">function</span> <span class="title">ShowGitment</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">               <span class="built_in">document</span>.getElementById(<span class="string">"gitment-display-button"</span>).style.display = <span class="string">"none"</span>;</span></span><br><span class="line"><span class="javascript">               <span class="built_in">document</span>.getElementById(<span class="string">"gitment-container"</span>).style.display = <span class="string">"block"</span>;</span></span><br><span class="line"><span class="javascript">               <span class="keyword">var</span> gitment = <span class="keyword">new</span> Gitment(&#123;</span></span><br><span class="line"><span class="javascript">                   id: <span class="built_in">document</span>.location.href, </span></span><br><span class="line"><span class="javascript">                   owner: <span class="string">'&#123;&#123;owner&#125;&#125;'</span>,</span></span><br><span class="line"><span class="javascript">                   repo: <span class="string">'&#123;&#123;repo&#125;&#125;'</span>,</span></span><br><span class="line">                   oauth: &#123;</span><br><span class="line"><span class="javascript">                       client_id: <span class="string">'&#123;&#123;cid&#125;&#125;'</span>,</span></span><br><span class="line"><span class="javascript">                       client_secret: <span class="string">'&#123;&#123;cs&#125;&#125;'</span>,</span></span><br><span class="line">                   &#125;&#125;);</span><br><span class="line"><span class="javascript">               gitment.render(<span class="string">'gitment-container'</span>);</span></span><br><span class="line">           &#125;</span><br><span class="line">       <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>然后在主题下<code>layout/_third-party/comments/index.swig</code>文件中引入 gitment.swig 文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;% include 'gitment.swig' %&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-4-5-添加gitment-styl"><a class="header-anchor" href="#2-4-5-添加gitment-styl">¶</a>2.4.5 添加<code>gitment.styl</code></h4>
<p>在主题下<code>source/css/_common/components/third-party/</code>目录下添加<code>gitment.styl</code>文件，设置 button 的样式：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#gitment-display-button</span>&#123;</span><br><span class="line">     <span class="attribute">display</span>: inline-block;</span><br><span class="line">     <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">15px</span>;</span><br><span class="line">     <span class="attribute">color</span>: <span class="number">#0a9caf</span>;</span><br><span class="line">     <span class="attribute">cursor</span>: pointer;</span><br><span class="line">     <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">     <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#0a9caf</span>;</span><br><span class="line">     <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-id">#gitment-display-button</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">     <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">     <span class="attribute">background</span>: <span class="number">#0a9caf</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>然后在主题下<code>source/css/_common/components/third-party/third-party.styl</code>文件中引入相应的 CSS 样式即可:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">"gitment"</span>;</span><br></pre></td></tr></table></figure>
<p>这样就 ok 了！</p>
<h4 id="2-4-6-易错点"><a class="header-anchor" href="#2-4-6-易错点">¶</a>2.4.6 易错点</h4>
<ol>
<li>修改<code>themes/next/_config.yml</code>这个文件时，格式要正确。另外，repo 是你要想创建 issues 的仓库，完全可以跟博文所放的仓库不一个。id 就写自己的 github 用户名就可以，这个用户名跟 repo 必须匹配。</li>
<li>gitment 可能不支持链接地址里有中文，所以安装 gitment 前一定要参考<a href="http://yangq.me/post/19acb239.html" target="_blank" rel="noopener">前文</a>把链接持久化搞成全是英文的。</li>
<li>同一篇文章需要<a href="https://github.com/imsun/gitment/issues/68" target="_blank" rel="noopener">初始化 comment 两次的问题</a>，是因为 <a href="http://xxx.com/post/ab9bb85a.html" target="_blank" rel="noopener">http://xxx.com/post/ab9bb85a.html</a> 和点击<strong>阅读全文</strong>进去的链接 <a href="http://yangq.me/post/ab9bb85a.html#more" target="_blank" rel="noopener">http://xxx.com/post/ab9bb85a.html#more</a> 对 issues 来说是不同的，所以创建两次。解决方法就是<code>gitment.swig</code>里 id 弄成<code>window.location.pathname</code>而不是<code>document.location.href</code>。</li>
<li>初始化评论后，可以到 github 里自己放 issues 的仓库查看 issues 是否创建成功，有时候浏览器可能会有缓存依然提示你初始化评论。一般过个两分钟就显示正常了。</li>
</ol>
<h4 id="2-4-7-参考文档"><a class="header-anchor" href="#2-4-7-参考文档">¶</a>2.4.7 参考文档</h4>
<ol>
<li><a href="http://www.jianshu.com/p/10134c474991" target="_blank" rel="noopener">主要参考文档</a></li>
<li><a href="https://meesong.github.io/StaticBlog/2017/NexT+Gitment/" target="_blank" rel="noopener">一种相对简略的配置方式</a></li>
<li><a href="https://github.com/imsun/gitment/issues" target="_blank" rel="noopener">作者 issue</a></li>
</ol>
<h3 id="2-x-gittalk-评论系统"><a class="header-anchor" href="#2-x-gittalk-评论系统">¶</a>2.x gittalk 评论系统</h3>
<p><a href="https://iochen.com/2018/01/06/use-gitalk-in-hexo/" target="_blank" rel="noopener">https://iochen.com/2018/01/06/use-gitalk-in-hexo/</a></p>
<p>403 error:<br>
<a href="https://zhuanlan.zhihu.com/p/350735142" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/350735142</a></p>
<p>申请个人worker
<a href="https://dash.cloudflare.com/" target="_blank" rel="noopener">https://dash.cloudflare.com/</a></p>
<h3 id="2-x-glup加速"><a class="header-anchor" href="#2-x-glup加速">¶</a>2.x glup加速</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install --global gulp</span><br><span class="line">npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean  gulp-imagemin --save</span><br></pre></td></tr></table></figure>
<p>使用Gulp压缩Hexo博客静态资源, 加快响应速度
<a href="https://blog.csdn.net/cpohui/article/details/98525437" target="_blank" rel="noopener">https://blog.csdn.net/cpohui/article/details/98525437</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 设置 淘宝镜像源</span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">// 查看 使用的 镜像源</span><br><span class="line">npm config get registry</span><br><span class="line"></span><br><span class="line">// 安装 淘宝镜像源</span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<h3 id="2-x-字体大小"><a class="header-anchor" href="#2-x-字体大小">¶</a>2.x 字体大小</h3>
<p>Hexo 修改字体大小
<a href="https://www.jianshu.com/p/02fbd409988c" target="_blank" rel="noopener">https://www.jianshu.com/p/02fbd409988c</a></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">themes/next/source/css/_variables</span><br></pre></td></tr></table></figure>
<p><a href="https://zenreal.github.io/posts/44730/" target="_blank" rel="noopener">页面美化</a></p>
<h3 id="2-x-利用-Github-Actions-自动部署-Hexo-博客"><a class="header-anchor" href="#2-x-利用-Github-Actions-自动部署-Hexo-博客">¶</a>2.x 利用 Github Actions 自动部署 Hexo 博客</h3>
<p>生成RSA密码对，部署到任务仓。
<a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/" target="_blank" rel="noopener">https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/</a></p>
<h3 id="2-5-copyright文字添加"><a class="header-anchor" href="#2-5-copyright文字添加">¶</a>2.5 copyright文字添加</h3>
<p><strong>效果</strong> 可以在md文件里面控制是否使用这个组建。</p>
<img src="/public/2016/12/22/build_blog/copyright.png" alt="copyright" title="copyright 效果" width="50%">
<p><strong>使用</strong></p>
<p>在md文件中的front-head部分，设置 <code>copyright:true</code>如下面。
设置next/_config.yml 文件，中设置<code>post_copyright</code> 的选项 <code>enable</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">---</span></span><br><span class="line"><span class="selector-tag">title</span>: 个人主页搭建</span><br><span class="line"><span class="selector-tag">date</span>: 2016<span class="selector-tag">-12-22</span> 12<span class="selector-pseudo">:39</span><span class="selector-pseudo">:04</span></span><br><span class="line"><span class="selector-tag">categories</span>:</span><br><span class="line">  <span class="selector-tag">-</span> 博客搭建</span><br><span class="line"><span class="selector-tag">tags</span>:</span><br><span class="line">  <span class="selector-tag">-</span> <span class="selector-tag">Hexo</span></span><br><span class="line"><span class="selector-tag">comments</span>: <span class="selector-tag">true</span></span><br><span class="line"><span class="selector-tag">copyright</span>: <span class="selector-tag">true</span></span><br><span class="line"><span class="selector-tag">---</span></span><br></pre></td></tr></table></figure>
<p><strong>说明</strong> 对原next的改变</p>
<p>对于一些原创的文本可以设置版权的声明，这个是next自带的，我进行了修改。next的_config.yml 文件，中设置<code>post_copyright</code> 的选项，启用它会对所有的页面添加，我多加了一个page的copyright使能判断。
对<code>next/layout/_macro/post-copyright.swig</code>修改。下面为修改后的文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.post_copyright.enable %&#125;</span><br><span class="line">&#123;% if page.copyright %&#125; <span class="comment">&lt;!-- 加上page md文件头部使能--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"post-copyright"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"post-copyright-author"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; __('post.copyright.author') + __('symbol.colon') &#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">      &#123;&#123; config.author &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"post-copyright-link"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; __('post.copyright.link') + __('symbol.colon') &#125;&#125;<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- url的修正，可能要根据你的情况修改--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; config.url &#125;&#125;&#123;&#123; config.root &#125;&#125;&#123;&#123; post.path &#125;&#125;"</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; post.title &#125;&#125;"</span>&gt;</span>&#123;&#123; config.url &#125;&#125;&#123;&#123; config.root &#125;&#125;&#123;&#123; post.path &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"post-copyright-license"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">strong</span>&gt;</span>&#123;&#123; __('post.copyright.license_title') + __('symbol.colon') &#125;&#125; <span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">      &#123;&#123; __('post.copyright.license_content', theme.post_copyright.license_url, theme.post_copyright.license) &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-RSS-可选"><a class="header-anchor" href="#2-6-RSS-可选">¶</a>2.6 RSS (可选)</h3>
<p>对一些网站的feed 的订阅 如rss，使用来进行订阅网站的rss，现在一些网站已经没有rss服务，google也停掉了google rss reader的项目，所以看你的喜好。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装hexo-generator-feed</span></span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line"><span class="comment"># 在_config.yml 启用feed</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>tips: 由于我博客在public文件夹下，导致hexo-generator-feed生成的地址不对。
在node_modules/hexo-generator-feed/lib/generator.js` 第35行下面添加一行:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">url += <span class="string">'public/'</span></span><br></pre></td></tr></table></figure>
<p>可用此脚本替换 <code>sed -i &quot;36c url += 'public/';&quot; node_modules/hexo-generator-feed/lib/generator.js  </code></p>
<p>note: mac中手动修改，sed指令<a href="https://blog.csdn.net/bertie_Jnn/article/details/51219670" target="_blank" rel="noopener">不一样</a></p>
<h3 id="2-7-添加-fork-me-github"><a class="header-anchor" href="#2-7-添加-fork-me-github">¶</a>2.7 添加 fork me github</h3>
<p>效果</p>
<img src="/public/2016/12/22/build_blog/image-20181122020200453.png" alt="image-20181122020200453" width="50%">
<p>在<a href="https://github.com/blog/273-github-ribbons" target="_blank" rel="noopener">GitHub Ribbons</a>或<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">GitHub Corners</a>选择一款你喜欢的挂饰。比如下面的 github corners 在<code>your-url</code>填上你的 url 。</p>
<img src="/public/2016/12/22/build_blog/image-20181122020427248.png" alt="image-20181122020427248" width="50%">
<p>将刚刚复制的挂饰代码，添加到<code>themes/next/layout/_layout.swig</code>文件中，添加位置，放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下方如下图。</p>
<img src="/public/2016/12/22/build_blog/image-20181122021516212.png" alt="image-20181122021516212" width="50%">
<h3 id="2-8-添加注脚"><a class="header-anchor" href="#2-8-添加注脚">¶</a>2.8 添加注脚</h3>
<p>hexo-renderer-markdown-it插件，<a href="https://www.dazhuanlan.com/2019/11/22/5dd6faa42d279/" target="_blank" rel="noopener">参考</a></p>
<p>首先卸载原来的markdown渲染插件（我这里原来是marked，这是Hexo提供的默认渲染插件），然后把hexo-renderer-markdown-it装上：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure>
<p>然后在根目录下的<code>_config.yml</code>中进行相应的配置。<a href="https://github.com/hexojs/hexo-renderer-markdown-it/wiki/Simple-Configuration" target="_blank" rel="noopener">简单的配置方法</a>只包括设置markdown格式，这里就不详述了。<a href="https://github.com/hexojs/hexo-renderer-markdown-it/wiki/Advanced-Configuration" target="_blank" rel="noopener">高级的配置方法</a>中包含很多可选项。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span><br><span class="line"><span class="selector-tag">markdown</span>:</span><br><span class="line">  # 渲染设置</span><br><span class="line">  <span class="selector-tag">render</span>:</span><br><span class="line">    # 置为<span class="selector-tag">true</span>时，<span class="selector-tag">html</span>内容保持不变；置为<span class="selector-tag">false</span>时，<span class="selector-tag">html</span>内容将被转义成普通字符串</span><br><span class="line">    <span class="selector-tag">html</span>: <span class="selector-tag">true</span></span><br><span class="line">    # 是否生成与<span class="selector-tag">XHTML</span>完全兼容的标签（虽然我不懂是什么意思）</span><br><span class="line">    <span class="selector-tag">xhtmlOut</span>: <span class="selector-tag">false</span></span><br><span class="line">    # 置为<span class="selector-tag">true</span>时，每个换行符都被渲染成一个&lt;<span class="selector-tag">br</span>&gt;（即<span class="selector-tag">Hexo</span>的默认表现）；置为<span class="selector-tag">false</span>时，只有空行才会被渲染为&lt;<span class="selector-tag">br</span>&gt;（<span class="selector-tag">GFM</span>的默认表现）</span><br><span class="line">    <span class="selector-tag">breaks</span>: <span class="selector-tag">true</span></span><br><span class="line">    # 是否自动识别链接并把它渲染成链接</span><br><span class="line">    <span class="selector-tag">linkify</span>: <span class="selector-tag">true</span></span><br><span class="line">    # 是否自动识别印刷格式（意思是把(<span class="selector-tag">c</span>)渲染为©这样的）</span><br><span class="line">    <span class="selector-tag">typographer</span>: <span class="selector-tag">true</span></span><br><span class="line">    # 如果<span class="selector-tag">typographer</span>被设置为<span class="selector-tag">true</span>，则该选项用于设置将<span class="selector-tag">dumb</span> <span class="selector-tag">quotes</span>（""）自动替换为<span class="selector-tag">smart</span> <span class="selector-tag">quotes</span></span><br><span class="line">    quotes: '“”‘’'</span><br><span class="line">  # 设置所需插件</span><br><span class="line">  <span class="selector-tag">plugins</span>:</span><br><span class="line">    <span class="selector-tag">-</span> <span class="selector-tag">markdown-it-abbr</span></span><br><span class="line">    <span class="selector-tag">-</span> <span class="selector-tag">markdown-it-footnote</span></span><br><span class="line">    <span class="selector-tag">-</span> <span class="selector-tag">markdown-it-ins</span></span><br><span class="line">    <span class="selector-tag">-</span> <span class="selector-tag">markdown-it-sub</span></span><br><span class="line">    <span class="selector-tag">-</span> <span class="selector-tag">markdown-it-sup</span></span><br><span class="line">  # 锚点设置（因为我没有尝试相关内容，所以就不翻译相关说明了）</span><br><span class="line">  <span class="selector-tag">anchors</span>:</span><br><span class="line">    <span class="selector-tag">level</span>: 2</span><br><span class="line">    collisionSuffix: 'v'</span><br><span class="line">    <span class="selector-tag">permalink</span>: <span class="selector-tag">true</span></span><br><span class="line">    <span class="selector-tag">permalinkClass</span>: <span class="selector-tag">header-anchor</span></span><br><span class="line">    <span class="selector-tag">permalinkSymbol</span>: ¶</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># ref https://www.dazhuanlan.com/2019/11/22/5dd6faa42d279/</span><br><span class="line">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span><br><span class="line"><span class="selector-tag">markdown</span>:</span><br><span class="line">  # 渲染设置</span><br><span class="line">  <span class="selector-tag">render</span>:</span><br><span class="line">    # 置为<span class="selector-tag">true</span>时，<span class="selector-tag">html</span>内容保持不变；置为<span class="selector-tag">false</span>时，<span class="selector-tag">html</span>内容将被转义成普通字符串</span><br><span class="line">    <span class="selector-tag">html</span>: <span class="selector-tag">true</span></span><br><span class="line">    # 是否生成与<span class="selector-tag">XHTML</span>完全兼容的标签（虽然我不懂是什么意思）</span><br><span class="line">    <span class="selector-tag">xhtmlOut</span>: <span class="selector-tag">false</span></span><br><span class="line">    # 置为<span class="selector-tag">true</span>时，每个换行符都被渲染成一个&lt;<span class="selector-tag">br</span>&gt;（即<span class="selector-tag">Hexo</span>的默认表现）；置为<span class="selector-tag">false</span>时，只有空行才会被渲染为&lt;<span class="selector-tag">br</span>&gt;（<span class="selector-tag">GFM</span>的默认表现）</span><br><span class="line">    <span class="selector-tag">breaks</span>: <span class="selector-tag">true</span></span><br><span class="line">    # 是否自动识别链接并把它渲染成链接</span><br><span class="line">    <span class="selector-tag">linkify</span>: <span class="selector-tag">true</span></span><br><span class="line">    # 是否自动识别印刷格式（意思是把(<span class="selector-tag">c</span>)渲染为©这样的）</span><br><span class="line">    <span class="selector-tag">typographer</span>: <span class="selector-tag">true</span></span><br><span class="line">    # 如果<span class="selector-tag">typographer</span>被设置为<span class="selector-tag">true</span>，则该选项用于设置将<span class="selector-tag">dumb</span> <span class="selector-tag">quotes</span>（""）自动替换为<span class="selector-tag">smart</span> <span class="selector-tag">quotes</span></span><br><span class="line">    quotes: '“”‘’'</span><br><span class="line">  # 设置所需插件</span><br><span class="line">  <span class="selector-tag">plugins</span>:</span><br><span class="line">    <span class="selector-tag">-</span> <span class="selector-tag">markdown-it-abbr</span></span><br><span class="line">    <span class="selector-tag">-</span> <span class="selector-tag">markdown-it-footnote</span></span><br><span class="line">    <span class="selector-tag">-</span> <span class="selector-tag">markdown-it-ins</span></span><br><span class="line">    <span class="selector-tag">-</span> <span class="selector-tag">markdown-it-sub</span></span><br><span class="line">    <span class="selector-tag">-</span> <span class="selector-tag">markdown-it-sup</span></span><br><span class="line">  # 锚点设置（因为我没有尝试相关内容，所以就不翻译相关说明了）</span><br><span class="line">  # <span class="selector-tag">anchors</span>:</span><br><span class="line">  #   <span class="selector-tag">level</span>: 2</span><br><span class="line">  #   collisionSuffix: 'v'</span><br><span class="line">  #   <span class="selector-tag">permalink</span>: <span class="selector-tag">true</span></span><br><span class="line">  #   <span class="selector-tag">permalinkClass</span>: <span class="selector-tag">header-anchor</span></span><br><span class="line">  #   <span class="selector-tag">permalinkSymbol</span>: ¶</span><br><span class="line">  <span class="selector-tag">anchors</span>:</span><br><span class="line">    # <span class="selector-tag">Minimum</span> <span class="selector-tag">level</span> <span class="selector-tag">for</span> <span class="selector-tag">ID</span> <span class="selector-tag">creation</span>. (<span class="selector-tag">Ex</span>. <span class="selector-tag">h2</span> <span class="selector-tag">to</span> <span class="selector-tag">h6</span>)</span><br><span class="line">    <span class="selector-tag">level</span>: 2</span><br><span class="line">    # <span class="selector-tag">A</span> <span class="selector-tag">suffix</span> <span class="selector-tag">that</span> <span class="selector-tag">is</span> <span class="selector-tag">prepended</span> <span class="selector-tag">to</span> <span class="selector-tag">the</span> <span class="selector-tag">number</span> <span class="selector-tag">given</span> <span class="selector-tag">if</span> <span class="selector-tag">the</span> <span class="selector-tag">ID</span> <span class="selector-tag">is</span> <span class="selector-tag">repeated</span>.</span><br><span class="line">    collisionSuffix: ''           </span><br><span class="line">    # <span class="selector-tag">If</span> `<span class="selector-tag">true</span>`, <span class="selector-tag">creates</span> <span class="selector-tag">an</span> <span class="selector-tag">anchor</span> <span class="selector-tag">tag</span> <span class="selector-tag">with</span> <span class="selector-tag">a</span> <span class="selector-tag">permalink</span> <span class="selector-tag">besides</span> <span class="selector-tag">the</span> <span class="selector-tag">heading</span>.</span><br><span class="line">    <span class="selector-tag">permalink</span>: <span class="selector-tag">true</span>              </span><br><span class="line">    # <span class="selector-tag">Class</span> <span class="selector-tag">used</span> <span class="selector-tag">for</span> <span class="selector-tag">the</span> <span class="selector-tag">permalink</span> <span class="selector-tag">anchor</span> <span class="selector-tag">tag</span>.</span><br><span class="line">    <span class="selector-tag">permalinkClass</span>: <span class="selector-tag">header-anchor</span></span><br><span class="line">    # Set to 'right' to add permalink after heading</span><br><span class="line">    permalinkSide: 'left'</span><br><span class="line">    # <span class="selector-tag">The</span> <span class="selector-tag">symbol</span> <span class="selector-tag">used</span> <span class="selector-tag">to</span> <span class="selector-tag">make</span> <span class="selector-tag">the</span> <span class="selector-tag">permalink</span></span><br><span class="line">    <span class="selector-tag">permalinkSymbol</span>: ¶</span><br><span class="line">    # <span class="selector-tag">Transform</span> <span class="selector-tag">anchor</span> <span class="selector-tag">to</span> (1) <span class="selector-tag">lower</span> <span class="selector-tag">case</span>; (2) <span class="selector-tag">upper</span> <span class="selector-tag">case</span></span><br><span class="line">    <span class="selector-tag">case</span>: 0</span><br><span class="line">    # <span class="selector-tag">Replace</span> <span class="selector-tag">space</span> <span class="selector-tag">with</span> <span class="selector-tag">a</span> <span class="selector-tag">character</span></span><br><span class="line">    separator: '-'</span><br></pre></td></tr></table></figure>
<h3 id="2-x-添加运行时间"><a class="header-anchor" href="#2-x-添加运行时间">¶</a>2.x 添加运行时间</h3>
<p><a href="https://blog.csdn.net/jieruis/article/details/104024884?utm_source=app&amp;app_version=4.21.0" target="_blank" rel="noopener">https://blog.csdn.net/jieruis/article/details/104024884?utm_source=app&amp;app_version=4.21.0</a></p>
<h3 id="2-x-使用Github-Action-自动布置"><a class="header-anchor" href="#2-x-使用Github-Action-自动布置">¶</a>2.x 使用Github Action 自动布置</h3>
<p>ruanyifeng</p>
<p><a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https://github.com/组织或个人/仓库</span><br><span class="line">/workflows/执行Action的Name注意转码/badge.svg)</span><br></pre></td></tr></table></figure>
<p>编译过程图标
<a href="https://lindexi.oschina.io/post/Github-%E6%B7%BB%E5%8A%A0-Action-%E7%BC%96%E8%AF%91%E5%9B%BE%E6%A0%87.html" target="_blank" rel="noopener">https://lindexi.oschina.io/post/Github-添加-Action-编译图标.html</a></p>
<p>自动部署</p>
<p>ref: <a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/" target="_blank" rel="noopener">https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/</a></p>
<h2 id="TODO"><a class="header-anchor" href="#TODO">¶</a>TODO</h2>
<p>这个TODO中放的是，我接下来对博客搭建这个项目，要做的事。平台的debug，内容的设计等等。</p>
<ul>
<li>
<p>[ ] 续写这篇博客，后面根据内容多少看要不要拆分这个博客。</p>
</li>
<li>
<p>[ ] 永久化连接 permalink
​ 这permalink 和本地图片的拷贝复制有关不好改，下面是可能的方法，由于现在的评论还比较少，后面改进。
​ <a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">https://github.com/rozbo/hexo-abbrlink</a>
​ <a href="https://github.com/EqualMa/hexo-plugin-permalink-pathed-title" target="_blank" rel="noopener">https://github.com/EqualMa/hexo-plugin-permalink-pathed-title</a></p>
</li>
<li>
<p>[ ] gitment object ProgressEvent #170
​ gitment 出现问题 作者好像放弃了，所以网上有一些解决方案，(gitment issue #170)(<a href="https://github.com/imsun/gitment/issues/170" target="_blank" rel="noopener">https://github.com/imsun/gitment/issues/170</a>)</p>
<p>​ 临时使用<code>https://www.wenjunjiang.win/js/gitment.js</code> 这个gitment.js</p>
</li>
<li>
<p>[ ] 编写规范 得写一个博客的编写规范。分类、标签的使用，图片的使用，公式的使用等等</p>
</li>
</ul>
<h2 id="博客编写规范"><a class="header-anchor" href="#博客编写规范">¶</a>博客编写规范</h2>
<ul>
<li>github上有项目图片就从项目中链接过来，比如头像就是我github的头像</li>
<li>重要的图片存在本项目中</li>
<li>Typora的使用</li>
</ul>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<p><a href="https://www.jianshu.com/p/9f0e90cc32c2" target="_blank" rel="noopener">Hexo-NexT配置超炫网页效果</a> 好多新奇玩意儿～</p>
<p><a href="https://blog.csdn.net/yanzi1225627/article/details/77890414" target="_blank" rel="noopener">Hexo gitment</a></p>
<p>原文地址</p>
<p>图标网站
<a href="https://icons8.com/icon/new-icons/all" target="_blank" rel="noopener">icon8 web</a> 比较舒服
<a href="http://fontawesome.io" target="_blank" rel="noopener">http://fontawesome.io</a> 标准风格
<a href="https://www.easyicon.net/" target="_blank" rel="noopener">https://www.easyicon.net/</a> 国内的图标</p>
<p>补充修改进行中，，，</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>爱立信的百年沉浮</title>
    <url>/public/2022/04/01/history_ericsson/</url>
    <content><![CDATA[<blockquote>
<p>文章来源：<br>
鲜枣课堂（ID：xzclasscom）
<a href="https://mp.weixin.qq.com/s?__biz=MjM5NTY1MjY0MQ==&amp;mid=2650814278&amp;idx=1&amp;sn=26083fed8d8dd76340e063fd42a59dea" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<p>19 世纪中叶，电报业务在欧洲大陆逐渐开始普及。</p>
<p>1853 年，北欧小国瑞典动用 “海盗基金”（不是海盗的钱，是政府用来打海盗的钱），架设了自己的第一条电报线路，从首都斯德哥尔摩到乌普萨拉。</p>
<p>为了确保负责这条线路的正常运营，瑞典政府还成立了自己的第一家电报公司，名字叫 Televerket。</p>
<p>当时，Televerket 公司急需大量的电报硬件设备。于是，乌普萨拉电报局的局长，<strong>安东 · 亨里克 · 奥勒</strong>（Anton Henric Öller），决定创办一家公司，为 Televerket 生产、修理和改进电报机。</p>
<p>不久后，这家电气设备维修公司正式成立，名字叫奥勒公司（Öller &amp; Co）。</p>
<p><img src="/public/2022/04/01/history_ericsson/640.png" alt></p>
<center><div>安东 · 亨里克 · 奥勒，瑞典电信业的先驱</div></center>
<p>奥勒公司名义上是一家公司，但实际上就是一个手工作坊，规模很小，只能靠 Televerket 公司的资助才能维持生存。</p>
<p>在奥勒公司的员工中，有一个勤奋的小伙子，当时专门负责维修电报设备以及其它机械设备。他的名字，叫做<strong>拉什 · 玛格纳斯 · 爱立信</strong>（Lars Magnus Ericsson）。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-16487839499382.png" alt></p>
<center><div> 拉什 · 玛格纳斯 · 爱立信</div></center>
<a id="more"></a>
<p>拉什 · 爱立信 1846 年 5 月 5 日出生于瑞典中部瓦姆兰省的一个小农场里。他的家庭条件贫困，自己在 9 个兄弟姐妹中排行第六。</p>
<p>11 岁时，由于父亲病逝，他不得不外出工作，养家糊口。这期间，他当过矿工，修过铁路，还在铁匠铺做了很长时间的学徒。</p>
<p>1867 年，拉什 · 爱立信终于攒够了路费，来到他梦寐以求的瑞典首都——斯德哥尔摩。经过一周的试用后，他成功加入了奥勒公司，成为一名修理工。</p>
<p>尽管这份工作的工资微薄，拉什 · 爱立信仍然感到十分满足。他后来回忆说：“（这份工作）足以满足我的需求，让我庆幸地看到生活比以往任何时候都更加光明，我心中第一次感受到了生活的快乐。”</p>
<p>工作之余，拉什 · 爱立信努力学习数学、材料技术、工程制图，以及德语和英语。在公司老板奥勒先生的推荐下，1873 年和 1875 年，拉什 · 爱立信先后两次获得瑞典政府的官方资助，前往德国和瑞士进行游学和实习。</p>
<p>这期间，拉什 · 爱立信来到了德国柏林的西门子公司（Siemens &amp; Halske），学到了很多电报工程技术知识，也接触到一些先进的机床设备。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-16487839554904.jpeg" alt></p>
<center><div> 拉什 · 爱立信在西门子公司时绘制的图纸，相当精妙</div></center>
<p>游学结束之后，拉什 · 爱立信返回瑞典。此时的他，已经具备了非常丰富的专业知识，有能力开创属于自己的事业。</p>
<p>1876 年 4 月，拉什 · 爱立信拒绝了奥勒公司升职加薪的提议，在斯德哥尔摩皇后街 15 号一个普通建筑的小厨房里，创建了 <strong>L.M.Ericsson</strong> 公司。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-16487839586856.png" alt></p>
<center><div> 爱立信公司最初的商标</div></center>
<center><div>MEK.WERKSTAD 的意思是 “机械作坊”</div></center>
<center><div> STOCKHOLM 就是瑞典首都 “斯德哥尔摩”</div></center>
<p>当时的 L.M.Ericsson 公司，其实就是一个作坊修理铺。启动资金 1000 克朗，是借来的。小厨房不到 13 平方米，是租来的。仅有的一套工作设备，是一架脚踏式机床。</p>
<p>公司的全部员工，除了拉什 · 爱立信本人之外，只有一名临时雇佣的 12 岁男孩。</p>
<p>不久后，拉什 · 爱立信在奥勒公司的前同事卡尔 · 乔汗 · 安德森（Carl Johan Andersson）加入了他的新公司，成为合伙人。</p>
<p>公司创立之后，主要业务是维修各种机械设备、电报机以及电器仪表。他们接到的第一单生意，是维修用于火警的一只机械指示器，收费 2 克朗。</p>
<p>没过多久，拉什 · 爱立信凭借自己的才华和经验，制造出了一些不错的产品，例如用于铁路系统的拨号电报仪器，以及小型社区的防火电报系统。</p>
<p>这些产品，逐渐赢得了铁路、消防等部门用户的认可，带来了源源不断的订单。</p>
<h2 id="█-涉足电话业务，规模迅速扩张"><a class="header-anchor" href="#█-涉足电话业务，规模迅速扩张">¶</a>█  涉足电话业务，规模迅速扩张</h2>
<p>爱立信公司成立的同一年（1876 年），美国的亚历山大 · 贝尔申请并获得了电话的发明专利，从而将人类带入了电话时代。</p>
<p>1877 年，电话被引入瑞典。拉什 · 爱立信第一时间去买了一对，并进行了拆解研究。</p>
<p>后来，很多用户将损坏的电话机送到拉什 · 爱立信这里维修，使得他对电话机内部结构有了更深入的了解。</p>
<p>凭借敏锐的商业嗅觉，拉什 · 爱立信意识到电话背后的巨大商机。于是，他决定研制自己的电话机型号。</p>
<p>1878 年底，拉什 · 爱立信在妻子<strong>希尔达 · 爱立信</strong>（Hilda Ericsson）的帮助下，成功研制出第一台电话机产品。这款产品性能出色，价格远低于对手，受到了用户的欢迎。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-16487981603198.jpeg" alt></p>
<center><div>拉什 · 爱立信的妻子（左），对他帮助极大</div></center>
<p>后来，拉什 · 爱立信又推出了自己的墙式电话机，再次获得畅销。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879816421310.png" alt></p>
<center><div>爱立信的墙式电话机</div></center>
<p>1880 年，拉什 · 爱立信和他的公司迎来了一次重大的机遇。</p>
<p>当时，美国贝尔公司在斯德哥尔摩、哥德堡、马尔默、松兹瓦尔和索德港建造了一个电话网络。如果任由贝尔公司发展下去，他们将垄断整个瑞典的电话市场。</p>
<p>于是，拉什 · 爱立信决定与贝尔公司进行正面竞争。不久后，L.M.Ericsson 公司成功击败对手，先后中标了耶夫勒市和挪威卑尔根市的本地电话系统合同。</p>
<p>拉什 · 爱立信的胜利，极大地增强了瑞典人民的信心。事实证明，瑞典的工艺和技术，完全可以与世界最领先的公司相媲美。</p>
<p>1883 年，拉什 · 爱立信遇到了自己创业早期最重要的合作伙伴兼客户，<strong>亨里克 · 托勒 · 塞德格伦</strong>（Henrik Thore Cedergren）。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879816726712.jpeg" alt></p>
<center><div>亨里克 · 托勒 · 塞德格伦</div></center>
<p>亨里克 · 塞德格伦原本是一个珠宝商人。作为瑞典最早的电话机用户之一，他非常看好电话的发展潜力。但是，他认为贝尔公司的收费太过昂贵，阻碍了电话业务的普及。</p>
<p>于是，1883 年 2 月，他成立了一家名为 Stockholms Allmänna Telefonaktiebolag（斯德哥尔摩公共电话公司，以下简称 SAT 公司）的独立瑞典电话公司，旨在为公众提供廉价的电话连接服务。</p>
<p>起初，拉什 · 爱立信并不看好亨里克 · 塞德格伦和他的公司，因为他们完全没有电话网络方面的经验。后来，亨里克 · 塞德格伦凭借自己的热情，打动了拉什 · 爱立信，说服他支持自己的事业。</p>
<p>1883 年，L.M.Ericsson 公司和 SAT 公司就电话供应签订了一项供货合同，全面负责 SAT 的电话及相关设备。那一年，L.M.Ericsson 公司完成了 SAT 订购的 1000 部电话机和 22 套电话交换设备的交付。</p>
<p>此后，L.M.Ericsson 公司进入了发展的快车道。</p>
<p>1884 年，公司建造完成了自己的第一家大规模工厂。1885 年，生产了第一部手持送受话筒。1887 年，签订了当时的最大的合同，为 SAT 在斯德哥尔摩开办的电话局提供设备。这个电话局，是当时欧洲最大的电话局。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879816988314.png" alt></p>
<center><div>当时的 SAT 公司电话塔</div></center>
<p>1890 年，L.M.Ericsson 公司的员工人数上升到 153 人。1896 年，L.M.Ericsson 公司改制为有限责任公司，股份资本为 100 万克朗。这一年的 6 月 1 日，爱立信公司累计生产电话超过十万部。</p>
<p>此后的爱立信，开始全面开拓海外市场。</p>
<p>1897 年，爱立信在俄罗斯圣彼得堡开办工厂，组装电话机。1902 年，爱立信在纽约开设办事处。1903 年，爱立信与英国国家电话公司联合组建英国爱立信制造有限公司。</p>
<p>后来，爱立信陆续进入了挪威、丹麦、芬兰、澳大利亚、新西兰、南非、墨西哥、法国、匈牙利、奥地利等国家，成为一家全球性的电信设备公司。</p>
<p>1900 年，正当爱立信公司高速发展的时候，创始人拉什 · 爱立信决定辞去总经理职务。次年，他又辞任董事长，并逐步出售他持有的爱立信公司的股票（1905 年全部卖完）。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879817266816.png" alt></p>
<center><div>拉什 · 爱立信</div></center>
<p>1926 年 12 月 17 日，拉什 · 爱立信逝世，安葬在距离斯德哥尔摩不远的博基尔卡。按照他的遗嘱，墓地没有立石碑。</p>
<p>1946 年，拉什 · 爱立信百年诞辰之际，他的家乡为他立了一座石碑，上面刻着——<strong>“瑞典电话工业见证了他的成就”</strong>。</p>
<h2 id="█-遭遇股权危机，险些沦落敌手"><a class="header-anchor" href="#█-遭遇股权危机，险些沦落敌手">¶</a>█  遭遇股权危机，险些沦落敌手</h2>
<p>1914 年，第一次世界大战爆发，爱立信的海外市场受到重创。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879817662718.png" alt></p>
<center><div>瑞典地处波罗的海，战争导致出海口被封，爱立信的设备根本运不出去。</div></center>
<p>1917 年，俄国十月革命爆发，新成立的布尔什维克政府将爱立信在俄国的工厂和业务全部国有化，夺取了价值约 2000 万瑞典克朗的资产，使得爱立信公司雪上加霜。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879818274520.jpeg" alt></p>
<center><div>被夺走的工厂，后来被改名为 “红色黎明”</div></center>
<p>1918 年，为了度过经营危机，L.M.Ericsson 与 SAT 公司正式合并，成为 <strong>Allmänna Telefonaktiebolaget LM Ericsson</strong> 公司。</p>
<p>合并之后的新公司，得到了瑞典政府支付的约 5000 万克朗电话网络运营费用，大大缓解了经营压力。</p>
<p>不久后，新公司迎来了一个更大的危机，关于<strong>控制权</strong>的危机。</p>
<p>当时的情况是这样的：1909 年，SAT 公司创始人亨里克 · 塞德格伦去世时，将公司所有权转移给了一个基金会和他的家人。后来，SAT 公司与 L.M.Ericsson 公司合并，基金会和亨里克 · 塞德格伦的家人继而拥有了新公司的大部分控制权。</p>
<p>再后来，一战期间的巨额经营亏损，使得他们面临巨大的经济压力，于是，他们将爱立信公司的股权卖给了<strong>卡尔 · 弗雷德里克 · 温克兰茨</strong>（Karl Henrik Wincrantz）。</p>
<p>温克兰茨是谁？温克兰茨原本是 SAT 公司旗下斯德哥尔摩电信的总裁，1925 年，他被任命为爱立信公司的总裁。</p>
<p>为了巩固自己的权力，温克兰茨一直在努力增加自己的持股比例。</p>
<p>1928 年，在温克兰茨的推动下，爱立信公司开始发行 “A” 和“B”股。其中，“B”股只有 “A” 股千分之一的投票权。</p>
<p>温克兰茨希望通过持有少数 “A” 股来控制公司。同时，他主导发行了大量的 “B” 股，筹措公司发展所需的资金。这一时期，公司更名为 Telefon AB LM Ericsson。</p>
<p>温克兰茨增持股票肯定需要资金，但自己并没有这么多资金。于是，他找到了国际金融家<strong>伊瓦尔 · 克鲁格</strong>（Ivar Kreuger）。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879818656822.jpeg" alt></p>
<center><div>伊瓦尔 · 克鲁格</div></center>
<p>伊瓦尔 · 克鲁格帮助温克兰茨控制了爱立信公司。后来，克鲁格与温克兰茨闹翻，干脆赶走了温克兰茨，委任了自己的亲信担任爱立信公司的总裁。</p>
<p>克鲁格是一个做火柴生意起家的商人，非常精明，也非常不靠谱。为了从资本市场骗取资金，他长期谎报自己的资产规模和旗下企业的盈利能力。</p>
<p>1931 年，经济大萧条愈演愈烈，克鲁格资金断链。为了偿还债务，他找到了 ITT 的主席，索申尼斯 · 奔尼（Sosthenes Behn），把自己的爱立信股票以 1100 万美元的价格出售给 ITT。</p>
<p>ITT 是什么公司？美国国际电话电报公司，爱立信最大的竞争对手。这一举动，相当于把爱立信的控制权拱手交给了死对头。</p>
<p>1932 年 3 月，克鲁格自杀身亡。此时，ITT 拥有爱立信三分之一的股份。</p>
<p>事情被揭露之后，瑞典举国哗然。自己的民族企业，竟然被对手完全控制，这是无法接受的事情。</p>
<p>不过好在瑞典法律规定，禁止外国利益在瑞典公司中行使多数表决权，导致 ITT 公司没有办法完全控制爱立信公司。</p>
<p>后来，瑞典三大银行——斯堪的纳维亚银行、斯德哥尔摩恩斯基尔达银行和瑞典商业银行——迅速采取行动，拯救爱立信。他们与 ITT 进行谈判，逐渐增加了对爱立信公司的控股，夺回了控制权。</p>
<p>当时，负责牵头拯救行动的是瓦伦堡家族的<strong>小马库斯 · 瓦伦堡</strong>（Marcus Wallenberg Jr），斯德哥尔摩恩斯基尔达银行就属于他的瓦伦堡家族。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879819009724.jpeg" alt></p>
<center><div>小马库斯 · 瓦伦堡</div></center>
<p>后来，经过数十年的漫长周旋，一直到 1960 年，小马库斯 · 瓦伦堡才完全收回了 ITT 所持有的爱立信公司股份。爱立信公司也由此彻底摆脱了伊瓦尔 · 克鲁格事件的阴影。</p>
<h2 id="█-专注技术研发，成功反超对手"><a class="header-anchor" href="#█-专注技术研发，成功反超对手">¶</a>█  专注技术研发，成功反超对手</h2>
<p>二战时期，爱立信的业务再度因为出海口问题遭受重创。它的很多国外资产都被战争摧毁，销售额也大幅下降。</p>
<p>这期间，爱立信不得不临时转行，进行军工生产，为军队制造电话、飞机仪表、机枪和弹药等，维持生存。</p>
<p>二战结束后，全球电话市场需求激增，爱立信公司的业务也逐渐开始复苏。</p>
<p>1960 年，爱立信开始业务聚焦，砍掉了电信业务之外的无关业务，专注通信设备的研发。</p>
<p>当时，爱立信启动了一种名为 AKE 的商用电子交换系统的研发。到了 60 年代末，爱立信意识到，AKE 系统已经跟不上时代，它的速度太慢而且价格过于昂贵。</p>
<p>因为技术和产品的落后，爱立信在市场竞争中屡次输给自己的对手——ITT、GTE 和西门子等。</p>
<p>1969 年底，爱立信在一个大额合同上再次输给了 ITT。这次失败，迫使爱立信管理层下定决心，与瑞典电报公司 Televerket 联手，共同开发有竞争力的新型产品。</p>
<p>于是，1970 年 4 月，爱立信与 Televerket 正式签署协议，成立一家名为 <strong>Ellemtel Utvecklings AB</strong> 的联合研发公司。该公司的主要任务，就是开发一种先进的自动化数字电话交换系统，名为 <strong>AX 系统</strong>。</p>
<p>1976 年，经过不懈努力，Ellemtel 公司成功研发出世界上首台全数字交换机——<strong>AXE 交换机</strong>。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879819313226.png" alt></p>
<center><div>AXE 是爱立信历史上最重要和最成功的产品</div></center>
<p>AXE 是一个划时代的产品。它采用模块化的软硬件设计方式，易于制造和测试，也易于维修。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879819539828.png" alt></p>
<center><div>AXE 设备</div></center>
<p>因为技术上非常领先，在推出的两年时间里，AXE 几乎赢得了所有主要的国际电信合同。领导 AXE 开发团队的年轻工程师 Björn Svedberg，1977 年直接被任命为公司总裁。</p>
<p>AXE 成功商用后，Ellemtel 完成了自己的使命，逐步将研究成果移交给了爱立信和 Televerket。后来，Televerket 将自己的 Ellemtel 股份出售给爱立信，Ellemtel 也因此被完全整合到爱立信中。</p>
<h2 id="█-移动通信浪潮，百年名企沉浮"><a class="header-anchor" href="#█-移动通信浪潮，百年名企沉浮">¶</a>█ 移动通信浪潮，百年名企沉浮</h2>
<p>20 世纪 80 年代初，爱立信的数字交换技术继续在行业保持领先。</p>
<p>这一时期，因为沉迷于自己的 AXE 系统，爱立信错过了移动通信技术崛起的第一波浪潮。等到对手纷纷有所成就后，爱立信公司才反应过来，赶紧调整自身的战略方向，转战蜂窝移动通信市场。</p>
<p>1981 年 9 月，爱立信在沙特阿拉伯建设完成了世界第一个投入商业运营的 NMT 网络（比瑞典自己还早了 1 个月）。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879819790330.jpeg" alt></p>
<center><div>项目签约现场</div></center>
<p>1988 年，爱立信决定继续聚焦核心业务。这一年，它以 2.17 亿美元的价格，将自己的计算机和终端业务出售给了芬兰公司诺基亚。</p>
<p>与此同时，爱立信最主要的竞争对手，美国 AT&amp;T 公司，因为垄断被美国政府强行拆分。爱立信从中受益，很快占据了全球 40% 的移动系统市场。</p>
<p>后来，到了 2G 时代。欧洲基于 NMT 推出了 GSM，爱立信也及时地推出了自己的产品。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879820007232.png" alt></p>
<center><div>爱立信的 2G GSM 原型机</div></center>
<p>这期间，爱立信保持了连续 10 年<strong>年均 35% 以上</strong>的惊人增长，成为了世界上最大的电话及蜂窝移动通信设备商之一。</p>
<p>1995 年，爱立信的收入达到 76.1 亿瑞典克朗。1996 年，爱立信全球研发工程师达到 18000 名。1997 年，爱立信在世界移动市场上的份额达到 40%，拥有大约 5400 万用户。</p>
<p>1998 年，<strong>斯温 · 克里斯特 · 尼尔森</strong>（Sven-Christer Nilsson）当选为爱立信公司的 CEO。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879820245334.png" alt></p>
<center><div>斯温 · 克里斯特 · 尼尔森</div></center>
<p>在他的领导下，爱立信进行了重大的组织架构调整。</p>
<p>他将公司业务分为三个板块，分别是网络运营商部门、消费品部门（包括手机业务）和企业解决方案部门。（是不是有点眼熟？）</p>
<p>除了重组之外，尼尔森还宣布了 11000 人的裁员计划。</p>
<p>1999 年，爱立信与高通公司解决了为期两年的 CDMA 技术专利官司。作为和解的一部分，爱立信收购了高通的无线基础设施业务。</p>
<p>这一年，爱立信的手机业务在与诺基亚的竞争中落后，导致市场份额从 15.1% 下降到 10.5%。当时，爱立信 70% 的收入来自基础设施销售，而 21% 来自手机销售。</p>
<p>1999 年 7 月，因为业务重组失败，尼尔森被迫辞职。</p>
<p>进入 21 世纪，爱立信的霉运没有结束。2000 年，因为产品质量问题以及工厂发生的火灾意外，爱立信亏损 240 亿瑞典克朗。</p>
<p>2001 年，爱立信宣布将其手机的生产外包给<strong>伟创力</strong>国际有限公司，自己则集中力量于手机的技术研发、设计以及市场推广。同时，爱立信大幅裁剪了消费品部门的员工人数。</p>
<p>同年 10 月，爱立信与日本索尼公司分别出资 50%，组建了<strong>索尼爱立信移动通信公司</strong>，专门生产手机产品。对于这家公司，相信大家都比较熟悉。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879820498536.jpeg" alt></p>
<p>2002 年，在全球金融危机的持续影响下，爱立信再次遭受巨额亏损。</p>
<p>面对亏损，爱立信一方面推出了降低运营成本、提高效率的 “成本控制计划”；另一方面，调整市场战略，将公司的核心业务做了全面的优化与整合，出售了一些非核心业务。</p>
<p>2002 年 6 月，爱立信以 4 亿美元的价格，将自己的微电子部门卖给了<strong>英飞凌</strong>科技股份公司（当时是西门子的子公司）。</p>
<p>2003 年，随着全球通信产业回暖，加上之前的一系列战略调整显露成效，爱立信宣告结束亏损，恢复盈利。</p>
<p>复苏后的爱立信，在全球 3G 市场上表现突出，拥有 40% 的 3G WCDMA 市场份额，是当之无愧的全球第一设备商。</p>
<h2 id="█-遭遇中国对手，迎来严峻挑战"><a class="header-anchor" href="#█-遭遇中国对手，迎来严峻挑战">¶</a>█ 遭遇中国对手，迎来严峻挑战</h2>
<p>爱立信与中国的历史渊源已超过百年。早在 1892 年，爱立信就接到了来自中国的订单（2000 个电话机），并为中国供货。1906 年，中国代表团还前往斯德哥尔摩，参观了爱立信总部。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879820869638.png" alt></p>
<center><div>当时的会面场景</div></center>
<p>一个多世纪以来，爱立信在中国电信发展史上贡献了多个 “第一”。</p>
<p>中国第一部人工交换机（1900 年）和第一部自动交换机（1924 年），就是来自爱立信。1987 年中国第一套移动电话系统在广州开通，设备也是来自爱立信。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879821103340.jpeg" alt></p>
<center><div>中国第一套移动电话系统</div></center>
<p><img src="/public/2022/04/01/history_ericsson/640-164879821453442.png" alt></p>
<center><div>改革开放后，国内也引进了 AXE（1985 年照片）</div></center>
<p>爱立信一直非常重视中国市场，不仅成立了合资公司和独资公司，还在中国设立了爱立信学院和研究院。</p>
<p>不过，拉什 · 爱立信当年卖电话到这个国家的时候，一定不会想到，一百多年后，这个国家会走出来两个名不见经传的小公司，把他开创的通信霸业给搅得鸡犬不宁。</p>
<p>这两个小公司，当然就是华为和中兴。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879821693844.jpeg" alt></p>
<p>在这两家公司的挑战和冲击下，爱立信公司在 21 世纪的市场份额不断下滑，CEO 频繁更换。那些年，伴随爱立信的坏消息总是一个接着一个，不是出售业务，就是裁员。</p>
<p>2013 年，华为全年销售收入正式超过爱立信，爱立信被迫将全球第一的位置拱手相让。</p>
<p>2016 年，爱立信计划关闭瑞典境内的所有工厂，结束在瑞典制造产品 140 年的历史。</p>
<p>2017 年，爱立信净亏损 44.76 亿美元，全年裁员达到 1.7 万人。</p>
<h2 id="█-外部环境变化，业绩迅速复苏"><a class="header-anchor" href="#█-外部环境变化，业绩迅速复苏">¶</a>█ 外部环境变化，业绩迅速复苏</h2>
<p>2018 年之后，爱立信的形势有了明显的好转，原因包括多个方面。</p>
<p>首先，就是 5G 市场增长带来的商业机会。</p>
<p>爱立信非常重视 5G，投入了大量的资源进行研发。2014 年，爱立信就发布了全球首台 5G 移动终端原型。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879822068446.jpeg" alt></p>
<p>2016 年，爱立信发布了一款号称 “全球首个 5G NR 无线设备” 的 5G 基站——AIR 6468。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879822338648.jpeg" alt></p>
<p>2017 年 2 月，爱立信推出了自己的 5G 平台。2018 年 1 月，爱立信发布了首个 5G 小基站 “5G Radio Dot”，吸引了行业的广泛关注。</p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879822621150.png" alt></p>
<center><div>5G NR DOT 点系统</div></center>
<p>除了 5G 之外，另一个帮助爱立信业绩复苏的主要原因，是微妙变化的外部环境。</p>
<p>正如大家所知道的，中美贸易摩擦，美国对中国通信设备商进行强力打压，多个国家宣布 “禁用” 华为和中兴。于是，欧美国家的设备商就有了难得的市场机会。</p>
<p>综合种种因素，爱立信的业绩迅速转好，扭亏为盈，股价攀升。</p>
<p>2020 年，爱立信全年净销售额达到 2324 亿瑞典克朗（约合 278 亿美元），同比上涨 2%；净利润 176 亿瑞典克郎（约合 21 亿美元），相比 2019 年，翻了近十倍。</p>
<h2 id="█-结语"><a class="header-anchor" href="#█-结语">¶</a>█  结语</h2>
<p>爱立信，是通信行业历史最悠久的企业之一（准确来说，是 145 年的历史）。</p>
<p>在很长的一段时间里，它都是世界排名第一的通信设备制造商。爱立信的很多技术创新，改变了通信行业的发展走向。很多经典的通信产品和知名的通信项目，都是出于这家企业。</p>
<p>在一百年的发展过程中，爱立信有过辉煌，也有过挫折，但是它仍然屹立不倒，在世界通信第一阵营中牢牢占据自己的位置。这充分说明，这家企业有着自己的技术积累和文化底蕴，有属于自己的 “韧性”。</p>
<p>如今，5G 的竞争还在继续，百年老店爱立信的奋斗之路也在继续。面对变幻莫测的市场环境，爱立信究竟会走向何方呢？它还会续写另一段百年辉煌吗？</p>
<p>（全文完）</p>
<p><strong>参考文献：</strong></p>
<p>1、<a href="https://www.ericsson.com/en/about-us/history/company" target="_blank" rel="noopener">https://www.ericsson.com/en/about-us/history/company</a></p>
<p>2、<a href="https://en.wikipedia.org/wiki/Ericsson" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Ericsson</a></p>
<p>3、《改变世界》，2009 年出版</p>
<p>4、<a href="https://ethw.org/Lars_Magnus_Ericsson" target="_blank" rel="noopener">https://ethw.org/Lars_Magnus_Ericsson</a></p>
<p>5、<a href="https://www.company-histories.com/Telefonaktiebolaget-LM-Ericsson-Company-History.html" target="_blank" rel="noopener">https://www.company-histories.com/Telefonaktiebolaget-LM-Ericsson-Company-History.html</a></p>
<p><img src="/public/2022/04/01/history_ericsson/640-164879825241752.gif" alt></p>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>通信</tag>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title>正则化「一」机器学习中的正则化</title>
    <url>/public/2019/07/17/AI/regulation_baysian/</url>
    <content><![CDATA[<p><strong>前言</strong>
本<strong>正则化系列</strong>文章我们将讨论<strong>正则化技术在机器学习和深度学习的应用</strong>。本文为该系列的第一篇，主要介绍<strong>机器学习正则化的概念，原理和应用实例</strong>。</p>
<p><a href="https://en.wikipedia.org/wiki/Regularization_(mathematics)" target="_blank" rel="noopener">正则化</a> 技术广泛应用在机器学习和深度学习算法中，本质作用是<strong>防止过拟合、提高模型泛化能力</strong>。其中过拟合的简单理解就是训练的算法模型太过复杂，模型过分考虑了当前样本的结构。</p>
<p>在早期的机器学习领域一般只是将范数惩罚叫做正则化技术，而在深度学习领域认为，能够显著减少方差，而不过度增加偏差的策略都可以认为是正则化技术。故<strong>推广的正则化技术</strong>还有：扩增样本集、早停止、Dropout、集成学习、多任务学习、对抗训练、参数共享等。(具体见“花书 第七章 <a href="http://www.deeplearningbook.org/contents/regularization.html" target="_blank" rel="noopener">Regularization for Deep Learning</a>”），关于<strong>深度学习正则化</strong>会在下一篇正则化文章中重点分析。</p>
<p>转载自：<a href="https://blog.csdn.net/BigData_Mining/article/details/81631249" target="_blank" rel="noopener">https://blog.csdn.net/BigData_Mining/article/details/81631249</a></p>
<a id="more"></a>
<h2 id="1-多角度看机器学习正则化"><a class="header-anchor" href="#1-多角度看机器学习正则化">¶</a>1. 多角度看机器学习正则化</h2>
<p><strong>机器学习领域正则化</strong>可以从以下三个角度进行理解：</p>
<p><strong>(1)</strong> <strong>正则化等价于结构风险最小化，其是通过在经验风险项后加上表示模型复杂度的正则化项或惩罚项，达到选择经验风险和模型复杂度都较小的模型目的</strong>。</p>
<p>​	<strong>经验风险</strong>：机器学习中的风险是指模型与真实解之间的误差的积累，经验风险是指使用训练出来的模型进行预测或者分类，存在多大的误差，可以简单理解为训练误差，经验风险最小化即为训练误差最小。</p>
<p>​	<strong>结构风险</strong>：结构风险定义为经验风险与置信风险(置信是指可信程度)的和，置信风险越大，模型推广能力越差。可以简单认为结构风险是经验风险后面多加了一项表示模型复杂度的函数项，从而可以同时控制模型训练误差和测试误差，结构风险最小化即为在保证模型分类精度(经验风险)的同时，降低模型复杂度，提高泛化能力。</p>
<p>​	<strong>公式表达</strong>
$$
R(f)=\frac{1}{n}\sum_{i=1}^{n}L(y_i,f(x_i)) + \lambda \Omega (f)
\tag{1}
$$
​		其中，$R(f)$表示结构风险，$L(y_i,f(x_i))$表示第 $i$ 个样本的经验风险，$\Omega(f)$是表征模型复杂度的正则项，$\lambda$ 是正则化参数。根据奥姆剃刀定律，“如无必要，勿增实体”，即认为相对简单的模型泛化能力更好。而模型泛化能力强、泛化误差小，即表示模型推广能力强，通俗理解就是在训练集中训练得到的优秀模型能够很好的适用于实际测试数据，而不仅仅是减少训练误差或者测试误差。泛化误差定义如下：
$$
E={Bias}^2(X) + {Var}(X) +{Noise}
\tag{2}
$$
​		其中，$E$ 表示泛化误差，${Bias}$ 代表偏差，${Var}$ 代表方差， ${Noise}$ 代表噪声。</p>
<p>​	<strong>关系图</strong></p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/1563350068097.png" alt="1563350068097"></p>
<div align="center"> Fig 1. 泛化误差与偏差和方差的关系</div>
​		从 Fig 1 可以看出，随着训练程度加深，模型复杂度会增加，偏差减少，方差增大，而泛化误差呈现U型变化。对于一个“好的系统”通常要求误差小，正则化的作用即为适当的控制模型复杂度，从而使得**泛化误差曲线**取最小值。
<p><strong>(2)</strong> <strong>正则化等价于带约束的目标函数中的约束项</strong></p>
<p>以平方误差损失和L2范数为例，优化问题的数学模型如下：
$$
J(\theta)=\sum_{i=1}^{n}(y_i-\theta^Tx_i)^2
\tag{3}
$$
$$
{s.t.}{|| \theta ||}_2^2 \leq C\<br>
\tag{4}
$$</p>
<p>针对上述约束条件的优化问题，采用拉格朗日乘积算子法可以转化为无约束化问题，即
$$
J(\theta)=\sum_{i=1}^{n}(y_i-w^Tx_i)^2 + \lambda({|| \theta ||}_2^2-C)
\tag{5}
$$</p>
<p>由于参数 $C$ 为常数，可以忽略，故上述公式和标准的正则化 公式完全一致。</p>
<p><strong>(3)</strong> <strong>从贝叶斯角度考虑</strong></p>
<p>正则项等价于引入参数的模型先验概率，可以简单理解为对最大似然估计引入先验概率，从而转化为最大后验估计，其中的先验概率即对于正则项（这部分内容后面详细讲解）。</p>
<h2 id="2-基本概念"><a class="header-anchor" href="#2-基本概念">¶</a>2 基本概念</h2>
<p>正则化也可以成为规则化、权重衰减技术，不同的领域叫法不一样，数学上常用范数实现，例如L1和L2范数，统计学领域叫做惩罚项、罚因子。</p>
<p>下面给出范数的数学公式，方便以后分析：</p>
<p>​	(1) $p$ 范数：
$$
Lp=(\sum_{i=1}^{n}{|| x_i ||}^p)^{\frac{1}{p}}
\tag{6}
$$
​	(2) $L0$ 范数：0 范数表示向量中非零元素的个数（即为其稀疏度）</p>
<p>​	(3) $L1$ 范数：即向量元素绝对值之和，$p$ 范数取1，即为1范数
$$
{||x||}_1=\sum^n_1 {|| x_i || }
\tag{7}
$$</p>
<p>​	(4) $L2$ 范数：即向量元素绝对值的平方和再开发，也称欧几里得距离，$p$ 范数取2，即为2范数
$$
{||x||}_{2}=\sqrt{\sum^{n}_1|| x_i ||^2}
\tag{8}
$$</p>
<p>​	(5) $\infty $ 范数：即所有向量元素的绝对值中的最大值，$p$ 范数取 $\infty $，即为 $\infty $ 范数
$$
{||x  ||}_{\infty }=\underset{i}{\max}{\left | x_i \right |}
\tag{9}
$$</p>
<p>​	(6) $-\infty $ 范数：即所有向量元素绝对值中的最小值，$p$ 范数取$-\infty $，即为 $-\infty $ 范数
$$
{||x  ||}_{-\infty }=\underset{i}{\min}{\left | x_i \right |}
\tag{10}
$$
<strong>图形描述</strong></p>
<p>​		从 Fig 2、Fig 3 图可以看出：q(p)越小，曲线越贴近坐标轴，q(p)越大，曲线越远离坐标轴，并且棱角越明显，当q(p)取0时候，是完全和坐标轴贴合，当q(p)取无穷的时候，呈现正方体形状。同时也可以看出，采用不同的范数作为正则项，会得到完全不同的算法模型结果，故而对于不同要求的模型，应该采用不同的范数作为正则项。</p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/1563354053269.png" alt="1563354053269"></p>
<div align="center"> Fig 2. 向量长度为2维的范数约束</div>
![1563354456894](regulation_baysian/1563354456894.png)
<div align="center"> Fig 3. 向量长度为3维的范数约束</div>
## 3 深度理解
<p>​		为了更好的理解正则化技术原理，下面从4个方面进行深度分析，希望对大家理解有帮助。</p>
<h3 id="3-1-简单数值假设分析法"><a class="header-anchor" href="#3-1-简单数值假设分析法">¶</a>3.1 简单数值假设分析法</h3>
<p>​		此处以L2范数讲解，下面的各图形来自吴恩达的机器学习课程。</p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/image-20190619002115576.png" alt="image-20190619002115576"></p>
<div align="center"> Fig 4. 不同参数下的曲线拟合结果</div>
​		左边的曲线拟合是欠拟合，中间的曲线拟合是刚好合适，右边的曲线拟合是过拟合。对于右边的拟合曲线，有
$$
h_{\theta}(x)={\theta}_0+{\theta}_0 x_1 +{\theta}_2 x_2^2 +{\theta}_3 x_3^3 +{\theta}_4 x_4^4
\tag{11}
$$
​		从上式可以看出，由于$\theta_3$和$\theta_4$对应了高阶，导致拟合曲线是4阶曲线，出现了过拟合。正则化的目的为适当缩减$\theta_3$和$\theta_4$的值，例如都为0.0001，则上述曲线本质上等价与
$$
h_{\theta}(x)={\theta}_0 + {\theta}_1 x_1 +{\theta}_2 x_2^2
\tag{12}
$$
​		也就是变成了中间的刚好合适的拟合曲线。对于$\theta_3$ 和$\theta_4$增加 L2 正则项后的代价函数表达式为：
$$
J(\theta)= \underset{\theta}{\min}\frac{1}{n}\sum_{i=1}^{n}((h_{\theta}(x_i)-y_i)+1000{\theta}_3^2 + 1000 {\theta}_4^2)
\tag{13}
$$
​		从上式可以看出，$\theta_3^2$ 和 $\theta_4^2$ 均大于 0，其乘上了1000，要 $J(\theta)$ 是最小，则会迫使模型学习到的$\theta_3$ 和 $\theta_4$ 会非常小，因为只有在$\theta_3$ 和 $\theta_4$ 会非常小的情况下整个代价函数值才会取的较小值。在实际开发中，是对所有参数进行正则化，为了使代价函数尽可能的小，所有的参数 $\theta$ 的值（不包括 $\theta_0$）都会在一定程度上减小，但是减小程度会不一样，从而实现了权重衰减、简化模型复杂度的作用。
<h3 id="3-2-图形分析法"><a class="header-anchor" href="#3-2-图形分析法">¶</a>3.2 图形分析法</h3>
<p>​		此处采用L1和L2范数讲解：
<strong>(1) L2 范数正则</strong>
$$
J(\beta)=\sum_{i=1}^{n}(y_i-{\beta}^T x_i)^2 + \lambda {|| {\beta} ||}_2^2
\tag{14}
$$
<img src="/public/2019/07/17/AI/regulation_baysian/1563366078400.png" alt="1563366078400"></p>
<div align="center"> Fig 5. L2 范数与代价函数的寻优图示</div>
​		在 Fig 5 中，蓝色的圆形空间表示 L2 范数空间，设为 $\beta_1^2 + \beta_2^2 = r^2$，可以看出，当 $r$ 从 0 逐渐增大时候，该圆形也逐渐增大，红色的线表示原始代价函数解空间即 $\sum_{i=1}^{n}(y_i-\beta^T x_i)^2$，此处为了方便绘图，设参数只有2维。红色圆环上的任何一点都表示一个可行解即代表一组$\beta_1$、$\beta_2$，其中任何一个红色圆环上面的$\beta_1$，$\beta_2$对应的代价函数值一样（可以简单理解为等值线），$\hat{\beta}$ 代表最佳解空间。
<h2 id="4-贝叶斯角度分析"><a class="header-anchor" href="#4-贝叶斯角度分析">¶</a>4. 贝叶斯角度分析</h2>
<p>​		以L1和L2范数为例，所得结论可以推广到P范数中，首先需要知道：整个最优化问题从贝叶斯观点来看是一种贝叶斯最大后验估计，其中正则化项对应后验估计中的先验信息，损失函数对应后验估计中的似然函数，两者的乘积即对应贝叶斯最大后验估计的形式。针对L1和L2范数还有结论：<strong>L2 范数相当于给模型参数设置一个协方差为1/alpha的零均值高斯先验分布，L1 范数相当于给模型参数 设置一个参数为1/alpha 拉普拉斯先验分布</strong>。</p>
<p>​		为了讲清楚上述结论，需要具备几点前置知识点：(1) 高斯分布和拉普拉斯分布的定义和形状；(2) 贝叶斯定理；(3) 最大似然估计；(4) 最大后验估计。下面我对这4个知识点进行解释。</p>
<p><strong>(1)</strong> <strong>高斯分布和拉普拉斯分布</strong></p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0.png" alt="0?wx_fmt=png"></p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610163845194.png" alt="0?wx_fmt=png"></p>
<p><strong>(2)</strong> <strong>最大似然估计</strong></p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610163845276.png" alt="0?wx_fmt=png"></p>
<p>​		如果上述公式不能理解，请各位读者去复习一下大学课程《概率论与数理统计》中的参数估计章节，为了更方便理解，下面举一个例子：假设我要统计出整个大学内所有同学的身高分布情况，设全校一共20000人，数量庞大，所有人都去问一遍不太靠谱，所以我打算采用抽样方法来估计，假设我已经知道身高分布服从高斯分布，但是我不知道高斯分布中的均值和方差参数，现在我打算采用最大似然估计方法来确定这两个参数。首先需要明确，全校20000即为总体X，我随机从各个班抽取10名同学，假设一共抽了2000个同学，那么2000同学就构成了样本空间，由于每个样本的概率密度函数已知，则很容易写出似然函数，对数求导即可求解参数。</p>
<p><strong>(3)</strong> <strong>最大后验估计</strong></p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610163845259.png" alt="0?wx_fmt=png"></p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610163845297.png" alt="0?wx_fmt=png"></p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610163845289.png" alt="0?wx_fmt=png"></p>
<h2 id="5-例子"><a class="header-anchor" href="#5-例子">¶</a>5. 例子</h2>
<h3 id="5-1-逻辑回归"><a class="header-anchor" href="#5-1-逻辑回归">¶</a>5.1 逻辑回归</h3>
<p>​		二分类逻辑回归使用Sigmoid作为决策函数进行分类，该函数可以将任意的输入映射到[0,1]区间，当预测结果小于0.5，则表示负类，当预测结果大于0.5.则表示正类，其模型本质是求最大似然估计，具体求解似然函数通常使用梯度下降法，而前面说过：最大似然估计法没有考虑训练集以外的因素，很容易造成过拟合，故而逻辑回归一般采用L2范数进行正则化操作，Sigmoid函数定义和图形如下：</p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0.jpeg" alt="0?wx_fmt=png"></p>
<h3 id="5-2-岭回归-Ridge-Regression"><a class="header-anchor" href="#5-2-岭回归-Ridge-Regression">¶</a>5.2 岭回归(Ridge Regression)</h3>
<p>​		岭回归本质上是针对线性回归问题引入了L2范数正则，通过缩减回归系数避免过拟合问题，最先用来处理特征数多于样本数的情况(高维小样本问题)，现在也用于在估计中加人偏差，从而得到更好的估计，加了正则化后的代价函数如下：</p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610174921016.png" alt="0?wx_fmt=png"></p>
<h3 id="5-3-Lasso-回归"><a class="header-anchor" href="#5-3-Lasso-回归">¶</a>5.3 Lasso 回归</h3>
<p>​		拉索回归(lasso回归)本质上是针对线性回归问题引入了L1范数正则，通过缩减回归系数避免过拟合问题，其不同于L2范数，其可以将某些系数缩减为0即所谓的具备稀疏性(稀疏性的好处是简化计算、容易理解模型、减少存储空间、不容易出现过拟合等等)，加了正则化后的代价函数如下：</p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610174920968.png" alt="0?wx_fmt=png"></p>
<p>​		其中，参数函数和岭回归中相同。L1范数罚有一个问题：由于|X|函数在0处不可导，故而直接使用最小二乘法、梯度下降法等方法均失效，但是由于其为第一类间断点中的可去间断点，可以通过补充该点的定义解决，通常，对于线性回归中的lasso回归可以采用近似的前向逐步回归替代。</p>
<h3 id="5-4-SVM"><a class="header-anchor" href="#5-4-SVM">¶</a>5.4 SVM</h3>
<p>​		支持向量机SVM优化目的为寻找一个超平面，使得正负样本能够以最大间隔分离开，从而得到更好的泛化性能，其通过引入核函数来将低维线性不可分的样本映射到高维空间从而线性可分，通过引入惩罚参数C(类似于正则化参数)来对错分样本进行惩罚，从而减少模型复杂度，提高泛化能力，其优化目标如下：</p>
<p><img src="/public/2019/07/17/AI/regulation_baysian/0-20190610174921029.png" alt="0?wx_fmt=png"></p>
<p>​		大家如果不知道上面公式的推导，不用紧张，对于本次内容不是重点，只需要关注后面正则项部分，惩罚参数C作用和正则化参数作用一致，只是反相关而已。需要明白以下结论：</p>
<p>​		<strong>(1)</strong> C越大，正则化参数越小，表示对分错样本的惩罚程度越大，正则化作用越小，偏差越小，方差越大，越容易出现过拟合(通俗理解，原本将低维空间映射到5维空间正好线性可分，但是由于惩罚过于严重，任何一个样本分错了都不可原谅，结果系统只能不断提高维数来拟合样本，假设为10维，最终导致映射维数过高，出现过拟合样本现象，数学上称为VC维较大)；</p>
<p>​		<strong>(2)</strong> C越小，正则化参数越大，表示对分错样本的惩罚程度越小，正则化作用越大，偏差越大，方差越小，越容易出现欠拟合(通俗理解，原本将低维空间映射到5维空间正好线性可分，但是由于惩罚过小，分错了好多样本都可以理解，比较随意，结果系统也采用简化版来拟合样本，假设为3维，最终导致映射维数过低，出现欠拟合样本现象，数学上称为VC维较小)。</p>
<h2 id="6-总结"><a class="header-anchor" href="#6-总结">¶</a>6. 总结</h2>
<p>根本目的本质：防止过拟合，提高模型泛化能力。</p>
<p>正则化技术分类：
<strong>狭义上</strong>（不同地方叫法不同）</p>
<ul>
<li>在早期的机器学习领域一般只是将范数惩罚叫做正则化技术</li>
<li>规则化、权重衰减</li>
<li>从贝叶斯角度考虑，正则项等价于引入参数的模型先验概率</li>
</ul>
<p><strong>广义上</strong>：
能够显著减少方差，而不过度增加偏差的策略都可以认为是正则化技术，推广的正则化技术还有：扩增样本集、早停止、Dropout、集成学习、多任务学习、对抗训练、参数共享等。</p>
<h2 id="Reference"><a class="header-anchor" href="#Reference">¶</a>Reference</h2>
<p><a href="https://blog.csdn.net/BigData_Mining/article/details/81631249" target="_blank" rel="noopener">正则化总结的比较好比较全面的文章</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
        <category>正则化</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter notebook的配置</title>
    <url>/public/2017/07/03/linux/jupyter_notebook/</url>
    <content><![CDATA[<p><strong>前言</strong>
本文介绍jupyter notebook的安装配置过程和实用技巧。
<a href="https://jupyter.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">jupyter.readthedocs教程</a></p>
<a id="more"></a>
<h2 id="1-安装与配置"><a class="header-anchor" href="#1-安装与配置">¶</a>1 安装与配置</h2>
<h3 id="1-1-安装-jupyter"><a class="header-anchor" href="#1-1-安装-jupyter">¶</a>1.1 安装 jupyter</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install jupyter</span><br><span class="line"><span class="comment"># pip install -i https://pypi.tuna.tsinghua.edu.cn/simple jupyter</span></span><br><span class="line"><span class="comment"># pip install jupyter -y</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-修改配置文件"><a class="header-anchor" href="#1-2-修改配置文件">¶</a>1.2 修改配置文件</h3>
<ul>
<li>生成配置文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jupyter notebook --generate-config</span><br><span class="line">vim ~/.jupyter/jupyter_notebook_config.py</span><br></pre></td></tr></table></figure>
<ul>
<li>修改配置文件内容</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">c.NotebookApp.ip = <span class="string">'0.0.0.0'</span></span><br><span class="line">c.NotebookApp.port = <span class="number">8018</span></span><br><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">c.NotebookApp.password = <span class="string">u'sha1:bcd259ccf...your hashed password here'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip: 利用ipython 生成密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; In [1]: from IPython.lib import passwd</span><br><span class="line">&gt; In [2]: passwd()</span><br><span class="line">&gt;   Enter password:</span><br><span class="line">&gt;   Verify password:</span><br><span class="line">&gt;   Out[2]: &apos;sha1:67xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&apos;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我选用的是password密码登陆jupyter的方案，其他的密码登陆方案见 <a href="https://zhuanlan.zhihu.com/p/23110830" target="_blank" rel="noopener">link</a></p>
<blockquote>
<p>新的方法
from notebook.auth import passwd; passwd()</p>
</blockquote>
<h3 id="1-3-安装插件管理"><a class="header-anchor" href="#1-3-安装插件管理">¶</a>1.3 安装插件管理</h3>
<p>jupyter_contrib_nbextensions 为 jupyter notebook 扩展插件管理器，下面简称nbextensions。</p>
<p>nbextensions的github <a href="https://github.com/ipython-contrib/jupyter_contrib_nbextensions" target="_blank" rel="noopener">repo</a>
nbextensions的教程<a href="https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/" target="_blank" rel="noopener">nbextensions_manual_readthedocs</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用conda安装</span></span><br><span class="line">conda install jupyter</span><br><span class="line">conda install -c conda-forge jupyter_contrib_nbextensions</span><br><span class="line"></span><br><span class="line"><span class="comment"># pip安装</span></span><br><span class="line">pip install jupyter_contrib_nbextensions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使能</span></span><br><span class="line">jupyter contrib nbextension install</span><br></pre></td></tr></table></figure>
<p>我启用的一些插件</p>
<table>
<thead>
<tr>
<th>plugins</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Table of Contents (2)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Freeze</td>
<td>比较好的一个插件，可以用来冻住cell</td>
<td></td>
</tr>
<tr>
<td>nbTranslate</td>
<td>这个插件利用Google翻译cell很好用</td>
<td><a href="https://github.com/jfbercher/jupyter_nbTranslate/blob/master/languages.js" target="_blank" rel="noopener">support languages</a></td>
</tr>
<tr>
<td>ExecuteTime</td>
<td>显示执行时间</td>
<td></td>
</tr>
<tr>
<td>Ruler</td>
<td>代码标尺</td>
<td></td>
</tr>
<tr>
<td>Autopep8</td>
<td>代码美化</td>
<td></td>
</tr>
<tr>
<td>Scratchpad</td>
<td>代码测试</td>
<td></td>
</tr>
</tbody>
</table>
<p>其他花样的配置</p>
<p><a href="https://zhuanlan.zhihu.com/p/74950682" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/74950682</a></p>
<h3 id="1-4-conda环境的设置"><a class="header-anchor" href="#1-4-conda环境的设置">¶</a>1.4 conda环境的设置</h3>
<p>jupyter使用Anaconda miniconda环境需要安装的组件。
<a href="https://repo.anaconda.com" target="_blank" rel="noopener">conda repo</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建虚拟环境</span></span><br><span class="line">conda create -n env_name python=3.6</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> conda虚拟核组件 切换kernel</span></span><br><span class="line">conda install nb_conda_kernels</span><br></pre></td></tr></table></figure>
<h3 id="1-5-解决界面中英文混杂"><a class="header-anchor" href="#1-5-解决界面中英文混杂">¶</a>1.5 解决界面中英文混杂</h3>
<img src="/public/2017/07/03/linux/jupyter_notebook/image-20200413125705473.png" alt="image-20200413125705473" style="zoom:50%;">
<p>如图，jupyter 界面中中英文混杂，解决方法为将界面文字中文切换成英文。</p>
<p>原理：让jupyter就找不到他的中文配置文件夹。</p>
<p>找到notebook的汉化文件夹的路径，比如<code>~/miniconda3/lib/python3.6/site-packages/notebook/i18n/zh_CN</code>。将其重命名如加个下划线作为后缀<code>zh_CN_old</code>，重启jupyter就行了。</p>
<p>为了方便，我作了个脚本自动找<code>notebook/i18n/zh_CN</code>位置并改名此文件夹，如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">from</span> distutils.sysconfig <span class="keyword">import</span> get_python_lib</span><br><span class="line"><span class="comment"># 获取site-package包的位置</span></span><br><span class="line">path_zh=get_python_lib()+<span class="string">'/notebook/i18n/zh_CN'</span></span><br><span class="line">path_zh_old=get_python_lib()+<span class="string">'/notebook/i18n/zh_CN_old'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 notebook/i18n/zh_CN 改为 notebook/i18n/zh_CN_old</span></span><br><span class="line">shutil.move(path_zh,path_zh_old)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回中文</span></span><br><span class="line"><span class="comment"># shutil.move(path_zh_old,path_zh)</span></span><br></pre></td></tr></table></figure>
<p>重启jupyter就行了, 这样jupyter就找不到这个中文配置，返回中文改回去就行了<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<h2 id="2-使用的技巧"><a class="header-anchor" href="#2-使用的技巧">¶</a>2 使用的技巧</h2>
<h3 id="2-1-快捷键"><a class="header-anchor" href="#2-1-快捷键">¶</a>2.1 快捷键</h3>
<hr>
<table>
<thead>
<tr>
<th>在非激活状态即是蓝颜色的边框</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>insert cell above</td>
</tr>
<tr>
<td>B</td>
<td>insert cell below</td>
</tr>
<tr>
<td>H</td>
<td>查看帮助</td>
</tr>
<tr>
<td>⌃↩(ctrl + enter)</td>
<td>run selected cells</td>
</tr>
</tbody>
</table>
<h3 id="2-2-显示图片-视频-音频"><a class="header-anchor" href="#2-2-显示图片-视频-音频">¶</a>2.2 显示图片 视频 音频</h3>
<p>主要是画图、显示视频和音频的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 图片</span></span><br><span class="line">%%HTML</span><br><span class="line">&lt;img src=<span class="string">"xxx.jpg"</span>  alt=<span class="string">"title"</span> /&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 视频</span></span><br><span class="line">%%HTML</span><br><span class="line">&lt;video width=<span class="string">"330"</span> height=<span class="string">"150"</span> controls&gt;</span><br><span class="line">&lt;source src=<span class="string">"out_all.mp4"</span> type=<span class="string">"video/mp4"</span>&gt;</span><br><span class="line">&lt;/video&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语音</span></span><br><span class="line">%%HTML</span><br><span class="line">&lt;audio src=<span class="string">"out.wav"</span> controls=<span class="string">"controls"</span>&gt;</span><br><span class="line">Your browser does <span class="keyword">not</span> support the audio element.</span><br><span class="line">&lt;/audio&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># html t是html的字符串</span></span><br><span class="line"><span class="keyword">from</span> IPython.core.display <span class="keyword">import</span> HTML</span><br><span class="line">HTML(str(t))</span><br></pre></td></tr></table></figure>
<h3 id="2-3-其他技巧"><a class="header-anchor" href="#2-3-其他技巧">¶</a>2.3 其他技巧</h3>
<h4 id="修复视频文件"><a class="header-anchor" href="#修复视频文件">¶</a>修复视频文件</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fix_use_ffmpeg</span><span class="params">(in_name, out_name,message=<span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(out_name):</span><br><span class="line">    os.remove(out_name)</span><br><span class="line">    cmd = <span class="string">'ffmpeg -i %s %s'</span> % (in_name, out_name)</span><br><span class="line">    log_lines = os.popen(cmd).readlines()</span><br><span class="line">    print(message,<span class="string">"ok"</span>)</span><br></pre></td></tr></table></figure>
<h4 id="加载自己的模块文件"><a class="header-anchor" href="#加载自己的模块文件">¶</a>加载自己的模块文件</h4>
<p>出于性能考虑，每个模块在每个解释器会话中只导入一遍。因此，如果你修改了你的模块，需要重启解释器；或者，如果你就是想交互式的测试这么一个模块，可以用 imp.reload() 重新加载，例如 <code>import imp; imp.reload(modulename)</code></p>
<h4 id="导出pdf支持中文"><a class="header-anchor" href="#导出pdf支持中文">¶</a>导出pdf支持中文</h4>
<p>Jupyter Notebook 输出PDF中文支持 <a href="https://www.jianshu.com/p/c3f660188766" target="_blank" rel="noopener">link</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/lib/python3.6/site-packages/nbconvert/templates/latex</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在里面的模版中添加，前提是安装好了texlive</span></span><br><span class="line">% add</span><br><span class="line">\usepackage&#123;ctex&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ipynb2pdf"><a class="header-anchor" href="#ipynb2pdf">¶</a>ipynb2pdf</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Current version of Jupyter doesn't support pdf exporting when it comes to</span></span><br><span class="line"><span class="string">russian language in the document. To fix this, current script has born.</span></span><br><span class="line"><span class="string">It requires nbconvert as long as jupyter to be installed.</span></span><br><span class="line"><span class="string">Author:     Sergey Ivanychev</span></span><br><span class="line"><span class="string">Email:      sergeyivanychev@gmail.com</span></span><br><span class="line"><span class="string">Revision:   1</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">FORMAT = <span class="string">".ipynb"</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">TODO:   What if user has ___o.tex in current folder?</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">TEMP_TEX = <span class="string">"___o.tex"</span></span><br><span class="line">TEMP_FOLDER = <span class="string">"/tmp"</span></span><br><span class="line">TRASH_EXTENSIONS = [<span class="string">".aux"</span>, <span class="string">".out"</span>, <span class="string">".log"</span>]</span><br><span class="line">OLD1 = <span class="string">r"\usepackage[utf8x]&#123;inputenc&#125;"</span></span><br><span class="line">NEW1 = <span class="string">r"""</span></span><br><span class="line"><span class="string">    \usepackage[utf8x]&#123;inputenc&#125;</span></span><br><span class="line"><span class="string">    \usepackage&#123;ctex&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">REPLACE = [(OLD1, NEW1)]</span><br><span class="line">HELP = <span class="string">"""</span></span><br><span class="line"><span class="string">This script is aimed at correctly converting .ipynb to .pdf files.</span></span><br><span class="line"><span class="string">You may use it via</span></span><br><span class="line"><span class="string"># ipynb2pdf Solution.ipynb</span></span><br><span class="line"><span class="string">To get .pdf in the same directory</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_args</span><span class="params">(argv)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> (len(argv) &gt; <span class="number">2</span>):</span><br><span class="line">        print(<span class="string">"Please, type .ipynb filename as argument"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> (len(argv) == <span class="number">1</span>):</span><br><span class="line">        print(HELP)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    script, filename = argv</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_ipynb(filename):</span><br><span class="line">        print(<span class="string">"Please, type .ipynb filename as argument"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_extention</span><span class="params">(string, extention)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Removes argumented extention from the end of the string</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> extention[<span class="number">0</span>] != <span class="string">'.'</span>:</span><br><span class="line">        extention = <span class="string">"."</span> + extention</span><br><span class="line">    <span class="keyword">if</span> string.endswith(extention):</span><br><span class="line">        string = string[<span class="number">0</span>:-len(extention)]</span><br><span class="line">    <span class="keyword">return</span> string</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_ipynb</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> filename.endswith(<span class="string">".ipynb"</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tex2pdf</span><span class="params">(filename, desired_name)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Converts filename (which is tex document) to desired_name (which is pdf)</span></span><br><span class="line"><span class="string">    leaving no trash in current folder</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    base = remove_extention(filename, <span class="string">"tex"</span>)</span><br><span class="line">    output = base + <span class="string">".pdf"</span></span><br><span class="line">    ret = subprocess.call(<span class="string">"xelatex %s"</span> % filename , </span><br><span class="line">                                        shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">for</span> ext <span class="keyword">in</span> TRASH_EXTENSIONS:</span><br><span class="line">        os.unlink(base + ext)</span><br><span class="line">    os.rename(output, desired_name)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> check_args(argv) == <span class="number">-1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    script, filename = argv</span><br><span class="line">    ret = subprocess.call(<span class="string">"jupyter nbconvert %s --to latex --output %s"</span> %</span><br><span class="line">                                            (filename, TEMP_TEX), shell=<span class="literal">True</span>,</span><br><span class="line">                                            stdout=subprocess.PIPE)</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>):</span><br><span class="line">        print(<span class="string">"ret = %d"</span> % ret)</span><br><span class="line">        os.unlink(TEMP_TEX)</span><br><span class="line">        print(<span class="string">"Converting to LaTeX failed. Return code: %d"</span> % ret)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    tex_file = open(TEMP_TEX, <span class="string">"r"</span>)</span><br><span class="line">    tex = tex_file.read()</span><br><span class="line">    <span class="keyword">for</span> old, new <span class="keyword">in</span> REPLACE:</span><br><span class="line">        tex = tex.replace(old, new)</span><br><span class="line">    tex_file.close()</span><br><span class="line">    os.unlink(TEMP_TEX)</span><br><span class="line">    tex_file = open(TEMP_TEX, <span class="string">"w+"</span>)</span><br><span class="line">    tex_file.write(tex)</span><br><span class="line">    tex_file.close()</span><br><span class="line">    ret = tex2pdf(TEMP_TEX, remove_extention(filename, <span class="string">".ipynb"</span>) + <span class="string">".pdf"</span>)</span><br><span class="line">    tex_file.close()</span><br><span class="line">    os.unlink(TEMP_TEX)</span><br><span class="line">    print(remove_extention(filename, <span class="string">".ipynb"</span>) + <span class="string">".pdf - DONE"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    exit(main(sys.argv))</span><br></pre></td></tr></table></figure>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://www.zhihu.com/question/302814218/answer/1029684239" target="_blank" rel="noopener">https://www.zhihu.com/question/302814218/answer/1029684239</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>jupyter</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Python</tag>
        <tag>笔记应用</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu的优化与设置</title>
    <url>/public/2017/05/22/linux/ubuntu/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>本文整理了一下我在使用ubuntu过程中的一些小技巧。
推荐一个好的Ubuntu教程.<a href="http://www.cnblogs.com/dutlei/archive/2012/11/20/2778327.html" target="_blank" rel="noopener">原文链接</a></p>
<p>Linux有很多分支，Ubuntu的使用安装比较方便.Ubuntu 16.04 LTS</p>
<a id="more"></a>
<h2 id="1-个性化"><a class="header-anchor" href="#1-个性化">¶</a>1 个性化</h2>
<h3 id="窗口颜色设置浅绿色"><a class="header-anchor" href="#窗口颜色设置浅绿色">¶</a>窗口颜色设置浅绿色</h3>
<p>窗口编程浅绿色  <a href="http://jingyan.baidu.com/article/ff42efa9195eb8c19e2202ec.html" target="_blank" rel="noopener">link</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/share/themes/Ambiance/gtk-3.0</span><br><span class="line">sudo gedit gtk-main.css</span><br></pre></td></tr></table></figure>
<p>编辑该文件,将base_color <code>#ffffff</code>修改成 <code>#CCE8CF</code>
对应RGB  48,19,36</p>
<h2 id="2-常用环境"><a class="header-anchor" href="#2-常用环境">¶</a>2  常用环境</h2>
<h3 id="安装jdk"><a class="header-anchor" href="#安装jdk">¶</a>安装jdk</h3>
<p>打开文件 <code>vim ~/.bashrc</code>，在文件后面添加下面几行，其中<code>JAVA_HOME</code>根据自己的java安装位置修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add java path</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/java/jdk1.7</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>别忘了，<code>source ~/.bashrc</code>激活环境</p>
<h2 id="3-安装软件"><a class="header-anchor" href="#3-安装软件">¶</a>3 安装软件</h2>
<h3 id="在线软件安装"><a class="header-anchor" href="#在线软件安装">¶</a>在线软件安装</h3>
<p><strong>源列表地址修改(可选)</strong>，如果选用靠近的源速度会比较快，但是可能不是最新的软件。现在好像ubuntu china的官方节点速度还不错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 备份源列表地址</span></span><br><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup</span><br><span class="line"><span class="comment"># 修改</span></span><br><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p><strong>在线安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新源</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get install xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包search</span></span><br><span class="line">apt-cache search xxx</span><br></pre></td></tr></table></figure>
<h3 id="deb本地软件安装"><a class="header-anchor" href="#deb本地软件安装">¶</a>deb本地软件安装</h3>
<p><strong>安装软件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装deb包命令</span></span><br><span class="line">dpkg -i *.deb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果缺少依赖执行</span></span><br><span class="line">apt-get -f install</span><br></pre></td></tr></table></figure>
<h2 id="4-常用软件"><a class="header-anchor" href="#4-常用软件">¶</a>4 常用软件</h2>
<h3 id="mpv播放器"><a class="header-anchor" href="#mpv播放器">¶</a>mpv播放器</h3>
<h3 id="有道字典"><a class="header-anchor" href="#有道字典">¶</a>有道字典</h3>
<p>有道字典 需要修改一下才能使用。 <a href="http://www.w2bc.com/article/227083" target="_blank" rel="noopener">link</a></p>
<h3 id="atom"><a class="header-anchor" href="#atom">¶</a>atom</h3>
<p>高分屏字体大小，Settings-&gt;Themes-&gt;your stylesheet</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">atom-pane</span> &#123;</span><br><span class="line">     <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.command-palette</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="图标设置"><a class="header-anchor" href="#图标设置">¶</a>图标设置</h3>
<p>对于一些绿化软件来说没有图标，我们可以手动创建一个图标。
在/usr/share/applications目录下创建eclipse启动器配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/share/applications</span><br><span class="line">vim eclipse.desktop</span><br></pre></td></tr></table></figure>
<p>编辑eclipse.desktop并保存。简单的配置示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env xdg-open</span></span><br><span class="line"></span><br><span class="line">[Desktop Entry]</span><br><span class="line">Version=22.0</span><br><span class="line">Name=eclipse</span><br><span class="line">Exec=/home/gtc/Android/adt-bundle-linux/eclipse/eclipse</span><br><span class="line">Terminal=false</span><br><span class="line">Icon=/home/gtc/Android/adt-bundle-linux/eclipse/icon.xpm</span><br><span class="line">Type=Application</span><br><span class="line">Categories=Development</span><br></pre></td></tr></table></figure>
<h2 id="5-其他优化"><a class="header-anchor" href="#5-其他优化">¶</a>5 其他优化</h2>
<h3 id="关闭错误报告"><a class="header-anchor" href="#关闭错误报告">¶</a>关闭错误报告</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭烦人的错误报告</span></span><br><span class="line">sudo gedit /etc/default/apport</span><br></pre></td></tr></table></figure>
<h3 id="CPU-100-占用"><a class="header-anchor" href="#CPU-100-占用">¶</a>CPU 100%占用</h3>
<p>gvfsd-smb-browse CPU 100%占用
我没有修改，它就自己停了，可以在mointer里中止这个进程
地址
<a href="http://tieba.baidu.com/p/4505730863" target="_blank" rel="noopener">http://tieba.baidu.com/p/4505730863</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/lib/gvfs</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将gvfsd-smb-brows权限改成744，取消普通用户的执行权限，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也挺有意思，暂时没引发别的问题</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>桥初始化（一）</title>
    <url>/public/2021/12/02/linux_network/br_init/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>注：章节中的源代码，基于 linux 内核 4.7.4</p>
<p>网桥的背景到处都有，在这里就不浪费的时间说废话了。</p>
<p>桥接程序的初始化，桥接程序既可以集成在内核中，也可以编译成独立模块。初始化函数br_init和清理函数br_deinit的定义在/net/bridge/br.c中</p>
<p>在网桥设备初始化的时候，主要是做一些注册和初始化的操作。</p>
<h2 id="桥初始化"><a class="header-anchor" href="#桥初始化">¶</a>桥初始化</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">br_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">/*注册协议生成树收包函数*/</span></span><br><span class="line">    err = stp_proto_register(&amp;br_stp_proto);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        pr_err(<span class="string">"bridge: can't register sap for STP\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*转发数据库初始化*/</span></span><br><span class="line">    err = br_fdb_init();</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> err_out;</span><br><span class="line">   <span class="comment">/*在/proc目录下生成任何与bridge相关的目录，如果我们想在/proc下生成bridge相关的子目录或子文件*/</span></span><br><span class="line">    err = register_pernet_subsys(&amp;br_net_ops);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> err_out1;</span><br><span class="line">    <span class="comment">/*目前好像没有什么实际作用，在内核中所注册的函数为空*/</span></span><br><span class="line">    err = br_nf_core_init();</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> err_out2;</span><br><span class="line">    <span class="comment">/*注册相关网络设备的事件通知连*/</span></span><br><span class="line">    err = register_netdevice_notifier(&amp;br_device_notifier);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> err_out3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*注册通知连，主要针对桥转发表事件的相关信息*/</span></span><br><span class="line">    err = register_switchdev_notifier(&amp;br_switchdev_notifier);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> err_out4;</span><br><span class="line">    <span class="comment">/*进行netlink的初始化*/</span></span><br><span class="line">    err = br_netlink_init();</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">goto</span> err_out5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*用来处理ioctl命令的函数，比如添加和删除网桥*/</span></span><br><span class="line">    brioctl_set(br_ioctl_deviceless_stub);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> IS_ENABLED(CONFIG_ATM_LANE)</span></span><br><span class="line">    br_fdb_test_addr_hook = br_fdb_test_addr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体的"><a class="header-anchor" href="#具体的">¶</a>具体的</h2>
<p>了解了桥初始化大致要做的事情后，我们再来看看这些初始化或者注册的事情到底干了些什么？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>注册协议生成树收包函数stp_proto_register</span><br><span class="line">    在桥初始化的时候，注册了一个br_stp_proto参数，此参数的具体模样是这样子的</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">stp_proto</span> <span class="title">br_stp_proto</span> = &#123;</span></span><br><span class="line">         .rcv   = br_stp_rcv,</span><br><span class="line">    &#125;;</span><br><span class="line">    br_stp_rcv函数在/net/bridge/br_stp_bpdu.c中主要针对网桥进行协议交换的帧（BPDU）进行配置操作。</span><br><span class="line"></span><br><span class="line">  <span class="number">2.</span>桥转发数据库初始化br_fdb_init</span><br><span class="line">    此函数就是在内存中建立一块slab cache，以存放net_bridge_fdb_entry</span><br><span class="line">    其中：net_bridge_fdb_entry是一个结构体，用来转发数据库的记录项网桥所学到对的每个MAC地址都有这样一个记录</span><br><span class="line"></span><br><span class="line">  <span class="number">3.</span>在proc目录下生成相关文件的注册函数register_pernet_subsys，初始化的时候给这个函数传递了一个参数br_net_ops，这个参数的模样是这样的</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pernet_operations</span> <span class="title">br_net_ops</span> = &#123;</span></span><br><span class="line">        .<span class="built_in">exit</span>   = br_net_exit,</span><br><span class="line">  &#125;;</span><br><span class="line">  但是在桥初始化的时候，仅仅注册了br_net_exit，这个函数会将桥下面的所有文件全部清空。</span><br><span class="line"></span><br><span class="line"> <span class="number">4.</span>通知链的相关函数注册register_netdevice_notifier这个注册函数主要针对设备信息的变化，注册参数br_device_notifier，具体如下：</span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">br_device_notifier</span> = &#123;</span></span><br><span class="line">        .notifier_call = br_device_event</span><br><span class="line">&#125;;</span><br><span class="line">br_device_event函数是用来当桥上的设备状态或者设备信息发生改变时做相应的处理，该函数在/net/bridge/br.c中</span><br><span class="line"></span><br><span class="line"> <span class="number">5.</span>注册通知连，主要针对桥转发表事件的相关信息register_switchdev_notifier，传入的参数br_switchdev_notifier详细信息如下：</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">br_switchdev_notifier</span> = &#123;</span></span><br><span class="line">    .notifier_call = br_switchdev_event,</span><br><span class="line">&#125;;</span><br><span class="line">br_switchdev_event，主要针对桥转发表的事件做出相应的处理该函数在/net/bridge/br.c中</span><br><span class="line"></span><br><span class="line"><span class="number">6.b</span>rioctl_set用来处理ioctl命令的函数，比如添加和删除网桥，br_ioctl_deviceless_stub给回调函数br_ioctl_hook,而br_ioctl_hook在sock_ioctl中</span><br><span class="line">使用，这样通过在应用层调用socket的ioctl函数，就能够进行网桥的添加与删除了，函数用来处理添加和删除网桥的相关操作，会在下一节详细介绍。</span><br></pre></td></tr></table></figure>
<p>以上就是网桥初始化的相关操作 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/NW_NW_NW" target="_blank" rel="noopener">@不留你的名字</a> <a href="https://blog.csdn.net/NW_NW_NW/article/details/75045966" target="_blank" rel="noopener">桥初始化</a> 2010-12-01 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux network</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp ip 协议族</title>
    <url>/public/2022/12/08/linux_network/tcp_ip/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>tcp ip 协议族</p>
<a id="more"></a>
<p><img src="/public/2022/12/08/linux_network/tcp_ip/tcp_ip.jpeg" alt></p>
]]></content>
      <categories>
        <category>linux 网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>现代数学手册</title>
    <url>/public/2017/05/22/math/math_handbook/</url>
    <content><![CDATA[<img src="/public/2017/05/22/math/math_handbook/Screen Shot 2020-03-06 at 13.24.51.png" alt="Screen Shot 2020-03-06 at 13.24.51" style="zoom:33%;">
<img src="/public/2017/05/22/math/math_handbook/Screen Shot 2020-03-06 at 13.24.27.png" alt="Screen Shot 2020-03-06 at 13.24.27" style="zoom: 33%;">
<img src="/public/2017/05/22/math/math_handbook/Screen Shot 2020-03-06 at 13.22.44.png" alt="Screen Shot 2020-03-06 at 13.22.44" style="zoom:33%;">
<img src="/public/2017/05/22/math/math_handbook/Screen Shot 2020-03-06 at 13.23.48.png" alt="Screen Shot 2020-03-06 at 13.23.48" style="zoom:33%;">
<img src="/public/2017/05/22/math/math_handbook/Screen Shot 2020-03-06 at 13.23.57.png" alt="Screen Shot 2020-03-06 at 13.23.57" style="zoom:33%;">
<p>百度云链接: <a href="https://pan.baidu.com/s/1AwNZNoMLgJcJ5X0G0fpC5w" target="_blank" rel="noopener">https://pan.baidu.com/s/1AwNZNoMLgJcJ5X0G0fpC5w</a> 提取码: pb1n</p>
]]></content>
      <categories>
        <category>现代数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>工具书</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么正好经过这个空隙？</title>
    <url>/public/2017/05/05/math/math_q1/</url>
    <content><![CDATA[<p><strong>前言</strong>
偶然看到的一个问题，如图1，为什么正好经过这个空隙？我们用空间解析几何来解一下吧。</p>
<p><img src="/public/2017/05/05/math/math_q1/math_q1_show.gif" alt="动图"></p>
<div align="center"> 图1 为什么会经过这个空隙？</div>
<a id="more"></a>
<p><strong>解答</strong></p>
<p>如图2，建立空间直角坐标系$xyz$，原点记为 $O$ ， $P$  点为水平杆与斜杆的交点， $Q$ 点为垂直杆与水平杆的交点， 将斜杆标记为 $L$ 。</p>
<p><img src="/public/2017/05/05/math/math_q1/v2-80ac80b8031d5782412f4f4ef4e22a1a_b.jpeg" alt="img"></p>
<div align="center"> 图2 建立空间直角坐标系</div>
<p>设 $OQ=q$  ， $QP=r$  。$Q$ 点坐标为 $(0, 0, q)$  。</p>
<p>设水平杆  $QP$  绕  $z$   轴以  $\omega, rad/s$  的角速度旋转，并设从开始旋转到现在的时长为 $t$  秒， 则  $P$  点坐标为 $(r\cos{\omega t}, r\sin{\omega t}, q)$  。</p>
<p>由 $Q$、$P$ 两点坐标得：</p>
<p>$$
\overrightarrow{OQ}=(0, 0, q) \qquad \overrightarrow{QP}=(r\cos{\omega t}, r\sin{\omega t}, 0) \tag{1}
$$</p>
<p>设 $L$ 的方向向量 $\overrightarrow{S}=(a, b, c) $，由 $L$ 的方向向量 $\overrightarrow{S}$ 和 $P$ 点得，得斜杆  $L$  代表的直线方程：
$$
\frac{x-r\cos{\omega t}}{a}=\frac{y-r\sin{\omega t}}{b}=\frac{z-q}{c} \tag{2}
$$</p>
<p>我们知道 $\overrightarrow{QP}$ 与斜杆 $L$ 垂直，假设 $\overrightarrow{OQ}$ 与斜杆 $L$ 成固定角 $ \theta$ ，得：
$$
\begin{cases} 0=\overrightarrow{QP} \cdot \overrightarrow{S} \ \cos{\theta}=\frac{\overrightarrow{OQ} \cdot \overrightarrow{S}}{\left|\overrightarrow{OQ}\right| \left| \overrightarrow{S}\right|} \end{cases} \tag{3}
$$</p>
<p>把 $\overrightarrow{QP}$， $\overrightarrow{S}$， $\overrightarrow{OQ}$ 代入 式(3)，得
$$
\begin{cases}  \frac{a}{b}=\frac{-\sin{\omega t}}{\cos{\omega t}} \ c^{2}(\tan{\theta})^{2}=a^{2}+b^{2}  \end{cases} \tag{4}
$$</p>
<p>式（4）中第2条等式两边除以 $b^2$ ，再化简得：
$$
\frac{c^{2}}{b^{2}}=\frac{1}{(\tan{\theta})^{2}(\cos{\omega t})^{2}} \tag{5}
$$</p>
<p>求直线组 $L$ 与 $xoz$ 平面相交的图形，即回答这个缝隙的形状为什么是图1 中这样的曲线。我们令 $y=0$ ，代入直线公式(2) 得：
$$
\frac{x-r\cos{\omega t}}{a}=\frac{-r\sin{\omega t}}{b} =\frac{z-q}{c} \tag{6}
$$
由式（4）（5）（6）得到方程组（7）。
$$
\begin{cases} \frac{a}{b}=\frac{-\sin{\omega t}}{\cos{\omega t}}\  \frac{x-r\cos{\omega t}}{a}=\frac{-r\sin{\omega t}}{b} \  \frac{c^2}{b^2}=\frac{1}{(\tan{\theta})^{2}(\cos{\omega t})^{2}}\  \frac{-r\sin{\omega t}}{b} =\frac{z-q}{c}  \end{cases}  \tag{7}
$$</p>
<p>由式（7）中上面两个等式，消去a，b得：
$$
\frac{-\sin{\omega t}}{\cos{\omega t}}=\frac{x-r\cos{\omega t}}{-r\sin{\omega t}}=\frac{a}{b} \tag{8}
$$
$$
x \cos{\omega t}=r   \tag{9}
$$</p>
<p>由式（7）中下面两个等式，消去b，c得：
$$
\frac{1}{(\tan{\theta})^2(\cos{\omega t})^2}
= \frac{(z-q)^2}{(-r\sin{\omega t})^2}
=\frac{c^2}{b^2} \tag{10}
$$</p>
<p>$$
\frac{(-r\sin{\omega t})^2}{(\tan{\theta})^2(\cos{\omega t})^2}
= {(z-q)}^2 \tag{11}
$$</p>
<p>由利用式（9），可消去式（11）中的 $(\sin{\omega t})^{2}$  和 $(\cos{\omega t})^{2}$  得：
$$
x^{2}-(\tan{\theta})^{2}(z-q)^{2}=r^{2} \tag{12}
$$
易知，为双曲线方程，所以在  xoz 平面相交得图形为双曲线。 ■</p>
<hr>
<p>欢迎观众老爷们评论回复，一键三连。
更多有趣问题，欢迎关注投稿 <a href="https://zhuanlan.zhihu.com/shuxuemanyou" target="_blank" rel="noopener">知乎小成 - 数学漫游专栏</a>，
我们聚焦生活中的数与形的小小问题们。
转载请注明出处，谢谢！</p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>Latex</tag>
        <tag>数学</tag>
        <tag>空间解析几何</tag>
      </tags>
  </entry>
  <entry>
    <title>希腊罗马神话</title>
    <url>/public/2018/11/05/readings/Gods_stories/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p>在我电的图书馆的还书柜子里面偶然所得，一本叫《希腊罗马神话对英语语言文化的影响》吕海平 著 江苏大学初版社，然后莫名的想研究一下，发现挺不错的。</p>
<a id="more"></a>
<p>古希腊罗马的神的关系还是比较乱的，尤其是jupiter 或者zeus的奥林匹斯神系。从上古的神系，总共有三代。</p>
<p>网上有个人（<a href="http://www.veritablehokum.com/" target="_blank" rel="noopener">Korwin Briggs</a>）做的关系图很不错。</p>
<p>TODO:后面我也会对其进行整理，以后给大家分享。</p>
<p><img src="http://www.veritablehokum.com/wp-content/uploads/2018/08/Roman-God-Family-Tree.jpg" alt></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>希腊罗马神话</tag>
        <tag>语言文化</tag>
      </tags>
  </entry>
  <entry>
    <title>红楼梦与我</title>
    <url>/public/2017/05/14/readings/hongloumeng/</url>
    <content><![CDATA[<p>红楼梦是我国四大名著之一，主要内容是贾府的兴衰和宝黛的悲剧爱情。电视剧红楼梦2010版，我是从八月开始看的，看完到现在，也有小一个月了。在网上大家对这版电视剧褒贬不一。与我来说，我是喜欢这部剧的，不能说拍得很好，但这部剧却勾起了我读书与写字的兴趣。于是乎，做了一篇随笔，以记录我的一些感触。</p>
<a id="more"></a>
<p>我记得最早是小学，我们还是顾着打玻璃珠和丢沙包的年纪，学校旁边的小书店里，也都是七龙珠，哆啦A梦，柯南的小人书，老师们讲到四大名著，顺带提了下红楼梦，其他没印象了。我们学习最多的是中文的拼音和书写，作文都是打油，日记也闹了不少笑话。后来上初中，有一次寒假附加作业是阅读红楼梦，我虽毫无兴趣，但还是硬着头皮，去新华书店，试看红楼梦。120章的红楼，厚得连看下去的勇气也没有。略看了几下，最后，做了一个红楼梦不好看的论断，也就放在那边了。那时有老版的红楼梦电视剧播映，打开电视偶尔会遇见，但是立马换台，央视的西游记与情深深雨蒙蒙，湖南电视台的还珠格格，也是欣赏了好几遍。再者，有动画片谁有兴趣去看这些什么破剧，关于书本，最多也就是看看汤姆索亚历险记。</p>
<p>再后来，去启中读书，学习上比较紧张，再加上理科班的非文学氛围，对这些文学的东西更不感冒。尽管偶尔也会入耳一些其中的人物，比如林妹妹，刘姥姥，也是不用大脑耳朵直接过滤。当时，大伙是杂志，读者，青年文摘读得比较多，班上一本，全班查阅，杂志文章篇幅较小，读起很顺很舒服。期间，与红楼的唯一一次接触是，高中教科书上有刘姥姥进大观园的章节，翻了一遍，当时，感叹人物好多，理不出人物关系，完全放弃看完红楼的欲望。以为姥姥是贾府的姥姥，猩猩然想着以后可以说看过一段红楼，红楼也比较贵不如多买几本读者，积累作文素材。不知什么时候，班上网络小说之风随着mp4和智能手机的普及而吹起，我也用MP4刷完了一两部网络小说，感觉都是一个套路，主角都是绝处逢生，越来越无敌，也就不敢兴趣了。</p>
<p>再然后，我上大学，藏书400百万册的成电图书馆，也并没有引起我读文学类的欲望，大学四年借的专业工具类书比较多，想来也是浪费资源。在一个工科高校，文学方面的课程几乎没有，虽说有个大学语文的选修课，俨然不感兴趣。大学里，再一次看到有人在看红楼梦电视剧，也是大二的时候的人工智能课上，也是闲得无聊。再后来，大四时，手机上自带一个蜻蜓网络电台应用，无聊点开蒋勋老师评述的红楼梦音频，红学大师讲到他与红楼梦的相遇，同时，他介绍的红楼基本背景和人物，通俗易懂，一下子引起我的兴趣。他说红楼梦写的都是15、6岁人的故事，15、16岁就可以读了。回想我15、16岁，基本没看什么名著。要说四大名著，我也就看了三国和水浒的少年版。上次回家，看美剧，老妈突然蹦出句，不能光看英文也应当看看我们老祖宗的文化。</p>
<p>现在得空，就这样抱着惭愧和一丝尝试我看起了2010版红楼梦。在这我得承认，我是个演员控。不得不说，三大主演都很不错。</p>
<p>50集过后，原来红楼讲得是这个，并表示有兴趣去读读名著了。原来有这么多原来。</p>
<ul>
<li>
<p>人物家族命运令人感慨。作者写出超越那个时代的朦胧的爱情与不得不提的丧心病狂的全部悲剧，果然是个失意文人的作品。 可叹停机德，堪怜咏絮才。宝钗落落大方德才兼备，黛玉因情而伤而痛去世，宝玉虽与宝钗结婚，最后离家成道去。精于人情世故,，胸有城府的王熙凤，平日的爽朗笑声终究悲剧，贾府里多么好的领导，最后也人情冷暖，不免为其伤心。刘姥姥，其实是个成功的投机分子，但也是朴实善良的“穷亲戚”，最后救了巧儿。十二金钗各有个的悲剧，正如宝玉在虚幻仙境里警幻仙姑给的设定。原来故事一开始就把结局告诉了读者。</p>
</li>
<li>
<p>体验古代贵族文化。里面还有个诗社的组织，古人的结社，好有雅致，也会给人起“绰号”。除此以外还有击鼓传花，有时主题是讲笑话有时对诗。猜灯谜，中秋赏月，生日宴会等等。</p>
</li>
<li>
<p>语言魅力。打秋风，这是形容刘姥姥找找贾府接济用的。恼，生气，或者使生气。不同人的称谓，宝兄弟，宝二爷，宝姐姐或者好姐姐，林妹妹或者好妹妹。</p>
</li>
<li>
<p>情节回味无穷。刘姥姥进大观园，是贾母和姥姥差不多年纪想和她聊聊，邀请她的。乡村来打秋风的刘姥姥像是在参观皇宫。在后面时期  ，家族里一次比一次捉襟见肘的聚会，可以看见这些家族的衰落。中国的各种人情世故体现在这里面。四个大家族，一个小社会。</p>
</li>
</ul>
<p>以上是我的一点点感悟。</p>
<p>只是，我与红楼梦，还差80章书页，希望还能有计划地读完。</p>
<p>2016年于成电</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>故事</tag>
        <tag>《红楼梦》</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」《中华古籍资源库》中国国家图书馆</title>
    <url>/public/2021/12/16/readings/zhonghuaguji/</url>
    <content><![CDATA[<h2 id="简介"><a class="header-anchor" href="#简介">¶</a>简介</h2>
<p>“中华古籍资源库”是“中华古籍保护计划”的重要成果。2016年9月28日，“中华古籍资源库”正式开通运行，陆续发布国家图书馆藏善本和普通古籍、法国国家图书馆藏敦煌遗书、天津图书馆藏普通古籍、日本永青文库捐赠汉籍、云南省图书馆善本古籍、芷兰斋藏稿抄校本等古籍影像资源，总量超过3.3万部。</p>
<p>《中华古籍资源库》！！！<br>
网址：<a href="http://www.nlc.cn/pcab/zy/zhgj_zyk/" target="_blank" rel="noopener">http://www.nlc.cn/pcab/zy/zhgj_zyk/</a><br>
查询：<a href="http://read.nlc.cn/thematDataSearch/toGujiIndex" target="_blank" rel="noopener">http://read.nlc.cn/thematDataSearch/toGujiIndex</a></p>
<img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216225907506.png" alt="image-20211216225907506" style="zoom:30%;">
<a id="more"></a>
<p>比如：《九章算数》的古籍</p>
<img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216231340351.png" alt="image-20211216231340351" style="zoom:30%;">
<img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216231141739.png" alt="image-20211216231141739" style="zoom:30%;">
<p>比如：卷第九的勾股</p>
<img src="/public/2021/12/16/readings/zhonghuaguji/image-20211216232009068.png" alt="image-20211216232009068" style="zoom:50%;">
<ul>
<li>
<p>数字古籍
国家图书馆收藏古籍15万部，其中善本古籍直接继承了南宋缉熙殿、元翰林国史院、明文渊阁、清内阁大库等皇家珍藏，以及明清以来许多私人藏书家的毕生所聚。宋元旧椠、明清精刻琳琅满目。通过全彩影像数字化和缩微胶卷转化影像方式建设，从2016年9月28日起陆续在线发布，目前已发布馆藏古籍2万余部，国家图书馆超过三分之二的善本古籍实现了在线阅览。</p>
</li>
<li>
<p>数字方志
地方志文献为我国所特有，也是国家图书馆独具特色的馆藏之一，所存文献数量与品质极高。该数据库以国家图书馆藏地方志文献建设，主要包括为清代（含清代）以前的方志资源6529种。</p>
</li>
<li>
<p>赵城金藏
《赵城金藏》被誉为国家图书馆四大镇馆之宝之一。《赵城金藏》是在金代刻的一部大藏，因为它藏在赵城县（今属山西洪洞县）广胜寺，所以后人将它定名为《赵城金藏》。全藏约七千卷左右，六千多万字，现存四千余卷。2017年12月28日，国家图书馆《赵城金藏》1281件正式发布。</p>
</li>
<li>
<p>宋人文集
国家图书馆精选所藏宋人文集善本二百七十五部，首选宋元刊本，次及明清精抄精刻，或经名家校勘题跋之本，通过缩微胶卷还原数字影像，并辅以详细书目建成本全文影像数据库，目前已发布275部，免费呈献公众利用。</p>
</li>
<li>
<p>碑帖菁华
以国家图书馆藏有的历代甲骨、青铜器、石刻等类拓片二十三万余件为基础建设的数据库，内容涉及历史、地理、政治、经济、军事、民族、民俗、文学、艺术、科技、建筑等方面。2019年11月12日又新增发布2595种馆藏明清碑刻拓片数字资源，现有元数据2.5万余条，影像3.1万余幅。</p>
</li>
<li>
<p>甲骨世界
被誉为二十世纪四大文献发现之一的甲骨文，集文献性、文物性、收藏性于一身，是研究我国商朝晚期不可多得的珍贵史料，该库包括甲骨实物元数据2964条，影像5932幅；甲骨拓片元数据2975条，影像3177幅。</p>
</li>
<li>
<p>西夏文献
以国家图书馆保存的西夏、元代孤本及各种西夏的珍贵实物资料为基础建设的数据库。包括西夏文献书目数据124条，原件影像近5000拍。</p>
</li>
<li>
<p>西夏论著
包括西夏研究论文篇名数据1200余条。</p>
</li>
<li>
<p>年画撷英
国家图书馆收藏了杨柳青、朱仙镇等地制作的4000余幅年画作品，从中精选出一部分制作了该库，并为每种年画编写了内容说明，重点介绍了该年画的故事梗概、历史背景、制作特色和相关知识。目前发布元数据及影像302组。</p>
</li>
<li>
<p>前尘旧影
该资源库收录了国家图书馆收藏的新旧照片3074组，真实生动地记录了过去的社会事件、历史人物、城乡面貌、名胜古迹和建筑服饰等，人们可从中解读出不同历史时期特定事物的形象特征和真实信息，具有十分重要的历史价值。</p>
</li>
<li>
<p>敦煌遗珍
国际敦煌项目（IDP）建设的数据库，发布来自敦煌和丝绸之路上的写本、绘画、纺织品及器物的信息和图片，其中包括国家图书馆藏敦煌写卷影像18万余拍。</p>
</li>
<li>
<p>徽州善本家谱
徽州善本家谱印刷资料数据库是中国国家图书馆与法国远东学院的合作项目，收录了中国国家图书馆藏善本古籍中徽州家谱243种286部，配有书影5437幅。</p>
</li>
<li>
<p>中华医药典籍资源库（测试版）
图书馆收藏的文献典籍是整理研究的基础资料，为使读者能够通过互联网检索、利用中医文献资源，国家图书馆（国家古籍保护中心）将逐步建设中华医药典藏资源库，目前首批对221种中医古籍影像进行发布测试。</p>
</li>
<li>
<p>云南图书馆古籍
云南省图书馆将该馆古籍数字资源共139种727册提供给国家图书馆（国家古籍保护中心），这批资源均是云南省图书馆所藏珍贵的、有代表性的古籍文献，特别是明代云南丽江木氏土司家族著述，更是明代少数民族汉文著述的代表。该批资源于2019年11月12日正式在线发布。</p>
</li>
<li>
<p>天津图书馆古籍
为进一步丰富古籍数字资源品种和版本，满足广大读者使用需求，2014年底，天津图书馆向国家图书馆（国家古籍保护中心）提供总量约5,800余种300万拍明清古籍数字资源，该批资源经加工后，于2018年9月28日、2019年1月28日分两批发布。</p>
</li>
<li>
<p>上海图书馆家谱
上海图书馆现藏有家谱近3万余种30余万册共计365个姓氏，收藏的家谱覆盖全国27个省、自治区及直辖市，是国内外收藏中国家谱原件最多的公藏机构，有着“全球中国家谱第一藏”之美誉。国家图书馆与上海图书馆合作，征集该馆所藏明清家谱资源2200余种，在国图网站发布使用。</p>
</li>
<li>
<p>中华古籍善本联合书目
中华古籍善本国际联合书目系统是由中文善本书国际联合目录项目发展而来的新数据库，著录了三十余家海内外图书馆所藏古籍善本，数据达2万多条，并配有1.4万余幅书影。</p>
</li>
<li>
<p>东文研汉籍影像库
东京大学东洋文化研究所收藏有大量中国古籍，其中包括东方文化学院东京研究所的旧藏以及大木幹一、长泽规矩也、仓石武四郎等各具特色的个人收藏。2009年11月，东洋文化研究所将所藏中文古籍4000余种，以数字化方式无偿提供给中国国家图书馆，在国图网站上面向读者提供服务。</p>
</li>
<li>
<p>哈佛大学善本特藏
哈佛大学哈佛燕京图书馆藏中文善本古籍特藏，以其质量之高、数量之大著称于世。为了方便海内外学人便捷地利用这些资料进行研究，同时以数字化形式保存这些中华古籍精品，2009年国家图书馆与哈佛大学哈佛燕京图书达成协议，对哈佛燕京图书馆所藏中文善本和齐如山专藏进行数字化。目前在线发布经部和史部善本数字资源741部，另有齐如山戏曲小说专藏204种。</p>
</li>
<li>
<p>法藏敦煌遗书
2015年，在法国国家图书馆与中国国家图书馆达成合作意向，由法国国家图书馆向中国国家图书馆赠送馆藏全部敦煌遗书高清数字资源。在双方共同努力下，实现了这批敦煌遗书的数字化回归，并于2018年3月5日正式在线发布，共计5300余号3.1万余拍。</p>
</li>
<li>
<p>中华寻根网
中华寻根网是国家图书馆与澳门基金会开展的文化合作项目，是以提供姓氏源流和家谱资源服务为核心、方便海内外华人寻根问祖活动的网络平台。“中华寻根网”目前提供500多个姓氏源流、2000多部家谱和6000种其他文献的阅览，以及自建家谱，交流联谊的互动服务。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>资源</tag>
        <tag>古籍</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows笔记本开共享wifi</title>
    <url>/public/2015/04/14/shells/share_win_wifi/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>网上有很多用笔记本设置无线热点的批处理，我中和了一下。复制下面代码到记事本，改后缀为bat就行了。其中，mssid和mkey可自定义</p>
<a id="more"></a>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@echo off</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set mssid=GOODGOOD</span><br><span class="line">::网络名字</span><br><span class="line">set mkey=123456789</span><br><span class="line">::大于八位密码</span><br><span class="line"></span><br><span class="line">echo ***********************************************</span><br><span class="line">echo              打开承载网络  1</span><br><span class="line">echo              关闭承载网络  2</span><br><span class="line">echo              承载网络信息  3</span><br><span class="line">echo              设置网络信息  set</span><br><span class="line">echo              退出          e</span><br><span class="line">echo        （网络名字、密码可在源文件中改）</span><br><span class="line">echo           （请以管理员身份打开!!!）</span><br><span class="line">echo ***********************************************</span><br><span class="line">:start</span><br><span class="line">set /p var=请选择:</span><br><span class="line">if %var%==1 netsh wlan start hostednetwork &amp;&amp; echo 网络名字:%mssid% 密码:%mkey% &amp;&amp; GOTO start</span><br><span class="line">if %var%==2 netsh wlan stop hostednetwork &amp;&amp; GOTO start</span><br><span class="line">if %var%==3 netsh wlan show hostednetwork &amp;&amp; echo 网络名字:%mssid% 密码:%mkey% &amp;&amp; GOTO start</span><br><span class="line">if %var%==set netsh wlan set hostednetwork mode=allow ssid=%mssid% key=%mkey% &amp;&amp; echo 网络名字:%mssid% 密码:%mkey% &amp;&amp; GOTO start</span><br><span class="line">if %var%==e pause</span><br></pre></td></tr></table></figure>
<h2 id="播放声音"><a class="header-anchor" href="#播放声音">¶</a>播放声音</h2>
<p>保存为<code>播放声音.vbs</code>,可以播放声音</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CreateObject(&quot;SAPI.SpVoice&quot;).Speak &quot;hello world&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>常用脚本</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>Windows脚本</tag>
        <tag>共享wifi</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>SRT中英文合并Python脚本</title>
    <url>/public/2016/04/14/shells/youtube_src_combine/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>从YouTube上看只有中文或英文分开的字幕，下载好视频，想要中英文字幕。可从 <a href="http://mo.dbxdb.com/Yang/setting.html" target="_blank" rel="noopener">Getting Youtube subtitles</a> 获取中或英文字幕，然后将其合并，即成中英文双字幕。下面是Python脚本。</p>
<a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">本脚本完成了中英文srt合并的功能</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">srt2lis</span><span class="params">(name)</span>:</span></span><br><span class="line">    lines = open(<span class="string">'srt/'</span>+name, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>).readlines()</span><br><span class="line">    lis = []</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> i, line <span class="keyword">in</span> enumerate(lines):</span><br><span class="line">        <span class="comment"># 以\n 结尾的一个时间点</span></span><br><span class="line">        <span class="keyword">if</span> line == <span class="string">'\n'</span>:</span><br><span class="line">            lis.append(tmp)</span><br><span class="line">            tmp = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(line)</span><br><span class="line">    <span class="keyword">return</span> lis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hebing</span><span class="params">(name_zh)</span>:</span></span><br><span class="line">    name_en = name_zh[:<span class="number">-7</span>] + <span class="string">'.srt'</span></span><br><span class="line">    out_name=<span class="string">'out/'</span>+name_en</span><br><span class="line">    f=open(out_name,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    lis_en=srt2lis(name_en)</span><br><span class="line">    lis_zh=srt2lis(name_zh)</span><br><span class="line">    <span class="keyword">for</span> i,item <span class="keyword">in</span> enumerate(lis_en):</span><br><span class="line">        print(item[<span class="number">0</span>])</span><br><span class="line">        f.write(item[<span class="number">0</span>])</span><br><span class="line">        f.write(item[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lis_zh[i][<span class="number">2</span>:]:</span><br><span class="line">            f.write(line)</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> item[<span class="number">2</span>:]:</span><br><span class="line">            f.write(line)</span><br><span class="line">        f.write(<span class="string">'\n'</span>)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flis=os.listdir(<span class="string">'srt/'</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'out'</span>):</span><br><span class="line">    os.mkdir(<span class="string">'out'</span>)</span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> flis:</span><br><span class="line">    print(name)</span><br><span class="line">    <span class="keyword">if</span> name[<span class="number">-6</span>:<span class="number">-4</span>]==<span class="string">'zh'</span>:</span><br><span class="line">        hebing(name)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>常用脚本</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>YouTube字幕合并</tag>
        <tag>SRT(文本格式字幕)</tag>
      </tags>
  </entry>
  <entry>
    <title>「202207月度汇报」ttrss</title>
    <url>/public/2022/07/15/test/202207/</url>
    <content><![CDATA[<p>total: 13</p>
<a id="more"></a>
<h2 id="🔖BGmi-–-自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人"><a class="header-anchor" href="#🔖BGmi-–-自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人">¶</a>🔖<a href="https://www.appinn.com/bgmi/" target="_blank" rel="noopener">BGmi – 自动追番的工具：同步最新番剧数据、追番日历、自动下载，适合所有追番懒人</a></h2>
<p>pubdata:2022-06-30 02:48:00
markdate:2022-07-01 06:32:58.020141</p>
<p><img src="/public/2022/07/15/test/202207/2022-07-01-063258020141.jpg" alt="img"></p>
<h2 id="🔖老牌截图工具-PicPick-更新，新增录屏功能，支持-MP4-GIF-格式"><a class="header-anchor" href="#🔖老牌截图工具-PicPick-更新，新增录屏功能，支持-MP4-GIF-格式">¶</a>🔖<a href="https://www.appinn.com/picpick-6-2/" target="_blank" rel="noopener">老牌截图工具 PicPick 更新，新增录屏功能，支持 MP4/GIF 格式</a></h2>
<p>pubdata:2022-06-29 07:19:19
markdate:2022-07-02 04:11:20.453414</p>
<p><img src="/public/2022/07/15/test/202207/2022-07-02-041120453414.jpg" alt="img"></p>
<h2 id="🔖白板与笔记融合：我的四个氢图使用场景"><a class="header-anchor" href="#🔖白板与笔记融合：我的四个氢图使用场景">¶</a>🔖<a href="https://sspai.com/post/73246" target="_blank" rel="noopener">白板与笔记融合：我的四个氢图使用场景</a></h2>
<p>pubdata:2022-06-30 03:30:02
markdate:2022-07-03 01:08:35.583781</p>
<p><img src="/public/2022/07/15/test/202207/2022-07-03-010835583781.jpg" alt="img"></p>
<h2 id="🔖跨时空圆桌：伟大创作者们如何安排日常生活"><a class="header-anchor" href="#🔖跨时空圆桌：伟大创作者们如何安排日常生活">¶</a>🔖<a href="https://sspai.com/post/73779" target="_blank" rel="noopener">跨时空圆桌：伟大创作者们如何安排日常生活</a></h2>
<p>pubdata:2022-06-15 09:30:00
markdate:2022-07-03 01:50:35.971655</p>
<p><img src="/public/2022/07/15/test/202207/2022-07-03-015035971655.jpg" alt="img"></p>
<h2 id="🔖Typing-Learner-–-硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」-Windows-macOS"><a class="header-anchor" href="#🔖Typing-Learner-–-硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」-Windows-macOS">¶</a>🔖<a href="https://www.appinn.com/typing-learner/" target="_blank" rel="noopener">Typing Learner – 硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」[Windows/macOS]</a></h2>
<p>pubdata:2022-07-03 04:07:39
markdate:2022-07-04 05:06:58.902152</p>
<p><img src="/public/2022/07/15/test/202207/2022-07-04-050658902152.jpg" alt="img"></p>
<h2 id="🔖创建自己的第一个-Power-Automate-工作流，从此繁琐操作是路人"><a class="header-anchor" href="#🔖创建自己的第一个-Power-Automate-工作流，从此繁琐操作是路人">¶</a>🔖<a href="https://sspai.com/post/73710" target="_blank" rel="noopener">创建自己的第一个 Power Automate 工作流，从此繁琐操作是路人</a></h2>
<p>pubdata:2022-07-05 10:44:47
markdate:2022-07-06 11:29:55.648077</p>
<p><img src="/public/2022/07/15/test/202207/2022-07-06-112955648077.jpg" alt="img"></p>
<h2 id="🔖为-WSL-配置这些新功能，不用虚拟机也能体验完整-Linux"><a class="header-anchor" href="#🔖为-WSL-配置这些新功能，不用虚拟机也能体验完整-Linux">¶</a>🔖<a href="https://sspai.com/post/74167" target="_blank" rel="noopener">为 WSL 配置这些新功能，不用虚拟机也能体验完整 Linux</a></h2>
<p>pubdata:2022-07-08 03:30:00
markdate:2022-07-09 03:08:43.747852</p>
<p><img src="/public/2022/07/15/test/202207/2022-07-09-030843747852.jpg" alt="img"></p>
<h2 id="🔖当飞盘成为人类的玩具，我们该如何参与这场游戏"><a class="header-anchor" href="#🔖当飞盘成为人类的玩具，我们该如何参与这场游戏">¶</a>🔖<a href="https://sspai.com/post/73505" target="_blank" rel="noopener">当飞盘成为人类的玩具，我们该如何参与这场游戏</a></h2>
<p>pubdata:2022-06-06 08:00:00
markdate:2022-07-10 01:36:40.114938</p>
<p><img src="/public/2022/07/15/test/202207/2022-07-10-013640114938.jpg" alt="img"></p>
<h2 id="🔖走进小众但不冷门的房车世界"><a class="header-anchor" href="#🔖走进小众但不冷门的房车世界">¶</a>🔖<a href="https://sspai.com/post/74043" target="_blank" rel="noopener">走进小众但不冷门的房车世界</a></h2>
<p>pubdata:2022-07-01 08:04:43
markdate:2022-07-10 02:09:34.733003</p>
<p><img src="/public/2022/07/15/test/202207/2022-07-10-020934733003.jpg" alt="img"></p>
<h2 id="🔖从盲目崇拜到理性使用，谈谈我眼中的「双向链接」"><a class="header-anchor" href="#🔖从盲目崇拜到理性使用，谈谈我眼中的「双向链接」">¶</a>🔖<a href="https://sspai.com/post/73407" target="_blank" rel="noopener">从盲目崇拜到理性使用，谈谈我眼中的「双向链接」</a></h2>
<p>pubdata:2022-05-27 06:31:27
markdate:2022-07-11 14:31:37.724795</p>
<p><img src="/public/2022/07/15/test/202207/2022-07-11-143137724795.jpg" alt="img"></p>
<h2 id="🔖打开终端总有好心情：我的美化方案及配置分享"><a class="header-anchor" href="#🔖打开终端总有好心情：我的美化方案及配置分享">¶</a>🔖<a href="https://sspai.com/post/74216" target="_blank" rel="noopener">打开终端总有好心情：我的美化方案及配置分享</a></h2>
<p>pubdata:2022-07-11 08:00:51
markdate:2022-07-12 04:52:00.122103</p>
<p><img src="/public/2022/07/15/test/202207/2022-07-12-045200122103.jpg" alt="img"></p>
<h2 id="🔖咖啡美酒冷泡茶，这些消暑饮品在家就能动手做"><a class="header-anchor" href="#🔖咖啡美酒冷泡茶，这些消暑饮品在家就能动手做">¶</a>🔖<a href="https://sspai.com/post/74196" target="_blank" rel="noopener">咖啡美酒冷泡茶，这些消暑饮品在家就能动手做</a></h2>
<p>pubdata:2022-07-10 07:17:11
markdate:2022-07-12 05:03:55.504330</p>
<p><img src="/public/2022/07/15/test/202207/2022-07-12-050355504330.jpg" alt="img"></p>
<h2 id="🔖语雀，即将开源！"><a class="header-anchor" href="#🔖语雀，即将开源！">¶</a>🔖<a href="https://zhuanlan.zhihu.com/p/540713275" target="_blank" rel="noopener">语雀，即将开源！</a></h2>
<p>pubdata:2022-07-12 08:19:47
markdate:2022-07-14 10:28:28.713392</p>
<p><img src="/public/2022/07/15/test/202207/2022-07-14-102828713392.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>「202208月度汇报」ttrss</title>
    <url>/public/2022/08/15/test/202208/</url>
    <content><![CDATA[<p>total: 5</p>
<a id="more"></a>
<h2 id="🔖AVNC-–-Android-上的开源-VNC-客户端"><a class="header-anchor" href="#🔖AVNC-–-Android-上的开源-VNC-客户端">¶</a>🔖<a href="https://www.appinn.com/avnc-for-android/" target="_blank" rel="noopener">AVNC – Android 上的开源 VNC 客户端</a></h2>
<p>pubdata:2022-08-07 04:59:52
markdate:2022-08-07 17:42:37.878979</p>
<p><img src="/public/2022/08/15/test/202208/2022-08-07-174237878979.jpg" alt="img"></p>
<h2 id="🔖TigerVNC-–-高性能、跨平台开源-VNC-服务器与客户端"><a class="header-anchor" href="#🔖TigerVNC-–-高性能、跨平台开源-VNC-服务器与客户端">¶</a>🔖<a href="https://www.appinn.com/tigervnc/" target="_blank" rel="noopener">TigerVNC – 高性能、跨平台开源 VNC 服务器与客户端</a></h2>
<p>pubdata:2022-08-08 04:30:32
markdate:2022-08-09 00:48:54.680756</p>
<p><img src="/public/2022/08/15/test/202208/2022-08-09-004854680756.jpg" alt="img"></p>
<h2 id="🔖Notion-又一开源替代品，诞生了！"><a class="header-anchor" href="#🔖Notion-又一开源替代品，诞生了！">¶</a>🔖<a href="https://zhuanlan.zhihu.com/p/552965032" target="_blank" rel="noopener">Notion 又一开源替代品，诞生了！</a></h2>
<p>pubdata:2022-08-12 04:42:26
markdate:2022-08-13 16:16:00.234349</p>
<p><img src="/public/2022/08/15/test/202208/2022-08-13-161600234349.jpg" alt="img"></p>
<h2 id="🔖如何写一份高可读性的软件工程设计文档"><a class="header-anchor" href="#🔖如何写一份高可读性的软件工程设计文档">¶</a>🔖<a href="https://zhuanlan.zhihu.com/p/552095835" target="_blank" rel="noopener">如何写一份高可读性的软件工程设计文档</a></h2>
<p>pubdata:2022-08-10 09:00:14
markdate:2022-08-20 02:27:47.773301</p>
<p><img src="/public/2022/08/15/test/202208/2022-08-20-022747773301.jpg" alt="img"></p>
<h2 id="🔖StrokesPlus-net-–-一款很厉害的鼠标手势软件，还有大佬汉化、以及持续更新脚本"><a class="header-anchor" href="#🔖StrokesPlus-net-–-一款很厉害的鼠标手势软件，还有大佬汉化、以及持续更新脚本">¶</a>🔖<a href="https://www.appinn.com/strokesplus-net/" target="_blank" rel="noopener">StrokesPlus.net – 一款很厉害的鼠标手势软件，还有大佬汉化、以及持续更新脚本</a></h2>
<p>pubdata:2022-08-24 04:29:23
markdate:2022-08-25 03:51:08.820884</p>
<p><img src="/public/2022/08/15/test/202208/2022-08-25-035108820884.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>「202208月度汇报」obsidian</title>
    <url>/public/2022/08/26/test/202208_obsidian/</url>
    <content><![CDATA[<p>统计 ✅ : 1 📅 : 1 🔖 : 26</p>
<a id="more"></a>
<h2 id="✅-1"><a class="header-anchor" href="#✅-1">¶</a>✅ : 1</h2>
<p>✅自动生成rss月报
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a></p>
<h2 id="📅-1"><a class="header-anchor" href="#📅-1">¶</a>📅 : 1</h2>
<p>📅 加上地区统计
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a></p>
<h2 id="🔖-26"><a class="header-anchor" href="#🔖-26">¶</a>🔖 : 26</h2>
<p>🔖 <a href="https://github.com/serhack/pdf-diff" target="_blank" rel="noopener">GitHub - serhack/pdf-diff: A tool for visualizing differences between two pdf files.</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>
🔖 <a href="http://arthurchiao.art/blog/conntrack-design-and-implementation-zh/" target="_blank" rel="noopener">连接跟踪（conntrack）：原理、应用及 Linux 内核实现</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>
🔖 <a href="https://codemirror.net/docs/guide/" target="_blank" rel="noopener">CodeMirror System Guide</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>
🔖 <a href="https://zhuanlan.zhihu.com/p/357334969?utm_id=0" target="_blank" rel="noopener">mac使用VNC远程访问Ubuntu图形界面</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>
🔖 <a href="https://mp.weixin.qq.com/s/FBJ_GIvdwNbvGKVKeroZjA" target="_blank" rel="noopener">冠军私教课</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>
🔖 <a href="https://cloud.tencent.com/developer/article/1585686" target="_blank" rel="noopener">如何统计 Hexo 网站的访问地区和IP - 腾讯云开发者社区-腾讯云</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W32.md">C日常/2022-W32.md</a><br>
🔖 <a href="https://www.appinn.com/navidrome/" target="_blank" rel="noopener">Navidrome - 开源音乐服务器，自建云端音乐播放器 - 小众软件</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W30.md">C日常/2022-W30.md</a><br>
🔖 <a href="https://sspai.com/post/73443" target="_blank" rel="noopener">力量训练：办卡之前需要了解的训练基础与细节制定 - 少数派</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W30.md">C日常/2022-W30.md</a><br>
🔖 <a href="https://zhuanlan.zhihu.com/p/495262462" target="_blank" rel="noopener">网站低代码开发</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖长大后，如果是时间修剪了我们的好奇心，我们应该责怪时间吗？
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖半导体行业的组成
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖Weylus – 共享屏幕，将平板作为电脑触摸屏使用[Win/macOS/Linux]
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖跨平台开发 <a href="https://beeware.org/" target="_blank" rel="noopener">BeeWare</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖资本论复旦大学
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖 Linux三剑客
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖pdf补丁丁
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖 <a href="https://www.wdbyte.com/java/char-image.html_1-%E5%AD%97%E7%AC%A6%E5%9B%BE%E6%A1%88%E6%80%9D%E8%B7%AF" target="_blank" rel="noopener">字符作画，我用字符画个冰墩墩 | 未读代码</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖 <a href="https://zhuanlan.zhihu.com/p/474337723?utm_source=ZHShareTargetIDMore&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">一文让你读懂Linux五大模块内核源码，内核整体架构设计（超详细）</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖 <a href="https://zhuanlan.zhihu.com/p/483731291?utm_source=ZHShareTargetIDMore&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">学习数学思维推荐阅读的五本数学书籍</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖Snapdrop for Android – 在电脑与 Android 手机间互传文件
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖Photoview – 支持人脸识别的开源、自托管本地相册
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖GitHub - LibrePhotos/librephotos: A self-hosted open source photo management service. This is the repository of the backend.
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖 <a href="https://www.cnblogs.com/imxiaobei/p/13619630.html" target="_blank" rel="noopener">一文搞懂后台高性能服务器设计的常见套路, BAT 高频面试系列 - 编程指北 - 博客园</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖 <a href="https://www.appinn.com/dual-subtitles/" target="_blank" rel="noopener">YouTube™ 双字幕 - 显示双语字幕（包括自动翻译）、字幕下载，以及自定义字幕样式[Chrome/Edge] - 小众软件</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖 <a href="https://mp.weixin.qq.com/s/cd-uS5NDIreT02GaHpdxlw" target="_blank" rel="noopener">一文搞懂WiFi的所有知识点</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a><br>
🔖 <a href="https://zhuanlan.zhihu.com/p/122523174" target="_blank" rel="noopener">Doxygen 中文文档</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W29.md">C日常/2022-W29.md</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>「202209月度汇报」ttrss</title>
    <url>/public/2022/09/15/test/202209/</url>
    <content><![CDATA[<p>total: 3</p>
<a id="more"></a>
<h2 id="🔖WireGuard-基础教程：wg-quick-路由策略解读"><a class="header-anchor" href="#🔖WireGuard-基础教程：wg-quick-路由策略解读">¶</a>🔖<a href="https://icloudnative.io/posts/linux-routing-of-wireguard/" target="_blank" rel="noopener">WireGuard 基础教程：wg-quick 路由策略解读</a></h2>
<p>pubdata:2022-08-31 01:06:37
markdate:2022-09-03 06:23:25.656749</p>
<p><img src="/public/2022/09/15/test/202209/2022-09-03-062325656749.jpg" alt="img"></p>
<h2 id="🔖微软官方超实用-15-小工具集-PowerToys-v0-62-0-发布，新增文本提取器-OCR-功能"><a class="header-anchor" href="#🔖微软官方超实用-15-小工具集-PowerToys-v0-62-0-发布，新增文本提取器-OCR-功能">¶</a>🔖<a href="https://www.appinn.com/powertoys-v0-62-0/" target="_blank" rel="noopener">微软官方超实用 15+ 小工具集 PowerToys v0.62.0 发布，新增文本提取器 OCR 功能</a></h2>
<p>pubdata:2022-09-07 04:11:14
markdate:2022-09-08 04:19:59.942860</p>
<p><img src="/public/2022/09/15/test/202209/2022-09-08-041959942860.jpg" alt="img"></p>
<h2 id="🔖Stream-Deck-太贵了？触屏音箱也能成为你的直播助手"><a class="header-anchor" href="#🔖Stream-Deck-太贵了？触屏音箱也能成为你的直播助手">¶</a>🔖<a href="https://sspai.com/post/75789" target="_blank" rel="noopener">Stream Deck 太贵了？触屏音箱也能成为你的直播助手</a></h2>
<p>pubdata:2022-09-19 06:31:44
markdate:2022-09-21 03:28:05.514939</p>
<p><img src="/public/2022/09/15/test/202209/2022-09-21-032805514939.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>「202209月度汇报」obsidian</title>
    <url>/public/2022/09/26/test/202209_obsidian/</url>
    <content><![CDATA[<p>统计 ✅ : 0 📅 : 2 🔖 : 10</p>
<a id="more"></a>
<h2 id="✅-0"><a class="header-anchor" href="#✅-0">¶</a>✅ : 0</h2>
<h2 id="📅-2"><a class="header-anchor" href="#📅-2">¶</a>📅 : 2</h2>
<p>📅升级电脑
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W35.md">C日常/2022-W35.md</a><br>
📅 添加rss
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a></p>
<h2 id="🔖-10"><a class="header-anchor" href="#🔖-10">¶</a>🔖 : 10</h2>
<p>🔖 <a href="https://www.appinn.com/umi-ocr/" target="_blank" rel="noopener">Umi-OCR - 免费的离线 OCR 文字识别软件[Windows] - 小众软件</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>
🔖 设计模式
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>
🔖 苏炳添向母校捐赠100万元！
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>
🔖 <a href="https://github.com/dlvhdr/gh-dash" target="_blank" rel="noopener">gh-dash</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>
🔖 <a href="https://nginxproxymanager.com/" target="_blank" rel="noopener">Nginx Proxy Manager</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>
🔖1、<a href="https://knots3d.com/knots/en_us/ALL" target="_blank" rel="noopener">Knots 3D</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>
🔖 <a href="https://m.runoob.com/typescript/" target="_blank" rel="noopener">TypeScript 教程 | 菜鸟教程</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>
🔖 <a href="https://m.runoob.com/js/" target="_blank" rel="noopener">Javascript 教程 | 菜鸟教程</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>
🔖 Makefile
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a><br>
🔖 <a href="https://www.zhihu.com/question/450738311/answer/2635126508?utm_medium=social&amp;utm_oi=619610399826382848&amp;utm_psn=1545021439438381056&amp;utm_source=ZHShareTargetIDMore" target="_blank" rel="noopener">windows 有什么好用的截图软件？ - 知乎</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W33.md">C日常/2022-W33.md</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>「202210月度汇报」ttrss</title>
    <url>/public/2022/10/15/test/202210/</url>
    <content><![CDATA[<p>total: 2</p>
<a id="more"></a>
<h2 id="🔖一日一技｜Obsidian-Command-进阶用法三则"><a class="header-anchor" href="#🔖一日一技｜Obsidian-Command-进阶用法三则">¶</a>🔖<a href="https://sspai.com/post/75847" target="_blank" rel="noopener">一日一技｜Obsidian Command 进阶用法三则</a></h2>
<p>pubdata:2022-10-01 07:00:00
markdate:2022-10-08 11:41:38.979766</p>
<p><img src="/public/2022/10/15/test/202210/2022-10-08-114138979766.jpg" alt="img"></p>
<h2 id="🔖用代码编辑器进行知识管理：我用-VSCode-构建自己的笔记系统"><a class="header-anchor" href="#🔖用代码编辑器进行知识管理：我用-VSCode-构建自己的笔记系统">¶</a>🔖<a href="https://sspai.com/post/75940" target="_blank" rel="noopener">用代码编辑器进行知识管理：我用 VSCode 构建自己的笔记系统</a></h2>
<p>pubdata:2022-09-28 03:29:57
markdate:2022-10-09 04:14:05.692239</p>
<p><img src="/public/2022/10/15/test/202210/2022-10-09-041405692239.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>月度汇报</category>
      </categories>
      <tags>
        <tag>月度汇报</tag>
      </tags>
  </entry>
  <entry>
    <title>「202210月度汇报」obsidian</title>
    <url>/public/2022/10/26/test/202210_obsidian/</url>
    <content><![CDATA[<p>统计 ✅ : 0 📅 : 2 🔖 : 8</p>
<a id="more"></a>
<h2 id="✅-0"><a class="header-anchor" href="#✅-0">¶</a>✅ : 0</h2>
<h2 id="📅-2"><a class="header-anchor" href="#📅-2">¶</a>📅 : 2</h2>
<p>📅 转载一下
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>
📅 tracker更新
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a></p>
<h2 id="🔖-8"><a class="header-anchor" href="#🔖-8">¶</a>🔖 : 8</h2>
<p>🔖肝下50万字的《Linux内核精通》笔记，你的底层原理水平将从入门到入魔【建议收藏】
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>
🔖计算机组成原理(万字爆肝整理)
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W36.md">C日常/2022-W36.md</a><br>
🔖 <a href="https://xiaolincoding.com/network/" target="_blank" rel="noopener">图解网络介绍</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>
🔖 <a href="https://refactoringguru.cn/design-patterns" target="_blank" rel="noopener">常用设计模式有哪些？</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>
🔖 智能家庭网关
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>
🔖 <a href="https://sadh.life/post/builtins/" target="_blank" rel="noopener">Understanding all of Python, through its builtins</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>
🔖 操作系统自学
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a><br>
🔖 机器人计划
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W37.md">C日常/2022-W37.md</a></p>
]]></content>
      <categories>
        <category>月度汇报</category>
      </categories>
      <tags>
        <tag>月度汇报</tag>
      </tags>
  </entry>
  <entry>
    <title>「202211月度汇报」ttrss</title>
    <url>/public/2022/11/15/test/202211/</url>
    <content><![CDATA[<p>total: 1</p>
<a id="more"></a>
<h2 id="🔖微软官方小工具更新，这些新特性你或许也能用得上"><a class="header-anchor" href="#🔖微软官方小工具更新，这些新特性你或许也能用得上">¶</a>🔖<a href="https://sspai.com/post/76649" target="_blank" rel="noopener">微软官方小工具更新，这些新特性你或许也能用得上</a></h2>
<p>pubdata:2022-11-06 03:40:00
markdate:2022-11-17 17:18:09.571032</p>
<p><img src="/public/2022/11/15/test/202211/2022-11-17-171809571032.jpg" alt="img"></p>
]]></content>
      <categories>
        <category>月度汇报</category>
      </categories>
      <tags>
        <tag>月度汇报</tag>
      </tags>
  </entry>
  <entry>
    <title>「202211月度汇报」obsidian</title>
    <url>/public/2022/11/26/test/202211_obsidian/</url>
    <content><![CDATA[<p>统计 ✅ : 0 📅 : 0 🔖 : 0</p>
<a id="more"></a>
<h2 id="✅-0"><a class="header-anchor" href="#✅-0">¶</a>✅ : 0</h2>
<h2 id="📅-0"><a class="header-anchor" href="#📅-0">¶</a>📅 : 0</h2>
<h2 id="🔖-0"><a class="header-anchor" href="#🔖-0">¶</a>🔖 : 0</h2>
]]></content>
      <categories>
        <category>月度汇报</category>
      </categories>
      <tags>
        <tag>月度汇报</tag>
      </tags>
  </entry>
  <entry>
    <title>这哈儿是重庆</title>
    <url>/public/2019/04/25/trips/chongqing/</url>
    <content><![CDATA[<p>重庆，旅游纪实。20190422 - 20190424</p>
<a id="more"></a>
<h2 id="四月二十二"><a class="header-anchor" href="#四月二十二">¶</a>四月二十二</h2>
<img src="/public/2019/04/25/trips/chongqing/tiankongzhicheng.jpg" alt="tiankongzhicheng" width="50%">
<div align="center"> <b>天空之城旅店的临江阳台</b></div>
<p>今天刚来到重庆。前天查天气说是多云，但是来这之后，天气极好。早上9点从成都出发，12点左右到达重庆北站，然后做地铁10号线倒到6号线的小什坊。在解放广场附近，中午吃了个碗杂面很不错，对于我来说有点辣，说是重庆排行第五的小面。</p>
<p>下午就准备午休一哈，今早上很早起来要赶到成都的市中心乘火车。在江边，也是在洪崖洞旁边，找了一家叫做天空之城的青年旅舍。晚上走在千厮大桥上，脚感受着下面的地铁穿过抖动。从青年旅馆房间里面刚好可以看到江边的夜景，管理人是个可爱的老人家。里面的床单是没有铺上的，得自己铺，老人家解释免得被认为不好，你也可以自己带睡袋。老人家在铁路上工作，与他聊了很久，谈到他在铁路站工作的经历，当然还有很多打理旅舍时的故事。</p>
<h2 id="四月二十三"><a class="header-anchor" href="#四月二十三">¶</a>四月二十三</h2>
<img src="/public/2019/04/25/trips/chongqing/guojiang1.jpeg" alt="guojiang1" width="50%">
<div align="center"> <b>排队2小时，乘过江索道</b></div>
<img src="/public/2019/04/25/trips/chongqing/goujiang2.jpeg" alt="goujiang2" width="50%">
<div align="center"> <b>过江索道，晃晃悠悠在路上</b></div>
<p>早上起来，去楼下买了个早餐，有八宝粥和一个米团（块），那个团米上面加了两个半枣。吃完早饭，阳光正照进那个青年公寓。四月底，节气谷雨过后，算还不是很热，在那个临江的阳台晒了会儿阳光。然后很困，大概是吃饱的缘故，我又回去睡了一个回笼觉。下午出发去白公馆，搭的是轻轨2号线，到大坪换到去烈士墓的地铁上，轻轨是一路沿江跑的，欣赏着嘉陵江的美景，羡慕着重庆人的立体公交系统。嘉陵江水比较清澈，也见到有人在游泳。过会儿就经过网红景点李子坝，轻轨穿房而过。白公馆旁边是四川外国语大学，没有去逛，直接去了白公馆，香山别墅，然后去了渣滓洞，白公馆的地势比较陡，台阶比较多，旁边是歌乐山。</p>
<img src="/public/2019/04/25/trips/chongqing/eling.jpg" alt="eling" width="50%">
<div align="center"> <b>鹅岭公园有个塔，从塔上望去</b></div>
<p>接着到了鹅岭公园，可直接做地铁鹅岭站，进门处分左右路线，我选了左转，然后绕了一大圈到了那个塔，其实可以右转沿着汽车的道往上到那个塔。到了塔顶，可以看到面向朝天门方向，左边是嘉陵江，右边是长江，然后各种大桥，轻轨地铁尽收眼底。吹着微风，站在那个塔上，可见重庆各种摩天大楼，然后就是更远处的山。离开鹅岭公园后，继续搭地铁去了上新街站，下车后往南岸区走，南岸发展比较慢，可以看到明显和渝中区的不同，路边找了一家店，选了几个小菜，吃了个晚饭。晚饭后，去了南山一棵树，人很多，夜景倒是很漂亮，有水有山，两水相交，滋润了这个大都市，今天的行程不错。</p>
<img src="/public/2019/04/25/trips/chongqing/yejing.jpg" alt="yejing" width="50%">
<div align="center"> <b>南山一棵松</b></div>
<h2 id="四月二十四"><a class="header-anchor" href="#四月二十四">¶</a>四月二十四</h2>
<img src="/public/2019/04/25/trips/chongqing/caotianmen.jpg" alt="caotianmen" width="50%">
<div align="center"> <b>朝天门码头，水清黄分明</b></div>
<p>今天也是懒懒起床，吃了个早饭，豆浆是放在那种果冻的包装袋里。今天差不多，就准备看看朝天门，然后回成都。去朝天门还是比较奇怪，随着百度地图导航走，到了一个商城里面，从地面进去是商城的8楼，下了电梯，走了一个商品批发的地方，然后向朝天门赶，今天太阳超级满足，比较热。岸边停了好多游船。到了朝天门，水分了两个颜色，黄的长江，清的嘉陵江。休息一刻，搭了公交车，沿着长江岸跑，居然到了李子坝，然后地铁转到重庆北火车站，这一趟重庆算是画上了一个句号。</p>
<p>『转载』，请联系博主。</p>
]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>重庆</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」九张图一览 Linux 性能工具 全景图</title>
    <url>/public/2022/12/11/linux/linux_tools/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>当今时代，绝大多数企业的应用都是运行在 Linux 操作系统上，所以对应用进行性能诊断和性能优化时，离不开 Linux 的各种性能观测工具和性能优化工具。</p>
<p>笔者使用过的常见的 Linux 性能观测和性能优化工具有：</p>
<ul>
<li>top/uptime</li>
<li>ps/pstree</li>
<li>df/du/free/lsblk</li>
<li>ip/ifconfig/ping/telnet</li>
<li>route/dig/nslookup</li>
<li>lsof/netstat/ss</li>
<li>tcpdump/tshark/wireshark</li>
<li>netstat/vmstat/iostat/pidstat/dstat/mpstat</li>
<li>sar/sysctl/ethtool</li>
</ul>
<p>最近在拜读国际著名的 LINUX 性能专家 Brendan Gregg 的个人博客和技术书籍，摘抄了如下九张图，一览 Linux 性能工具全景图，大家共勉！</p>
<a id="more"></a>
<h2 id="2-Linux-性能工具全景图"><a class="header-anchor" href="#2-Linux-性能工具全景图">¶</a><strong>2. Linux 性能工具全景图</strong></h2>
<ul>
<li>linux performance observability tools</li>
</ul>
<p><img src="/public/2022/12/11/linux/linux_tools/v2-2eadd97c53a3f20f255394c3d90ea914_r.jpg" alt></p>
<ul>
<li>linux static performance tools</li>
</ul>
<p><img src="/public/2022/12/11/linux/linux_tools/v2-20032bac53c856c5733259eece5c2f76_r.jpg" alt></p>
<ul>
<li>linux performance benchmark tools</li>
</ul>
<p><img src="/public/2022/12/11/linux/linux_tools/v2-de23423f2eb9deb5410b7128c933f9a9_r.jpg" alt></p>
<ul>
<li>linux performance tuning tools</li>
</ul>
<p><img src="/public/2022/12/11/linux/linux_tools/v2-cdf37de145763b762ba5af1a620f9686_r.jpg" alt></p>
<ul>
<li>linux performance observability: sar</li>
</ul>
<p><img src="/public/2022/12/11/linux/linux_tools/v2-eee71a6bf3865367741137da03031411_r.jpg" alt></p>
<ul>
<li>linux performance observability: perf-tools</li>
</ul>
<p><img src="/public/2022/12/11/linux/linux_tools/v2-1c0134fefbb04597db98ae455a40fad5_r.jpg" alt></p>
<ul>
<li><a href="https://www.zhihu.com/search?q=linux%20bcc&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2795830055%7D" target="_blank" rel="noopener">linux bcc</a>/BPF Tracing tools</li>
</ul>
<p><img src="/public/2022/12/11/linux/linux_tools/v2-ffe70303f4d64828ca931d987b12a6d8_r.jpg" alt></p>
<ul>
<li>bpftrace/eBPF Tools</li>
</ul>
<p><img src="/public/2022/12/11/linux/linux_tools/v2-5985d44e43738933c0b54c89cc20ec09_r.jpg" alt></p>
<ul>
<li>BPF Performance Tools: Linux System and Application Observability</li>
</ul>
<p><img src="/public/2022/12/11/linux/linux_tools/v2-0f53016fa1d993ffbbf6fc520e318784_r.jpg" alt></p>
<h2 id="后记"><a class="header-anchor" href="#后记">¶</a>后记</h2>
<p>更多 LINUX 性能资料，大家可以访问大师的个人网站和和技术书籍</p>
<ul>
<li><a href="https://www.brendangregg.com/" target="_blank" rel="noopener">https://www.brendangregg.com/</a></li>
<li>《性能之巅：洞悉系统、企业与云计算》（《Systems Performance: Enterprise and the Cloud, 2nd Edition (2020)》）</li>
<li>《洞悉 Linux 系统和应用性能》（《BPF Performance Tools》）</li>
<li>ps: 要说 LINUX 内核近几年 (和今后几年）最引人注目的发展模块，那就是 <a href="https://www.zhihu.com/search?q=bpf&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2795830055%7D" target="_blank" rel="noopener">bpf</a> 了，完全值得花点精力学习跟进下。</li>
<li>如何更深入地学习 Linux？ - michaelli的回答 - 知乎
<a href="https://www.zhihu.com/question/23564190/answer/2795830055" target="_blank" rel="noopener">https://www.zhihu.com/question/23564190/answer/2795830055</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux代理的使用</title>
    <url>/public/2018/07/24/linux/linux_proxy/</url>
    <content><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>最近要下载一个在youtube上的数据库，用来训练神经网络。走国内通道下载比较慢。于是，我使用了vps代理方式下载，速度取决于你的机器连接vps的网速。本文的主要内容有，实现shadowsocks 代理 ，tsocks 代理工具使用，可组合使用的一些下载工具如wget 和axel等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 举个栗子</span></span><br><span class="line">$ tsocks wget -c https://www.dropbox.com/s/minpyv59crdifk9/datasets.zip</span><br></pre></td></tr></table></figure>
<p>嗯嗯，这个速度还不错！</p>
<center><img src="/public/2018/07/24/linux/linux_proxy/1565246896718.png" width="60%">
</center>
<p><strong>声明</strong>：本文以科学研究为目的，请勿滥用。</p>
<a id="more"></a>
<h2 id="1-Shadowsocks"><a class="header-anchor" href="#1-Shadowsocks">¶</a>1 Shadowsocks</h2>
<p><strong>Shadowsocks</strong>是一个轻量级socks5代理工具。在linux平台，我们可使用 python 提供的包管理工具 pip <strong>安装 Shadowsocks</strong> ，如下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pip 安装 Shadowsocks</span></span><br><span class="line">$ pip install shadowsocks</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ pip install git+https://github.com/shadowsocks/shadowsocks.git@master</span><br></pre></td></tr></table></figure>
<p>pip安装完之后，可能要重启终端，我们就有ssserver和sslocal小工具了。下面配置server或者client。一般，server配置在国外的vps上，client配置在本地国内机器上。</p>
<p>PS：其他平台安装 参考 shadowsocks官方 <a href="https://github.com/shadowsocks/shadowsocks/tree/master#install" target="_blank" rel="noopener">install</a></p>
<h3 id="1-1-配置-Shadowsocks-server"><a class="header-anchor" href="#1-1-配置-Shadowsocks-server">¶</a>1.1 配置 Shadowsocks server</h3>
<p>按下面的三步走，即可。</p>
<ul>
<li>
<p>通过ssh连接到（Virtual Private Server）vps上，或者本地打开终端。</p>
</li>
<li>
<p>新建一个<strong>server_shadowsocks.json</strong>文件，内容如下：</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>:<span class="number">443</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>:<span class="string">"密码"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行<code>ssserver -c server_shadowsocks.json</code></li>
</ul>
<p>说一点: 由于我们的下载任务是临时的，开个screen（终端复用工具）放在后台。当然你也可以设置为开机自启动，这里不再赘述。</p>
<h3 id="1-2-配置-Shadowsocks-client"><a class="header-anchor" href="#1-2-配置-Shadowsocks-client">¶</a>1.2 配置 Shadowsocks client</h3>
<ul>
<li>
<p>通过ssh连接到机器上，或者本地打开终端。</p>
</li>
<li>
<p>新建文件 <strong>client_shadowsocks.json</strong></p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">"server"</span>:<span class="string">"服务器ip或域名"</span>,</span><br><span class="line">        <span class="attr">"server_port"</span>:<span class="number">443</span>,</span><br><span class="line">        <span class="attr">"local_address"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">        <span class="attr">"local_port"</span>:<span class="number">1280</span>,</span><br><span class="line">        <span class="attr">"password"</span>:<span class="string">"密码"</span>,</span><br><span class="line">        <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">        <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">        <span class="attr">"fast_open"</span>:<span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"workers"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行<code>sslocal -c client_shadowsocks.json</code>。</li>
</ul>
<p>说一点：推荐使用screen方式放在后台。当然也可以使用-d 参数放在后台运行。
<code>sslocal -c client_shadowsocks.json -d start</code></p>
<h2 id="2-tsocks"><a class="header-anchor" href="#2-tsocks">¶</a>2 tsocks</h2>
<p>有些linux工具可能没有proxy的代理功能，或者不支持sock5代理，而用tsocks可以很好的解决这些问题。<strong>tsocks</strong> 是个终端代理工具，可以直接连接shadowsocks提供socks 5代理端口，有点类似于proxychains。</p>
<p>下面简单介绍下安装与使用：</p>
<ul>
<li>安装<strong>tsocks</strong>
<ul>
<li>linux安装tsocks 命令：<code>apt install tsocks</code></li>
<li>mac 安装参考 <a href="https://github.com/Anakros/homebrew-tsocks" target="_blank" rel="noopener">homebrew-tsocks</a></li>
</ul>
</li>
<li>开启上面Shadowsocks的client放在后台。</li>
<li>修改tsocks 配置文件，在 <code>/etc/tsocks.conf</code>  文件的最后添加：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local = 192.168.1.0/255.255.255.0</span><br><span class="line">server = 127.0.0.1</span><br><span class="line">server_type = 5</span><br><span class="line">server_port = 1080</span><br></pre></td></tr></table></figure>
<h2 id="3-Demo：代理使用"><a class="header-anchor" href="#3-Demo：代理使用">¶</a>3 Demo：代理使用</h2>
<h3 id="3-1-使用-tsocks"><a class="header-anchor" href="#3-1-使用-tsocks">¶</a>3.1 使用 tsocks</h3>
<p>在所需代理的命令前加个tsocks就行，如：
<code>tsocks wget -c xxxx</code>,<code>tsocks axel -n 10 -av xxxx</code>,<code>tsocks curl xxx</code></p>
<h3 id="3-2-使用-youtube-dl"><a class="header-anchor" href="#3-2-使用-youtube-dl">¶</a>3.2 使用 youtube-dl</h3>
<p>youtube-dl是批量下载youtube视频的好工具。youtube-dl 可以指定 proxy，<strong>可以不使用tsocks</strong>。</p>
<ul>
<li>安装youtube-dl</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install --upgrade youtube-dl</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>使用举个例子</p>
<ul>
<li>下载youtube视频</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL=https://www.youtube.com/playlist?list=PLLbeS1kM6teJqdFzw1ICHfa4a1y0hg8Ax</span><br><span class="line">./youtube-dl --proxy socks5://127.0.0.1:1280 $&#123;URL&#125;</span><br><span class="line"># 在 client_shadowsocks.json 的 local_port 设置为1280，这儿也为1280</span><br></pre></td></tr></table></figure>
<ul>
<li>下载里面的mp3</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">youtube-dl -x --audio-format mp3 https://www.youtube.com/watch?v=xpVfcZ0ZcFM</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>youtube-dl 中待解决的问题？</strong>
想只下载一个视频中的一部分，不用下载整个视频，太费vps流量了。暂未找到解决办法，我找到的一个跟问题很相似的issue，有朋友会整的，望告诉一下。<a href="https://github.com/rg3/youtube-dl/issues/4821" target="_blank" rel="noopener">is it possible to download only desired time interval?</a></p>
<h3 id="3-3-使用-axel"><a class="header-anchor" href="#3-3-使用-axel">¶</a>3.3 使用 axel</h3>
<p>axel多线程下载。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tsocks axel -n 3 -a https://www.dropbox.com/s/minpyv59crdifk9/datasets.zip</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-n 3 : 3个线程下载</span><br><span class="line">-a   : 有个进度条</span><br></pre></td></tr></table></figure>
<p>其他方式：下载脚本 <a href="http://axel-bash.sh" target="_blank" rel="noopener">axel-bash.sh</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh -e  </span></span><br><span class="line"><span class="comment"># usage:  ./axel-batch.sh the-download-url.list  </span></span><br><span class="line">cat <span class="variable">$1</span> | <span class="keyword">while</span> <span class="built_in">read</span> LINE  </span><br><span class="line"><span class="keyword">do</span>  </span><br><span class="line">	<span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$LINE</span>"</span> ]; <span class="keyword">then</span>  </span><br><span class="line">	axel -n 3 -a `<span class="built_in">echo</span> <span class="variable">$LINE</span>`  </span><br><span class="line">	<span class="keyword">fi</span>  </span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>linux</tag>
        <tag>proxy代理</tag>
      </tags>
  </entry>
  <entry>
    <title>[译] Face Detection – OpenCV, Dlib and Deep Learning ( C++ / Python )</title>
    <url>/public/2018/11/12/cv/FaceDetectionComparison/</url>
    <content><![CDATA[<p><strong>前言</strong>
本文为翻译文章。原文地址 <a href="https://www.learnopencv.com/face-detection-opencv-dlib-and-deep-learning-c-python/" target="_blank" rel="noopener">https://www.learnopencv.com/face-detection-opencv-dlib-and-deep-learning-c-python/</a></p>
<p>在这篇文章中，作者讨论使用了OpenCV或Dlib的多种人脸检测的代码，并给出性能分析。作者使用的 Face Detector 包括以下四个，后面分别给出 c++ 和 python 实现。</p>
<ol>
<li>OpenCV 的 Haar Cascade Face Detector</li>
<li>OpenCV 的 Deep Learning based Face Detector</li>
<li>Dlib 的 HoG Face Detector</li>
<li>Dlib 的 Deep Learning based Face Detector</li>
</ol>
<p>作者限于篇幅没有对对理论进行深入解读，只讨论框架的使用，同时分享一些应用上的选择权衡的经验。</p>
<p>结论：在多数场景中，我们提前不知道图片大小，因此 选用 OpenCV – DNN 相当快也很精确，甚至对于小人脸也不错，各种人脸角度也可以。选用这个在大多情况下是最优的。</p>
<p><a href="https://github.com/spmallick/learnopencv/tree/master/FaceDetectionComparison" target="_blank" rel="noopener">code FaceDetectionComparison</a> 说明：为了使文章显得简洁一些，在文中只提供关键的代码片段。在github项目中详细代码，包括每个方法独立的代码和整合在一起的cpp和py文件（<a href="http://run-all.py" target="_blank" rel="noopener">run-all.py</a> 和 run-all.cpp），同时里面也有运行代码所使用的人脸检测模型。</p>
<a id="more"></a>
<center><iframe width="100%" height="360" frameborder="0" src="http://v.qq.com/iframe/player.html?vid=k07615vrzj8&tiny=0&auto=0" allowfullscreen></iframe></center>
> 实验的图片尺寸是  image size 300×300
<h2 id="1-OpenCV-Haar"><a class="header-anchor" href="#1-OpenCV-Haar">¶</a>1. OpenCV-Haar</h2>
<p>在2001年，Viola 和 Jones提出Haar Cascade 特征为基础的 Face Detector，在以后的多年内都是最优的人脸检测算法。以他们的算法为基础人们做了很多改进。OpenCV提供了很多Haar特征的模型算法，更多的Haar特征模型 <strong><a href="https://github.com/opencv/opencv/tree/master/data/haarcascades" target="_blank" rel="noopener">here</a></strong></p>
<h3 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h3>
<h4 id="Python"><a class="header-anchor" href="#Python">¶</a>Python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">faceCascade = cv2.CascadeClassifier(<span class="string">'./haarcascade_frontalface_default.xml'</span>)</span><br><span class="line">faces = faceCascade.detectMultiScale(frameGray)</span><br><span class="line"><span class="keyword">for</span> face <span class="keyword">in</span> faces:</span><br><span class="line">    x1, y1, w, h = face</span><br><span class="line">    x2 = x1 + w</span><br><span class="line">    y2 = y1 + h</span><br></pre></td></tr></table></figure>
<h4 id="C"><a class="header-anchor" href="#C">¶</a>C++</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">faceCascadePath = <span class="string">"./haarcascade_frontalface_default.xml"</span>;</span><br><span class="line">faceCascade.load( faceCascadePath )</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Rect&gt; faces;</span><br><span class="line">faceCascade.detectMultiScale(frameGray, faces);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; faces.size(); i++ )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> x1 = faces[i].x;</span><br><span class="line">  <span class="keyword">int</span> y1 = faces[i].y;</span><br><span class="line">  <span class="keyword">int</span> x2 = faces[i].x + faces[i].width;</span><br><span class="line">  <span class="keyword">int</span> y2 = faces[i].y + faces[i].height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对图片灰度变化（grayscale）后，再应用 haar cascade 特征，输出是脸的list。list中每个item有四个element 分别为 top-left corner的(x, y) 、检测出来脸的大小(width, height) 。</p>
<h3 id="优点"><a class="header-anchor" href="#优点">¶</a>优点</h3>
<ol>
<li>在CPU上几乎是实时的（real-time）</li>
<li>简单的框架 （Simple Architecture）</li>
<li>能检测不同大小的脸 （different scales）</li>
</ol>
<h3 id="缺点"><a class="header-anchor" href="#缺点">¶</a>缺点</h3>
<ol>
<li>主要缺点是有很多错误的预测（False predictions），会多预测出人脸。</li>
<li>人脸非正面效果不好 （non-frontal）</li>
<li>人脸遮挡效果不好 （under occlusion）</li>
</ol>
<h2 id="2-OpenCV-DNN"><a class="header-anchor" href="#2-OpenCV-DNN">¶</a>2. OpenCV-DNN</h2>
<p>在 OpenCV 3.3 中引入这个方法。DNN模型使用SSD **<a href="https://arxiv.org/abs/1512.02325" target="_blank" rel="noopener">Single-Shot-Multibox detector</a>**框架和  ResNet-10 特征提取网络（backbone）。这个模型喂的数据是从网上采集的，但是训练的源代码没有公开。OpenCV提供了2个模型文件。</p>
<ol>
<li>Float 16 位版本模型，使用原始的 caffe 训练  (5.4 MB)</li>
<li>8 bit quantized 版本模型，使用 Tensorflow 训练 (2.7 MB)</li>
</ol>
<p>代码 <a href="https://github.com/spmallick/learnopencv/tree/master/FaceDetectionComparison" target="_blank" rel="noopener">FaceDetectionComparison</a>  里面放了这两个模型文件。</p>
<h3 id="代码-2"><a class="header-anchor" href="#代码-2">¶</a>代码</h3>
<h4 id="Python-2"><a class="header-anchor" href="#Python-2">¶</a>Python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DNN = <span class="string">"TF"</span></span><br><span class="line"><span class="keyword">if</span> DNN == <span class="string">"CAFFE"</span>:</span><br><span class="line">    modelFile = <span class="string">"res10_300x300_ssd_iter_140000_fp16.caffemodel"</span></span><br><span class="line">    configFile = <span class="string">"deploy.prototxt"</span></span><br><span class="line">    net = cv2.dnn.readNetFromCaffe(configFile, modelFile)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    modelFile = <span class="string">"opencv_face_detector_uint8.pb"</span></span><br><span class="line">    configFile = <span class="string">"opencv_face_detector.pbtxt"</span></span><br><span class="line">    net = cv2.dnn.readNetFromTensorflow(modelFile, configFile)</span><br></pre></td></tr></table></figure>
<h4 id="C-2"><a class="header-anchor" href="#C-2">¶</a>C++</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> caffeConfigFile = <span class="string">"./deploy.prototxt"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> caffeWeightFile = <span class="string">"./res10_300x300_ssd_iter_140000_fp16.caffemodel"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> tensorflowConfigFile = <span class="string">"./opencv_face_detector.pbtxt"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> tensorflowWeightFile = <span class="string">"./opencv_face_detector_uint8.pb"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> CAFFE</span></span><br><span class="line"></span><br><span class="line">  Net net = cv::dnn::readNetFromCaffe(caffeConfigFile, caffeWeightFile);</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line">  Net net = cv::dnn::readNetFromTensorflow(tensorflowWeightFile, tensorflowConfigFile);</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>caffe 和 Tensorflow 框架加载模型的代码。使用 Float 16 的 Caffe 模型，需要 caffemodel 和 prototxt 文件。使用 8 bit quantized 的 Tensorflow 模型，需要 Tensorflow 配置文件和模型。</p>
<h4 id="Python-3"><a class="header-anchor" href="#Python-3">¶</a>Python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blob = cv2.dnn.blobFromImage(frameOpencvDnn, <span class="number">1.0</span>, (<span class="number">300</span>, <span class="number">300</span>), [<span class="number">104</span>, <span class="number">117</span>, <span class="number">123</span>], <span class="literal">False</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">net.setInput(blob)</span><br><span class="line">detections = net.forward()</span><br><span class="line">bboxes = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(detections.shape[<span class="number">2</span>]):</span><br><span class="line">    confidence = detections[<span class="number">0</span>, <span class="number">0</span>, i, <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">if</span> confidence &gt; conf_threshold:</span><br><span class="line">        x1 = int(detections[<span class="number">0</span>, <span class="number">0</span>, i, <span class="number">3</span>] * frameWidth)</span><br><span class="line">        y1 = int(detections[<span class="number">0</span>, <span class="number">0</span>, i, <span class="number">4</span>] * frameHeight)</span><br><span class="line">        x2 = int(detections[<span class="number">0</span>, <span class="number">0</span>, i, <span class="number">5</span>] * frameWidth)</span><br><span class="line">        y2 = int(detections[<span class="number">0</span>, <span class="number">0</span>, i, <span class="number">6</span>] * frameHeight)</span><br></pre></td></tr></table></figure>
<h4 id="C-3"><a class="header-anchor" href="#C-3">¶</a>C++</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CAFFE</span></span><br><span class="line">cv::Mat inputBlob = cv::dnn::blobFromImage(frameOpenCVDNN, inScaleFactor, cv::Size(inWidth, inHeight), meanVal, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">cv::Mat inputBlob = cv::dnn::blobFromImage(frameOpenCVDNN, inScaleFactor, cv::Size(inWidth, inHeight), meanVal, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">net.setInput(inputBlob, <span class="string">"data"</span>);</span><br><span class="line">cv::Mat detection = net.forward(<span class="string">"detection_out"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">cv::Mat <span class="title">detectionMat</span><span class="params">(detection.size[<span class="number">2</span>], detection.size[<span class="number">3</span>], CV_32F, detection.ptr&lt;<span class="keyword">float</span>&gt;())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; detectionMat.rows; i++)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">float</span> confidence = detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (confidence &gt; confidenceThreshold)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">int</span> x1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">3</span>) * frameWidth);</span><br><span class="line">         <span class="keyword">int</span> y1 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">4</span>) * frameHeight);</span><br><span class="line">         <span class="keyword">int</span> x2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">5</span>) * frameWidth);</span><br><span class="line">         <span class="keyword">int</span> y2 = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(detectionMat.at&lt;<span class="keyword">float</span>&gt;(i, <span class="number">6</span>) * frameHeight);</span><br><span class="line"></span><br><span class="line">        cv::rectangle(frameOpenCVDNN, cv::Point(x1, y1), cv::Point(x2, y2), cv::Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码里面，图像转为blob输入进network里，利用前向传播函数forward()，得到一个4-D matrix。 #TODO :这里不是很理解，代码跑起来看一下？？？</p>
<ul>
<li>The 3rd dimension iterates over the detected faces. (i is the iterator over the number of faces)</li>
<li>The fourth dimension contains information about the bounding box and score for each face. For example, detections[0,0,0,2] gives the confidence score for the first face, and detections[0,0,0,3:6] give the bounding box.</li>
</ul>
<p>The output coordinates of the bounding box are normalized between [0,1]. Thus the coordinates should be multiplied by the height and width of the original image to get the correct bounding box on the image.</p>
<h3 id="优点（merits）"><a class="header-anchor" href="#优点（merits）">¶</a>优点（merits）</h3>
<ol>
<li>在本文四个方法中最精确（Most accurate）</li>
<li>可以在CPU上实时运行（real-time）</li>
<li>人脸不同方向效果不错（上下左右，侧脸等）up, down, left, right, side-face etc</li>
<li>人脸不同大小效果不错哦（various scales, big and tiny OK）</li>
</ol>
<p>OpenCV的这个DNN方法克服了 Haar cascade 方法的不足，同时精度也不比它差。暂时没有发现这个方法其他有不足地方，除了比后面的 Dlib HoG 方法速度慢一点以外。</p>
<p>作者建议，在使用OpenCV时，比Haar方法，可以优先考虑DNN方法。</p>
<h2 id="3-Dlib-HoG"><a class="header-anchor" href="#3-Dlib-HoG">¶</a>3. Dlib-HoG</h2>
<p>HoG 人脸检测方法被广泛的使用，基于 HoG 特征和 SVM 分类。作者还写了一篇 HoG 的博客 <a href="https://www.learnopencv.com/histogram-of-oriented-gradients/" target="_blank" rel="noopener">post</a>。模型有5个 HOG filters 滤波器（ front looking, left looking, right looking, front looking but rotated left, and a front looking but rotated right），模型直接放在了头文件里面 <strong><a href="https://github.com/davisking/dlib/blob/master/dlib/image_processing/frontal_face_detector.h" target="_blank" rel="noopener">header file</a></strong>。</p>
<p>训练模型的数据库，来自LFW dataset，由 Davis King (Dlib的作者) 手工标记 （manually annotated）共2825张。需要的话，数据库从这里可以下载 <strong><a href="http://dlib.net/files/data/dlib_face_detector_training_data.tar.gz" target="_blank" rel="noopener">dlib_face_detector_training_data.tar.gz</a></strong>.</p>
<h3 id="代码-3"><a class="header-anchor" href="#代码-3">¶</a>代码</h3>
<h4 id="Python-4"><a class="header-anchor" href="#Python-4">¶</a>Python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hogFaceDetector = dlib.get_frontal_face_detector()</span><br><span class="line">faceRects = hogFaceDetector(frameDlibHogSmall, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> faceRect <span class="keyword">in</span> faceRects:</span><br><span class="line">    x1 = faceRect.left()</span><br><span class="line">    y1 = faceRect.top()</span><br><span class="line">    x2 = faceRect.right()</span><br><span class="line">    y2 = faceRect.bottom()</span><br></pre></td></tr></table></figure>
<h4 id="C-4"><a class="header-anchor" href="#C-4">¶</a>C++</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">frontal_face_detector hogFaceDetector = get_frontal_face_detector();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert OpenCV image format to Dlib's image format</span></span><br><span class="line"><span class="function">cv_image&lt;bgr_pixel&gt; <span class="title">dlibIm</span><span class="params">(frameDlibHogSmall)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect faces in the image</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dlib::rectangle&gt; faceRects = hogFaceDetector(dlibIm);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; faceRects.size(); i++ )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> x1 = faceRects[i].left();</span><br><span class="line">  <span class="keyword">int</span> y1 = faceRects[i].top();</span><br><span class="line">  <span class="keyword">int</span> x2 = faceRects[i].right();</span><br><span class="line">  <span class="keyword">int</span> y2 = faceRects[i].bottom();</span><br><span class="line">  cv::rectangle(frameDlibHog, Point(x1, y1), Point(x2, y2), Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), (<span class="keyword">int</span>)(frameHeight/<span class="number">150.0</span>), <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，首先加载 face detector，然后将图像输入给 detector 。其中第二个参数代表，想要上采样图片的倍数（times of upscale）。你给的数字越大，小脸检测出的概率越大。但是upscaling 会在计算上花费可观的时间（ substantial impact on the computation speed）。输出是脸的list， 框框对角的坐标（diagonal corners）。</p>
<h3 id="优点-2"><a class="header-anchor" href="#优点-2">¶</a>优点</h3>
<ol>
<li>在cpu上最快的方法（在四个方法中）</li>
<li>对正面和轻微非正面的方法效果很不错</li>
<li>模型比较少对于其他三个的文件来说</li>
<li>轻微遮挡下可以检测</li>
</ol>
<p>大概以上，这个方法多数情况可以工作，除了下面的情况。</p>
<h3 id="缺点-2"><a class="header-anchor" href="#缺点-2">¶</a>缺点</h3>
<ol>
<li>主要缺点对小人脸不识别。由于训练在最小 80×80 的数据集上，要确保你的使用环境，不然的话你要自己再训练一下小人脸。</li>
<li>人脸框经常去掉了人额头一部分，有时脸颊一部分。
（part of forehead and even part of chin sometimes）</li>
<li>在明显的遮挡情况下效果不好</li>
<li>在测量和极端不正面的脸情况不工作，像向上看，和向下看的情况。</li>
</ol>
<h2 id="4-Dlib-CNN"><a class="header-anchor" href="#4-Dlib-CNN">¶</a>4. Dlib-CNN</h2>
<p>这个模型使用了**<a href="https://arxiv.org/pdf/1502.00046.pdf" target="_blank" rel="noopener">Maximum-Margin Object Detector (MMOD)</a>** 加CNN的特征的方法。训练过程相当简单，也不需要大量的数据去训练一个新的 object detector。更多的训练套路，在这个网站上 <strong><a href="http://blog.dlib.net/2016/10/easily-create-high-quality-object.html" target="_blank" rel="noopener">website</a></strong>.</p>
<p>使用的模型可以从 <strong><a href="https://github.com/davisking/dlib-models" target="_blank" rel="noopener">dlib-models repository</a></strong> 下载。</p>
<p>训练使用的数据库是dlib的作者 Davis King 手工标的，7220张从  ImageNet, PASCAL VOC, VGG, WIDER, Face Scrub等数据库里面挑的。这个数据库可以下载到。<a href="http://dlib.net/files/data/dlib_face_detection_dataset-2016-09-30.tar.gz" target="_blank" rel="noopener"><strong>dlib_face_detection_dataset-2016-09-30.tar.gz</strong></a></p>
<h3 id="代码-4"><a class="header-anchor" href="#代码-4">¶</a>代码</h3>
<h4 id="Python-5"><a class="header-anchor" href="#Python-5">¶</a>Python</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dnnFaceDetector = dlib.cnn_face_detection_model_v1(<span class="string">"./mmod_human_face_detector.dat"</span>)</span><br><span class="line">faceRects = dnnFaceDetector(frameDlibHogSmall, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> faceRect <span class="keyword">in</span> faceRects:</span><br><span class="line">    x1 = faceRect.rect.left()</span><br><span class="line">    y1 = faceRect.rect.top()</span><br><span class="line">    x2 = faceRect.rect.right()</span><br><span class="line">    y2 = faceRect.rect.bottom()</span><br></pre></td></tr></table></figure>
<h4 id="C-5"><a class="header-anchor" href="#C-5">¶</a>C++</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">String mmodModelPath = <span class="string">"./mmod_human_face_detector.dat"</span>;</span><br><span class="line">net_type mmodFaceDetector;</span><br><span class="line">deserialize(mmodModelPath) &gt;&gt; mmodFaceDetector;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert OpenCV image format to Dlib's image format</span></span><br><span class="line"><span class="function">cv_image&lt;bgr_pixel&gt; <span class="title">dlibIm</span><span class="params">(frameDlibMmodSmall)</span></span>;</span><br><span class="line">matrix&lt;rgb_pixel&gt; dlibMatrix;</span><br><span class="line">assign_image(dlibMatrix, dlibIm);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Detect faces in the image</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dlib::mmod_rect&gt; faceRects = mmodFaceDetector(dlibMatrix);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; faceRects.size(); i++ )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> x1 = faceRects[i].rect.left();</span><br><span class="line">  <span class="keyword">int</span> y1 = faceRects[i].rect.top();</span><br><span class="line">  <span class="keyword">int</span> x2 = faceRects[i].rect.right();</span><br><span class="line">  <span class="keyword">int</span> y2 = faceRects[i].rect.bottom();</span><br><span class="line">  cv::rectangle(frameDlibMmod, Point(x1, y1), Point(x2, y2), Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), (<span class="keyword">int</span>)(frameHeight/<span class="number">150.0</span>), <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码和  HoG detector 差不多，除了下载的 CNN face detection 的模型文件。</p>
<h3 id="优点-3"><a class="header-anchor" href="#优点-3">¶</a>优点</h3>
<ol>
<li>不同的脸朝向效果不错 （face orientations）</li>
<li>遮挡比较稳定 （occlusion）</li>
<li>在GPU上很快</li>
<li>训练模型过程很简单</li>
</ol>
<h3 id="缺点-3"><a class="header-anchor" href="#缺点-3">¶</a>缺点</h3>
<ol>
<li>CPU上很慢</li>
<li>脸大小于 80×80  检测不出，因为模型在小脸训练的。所以要考虑你应用的具体场景脸的大小，当然也可以对小脸数据库再训练一下。</li>
<li>人脸框 bounding box 甚至比 HoG detector 还小。</li>
</ol>
<h2 id="5-精度比较"><a class="header-anchor" href="#5-精度比较">¶</a>5. 精度比较</h2>
<p>（Accuracy Comparison）</p>
<p>作者评估这四个模型使用的是 FDDB 数据库，其中评估OpenCV-DNN 脚本为 <a href="https://github.com/opencv/opencv/blob/master/modules/dnn/misc/face_detector_accuracy.py" target="_blank" rel="noopener">OpenCV face_detector_accuracy.py</a>.</p>
<p>作者发现奇怪的结果。Dlib 的结果比 Haar OpenCV还要低，然而实际从图片上效果比较好。下图是这四个方法的精度得分（ Precision scores）。</p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/face-detection-coco-comparison.jpg" alt></p>
<p>指标说明（Metric）：
AP_50 = Precision when overlap between Ground Truth and predicted bounding box is at least 50% (IoU = 50%)
AP_75 = Precision when overlap between Ground Truth and predicted bounding box is at least 75% (IoU = 75%)
AP_Small = Average Precision for small size faces (Average of IoU = 50% to 95%)
AP_medium = Average Precision for medium size faces (Average of IoU = 50% to 95%)
AP_Large = Average Precision for large size faces (Average of IoU = 50% to 95%)
mAP = Average precision across different IoU (Average of IoU = 50% to 95%)</p>
<p><strong>作者最近的发现评估过程对 Dlib 不够公平，科学。</strong></p>
<h3 id="5-1-评估过程出错了，分析的二个原因！"><a class="header-anchor" href="#5-1-评估过程出错了，分析的二个原因！">¶</a>5.1. 评估过程出错了，分析的二个原因！</h3>
<p>根据我们的分析，Dlib拿到低的精度的原因如下：
<strong>第一个主要原因是训练dlib的是标准数据库没有加标签（annotations）</strong>。数据库图片是由dlib作者自己切的，因此可以发现同样是人脸检测的框，同OpenCV 中的两个方法 OpenCV-Haar 或者 OpenCV-DNN 相比，dlib的方法会裁掉额头一部分或者脸颊一部分（forehead chin）。下面的图中可以看到。</p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-acc-result1-e1539872861105.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-acc-result2-e1539872827875.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-acc-result3-e1539872783684.jpg" alt></p>
<p>这个问题可以导致 在上个柱状图中 dlib 分数会低。AP_X 代表着  X% 预测框和真实框交叠的面积占合起来面积的比率。dlib 的 AP_75 的得分为0，尽管有在 AP_75 比 Haar 还高。这个就意味着：<strong>Dlib 模型可以预测更多的人脸比 Haar 特征，但是dlib的框的 AP_75 得分比较低</strong>。</p>
<p><strong>第二个原因是 dlib 不能检测小的人脸，进一步拉低了得分。</strong></p>
<p><strong>因此，比较 OpenCV 和 Dlib 精确性的一个相对合理的指标是 AP_50 （或者可以使用小于50%的指标，我们只是设阈值用来计算人头的个数）</strong> 以上分析大家使用 Dlib 的时候注意一下。</p>
<h2 id="6-速度比较"><a class="header-anchor" href="#6-速度比较">¶</a>6. 速度比较</h2>
<p>Speed Comparison</p>
<p>我们使用 300x300 图像做的对比实验。Dlib 的 MMOD 模型可以利用上GPU，但是OpenCV方法对 NVIDIA GPUs 支持还没有。所以我们评估对比这些方法在CPU上，但我们也给出 GPU 版本 MMOD 结果。</p>
<p>(这段话以后写论文的时候可以用到，保留:cat:) We used a 300×300 image for the comparison of the methods. The MMOD detector can be run on a GPU, but the support for NVIDIA GPUs in OpenCV is still not there. So, we evaluate the methods on CPU only and also report result for MMOD on GPU as well as CPU.</p>
<h3 id="硬件的配置"><a class="header-anchor" href="#硬件的配置">¶</a>硬件的配置</h3>
<p>Processor : Intel Core i7 6850K – 6 Core
RAM : 32 GB
GPU : NVIDIA GTX 1080 Ti with 11 GB RAM
OS : Linux 16.04 LTS
Programming Language : Python</p>
<p>我们跑了10次，每次对图片进行10000趟测试得总时间，然后对这10次取平均。下面的柱状图是结果。We run each method 10000 times on the given image and take 10 such iterations and average the time taken. Given below are the results.</p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/face-detection-speed-comparison.jpg" alt></p>
<p>从图中可以看到，对于 300x300 的图片，除了 MMOD。MMOD 在GPU上还是很快的，CPU上就是渣渣了。As you can see that for the image of this size, all the methods perform in real-time, except MMOD. MMOD detector is very fast on a GPU but is very slow on a CPU.</p>
<p>以上的结果在不同电脑硬软件环境下可能不一样。</p>
<h2 id="7-多种情况讨论"><a class="header-anchor" href="#7-多种情况讨论">¶</a>7. 多种情况讨论</h2>
<p>除了速度和精度外，我们在选择哪个模型来使用还有一些因素可以考虑。在这节中，将考虑这些情况下的选择。主要为人脸大小变化、非正脸、遮挡。</p>
<h3 id="7-1-人脸大小变化"><a class="header-anchor" href="#7-1-人脸大小变化">¶</a>7.1. 人脸大小变化</h3>
<p>Detection across scale</p>
<p>下面有一个例子视频，这位帅哥在做一个前后的健身动作，使得脸部区域变大变小。可以看到OpenCV DNN 检测出了所有的脸，而 Dlib 的方法只有在大于某个 size 的时候才被检测出来。</p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/face-detection-scale-comparison.gif" alt></p>
<p>我们测试后，脸大于 70×70 才能被 dlib检测出。正如在前面说到的，对小人脸检测是dlib方法的一个大的缺点。我们也可以将图片上采样，但这样的话速度的话相对于 OpenCV-DNN 就太慢了。</p>
<p>It can be seen that dlib based methods are able to detect faces of size upto ~(70×70) after which they fail to detect. As we discussed earlier, I think this is the major drawback of Dlib based methods. Since it is not possible to know the size of the face before-hand in most cases. We can get rid of this problem by upscaling the image, but then the speed advantage of dlib as compared to OpenCV-DNN goes away.</p>
<h3 id="7-2-非正脸"><a class="header-anchor" href="#7-2-非正脸">¶</a>7.2. 非正脸</h3>
<p>Non-frontal Face</p>
<p>对于非正脸的测试，我们选用了 looking towards right, left, up, down。为了对 dlib 公平，我们选择了face 大于 80×80 的图片。下面是一些例子。</p>
<p>Non-frontal can be looking towards right, left, up, down. Again, to be fair with dlib, we make sure the face size is more than 80×80. Given below are some examples.</p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result7.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result6.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result5.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result4.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result2.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-non-frontal-result1.jpg" alt></p>
<p>和预期的一样，OpenCV Haar 方法完全败了。Dlib HoG能检测出 left 或 right looking faces，但是精度不如那些DNN方法。</p>
<p>As expected, Haar based detector fails totally. HoG based detector does detect faces for left or right looking faces (since it was trained on them) but not as accurately as the DNN based detectors of OpenCV and Dlib.</p>
<h3 id="7-3-遮挡"><a class="header-anchor" href="#7-3-遮挡">¶</a>7.3. 遮挡</h3>
<p>Occlusion</p>
<p>接下来看一下遮挡的情况。Let us see how well the methods perform under occlusion.</p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-occlusion-result1.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-occlusion-result2.jpg" alt></p>
<p><img src="https://www.learnopencv.com/wp-content/uploads/2018/10/fd-occlusion-result3.jpg" alt></p>
<p>再一次看到，DNN方法比其他方法更优，OpenCV-DNN 比  Dlib-MMOD 还好一点。这是因为CNN 特征 比 HoG or Haar 更加鲁棒，稳定。</p>
<p>Again, the DNN methods outperform the other two, with OpenCV-DNN slightly better than Dlib-MMOD. This is mainly because the CNN features are much more robust than HoG or Haar features.</p>
<h2 id="8-总结"><a class="header-anchor" href="#8-总结">¶</a>8. 总结</h2>
<p>我们讨论了每个方法的优缺点。个人建议使用 OpenCV-DNN 和 Dlib-HoG 在应用和设备成本权衡中。以下我们的建议：</p>
<p>We had discussed the pros and cons of each method in the respective sections. I recommend to try both OpenCV-DNN and HoG methods for your application and decide accordingly. We share some tips to get started.</p>
<h3 id="8-1-大多数的情况"><a class="header-anchor" href="#8-1-大多数的情况">¶</a>8.1 大多数的情况</h3>
<p>General Case</p>
<p>在多数场景中，我们提前不知道图片大小，因此 选用 OpenCV – DNN 相当快也很精确，甚至对于小人脸也不错，各种人脸角度也可以。选用这个在大多情况下是最优的。</p>
<p>In most applications, we won’t know the size of the face in the image before-hand. Thus, it is better to use OpenCV – DNN method as it is pretty fast and very accurate, even for small sized faces. It also detects faces at various angles. We recommend to use OpenCV-DNN in most</p>
<h3 id="8-2-大小中等或大一点图片"><a class="header-anchor" href="#8-2-大小中等或大一点图片">¶</a>8.2 大小中等或大一点图片</h3>
<p>For medium to large image sizes</p>
<p>Dlib HoG 在 cpu上是最快的一个方法。但是它不能检测出 face size (&lt; 70x70) 的图片。所以你得清楚使用的场景，比如自拍的话就可以。如果能使用GPU的话 dlib-MMOD 是一个最好的选择，因为它支持GPU，跑得也比较快，也能适应人脸的角度变化。</p>
<p>Dlib HoG is the fastest method on CPU. But it does not detect small sized faces (&lt; 70x70). So, if you know that your application will not be dealing with very small sized faces ( for example a selfie app ), then HoG based Face detector is a better option. Also, If you can use a GPU, then MMOD face detector is the best option as it is very fast on GPU and also provides detection at various angles.</p>
<h3 id="8-3-高分辨率图像"><a class="header-anchor" href="#8-3-高分辨率图像">¶</a>8.3 高分辨率图像</h3>
<p>High resolution images</p>
<p>对于这些方法来说，高分辨图像都有点难度，计算时间比较长。可能采用的方法是resize图像 （ scale down the image），HoG / MMOD方法可能就识别不出了，但是可以使用 OpenCV-DNN 尝试一下。我认为也可以将图片分割开再识别呀，嘻嘻。</p>
<p>Since feeding high resolution images is not possible to these algorithms (for computation speed), HoG / MMOD detectors might fail when you scale down the image. On the other hand, OpenCV-DNN method can be used for these since it detects small faces.</p>
<p>有任何建议，欢迎在下面评论。
Have any other suggestions? Please mention in the comments and we’ll update the post with them!</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<p><a href="https://github.com/opencv/opencv/blob/master/modules/dnn/misc/face_detector_accuracy.py" target="_blank" rel="noopener">FDDB Comparison code</a>
<a href="http://blog.dlib.net/2016/10/easily-create-high-quality-object.html" target="_blank" rel="noopener">Dlib Blog</a>
<a href="http://dlib.net/cnn_face_detector.py.html" target="_blank" rel="noopener">dlib mmod python example</a>
<a href="http://dlib.net/dnn_mmod_face_detection_ex.cpp.html" target="_blank" rel="noopener">dlib mmod cpp example</a>
<a href="https://github.com/opencv/opencv/tree/master/samples/dnn/face_detector" target="_blank" rel="noopener">OpenCV DNN Face detector</a>
<a href="https://docs.opencv.org/3.4/d7/d8b/tutorial_py_face_detection.html" target="_blank" rel="noopener">Haar Based Face Detector</a></p>
<h2 id="TODOS"><a class="header-anchor" href="#TODOS">¶</a>TODOS</h2>
<p>文章作者是 <a href="https://www.learnopencv.com/author/vikas/" target="_blank" rel="noopener">VIKAS GUPTA</a></p>
<p>来，看看这个是站长大佬的图片，是不是很熟悉？膜拜一哈。</p>
<p><img src="https://secure.gravatar.com/avatar/708995cd13fb5756f6bc418aecb23b78?s=250&amp;d=mm&amp;r=g" alt="blog_author"></p>
<p>我订阅后文章后，作者发的邮件内容，并没有给文章页的代码。</p>
<ul>
<li><a href="https://www.learnopencv.com/wp-content/uploads/2015/05/Computer-Vision-Resources.pdf" target="_blank" rel="noopener">给的Computer-Vision-Resources.pdf</a></li>
<li><a href="https://github.com/spmallick/dlib" target="_blank" rel="noopener">作者的Dlib fork</a></li>
</ul>
<p><strong>重要资源</strong></p>
<ul>
<li>
<p>作者博客 <a href="https://www.learnopencv.com/" target="_blank" rel="noopener">link</a></p>
</li>
<li>
<p>作者的所有代码拿走不谢 <a href="https://github.com/spmallick/learnopencv" target="_blank" rel="noopener">link</a></p>
</li>
<li>
<p>[x] 翻译</p>
</li>
<li>
<p>[x] 代码运行</p>
</li>
<li>
<p>[ ] 根据该作者的博客继续翻译，学习，向大佬致敬。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>转载</category>
        <category>cv</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
        <tag>Face Detection</tag>
        <tag>Dlib</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」GRE隧道测试</title>
    <url>/public/2022/05/05/linux/gre_test/</url>
    <content><![CDATA[<blockquote>
<p>本文由 <a href="http://ksria.com/simpread/" target="_blank" rel="noopener">简悦 SimpRead</a> 转码， 原文地址 <a href="https://juejin.cn/post/6988645230987706398" target="_blank" rel="noopener">juejin.cn</a></p>
</blockquote>
<p><img src="/public/2022/05/05/linux/gre_test/e31bac5bcb1347a59142486adaf94e30.jpg" alt></p>
<h2 id="0-前言"><a class="header-anchor" href="#0-前言">¶</a>0. 前言</h2>
<p>在学习 ipsec 过程中，一般都会涉及到 ipsec 的局限性：ipsec 协议是一种点对点协议，不支持组播，也不能保护组播、广播报文。因此 ipsec 协议无法用于音视频会议等场合，此时通常的解决办法是采用 <strong>GRE Over IPSec</strong> .</p>
<p>给出的解释是：GRE 协议可以封装组播、广播报文，但是无法对业务内容进行加密；而 ipsec 可以对报文进行加密，但是无法封装组播和广播报文。因此将两种协议结合，因而 GRE over IPSec 协议应运而生。 但是我找了很多资料 (其实没有多少)，都没有找到为什么 GRE 协议支持封装组播和广播报文，而 ipsec 不行；他们作为点对点协议，为什么  GRE 可以而 IPsec  不行呢？因为没有找到答案，所以不能证实自己的想法正确与否，于是通过搭建 GRE 隧道环境，学习 Linux 内核中 GRE 隧道的操作配置原则，希望能从中得到些许启发。</p>
<p>搭建 GRE 隧道环境实际上是很简单的，因为 Linux 内核已经支持了 GRE 隧道，因此直接在虚拟机 (ubuntu 和 CentOS) 里进行简单的配置即可完成操作。</p>
<a id="more"></a>
<p><img src="/public/2022/05/05/linux/gre_test/db260d2dc98445f9988f1c768ca3e744.jpg" alt></p>
<h2 id="1-Linux-内核支持的隧道类型"><a class="header-anchor" href="#1-Linux-内核支持的隧道类型">¶</a>1. Linux 内核支持的隧道类型</h2>
<p>目前 Linux 内核已经支持多种隧道类型，包括：IPIP 隧道，GRE 隧道，... 。其余这几个我也没见过。当然除了这几种，还有 ipsec 协议，l2tp 协议，可以的是我目前都还没有用过，实在是暴殄天物，罪过罪过</p>
<p><img src="/public/2022/05/05/linux/gre_test/412f1154b6c64d74acd7b8cb31f713a5.jpg" alt></p>
<p><img src="/public/2022/05/05/linux/gre_test/e080bb892ca045a3b92f83ace7642a68.jpg" alt></p>
<p>下面通过搭建两组拓扑环境，来学习 GRE 隧道的基本规则，然后在此基础上分析下 GRE 和 IPSEC 在组播和广播报文封装的表现出不同行为的可能原因 (另写一遍文章喽)。</p>
<h2 id="2-GRE-隧道跨-公-网连接相同子网地址主机"><a class="header-anchor" href="#2-GRE-隧道跨-公-网连接相同子网地址主机">¶</a>2. GRE 隧道跨 (公) 网连接相同子网地址主机</h2>
<h3 id="2-1-拓扑环境"><a class="header-anchor" href="#2-1-拓扑环境">¶</a>2.1 拓扑环境</h3>
<p><img src="/public/2022/05/05/linux/gre_test/4759759198334a2ebc2c296e548026b0.jpg" alt></p>
<p>家里设备有限，只有一台电脑，还是通过无线网卡来上网的，因此拓扑环境比较寒酸，其实这些并不重要，只需明白我的两台虚拟机 Ubantu 和 CentOS 通过桥接的方式连在一起，网络上可以通讯即可。</p>
<p>现在，我准备将两个地址分别为 10.1.2.1/24、10.1.2.2/24 的两台主机 (假的，只是个 IP 地址而已) 通过 GRE 隧道连接起来进行通讯。原则上这两个地址属于不同的子网中(Ubantu 中的子网和 CentOS 中的子网，只是这两个子网的网段相同仅此而已)，无法直接通讯。</p>
<h3 id="2-1-ubuntu-配置"><a class="header-anchor" href="#2-1-ubuntu-配置">¶</a>2.1 ubuntu 配置</h3>
<p>首先，我确定了下该虚拟机中是否存在 gre 相关的接口，结果当然是没有了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/home/toney<span class="comment"># ifconfig -a</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 2409:8a00:18e9:810:141:383c:ac6f:8b11  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 2409:8a00:18e9:810:f8dd:500e:b1a:463b  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 fe80::8e84:574c:7a8b:440a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:fb:db:ad  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 3581  bytes 1030105 (1.0 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1177  bytes 114532 (114.5 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 160  bytes 12920 (12.9 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 160  bytes 12920 (12.9 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="2-1-1-添加-GRE-隧道"><a class="header-anchor" href="#2-1-1-添加-GRE-隧道">¶</a>2.1.1 添加 GRE 隧道</h4>
<blockquote>
<p>ip tunnel add Tunnel-1 mode gre remote 192.168.1.13 local 192.168.1.10</p>
</blockquote>
<p>添加 GRE 隧道时, 需要指定隧道的名称，我这里叫做 Tunnel-1; 因为要搭建 GRE 类型隧道，因此 mode 为 gre。 而 GRE 隧道的地址为 192.168.1.13&lt;========&gt;192.168.1.10。</p>
<p>由于是第一次执行此命令，底层实际上安装上了 gre 隧道相关的驱动。用户只有在此基础上才能配置 GRE 隧道，不过，无需担心，内核自动完成。</p>
<p>如果在添加隧道时不指定 remote 和 local 地址，也是可以的，它实际上是只是安装 gre 隧道相关驱动。下面是添加隧道时没有指定 remote 和 local 地址时的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubantu:/home/toney<span class="comment"># ip tunnel add Tunnel-1</span></span><br><span class="line">cannot determine tunnel mode (ipip, gre, vti or sit)</span><br><span class="line">root@ubantu:/home/toney<span class="comment"># ifconfig -a</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 2409:8a00:18e9:810:141:383c:ac6f:8b11  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 2409:8a00:18e9:810:200d:99e2:4f3d:cb6f  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 fe80::8e84:574c:7a8b:440a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:fb:db:ad  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 5038  bytes 5896155 (5.8 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2744  bytes 309264 (309.2 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 164  bytes 15044 (15.0 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 164  bytes 15044 (15.0 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">root@ubantu:/home/toney<span class="comment"># ip tunnel add Tunnel-1 mode gre</span></span><br><span class="line">add tunnel <span class="string">"gre0"</span> failed: File exists</span><br><span class="line">root@ubantu:/home/toney<span class="comment"># ifconfig -a</span></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 2409:8a00:18e9:810:141:383c:ac6f:8b11  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 2409:8a00:18e9:810:200d:99e2:4f3d:cb6f  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 fe80::8e84:574c:7a8b:440a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:fb:db:ad  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 5097  bytes 5900501 (5.9 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2766  bytes 311496 (311.4 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">erspan0: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1450</span><br><span class="line">        ether 00:00:00:00:00:00  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">gre0: flags=128&lt;NOARP&gt;  mtu 1452</span><br><span class="line">        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 1000  (UNSPEC)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">gretap0: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1462</span><br><span class="line">        ether 00:00:00:00:00:00  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 164  bytes 15044 (15.0 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 164  bytes 15044 (15.0 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">root@ubantu:/home/toney<span class="comment">#</span></span><br><span class="line">root@ubantu:/home/toney<span class="comment"># lsmod | grep gre</span></span><br><span class="line">ip_gre                 28672  0</span><br><span class="line">ip_tunnel              24576  1 ip_gre</span><br><span class="line">gre                    16384  1 ip_gre</span><br><span class="line">root@ubantu:/home/toney<span class="comment">#</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>如果输入完整的命令，则会成功添加上 Tunnel-1 隧道：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubantu:/home/toney<span class="comment"># ifconfig -a</span></span><br><span class="line">Tunnel-1: flags=144&lt;POINTOPOINT,NOARP&gt;  mtu 1476</span><br><span class="line">        unspec C0-A8-01-0A-00-00-00-87-00-00-00-00-00-00-00-00  txqueuelen 1000  (UNSPEC)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.10  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 2409:8a00:18e9:810:141:383c:ac6f:8b11  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 2409:8a00:18e9:810:200d:99e2:4f3d:cb6f  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class="line">        inet6 fe80::8e84:574c:7a8b:440a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:fb:db:ad  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 5745  bytes 5947674 (5.9 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 2965  bytes 329731 (329.7 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">erspan0: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1450</span><br><span class="line">        ether 00:00:00:00:00:00  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">gre0: flags=128&lt;NOARP&gt;  mtu 1452</span><br><span class="line">        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 1000  (UNSPEC)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">gretap0: flags=4098&lt;BROADCAST,MULTICAST&gt;  mtu 1462</span><br><span class="line">        ether 00:00:00:00:00:00  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 169  bytes 15509 (15.5 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 169  bytes 15509 (15.5 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-配置-GRE-隧道接口-IP"><a class="header-anchor" href="#2-1-2-配置-GRE-隧道接口-IP">¶</a>2.1.2 配置 GRE 隧道接口 IP</h4>
<blockquote>
<p>ip addr add 10.1.2.1/24 dev Tunnel-1</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>ifconfig Tunnel-1 10.1.2.1/24</p>
</blockquote>
<p>从添加隧道结果来看，Tunnel-1 接口虽然已经成功添加，但是处于 down 状态，此外也没有 IP 地址。 不，等等，那我们在添加隧道时指定的 remote 和 local 是什么呢？</p>
<p><strong>它是经过 <strong><strong>GRE</strong></strong> 隧道封装后的报文 <strong><strong>IP</strong></strong> 地址，但是针对什么报文进行封装，目前我们尚未配置</strong>。</p>
<p>配置此接口 IP 的目的是：为了确定哪些报文需要进入 GRE 接口，然后进行隧道封装。为什么需要添加 IP 呢？ 因为我们是通过路由将报文引入到 Tunnel-1 接口的, 如果不填 IP，那么我路由的下一条该写成什么呢， 是吧。</p>
<p><img src="/public/2022/05/05/linux/gre_test/772109c097cd48cab17c50d4dad64b10.jpg" alt></p>
<h4 id="2-1-3-激活-GRE-隧道接口-IP"><a class="header-anchor" href="#2-1-3-激活-GRE-隧道接口-IP">¶</a>2.1.3 激活 GRE 隧道接口 IP</h4>
<blockquote>
<p>ifconfig Tunnel-1 up</p>
</blockquote>
<p>或者</p>
<blockquote>
<p>ip link set Tunnel-1 up</p>
</blockquote>
<p>至于配置接口 IP 和是否 up 接口，没有什么先后顺序，把他们当做不同的 eth 接口处理即可。</p>
<p><img src="/public/2022/05/05/linux/gre_test/2410e66154a84a70b95d16a5df32e360.jpg" alt></p>
<h3 id="2-2-CentOS-配置"><a class="header-anchor" href="#2-2-CentOS-配置">¶</a>2.2 CentOS 配置</h3>
<p>CentOS 虚拟机的配置和 Ubantu 的配置完全相同，安照此步骤操作即可。</p>
<blockquote>
<p>ip tunnel add Tunnel-1 mode gre local 192.168.1.13 remote 192.168.1.10<br>
ip link set Tunnel-1 up<br>
ip addr add 10.1.2.2/24 dev Tunnel-1</p>
</blockquote>
<p>查看配置结果 r 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@toney toney]#</span><br><span class="line">[root@toney toney]#</span><br><span class="line">[root@toney toney]# ifconfig</span><br><span class="line">Tunnel-1  Link encap:UNSPEC  HWaddr C0-A8-01-0D-FF-FF-90-6D-00-00-00-00-00-00-00-00</span><br><span class="line">          inet addr:10.1.2.2  P-t-P:10.1.2.2  Mask:255.255.255.0</span><br><span class="line">          UP POINTOPOINT RUNNING NOARP  MTU:1476  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:0 (0.0 b)  TX bytes:0 (0.0 b)</span><br><span class="line"></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:0C:29:DA:34:3C</span><br><span class="line">          inet addr:192.168.1.13  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: 2409:8a00:18e9:810:20c:29ff:feda:343c/64 Scope:Global</span><br><span class="line">          inet6 addr: fe80::20c:29ff:feda:343c/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:3571 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:781 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:236685 (231.1 KiB)  TX bytes:71021 (69.3 KiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:4 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:4 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:240 (240.0 b)  TX bytes:240 (240.0 b)</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>路由表信息如下：</p>
<p><img src="/public/2022/05/05/linux/gre_test/f70bfbe84af74c21bab5b21a5bea3821.jpg" alt></p>
<h3 id="2-3-ping-包测试通讯链路"><a class="header-anchor" href="#2-3-ping-包测试通讯链路">¶</a>2.3 ping 包测试通讯链路</h3>
<p>这里有一点需要注意：Linux 系统可能开了 iptables 过滤功能，因此在 ping 时出现了类似 &quot;ICMP host 192.168.1.13 unreachable - admin prohibited, length 116&quot; 信息，详情如下：</p>
<p><img src="/public/2022/05/05/linux/gre_test/26f4422a5f9d4772ac9a354db2dd9847.jpg" alt></p>
<p>百度一下, 在两台虚拟机上都执行如下操作即可：</p>
<blockquote>
<p>iptables -F</p>
</blockquote>
<p>然后在 ping 包测试，数据可通：</p>
<p><img src="/public/2022/05/05/linux/gre_test/2df9a98e03d54319ad3b00704fc31a32.jpg" alt></p>
<p><img src="/public/2022/05/05/linux/gre_test/b01f9527ea6842b68acbf612ec34c084.jpg" alt></p>
<p>至此，基本 GRE 隧道环境搭建成功。</p>
<h2 id="3-GRE-隧道跨-公-网连接不同子网地址主机"><a class="header-anchor" href="#3-GRE-隧道跨-公-网连接不同子网地址主机">¶</a>3. GRE 隧道跨 (公) 网连接不同子网地址主机</h2>
<h3 id="3-1-拓扑环境"><a class="header-anchor" href="#3-1-拓扑环境">¶</a>3.1 拓扑环境</h3>
<p><img src="/public/2022/05/05/linux/gre_test/8752f3648dbc4dc4bd9036f00348ec9c.jpg" alt></p>
<p><strong>目的：</strong> 通过 GRE 隧道将 20.1.2.1/24、20.1.3.2/24 两个子网连接起来进行通讯。</p>
<h3 id="3-2-Ubantu-配置"><a class="header-anchor" href="#3-2-Ubantu-配置">¶</a>3.2 Ubantu 配置</h3>
<h4 id="3-2-1-配置-ens33-子接口-IP"><a class="header-anchor" href="#3-2-1-配置-ens33-子接口-IP">¶</a>3.2.1 配置 ens33 子接口 IP</h4>
<blockquote>
<p>ifconfig eth0:1 192.168.100.1/24</p>
</blockquote>
<p>查看接口配置如下：</p>
<p><img src="/public/2022/05/05/linux/gre_test/773d0b1700254e8ba9f847fdc2e79fd4.jpg" alt></p>
<h4 id="3-2-2-添加另一个-GRE-隧道接口并-up"><a class="header-anchor" href="#3-2-2-添加另一个-GRE-隧道接口并-up">¶</a>3.2.2 添加另一个 GRE 隧道接口并 up</h4>
<blockquote>
<p>ip tunnel add Tunnel-2 mode gre local 192.168.100.1 remote 192.168.100.2</p>
<p>ifconfig Tunnel-2 up</p>
</blockquote>
<h4 id="3-2-3-配置隧道接口-IP"><a class="header-anchor" href="#3-2-3-配置隧道接口-IP">¶</a>3.2.3 配置隧道接口 IP</h4>
<blockquote>
<p>ifconfig Tunnel-2 20.1.2.1/24</p>
</blockquote>
<p><img src="/public/2022/05/05/linux/gre_test/fbefdbdcba514312960176a103139de9.jpg" alt></p>
<h4 id="3-2-4-添加对端子网路由表"><a class="header-anchor" href="#3-2-4-添加对端子网路由表">¶</a>3.2.4 添加对端子网路由表</h4>
<p>由于本端没有对端子网 20.1.3.0/24 的路由，因此需要添加路由，将该网段报文引入到 Tunnel-2 接口，这样便可以通过 GRE 隧道进行封装。</p>
<blockquote>
<p>route add -net 20.1.3.0/24 gw 20.1.2.1</p>
</blockquote>
<p><img src="/public/2022/05/05/linux/gre_test/199432ae8e9e40e8b993ec0a0bca9016.jpg" alt></p>
<h3 id="3-3-CentOS-配置"><a class="header-anchor" href="#3-3-CentOS-配置">¶</a>3.3 CentOS 配置</h3>
<h4 id="3-3-1-配置-ens33-子接口-IP"><a class="header-anchor" href="#3-3-1-配置-ens33-子接口-IP">¶</a>3.3.1 配置 ens33 子接口 IP</h4>
<blockquote>
<p>ifconfig ens33:1 192.168.100.2/24</p>
</blockquote>
<p><img src="/public/2022/05/05/linux/gre_test/e9e2f1e4871f4c42ade68774b4bb4e75.jpg" alt></p>
<h4 id="3-3-2-添加另一个-GRE-隧道接口并-up"><a class="header-anchor" href="#3-3-2-添加另一个-GRE-隧道接口并-up">¶</a>3.3.2 添加另一个 GRE 隧道接口并 up</h4>
<blockquote>
<p>ip tunnel add Tunnel-2 mode gre remote 192.168.100.1 local 192.168.100.2</p>
<p>ifconfig Tunnel-2 up</p>
</blockquote>
<p>结果如下：</p>
<p><img src="/public/2022/05/05/linux/gre_test/8618b40c1afb497dbc85234fd0c58ad8.jpg" alt></p>
<h4 id="3-3-3-配置隧道接口-IP"><a class="header-anchor" href="#3-3-3-配置隧道接口-IP">¶</a>3.3.3 配置隧道接口 IP</h4>
<blockquote>
<p>ifconfig Tunnel-2 20.1.3.1/24</p>
</blockquote>
<h4 id="3-3-4-添加对端子网路由表"><a class="header-anchor" href="#3-3-4-添加对端子网路由表">¶</a>3.3.4 添加对端子网路由表</h4>
<p>由于本端没有对端子网 20.1.2.0/24 的路由，因此需要添加路由，将该网段报文引入到 Tunnel-2 接口，这样便可以通过 GRE 隧道进行封装。</p>
<blockquote>
<p>route add -net 20.1.2.0/24 gw 20.1.3.1</p>
</blockquote>
<p><img src="/public/2022/05/05/linux/gre_test/da52fb97c1044858bd28e645df512622.jpg" alt></p>
<h3 id="3-4-ping-测试链路连通性"><a class="header-anchor" href="#3-4-ping-测试链路连通性">¶</a>3.4 ping 测试链路连通性</h3>
<p><img src="/public/2022/05/05/linux/gre_test/1a28e720a97746f3a801a824a9ff95fd.jpg" alt></p>
<p><img src="/public/2022/05/05/linux/gre_test/5d3739151b0843c98c1c7352e91008c3.jpg" alt></p>
<p>​</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>隧道技术</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」Linux内核数据包bridge上转发流程</title>
    <url>/public/2022/07/06/linux/linux_bridge_forward/</url>
    <content><![CDATA[<blockquote>
<p>原文地址 <a href="https://blog.csdn.net/hhhhhyyyyy8/article/details/102133863" target="_blank" rel="noopener">blog.csdn.net</a>
@hhhhhyyyyy8 @4.15.1</p>
</blockquote>
<h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2>
<p>linux 内核源代码变动怎么这么大，handle_bridge 函数居然没有了，本来接着准备以 3.9.1 分析的，但发现和后面的又变了，还是以 4.15.1 现在电脑上用的版本分析吧。</p>
<p><strong>linux kernel：4.15.1</strong></p>
<p>best of best [<a href="url">link</a>](<a href="https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg" target="_blank" rel="noopener">https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg</a>)</p>
<p><img src="/public/2022/07/06/linux/linux_bridge_forward/Netfilter-packet-flow5.svg" alt></p>
<p>先看三张图片</p>
<p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76153027" target="_blank" rel="noopener">IMG skb桥转发蓝图</a>
<img src="/public/2022/07/06/linux/linux_bridge_forward/20191005153149853.jpg" alt></p>
<p><a href="https://blog.csdn.net/u012247418/article/details/90137663" target="_blank" rel="noopener">IMG linux TCP/IP L2层数据包接收流程</a>
<img src="/public/2022/07/06/linux/linux_bridge_forward/t_70.png" alt></p>
<p><a href="https://www.cnblogs.com/xuanxuanBOSS/p/11424290.html" target="_blank" rel="noopener">IMG 浅析ebtables的概念和一些基本应用</a>
<img src="/public/2022/07/06/linux/linux_bridge_forward/netfilter.png" alt></p>
<blockquote>
<p>tips: linux 内核版本不一样，流程函数会发生细微改变。</p>
</blockquote>
<a id="more"></a>
<h2 id="1-br-handle-frame"><a class="header-anchor" href="#1-br-handle-frame">¶</a>1. br_handle_frame()</h2>
<p>作用：</p>
<ol>
<li>
<p>对于需要转发的报文，调用 <code>NF_BR_PRE_ROUTING</code> 处钩子函数，结束后，进入 <code>br_handle_frame_finish()</code> 函数；</p>
</li>
<li>
<p>对于 STP 报文，调用 <code>NF_BR_LOCAL_IN</code> 处钩子函数，结束后，进入 <code>br_handle_local_finish()</code> 函数，在 <code>br_handle_local_finish()</code> 函数中会调用 <code>br_pass_frame_up()</code> 函数。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return NULL if skb is handled</span></span><br><span class="line"><span class="comment"> * note: already called with rcu_read_lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">rx_handler_result_t</span> <span class="title">br_handle_frame</span><span class="params">(struct sk_buff **pskb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> = *<span class="title">pskb</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line">	<span class="keyword">br_should_route_hook_t</span> *rhook;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*如果是环回地址，直接返回RX_HANDLER_PASS*/</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(skb-&gt;pkt_type == PACKET_LOOPBACK))</span><br><span class="line">		<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*判断源MAC地址是否是有效的地址，不是直接丢弃，源MAC地址不能是多播地址和全0地址*/</span></span><br><span class="line">	<span class="keyword">if</span> (!is_valid_ether_addr(eth_hdr(skb)-&gt;h_source))</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	<span class="comment">/*判断是否是共享数据包，若是则clone该数据包；若clone时分配内存出错，返回NULL*/</span></span><br><span class="line">	skb = skb_share_check(skb, GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*获取dev对应的网桥端口*/</span></span><br><span class="line">	p = br_port_get_rcu(skb-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; BR_VLAN_TUNNEL) &#123;</span><br><span class="line">		<span class="keyword">if</span> (br_handle_ingress_vlan_tunnel(skb, p,</span><br><span class="line">						  nbp_vlan_group_rcu(p)))</span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*特殊MAC地址处理*/</span></span><br><span class="line">	<span class="comment">//如果目的mac地址是本地链路地址link local reserved addr (01:80:c2:00:00:0X) STP报文</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(is_link_local_ether_addr(dest))) &#123;</span><br><span class="line">		u16 fwd_mask = p-&gt;br-&gt;group_fwd_mask_required;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * See IEEE 802.1D Table 7-10 Reserved addresses</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Assignment		 		Value</span></span><br><span class="line"><span class="comment">		 * Bridge Group Address		01-80-C2-00-00-00</span></span><br><span class="line"><span class="comment">		 * (MAC Control) 802.3		01-80-C2-00-00-01</span></span><br><span class="line"><span class="comment">		 * (Link Aggregation) 802.3	01-80-C2-00-00-02</span></span><br><span class="line"><span class="comment">		 * 802.1X PAE address		01-80-C2-00-00-03</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 802.1AB LLDP 		01-80-C2-00-00-0E</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Others reserved for future standardization</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		fwd_mask |= p-&gt;group_fwd_mask;</span><br><span class="line">		<span class="keyword">switch</span> (dest[<span class="number">5</span>]) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x00</span>:	<span class="comment">/* Bridge Group Address */</span></span><br><span class="line">			<span class="comment">/* If STP is turned off,</span></span><br><span class="line"><span class="comment">			   then must forward to keep loop detection */</span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;br-&gt;stp_enabled == BR_NO_STP ||</span><br><span class="line">			    fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line">				<span class="keyword">goto</span> forward;</span><br><span class="line">			*pskb = skb;</span><br><span class="line">			__br_handle_local_finish(skb);</span><br><span class="line">			<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x01</span>:	<span class="comment">/* IEEE MAC (Pause) */</span></span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x0E</span>:	<span class="comment">/* 802.1AB LLDP */</span></span><br><span class="line">			fwd_mask |= p-&gt;br-&gt;group_fwd_mask;</span><br><span class="line">			<span class="keyword">if</span> (fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line">				<span class="keyword">goto</span> forward;</span><br><span class="line">			*pskb = skb;</span><br><span class="line">			__br_handle_local_finish(skb);</span><br><span class="line">			<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">/* Allow selective forwarding for most other protocols */</span></span><br><span class="line">			fwd_mask |= p-&gt;br-&gt;group_fwd_mask;</span><br><span class="line">			<span class="keyword">if</span> (fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line">				<span class="keyword">goto</span> forward;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/* Deliver packet to local host only */</span></span><br><span class="line">		<span class="comment">/*调用NF_BR_LOCAL_IN处钩子函数，结束后，进入br_handle_local_finish函数*/</span></span><br><span class="line">		NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, dev_net(skb-&gt;dev),</span><br><span class="line">			<span class="literal">NULL</span>, skb, skb-&gt;dev, <span class="literal">NULL</span>, br_handle_local_finish);</span><br><span class="line">		<span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">forward:</span><br><span class="line">	<span class="keyword">switch</span> (p-&gt;state) &#123;</span><br><span class="line">	<span class="comment">//网桥端口处于转发状态</span></span><br><span class="line">	<span class="keyword">case</span> BR_STATE_FORWARDING:</span><br><span class="line">		rhook = rcu_dereference(br_should_route_hook);</span><br><span class="line">		<span class="keyword">if</span> (rhook) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((*rhook)(skb)) &#123;</span><br><span class="line">				*pskb = skb;</span><br><span class="line">				<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line">			&#125;</span><br><span class="line">			dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* fall through */</span></span><br><span class="line">	<span class="comment">/*网桥端口处于学习状态，处于转发状态也会执行下面的代码，因为上面的case没有break。*/</span></span><br><span class="line">	<span class="keyword">case</span> BR_STATE_LEARNING:</span><br><span class="line">	<span class="comment">/*数据包目的MAC为网桥的Mac，发往本地的数据包*/</span></span><br><span class="line">		<span class="keyword">if</span> (ether_addr_equal(p-&gt;br-&gt;dev-&gt;dev_addr, dest))</span><br><span class="line">			skb-&gt;pkt_type = PACKET_HOST;</span><br><span class="line">		<span class="comment">/*调用NF_BR_PRE_ROUTING处钩子函数，结束后进入br_handle_frame_finish函数*/</span></span><br><span class="line">		NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,</span><br><span class="line">			dev_net(skb-&gt;dev), <span class="literal">NULL</span>, skb, skb-&gt;dev, <span class="literal">NULL</span>,</span><br><span class="line">			br_handle_frame_finish);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">drop:</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关函数</p>
<h3 id="rx-handler-result-t-枚举类型"><a class="header-anchor" href="#rx-handler-result-t-枚举类型">¶</a><code>rx_handler_result_t</code> 枚举类型</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> rx_handler_result &#123;</span><br><span class="line">	RX_HANDLER_CONSUMED,</span><br><span class="line">	RX_HANDLER_ANOTHER,</span><br><span class="line">	RX_HANDLER_EXACT,</span><br><span class="line">	RX_HANDLER_PASS,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> rx_handler_result <span class="keyword">rx_handler_result_t</span>;</span><br></pre></td></tr></table></figure>
<h3 id="is-valid-ether-addr"><a class="header-anchor" href="#is-valid-ether-addr">¶</a><code>is_valid_ether_addr()</code></h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * is_valid_ether_addr - Determine if the given Ethernet address is valid</span></span><br><span class="line"><span class="comment"> * @addr: Pointer to a six-byte array containing the Ethernet address</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not</span></span><br><span class="line"><span class="comment"> * a multicast address, and is not FF:FF:FF:FF:FF:FF.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return true if the address is valid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Please note: addr must be aligned to u16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_valid_ether_addr</span><span class="params">(<span class="keyword">const</span> u8 *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to</span></span><br><span class="line"><span class="comment">	 * explicitly check for it here. */</span></span><br><span class="line">	<span class="keyword">return</span> !is_multicast_ether_addr(addr) &amp;&amp; !is_zero_ether_addr(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="br-handle-local-finish"><a class="header-anchor" href="#br-handle-local-finish">¶</a><code>br_handle_local_finish()</code></h3>
<p><code>br_handle_local_finish()</code> 函数中调用 <code>br_pass_fame_up()</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/* note: already called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">br_handle_local_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span> = <span class="title">br_port_get_rcu</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line"> </span><br><span class="line">	__br_handle_local_finish(skb);</span><br><span class="line"> </span><br><span class="line">	BR_INPUT_SKB_CB(skb)-&gt;brdev = p-&gt;br-&gt;dev;</span><br><span class="line">	br_pass_frame_up(skb);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-br-handle-frame-finish"><a class="header-anchor" href="#2-br-handle-frame-finish">¶</a>2. br_handle_frame_finish()</h2>
<p>作用：</p>
<p>网桥设备是否处于混杂模式，如果是，则会发一份到本地进行处理</p>
<p>如果是广播包，则会进行广播洪泛，并会发一份到本地处理</p>
<p>如果是组播包，则根据组播表进行组播转发，并发一份数数包到本地处理</p>
<p>如果是单播包，发往本地的单播包则送到本地处理，在 fdb 表中可以找到转发表项的单播包则进行转发，未知单播包在广播域内进行洪泛</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="comment">/* note: already called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_handle_frame_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span> = <span class="title">br_port_get_rcu</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line">	<span class="keyword">enum</span> br_pkt_type pkt_type = BR_PKT_UNICAST;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_fdb_entry</span> *<span class="title">dst</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_mdb_entry</span> *<span class="title">mdst</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> local_rcv, mcast_hit = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *dest;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span>;</span></span><br><span class="line">	u16 vid = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*如果网桥端口不存在或者网桥端口状态为BR_STATE_DISABLED，则丢弃*/</span></span><br><span class="line">	<span class="keyword">if</span> (!p || p-&gt;state == BR_STATE_DISABLED)</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	<span class="comment">/*判断是否允许进入桥内，如果没有开启VLAN则所有数据包都可以进入，</span></span><br><span class="line"><span class="comment">	如果开启了VLAN,则根据VLAN相应的规则，从桥上进行数据包转发。*/</span></span><br><span class="line">	<span class="keyword">if</span> (!br_allowed_ingress(p-&gt;br, nbp_vlan_group_rcu(p), skb, &amp;vid))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line">	nbp_switchdev_frame_mark(p, skb);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* insert into forwarding database after filtering to avoid spoofing */</span></span><br><span class="line">	br = p-&gt;br;</span><br><span class="line">	<span class="comment">/*如果网桥端口标志有BR_LEARNING,则更新fdb表。</span></span><br><span class="line"><span class="comment">    一般新建网桥端口p-&gt;flags=BR_LEARNING| BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD*/</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; BR_LEARNING)</span><br><span class="line">		br_fdb_update(br, p, eth_hdr(skb)-&gt;h_source, vid, <span class="literal">false</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发往本地数据包标记，!!的作用是转换为bool值</span></span><br><span class="line">	local_rcv = !!(br-&gt;dev-&gt;flags &amp; IFF_PROMISC);</span><br><span class="line">	dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line">	<span class="comment">/*目的地址为多播地址*/</span></span><br><span class="line">	<span class="keyword">if</span> (is_multicast_ether_addr(dest)) &#123;</span><br><span class="line">		<span class="comment">/* by definition the broadcast is also a multicast address */</span></span><br><span class="line">		<span class="comment">/*如果目的地址是广播地址，将数据包也发往本地一份*/</span></span><br><span class="line">		<span class="keyword">if</span> (is_broadcast_ether_addr(dest)) &#123;</span><br><span class="line">			pkt_type = BR_PKT_BROADCAST;</span><br><span class="line">			local_rcv = <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pkt_type = BR_PKT_MULTICAST;</span><br><span class="line">			<span class="comment">//igmp snooping留给网桥子系统的外部接口函数，</span></span><br><span class="line">			<span class="comment">//当网桥接收了igmp数据包后就会调用该函数进行后续处理</span></span><br><span class="line">			<span class="keyword">if</span> (br_multicast_rcv(br, p, skb, vid))</span><br><span class="line">				<span class="keyword">goto</span> drop;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果网桥端口状态此时还是BR_STATE_LEARNING,则丢弃。</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;state == BR_STATE_LEARNING)</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	<span class="comment">//将网桥所属的net_device放入skb的私有数据中（struct br_input_skb_cb）</span></span><br><span class="line">	BR_INPUT_SKB_CB(skb)-&gt;brdev = br-&gt;dev;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_INET) &amp;&amp;</span><br><span class="line">	    (skb-&gt;protocol == htons(ETH_P_ARP) ||</span><br><span class="line">	     skb-&gt;protocol == htons(ETH_P_RARP))) &#123;</span><br><span class="line">		br_do_proxy_suppress_arp(skb, br, vid, p);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ENABLED(CONFIG_IPV6) &amp;&amp;</span><br><span class="line">		   skb-&gt;protocol == htons(ETH_P_IPV6) &amp;&amp;</span><br><span class="line">		   br-&gt;neigh_suppress_enabled &amp;&amp;</span><br><span class="line">		   pskb_may_pull(skb, <span class="keyword">sizeof</span>(struct ipv6hdr) +</span><br><span class="line">				 <span class="keyword">sizeof</span>(struct nd_msg)) &amp;&amp;</span><br><span class="line">		   ipv6_hdr(skb)-&gt;nexthdr == IPPROTO_ICMPV6) &#123;</span><br><span class="line">			struct nd_msg *msg, _msg;</span><br><span class="line"> </span><br><span class="line">			msg = br_is_nd_neigh_msg(skb, &amp;_msg);</span><br><span class="line">			<span class="keyword">if</span> (msg)</span><br><span class="line">				br_do_suppress_nd(skb, br, vid, p, msg);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">switch</span> (pkt_type) &#123;</span><br><span class="line">	<span class="comment">//组播包</span></span><br><span class="line">	<span class="keyword">case</span> BR_PKT_MULTICAST:</span><br><span class="line">		<span class="comment">//获取组播转发项，设置local_rcv为true，组播包也要发往本地一份。</span></span><br><span class="line">		mdst = br_mdb_get(br, skb, vid);</span><br><span class="line">		<span class="keyword">if</span> ((mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) &amp;&amp;</span><br><span class="line">		    br_multicast_querier_exists(br, eth_hdr(skb))) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((mdst &amp;&amp; mdst-&gt;host_joined) ||</span><br><span class="line">			    br_multicast_is_router(br)) &#123;</span><br><span class="line">				local_rcv = <span class="literal">true</span>;</span><br><span class="line">				br-&gt;dev-&gt;stats.multicast++;</span><br><span class="line">			&#125;</span><br><span class="line">			mcast_hit = <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			local_rcv = <span class="literal">true</span>;</span><br><span class="line">			br-&gt;dev-&gt;stats.multicast++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">//单播包</span></span><br><span class="line">	<span class="keyword">case</span> BR_PKT_UNICAST:</span><br><span class="line">		<span class="comment">//根据目的MAC地址查找fdb表，看是否有对应的表项</span></span><br><span class="line">		dst = br_fdb_find_rcu(br, dest, vid);</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果找到目的MAC对应的表项</span></span><br><span class="line">	<span class="keyword">if</span> (dst) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> now = jiffies;</span><br><span class="line">		<span class="comment">//送入上层处理</span></span><br><span class="line">		<span class="keyword">if</span> (dst-&gt;is_local)</span><br><span class="line">			<span class="keyword">return</span> br_pass_frame_up(skb);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (now != dst-&gt;used)</span><br><span class="line">			dst-&gt;used = now;</span><br><span class="line">		<span class="comment">//根据fdb转发表项进行转发，若这里local_rcv 为1,（即端口处于混杂模式IFF_PROMISC），则会克隆一份再转发</span></span><br><span class="line">		<span class="comment">//传入的第一个参数dst-&gt;dst 即为要转发的目的端口</span></span><br><span class="line">		br_forward(dst-&gt;dst, skb, local_rcv, <span class="literal">false</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//进行广播或者组播洪泛</span></span><br><span class="line">		<span class="keyword">if</span> (!mcast_hit)</span><br><span class="line">			br_flood(br, skb, pkt_type, local_rcv, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			br_multicast_flood(mdst, skb, local_rcv, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//local_rcv标记为1，送入上层处理。</span></span><br><span class="line">	<span class="keyword">if</span> (local_rcv)</span><br><span class="line">		<span class="keyword">return</span> br_pass_frame_up(skb);</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">drop:</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-br-pass-frame-up"><a class="header-anchor" href="#3-br-pass-frame-up">¶</a>3.br_pass_frame_up</h2>
<p>数据包的目的 MAC 是本地的单播报文，广播，组播和网桥处于混杂模式时，报文都会通过 br_pass_frame_up 函数交由上层处理。</p>
<p>作用：</p>
<p>调用 NF_BR_LOCAL_IN 处钩子函数，最后调用 br_netif_receive_skb 函数，绕一圈后，交友上层处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">br_pass_frame_up</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">indev</span>, *<span class="title">brdev</span> = <span class="title">BR_INPUT_SKB_CB</span>(<span class="title">skb</span>)-&gt;<span class="title">brdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span> = <span class="title">netdev_priv</span>(<span class="title">brdev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_vlan_group</span> *<span class="title">vg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pcpu_sw_netstats</span> *<span class="title">brstats</span> = <span class="title">this_cpu_ptr</span>(<span class="title">br</span>-&gt;<span class="title">stats</span>);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//统计网桥设备上的收包流量数据</span></span><br><span class="line">	u64_stats_update_begin(&amp;brstats-&gt;syncp);</span><br><span class="line">	brstats-&gt;rx_packets++;</span><br><span class="line">	brstats-&gt;rx_bytes += skb-&gt;len;</span><br><span class="line">	u64_stats_update_end(&amp;brstats-&gt;syncp);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取网桥设备上的VLAN组</span></span><br><span class="line">	vg = br_vlan_group_rcu(br);</span><br><span class="line">	<span class="comment">/* Bridge is just like any other port.  Make sure the</span></span><br><span class="line"><span class="comment">	 * packet is allowed except in promisc modue when someone</span></span><br><span class="line"><span class="comment">	 * may be running packet capture.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(brdev-&gt;flags &amp; IFF_PROMISC) &amp;&amp;</span><br><span class="line">	    !br_allowed_egress(vg, skb)) &#123;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//记录数据包的收包网络设备</span></span><br><span class="line">	indev = skb-&gt;dev;</span><br><span class="line">	<span class="comment">//将数据包的收包设备改为网桥设备</span></span><br><span class="line">	<span class="comment">//当再次进入__netif_receive_skb_core时就不会再次进入桥处理了，因为网桥上没有注册rx_handler 函数</span></span><br><span class="line">	skb-&gt;dev = brdev;</span><br><span class="line">	<span class="comment">//配置数据包vlan相关信息</span></span><br><span class="line">	skb = br_handle_vlan(br, <span class="literal">NULL</span>, vg, skb);</span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">	<span class="comment">/* update the multicast stats if the packet is IGMP/MLD */</span></span><br><span class="line">	<span class="comment">//如果数据包是组播，更新组播数据包的统计信息</span></span><br><span class="line">	br_multicast_count(br, <span class="literal">NULL</span>, skb, br_multicast_igmp_type(skb),</span><br><span class="line">			   BR_MCAST_DIR_TX);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用NF_BR_LOCAL_IN处钩子函数，最后调用br_netif_receive_skb函数。</span></span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,</span><br><span class="line">		       dev_net(indev), <span class="literal">NULL</span>, skb, indev, <span class="literal">NULL</span>,</span><br><span class="line">		       br_netif_receive_skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次进入 netif_receive_skb，由于 skb-dev 被设置成了 bridge，而 bridge 设备的 rx_handler 函数是没有被设置的，所以就不会再次进入 bridge 逻辑，而直接进入了主机上层协议栈。</p>
<p>相关函数</p>
<h3 id="br-netif-receive-skb"><a class="header-anchor" href="#br-netif-receive-skb">¶</a><code>br_netif_receive_skb()</code></h3>
<p>可以看到在 br_netif_receive_skb() 函数中调用了 netif_receive_skb() 函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">static int</span><br><span class="line">br_netif_receive_skb(struct net *net, struct sock *sk, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">	br_drop_fake_rtable(skb);</span><br><span class="line">	return netif_receive_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-br-forward"><a class="header-anchor" href="#4-br-forward">¶</a>4. br_forward()</h2>
<p>不是发往本地的数据包，但在 fdb 表中能找到对应的表项，则进行转发 br_forward()，若在 fdb 表中找不到对应表项就进行洪泛 br_blood().</p>
<p>作用：</p>
<p>主要是调用__br_forward() 转发报文</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * br_forward - forward a packet to a specific port</span></span><br><span class="line"><span class="comment"> * @to: destination port</span></span><br><span class="line"><span class="comment"> * @skb: packet being forwarded</span></span><br><span class="line"><span class="comment"> * @local_rcv: packet will be received locally after forwarding</span></span><br><span class="line"><span class="comment"> * @local_orig: packet is locally originated</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Should be called with rcu_read_lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_forward</span><span class="params">(<span class="keyword">const</span> struct net_bridge_port *to,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct sk_buff *skb, <span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//should_deliver测试是否应该将该包转发出去</span></span><br><span class="line">	<span class="keyword">if</span> (to &amp;&amp; should_deliver(to, skb)) &#123;</span><br><span class="line">		<span class="comment">//如果local_rcv为1，表明端口为混杂模式，先clone一份数据包再进行转发</span></span><br><span class="line">		<span class="keyword">if</span> (local_rcv)</span><br><span class="line">			deliver_clone(to, skb, local_orig);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			__br_forward(to, skb, local_orig);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (!local_rcv)</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-br-forward"><a class="header-anchor" href="#5-br-forward">¶</a>5. __br_forward()</h2>
<p>作用:</p>
<p>__br_forward() 函数根据数据包的来源（local_orig）分别进入不同的钩子点，如果数据包是从本地发出的，则进入 NF_BR_LOCAL_OUT，如果不是本地发出的，则进入 NF_BR_FORWARD 钩子，最后都进入 br_forward_finish() 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __br_forward(<span class="keyword">const</span> struct net_bridge_port *to,</span><br><span class="line">			 struct sk_buff *skb, <span class="keyword">bool</span> local_orig)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_vlan_group</span> *<span class="title">vg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">indev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line">	<span class="keyword">int</span> br_hook;</span><br><span class="line">	<span class="comment">//获取vlan组，这个组中有许多的vlanid，br_handle_vlan函数就是要在这个组中查找自己的vid</span></span><br><span class="line">	vg = nbp_vlan_group_rcu(to);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加vlan的相关配置</span></span><br><span class="line">	skb = br_handle_vlan(to-&gt;br, to, vg, skb);</span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//记录数据包的原始收包网络设备</span></span><br><span class="line">	indev = skb-&gt;dev;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将skb的dev修改为出口网络设备</span></span><br><span class="line">	skb-&gt;dev = to-&gt;dev;</span><br><span class="line">	<span class="comment">/*如果local_orig标志位(判断是否从本地发出的数据包)为false，就进入NF_BR_FORWARD钩子</span></span><br><span class="line"><span class="comment">	若为true，就进入NF_BR_LOCAL_OUT钩子点*/</span></span><br><span class="line">	<span class="keyword">if</span> (!local_orig) &#123;</span><br><span class="line">		<span class="keyword">if</span> (skb_warn_if_lro(skb)) &#123;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//不是本地发出的数据包，进入NF_BR_FORWARD</span></span><br><span class="line">		br_hook = NF_BR_FORWARD;</span><br><span class="line">		skb_forward_csum(skb);</span><br><span class="line">		net = dev_net(indev);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(netpoll_tx_running(to-&gt;br-&gt;dev))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!is_skb_forwardable(skb-&gt;dev, skb)) &#123;</span><br><span class="line">				kfree_skb(skb);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				skb_push(skb, ETH_HLEN);</span><br><span class="line">				br_netpoll_send_skb(to, skb);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//若是本地发出的数据包，进入NF_BR_LOCAL_OUT处理</span></span><br><span class="line">		br_hook = NF_BR_LOCAL_OUT;</span><br><span class="line">		net = dev_net(skb-&gt;dev);</span><br><span class="line">		indev = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//进入钩子点，最后执行br_forward_finish函数。</span></span><br><span class="line">	NF_HOOK(NFPROTO_BRIDGE, br_hook,</span><br><span class="line">		net, <span class="literal">NULL</span>, skb, indev, skb-&gt;dev,</span><br><span class="line">		br_forward_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-br-forward-finish"><a class="header-anchor" href="#6-br-forward-finish">¶</a>6. br_forward_finish()</h2>
<p><code>br_forward_finish()</code> 函数比较简单，调用 <code>NF_BR_POST_ROUTING</code> 处的钩子函数，最后进入 <code>br_dev_queue_push_xmit</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_forward_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING,</span><br><span class="line">		       net, sk, skb, <span class="literal">NULL</span>, skb-&gt;dev,</span><br><span class="line">		       br_dev_queue_push_xmit);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-br-dev-queue-push-xmit"><a class="header-anchor" href="#7-br-dev-queue-push-xmit">¶</a>7. br_dev_queue_push_xmit</h2>
<p>在 <code>br_dev_queue_push_xmit()</code> 中，会先 <code>skb_push(skb,ETH,HLEN);</code> 将 data 指向二层头部，然后调用 <code>dev_queue_xmit()</code> 发送报文。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_dev_queue_push_xmit</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_skb_forwardable(skb-&gt;dev, skb))</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//注意这句操作</span></span><br><span class="line">	skb_push(skb, ETH_HLEN);</span><br><span class="line">	br_drop_fake_rtable(skb);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_PARTIAL &amp;&amp;</span><br><span class="line">	    (skb-&gt;protocol == htons(ETH_P_8021Q) ||</span><br><span class="line">	     skb-&gt;protocol == htons(ETH_P_8021AD))) &#123;</span><br><span class="line">		<span class="keyword">int</span> depth;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (!__vlan_get_protocol(skb, skb-&gt;protocol, &amp;depth))</span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">		skb_set_network_header(skb, depth);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	dev_queue_xmit(skb);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">drop:</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-br-flood"><a class="header-anchor" href="#8-br-flood">¶</a>8. br_flood</h2>
<p><code>br_flood()</code> 也是调用 <code>__br_forward()</code> 函数转发报文。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/* called under rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_flood</span><span class="params">(struct net_bridge *br, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">	      <span class="keyword">enum</span> br_pkt_type pkt_type, <span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 igmp_type = br_multicast_igmp_type(skb);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span>;</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*遍历网桥设备的port_list，取出所有的网桥端口*/</span></span><br><span class="line">	list_for_each_entry_rcu(p, &amp;br-&gt;port_list, <span class="built_in">list</span>) </span><br><span class="line">        &#123;</span><br><span class="line">		<span class="comment">/* Do not flood unicast traffic to ports that turn it off, nor</span></span><br><span class="line"><span class="comment">		 * other traffic if flood off, except for traffic we originate</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">switch</span> (pkt_type) </span><br><span class="line">                &#123;</span><br><span class="line">		<span class="keyword">case</span> BR_PKT_UNICAST:</span><br><span class="line">			<span class="keyword">if</span> (!(p-&gt;flags &amp; BR_FLOOD))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> BR_PKT_MULTICAST:</span><br><span class="line">			<span class="keyword">if</span> (!(p-&gt;flags &amp; BR_MCAST_FLOOD) &amp;&amp; skb-&gt;dev != br-&gt;dev)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> BR_PKT_BROADCAST:</span><br><span class="line">			<span class="keyword">if</span> (!(p-&gt;flags &amp; BR_BCAST_FLOOD) &amp;&amp; skb-&gt;dev != br-&gt;dev)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/* Do not flood to ports that enable proxy ARP */</span></span><br><span class="line">                <span class="comment">/*代理arp*/</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;flags &amp; BR_PROXYARP)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> ((p-&gt;flags &amp; (BR_PROXYARP_WIFI | BR_NEIGH_SUPPRESS)) &amp;&amp;</span><br><span class="line">		    BR_INPUT_SKB_CB(skb)-&gt;proxyarp_replied)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">		prev = maybe_deliver(prev, p, skb, local_orig);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(prev))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		<span class="keyword">if</span> (prev == p)</span><br><span class="line">			br_multicast_count(p-&gt;br, p, skb, igmp_type,</span><br><span class="line">					   BR_MCAST_DIR_TX);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (!prev)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (local_rcv)</span><br><span class="line">		deliver_clone(prev, skb, local_orig);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__br_forward(prev, skb, local_orig);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (!local_rcv)</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-br-mulicast-flood"><a class="header-anchor" href="#9-br-mulicast-flood">¶</a>9. br_mulicast_flood()</h2>
<hr>
<p>以后再分析，肚子饿了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/* called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_multicast_flood</span><span class="params">(struct net_bridge_mdb_entry *mdst,</span></span></span><br><span class="line"><span class="function"><span class="params">			struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">BR_INPUT_SKB_CB</span>(<span class="title">skb</span>)-&gt;<span class="title">brdev</span>;</span></span><br><span class="line">	u8 igmp_type = br_multicast_igmp_type(skb);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port_group</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">rp</span>;</span></span><br><span class="line"> </span><br><span class="line">	rp = rcu_dereference(hlist_first_rcu(&amp;br-&gt;router_list));</span><br><span class="line">	p = mdst ? rcu_dereference(mdst-&gt;ports) : <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (p || rp) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">port</span>, *<span class="title">lport</span>, *<span class="title">rport</span>;</span></span><br><span class="line"> </span><br><span class="line">		lport = p ? p-&gt;port : <span class="literal">NULL</span>;</span><br><span class="line">		rport = rp ? hlist_entry(rp, struct net_bridge_port, rlist) :</span><br><span class="line">			     <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)lport &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)rport) &#123;</span><br><span class="line">			port = lport;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">if</span> (port-&gt;flags &amp; BR_MULTICAST_TO_UNICAST) &#123;</span><br><span class="line">				maybe_deliver_addr(lport, skb, p-&gt;eth_addr,</span><br><span class="line">						   local_orig);</span><br><span class="line">				<span class="keyword">goto</span> delivered;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			port = rport;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		prev = maybe_deliver(prev, port, skb, local_orig);</span><br><span class="line">delivered:</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(prev))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		<span class="keyword">if</span> (prev == port)</span><br><span class="line">			br_multicast_count(port-&gt;br, port, skb, igmp_type,</span><br><span class="line">					   BR_MCAST_DIR_TX);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)lport &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)port)</span><br><span class="line">			p = rcu_dereference(p-&gt;next);</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)rport &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)port)</span><br><span class="line">			rp = rcu_dereference(hlist_next_rcu(rp));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (!prev)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (local_rcv)</span><br><span class="line">		deliver_clone(prev, skb, local_orig);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__br_forward(prev, skb, local_orig);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (!local_rcv)</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<p><a href="http://ebtables.netfilter.org/br_fw_ia/br_fw_ia.html" target="_blank" rel="noopener">ebtables/iptables interaction on a Linux-based bridge</a>
@ebtables @2.4.x kernel</p>
<p><a href="https://blog.csdn.net/sxd2001/article/details/125031113" target="_blank" rel="noopener">Iptables DNAT实现broadcast与unicast之间相互映射</a>
@sxd2001 分析ebtables 的redirect 和 iptables 的redirect</p>
<p><a href="https://blog.csdn.net/Sophisticated_/article/details/87923362" target="_blank" rel="noopener">Linux-4.20.8内核桥收包源码解析（七）--本地（br_pass_frame_up）or 转发（br_forward）</a>
@lw_yang @Linux-4.20.8</p>
<p><a href="http://blog.chinaunix.net/uid-28541347-id-5750406.html" target="_blank" rel="noopener">Linux 3.10 kernel bridge转发逻辑</a>
@lvyilong316 @Linux 3.10 kernel</p>
<p><a href="https://blog.csdn.net/linyt/article/details/5191512" target="_blank" rel="noopener">kernel 网桥代码分析</a>
@海枫 @ 2.6.24.4</p>
<p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76674232" target="_blank" rel="noopener">桥数据包处理函数——br_handle_frame_finish（七）</a>
@不留你的名字</p>
<p><a href="https://www.cnblogs.com/super-king/p/bridge_implement.html" target="_blank" rel="noopener">Bridge实现</a>
@SuperKing @linux 2.6.18</p>
<p><a href="https://www.cnblogs.com/ck1020/p/5894235.html" target="_blank" rel="noopener">LInux下桥接模式详解三</a>
@jack.chen @linux 3.10.1</p>
<p><a href="https://blog.csdn.net/one_clouder/article/details/52877737" target="_blank" rel="noopener">协议栈报文接收之netif_receive_skb函数分析</a>
@one_clouder @Linux4.1.12</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>bridge</tag>
        <tag>netfilter</tag>
      </tags>
  </entry>
  <entry>
    <title>选择困难者的福音？层次分析法</title>
    <url>/public/2021/04/02/math/math_AHP/</url>
    <content><![CDATA[<h2 id="摘要"><a class="header-anchor" href="#摘要">¶</a>摘要</h2>
<p>日常生活中，我们面临很多的选择，选择工作offer，选择买哪个牌子的手机，选择哪个地方旅行等等。这些选择难以定量的衡量，有很多不确定性。内心小纠结，我选择了这个，万一那个好呢，怎么办？请看层次分析法。</p>
<p>层次分析法(Analytic Hierarchy Process，简称 AHP)是对一些较为复杂、较为模糊的问题作出决策的简易方法，它特别适用于那些难于完全定量分析的问题。它是美国运筹学家 T. L. Saaty 教授于上世纪 70 年代初期提出的一种简便、灵活而又实用的多准则决策方法。</p>
<p>运用层次分析法建模，大体上可按下面四个步骤进行</p>
<ul>
<li>建立递阶层次结构模型</li>
<li>构造出各层次中的所有判断矩阵</li>
<li>层次单排序及一致性检验</li>
<li>层次总排序及一致性检验。（一般不用）</li>
</ul>
<a id="more"></a>
<p>让我们从offer大佬的例子开始吧！</p>
<p>举个栗子，今年有位大学生，有三个offer，C1 C2 C3。</p>
<p>第一步，建立层次模型。</p>
<ul>
<li>目标层A：找工作的目标，自己满意程度。
<ul>
<li>这个程度怎么计算呢？比如工作1。</li>
</ul>
</li>
<li>准则层B：研究课题、发展前途、待遇、同事情况、地理位置、单位名气等等。
<ul>
<li>尽量列全一点，不需要排列重要顺序。</li>
<li>小于等于9个，后面要两两拍脑袋给出相对的重要层度，给多了不得把脑袋拍疼了。</li>
<li>也可以有子准则层，比如待遇中的放假、工作环境等等，列出也小于9个。</li>
</ul>
</li>
<li>方案层C：就是我们的offer</li>
</ul>
<img src="/public/2021/04/02/math/math_AHP/image-20200406145535585.png" alt="image-20200406145535585" style="zoom:50%;">
<h2 id="构造-A-B-之间判断矩阵"><a class="header-anchor" href="#构造-A-B-之间判断矩阵">¶</a>构造 A B 之间判断矩阵</h2>
<p>准则层B与目标A之间的关系。为了求出准则层中(B1-6) 对目标的重要层度的排序。比如对于该生工作满意度第一重要是待遇，然后是地点，其实该生自己也很模糊。就是固定A，然后求B中准则，对A重要性的排序。</p>
<h3 id="我们怎么对B中的准则们的重要排序呢？"><a class="header-anchor" href="#我们怎么对B中的准则们的重要排序呢？">¶</a>我们怎么对B中的准则们的重要排序呢？</h3>
<p>直接给每一个准则，0-1的评分，然后排序。经常会想，给完分之后，这个不合理呀要不我再给哪个准则加加分。所以这样的方法常常会因考虑不周全、顾此失彼而使决策者提出与他实际认为的重要性程度不相一致的数据。</p>
<p>我们可以将这个过程细化，我就比较两个准则对于目标的重要性，然后通过下面的矩阵方法，求出优先顺序。</p>
<p>还能通过一个一致性检验，来检验在你评分的过程中，有没有自相矛盾的地方，当然这种方法允许一些自相矛盾。反正评分的时候尊从内心拍脑袋就对了。</p>
<p>所以我们拿出一个B1 与 B2 对于目标的重要，想一想然后给出B2/B1，填入下面的表格中的(2,1)的位置。</p>
<p>整个矩阵i,j 与j，i 是取倒数的关系，所以只要做一半。</p>
<p>在找工作的目标下，准则i与j相对的重要性表示，B2/B1 的值。采用9个标度。而相比不重要刻度取倒数就可以了</p>
<table>
<thead>
<tr>
<th>准则i比j的比较</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>相同重要</td>
<td></td>
<td>比较重要</td>
<td></td>
<td>明显重要</td>
<td></td>
<td>强烈重要</td>
<td></td>
<td>极端重要</td>
</tr>
</tbody>
</table>
<p>最后的两两相对重要表格</p>
<img src="/public/2021/04/02/math/math_AHP/image-20200406145640316.png" alt="image-20200406145640316" style="zoom:50%;">
<p>对角线对称的两个数互为倒数，即 $$a_{ji}=\frac{1}{a_{ij}}$$  B1/B2 不就是和 B2/B1互为倒数嘛</p>
<p>从心理学观点来看，分级太多会超越人们的判断能力，既增加了作判断的难度， 又容易因此而提供虚假数据。Saaty 等人还用实验方法比较了在各种不同标度下人们判断结果的正确性，实验结果也表明，采用 1~9 标度最为合适。</p>
<p>判断矩阵的一致性指标步骤：</p>
<ul>
<li>1）计算一致性指标 CI 。$$CI=\frac{ \lambda_{max}-n}{n-1}$$</li>
<li>2）查表，平均随机一致性指标 RI。</li>
</ul>
<table>
<thead>
<tr>
<th>n</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody>
<tr>
<td>RI</td>
<td>0</td>
<td>0</td>
<td>0.58</td>
<td>0.90</td>
<td>1.12</td>
<td>1.24</td>
<td>1.32</td>
<td>1.41</td>
<td>1.45</td>
</tr>
</tbody>
</table>
<blockquote>
<p><em>RI</em> 的值是这样得到的，用随机方法构造500个样本矩阵:随机地从1~9及其倒数中抽取数字构造正互反矩阵，求得最大特征根的平均值 $$\bar \lambda_{max}$$ 并定义$$RI=\frac{\bar \lambda_{max}-n}{n-1}$$</p>
</blockquote>
<ul>
<li>3）计算一致性比例CR。 $$CR=\frac{CI}{RI}$$，当$$CR&lt;0.10$$ 时，认为判断矩阵的一致性是可以接受的，否则应对判断矩阵作适当修正。</li>
</ul>
<p>如果一个矩阵满足上面的条件，那么它最大特征值对应的特征向量就可以认为是每个维度的重要性权重。</p>
<h2 id="构造-B-C-之间判断矩阵"><a class="header-anchor" href="#构造-B-C-之间判断矩阵">¶</a>构造 B C 之间判断矩阵</h2>
<p>相同的方法，在同一B准则下，考虑不同工作的优先顺序。求工作排序的方法，和上面一样。</p>
<img src="/public/2021/04/02/math/math_AHP/image-20200406162644137.png" alt="image-20200406162644137" style="zoom:50%;">
<p>python代码<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AHP</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, criteria, b)</span>:</span></span><br><span class="line">        self.RI = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.58</span>, <span class="number">0.9</span>, <span class="number">1.12</span>, <span class="number">1.24</span>, <span class="number">1.32</span>, <span class="number">1.41</span>, <span class="number">1.45</span>, <span class="number">1.49</span>)</span><br><span class="line">        self.criteria = criteria</span><br><span class="line">        self.b = b</span><br><span class="line">        self.num_criteria = criteria.shape[<span class="number">0</span>]</span><br><span class="line">        self.num_project = b[<span class="number">0</span>].shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cal_weights</span><span class="params">(self, input_matrix)</span>:</span></span><br><span class="line">        input_matrix = np.array(input_matrix)</span><br><span class="line">        n, n1 = input_matrix.shape</span><br><span class="line">        <span class="keyword">assert</span> n == n1, <span class="string">'不是一个方阵'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> np.abs(input_matrix[i, j] * input_matrix[j, i] - <span class="number">1</span>) &gt; <span class="number">1e-7</span>:</span><br><span class="line">                    <span class="keyword">raise</span> ValueError(<span class="string">'不是反互对称矩阵'</span>)</span><br><span class="line"></span><br><span class="line">        eigenvalues, eigenvectors = np.linalg.eig(input_matrix)</span><br><span class="line"></span><br><span class="line">        max_idx = np.argmax(eigenvalues)</span><br><span class="line">        max_eigen = eigenvalues[max_idx].real</span><br><span class="line">        eigen = eigenvectors[:, max_idx].real</span><br><span class="line">        eigen = eigen / eigen.sum()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">9</span>:</span><br><span class="line">            CR = <span class="literal">None</span></span><br><span class="line">            warnings.warn(<span class="string">'无法判断一致性'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            CI = (max_eigen - n) / (n - <span class="number">1</span>)</span><br><span class="line">            CR = CI / self.RI[n]</span><br><span class="line">        <span class="keyword">return</span> max_eigen, CR, eigen</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        max_eigen, CR, criteria_eigen = self.cal_weights(self.criteria)</span><br><span class="line">        print(<span class="string">'准则层：最大特征值&#123;:&lt;5f&#125;,CR=&#123;:&lt;5f&#125;,检验&#123;&#125;通过'</span>.format(max_eigen, CR, <span class="string">''</span> <span class="keyword">if</span> CR &lt; <span class="number">0.1</span> <span class="keyword">else</span> <span class="string">'不'</span>))</span><br><span class="line">        print(<span class="string">'准则层权重=&#123;&#125;\n'</span>.format(criteria_eigen))</span><br><span class="line"></span><br><span class="line">        max_eigen_list, CR_list, eigen_list = [], [], []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.b:</span><br><span class="line">            max_eigen, CR, eigen = self.cal_weights(i)</span><br><span class="line">            max_eigen_list.append(max_eigen)</span><br><span class="line">            CR_list.append(CR)</span><br><span class="line">            eigen_list.append(eigen)</span><br><span class="line"></span><br><span class="line">        pd_print = pd.DataFrame(eigen_list,</span><br><span class="line">                                index=[<span class="string">'准则'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num_criteria)],</span><br><span class="line">                                columns=[<span class="string">'方案'</span> + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num_project)],</span><br><span class="line">                                )</span><br><span class="line">        pd_print.loc[:, <span class="string">'最大特征值'</span>] = max_eigen_list</span><br><span class="line">        pd_print.loc[:, <span class="string">'CR'</span>] = CR_list</span><br><span class="line">        pd_print.loc[:, <span class="string">'一致性检验'</span>] = pd_print.loc[:, <span class="string">'CR'</span>] &lt; <span class="number">0.1</span></span><br><span class="line">        print(<span class="string">'方案层'</span>)</span><br><span class="line">        print(pd_print)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 目标层</span></span><br><span class="line">        obj = np.dot(criteria_eigen.reshape(<span class="number">1</span>, <span class="number">-1</span>), np.array(eigen_list))</span><br><span class="line">        print(<span class="string">'\n目标层'</span>, obj)</span><br><span class="line">        print(<span class="string">'最优选择是方案&#123;&#125;'</span>.format(np.argmax(obj)))</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 准则重要性矩阵</span></span><br><span class="line">    criteria = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">7</span>, <span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span> / <span class="number">3</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">5</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                         [<span class="number">1</span> / <span class="number">5</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对每个准则，方案优劣排序</span></span><br><span class="line">    b1 = np.array([[<span class="number">1</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span> / <span class="number">8</span>], [<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">3</span>], [<span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>]])</span><br><span class="line">    b2 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span> / <span class="number">5</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">    b3 = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>], [<span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span>]])</span><br><span class="line">    b4 = np.array([[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">    b5 = np.array([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span> / <span class="number">2</span>], [<span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">4</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">    b = [b1, b2, b3, b4, b5]</span><br><span class="line">    a = AHP(criteria, b).run()</span><br></pre></td></tr></table></figure>
<h2 id="层次分析法与控制变量法"><a class="header-anchor" href="#层次分析法与控制变量法">¶</a>层次分析法与控制变量法</h2>
<p>我们的任务是选择工作，最后使得我们满意，直接选择我们当然一头雾水。所以我们设立一些准则，然后对这些准则对于目标的重要性排序。</p>
<p>这又有点像概率图模型，只是赋权的方法，是相互比较的方法。</p>
<h2 id="选择困难者的福音？"><a class="header-anchor" href="#选择困难者的福音？">¶</a>选择困难者的福音？</h2>
<p>层次分析法对人们的思维过程进行了加工整理，提出了一套系统分析问题的方法，为科学管理和决策提供了较有说服力的依据。</p>
<p>在应用层次分析法研究问题时，遇到的主要困难有两个:<br>
(1) 如何根据实际情况抽象出较为贴切的层次结构;<br>
(2) 如何将某些定性的量作比较接近实际定量化处理。</p>
<p>层次分析法的其局限性<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：<br>
(1) 它在很大程度上依赖于人们的经验，主观因素的影响很大，它至多只能排除思维过程中的严重非一致性，却无法排除决策者个人可能存在的严重片面性。<br>
(2) 比较、 判断过程较为粗糙，不能用于精度要求较高的决策问题。</p>
<p>所以，AHP 至多只能算是一种半定量(或定性与定量结合)的方法。
本文仅供参考，不负法律责任，哈哈。</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>幼鹰me 知乎 <a href="https://zhuanlan.zhihu.com/p/101505929" target="_blank" rel="noopener">层次分析法原理与Python实现</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>司守奎《数学建模算法与程序》第八章 层次分析法 P167 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>层次分析法</tag>
      </tags>
  </entry>
  <entry>
    <title>「202207月度汇报」obsidian</title>
    <url>/public/2022/07/26/test/202207_obsidian/</url>
    <content><![CDATA[<p>统计 ✅ : 6 📅 : 3 🔖 : 47</p>
<a id="more"></a>
<h2 id="✅-6"><a class="header-anchor" href="#✅-6">¶</a>✅ : 6</h2>
<p>✅目标图标系统
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
✅ <a href="https://blog.csdn.net/hhhhhyyyyy8/article/details/102133863" target="_blank" rel="noopener">Linux内核数据包bridge上转发流程_hhhhhyyyyy8的博客-CSDN博客_br_multicast_flood</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>
✅ 邮箱转rss
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a><br>
✅  hacker news rss添加
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a><br>
✅ 经济学人转载leader文章
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a><br>
✅ github博客评论系统是否换成【不换】
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W23.md">C日常/2022-W23.md</a></p>
<h2 id="📅-3"><a class="header-anchor" href="#📅-3">¶</a>📅 : 3</h2>
<p>📅 端口触发 端口转发
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
📅 全屋智能
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>
📅 改进
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a></p>
<h2 id="🔖-47"><a class="header-anchor" href="#🔖-47">¶</a>🔖 : 47</h2>
<p>🔖 ish保持后台运行
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>
🔖 <a href="https://www.jianshu.com/p/f29ca723db4f" target="_blank" rel="noopener">Git 运行配置（git config、gitk、git gui） - michael_jia - 简书</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>
🔖<a href="https://www.cnblogs.com/xuanbjut/p/12624702.html" target="_blank" rel="noopener">wmctrl像xmonad那样方便地用快捷键来控制任务窗口的显示 - pycod - 博客园</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>
🔖 <a href="https://blog.csdn.net/anlian523/article/details/113627568" target="_blank" rel="noopener">VSCode复制代码时去掉样式/语法高亮/代码高亮/黑色背景_anlian523的博客-CSDN博客_idea复制代码不带黑色背景</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W19.md">C日常/2022-W19.md</a><br>
🔖 <a href="https://blog.csdn.net/dog250/article/details/121400218" target="_blank" rel="noopener">为什么除法，开方，求对数比乘法，乘方，求指数更难_dog250的博客-CSDN博客</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖学习小林博客的写法
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖一万字统计学梳理
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖腾讯 彻底搞清楚tcp
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖0x5f3759df这个快速开方中的常数的数学依据是什么？
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖https流程
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖使用 Clion + QEMU/GDB 远程调试Linux内核（分享自知乎网）<a href="https://zhuanlan.zhihu.com/p/412604505?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/412604505?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖TCP/IP协议到底在讲什么？ <a href="http://www.zhihu.com/question/51074319?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">http://www.zhihu.com/question/51074319?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖【什么是动态规划（Dynamic Programming）？动态规划的意义是什么？】阮行止：… <a href="https://www.zhihu.com/question/23995189/answer/613096905?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/23995189/answer/613096905?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖【为什么有人说弄懂了《算法导论》的 90%，就超越了 90%的程序员？】启舰：… <a href="https://www.zhihu.com/question/315201616/answer/1960517601?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/315201616/answer/1960517601?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖【vs code】【keil】优雅地使用vs code代替keil。by 童话与云 👉 <a href="https://www.zhihu.com/zvideo/1422934459457253376?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/zvideo/1422934459457253376?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖图解网络 - 75张图带你了解网络设备、网络地址规划、静态路由、实战演练（分享自知乎网）
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖vscode-journal：vscode中写日记/便签/提醒，配合nutstore与安卓、ios同步_TeQuL的博客-CSDN博客
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖结构体（结构体嵌套、结构体指针、结构体参数传递） - 蓝海人 - 博客园
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖Feedme - 8大 RSS 阅读器第三方客户端[Android] - 小众软件
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖聪明人必学的停车小技巧！。by Felicidades 👉 <a href="https://www.zhihu.com/zvideo/1414008107094093824?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/zvideo/1414008107094093824?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖在线 DOS 游戏 - 近 2000 款怀旧游戏，仙剑、红警、三国志、大富翁、明星志愿、大航海、主题医院等 - 小众软件
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖Feeddd · 重新掌控你的订阅源
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖【如何长时间高效学习？】硬核学长2077：… <a href="https://www.zhihu.com/question/28358499/answer/1762418904?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/28358499/answer/1762418904?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖【你身边的学霸都有怎样的学习方法或习惯？】硬核学长2077：… <a href="https://www.zhihu.com/question/54265751/answer/1995587976?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/54265751/answer/1995587976?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖【如何不痛苦地早起？】铁木君：… <a href="https://www.zhihu.com/question/22120300/answer/1887544838?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848" target="_blank" rel="noopener">https://www.zhihu.com/question/22120300/answer/1887544838?utm_source=md.obsidian&amp;utm_medium=social&amp;utm_oi=619610399826382848</a> （分享自知乎网）
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖[[obsidian_tips]]
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖<a href="https://sspai.com/post/72757" target="_blank" rel="noopener">随时可用的 PC 体验是这样「炼」成的，Windows 新版睡眠机制详解 - 少数派</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖<a href="https://blog.csdn.net/who538592/article/details/79483323" target="_blank" rel="noopener">TC流量控制_who538592的博客-CSDN博客_tc流量控制</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W16.md">C日常/2022-W16.md</a><br>
🔖 <a href="https://sspai.com/post/74090" target="_blank" rel="noopener">大家都说好的蛋白粉，我们应该如何取舍 - 少数派</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>
🔖 <a href="https://zhuanlan.zhihu.com/p/508345279" target="_blank" rel="noopener">我的obsidian插件开发的学习过程</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>
🔖 <a href="https://blog.csdn.net/Haywardwang/article/details/108626491" target="_blank" rel="noopener">python 词云构建_Haywardwang的博客-CSDN博客</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>
🔖 <a href="https://blog.csdn.net/weixin_56842628/article/details/117921526?utm_medium=distribute.wap_relevant.none-task-blog-2~default~baidujs_title~default-9-117921526-blog-108626491.wap_blog_relevant_default&amp;spm=1001.2101.3001.4242.6&amp;utm_relevant_index=10" target="_blank" rel="noopener">如何用Python制作简单又好看的词云？来瞅瞅吧~_小熊爱Python的博客-CSDN博客_python词云代码简单</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W28.md">C日常/2022-W28.md</a><br>
🔖 <a href="https://sspai.com/post/73779" target="_blank" rel="noopener">跨时空圆桌：伟大创作者们如何安排日常生活 - 少数派</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>
🔖 <a href="https://www.appinn.com/typing-learner/" target="_blank" rel="noopener">Typing Learner - 硬核单词记忆：从电影台词筛选生词，边追美剧边学英语，用户直喊「好家伙！」[Windows/macOS] - 小众软件</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>
🔖 <a href="https://www.zhihu.com/question/391756708/answer/2556173863" target="_blank" rel="noopener">SpaceX的可回收火箭有什么神奇之处，为何其他航天大国还不能仿造？ - YY硕 的回答 - 知乎</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>
🔖 <a href="https://mp.weixin.qq.com/s/KBKO4C1d4CkyHAPEkh8D4Q" target="_blank" rel="noopener">这几个通信协议的动图不错</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>
🔖 <a href="https://oorkan.medium.com/emojifying-your-linux-terminal-9a5c1e8f6b3c" target="_blank" rel="noopener">Emojifying your Linux terminal  🚀</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>
🔖 <a href="https://sspai.com/post/74167" target="_blank" rel="noopener">为 WSL 配置这些新功能，不用虚拟机也能体验完整 Linux - 少数派</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>
🔖<a href="https://sspai.com/post/72274" target="_blank" rel="noopener">意识先行，工具辅助：谈谈我们该怎样分辨虚假信息</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>
🔖<a href="https://zhuanlan.zhihu.com/p/495262462" target="_blank" rel="noopener">网站低代码开发</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>
🔖 学习体系化，效率提升
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W27.md">C日常/2022-W27.md</a><br>
🔖 <a href="https://sspai.com/post/73958" target="_blank" rel="noopener">玩转 Obsidian 08：利用 Dataview 打造自动化 HomePage - 少数派</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>
🔖 <a href="https://post.m.smzdm.com/p/adwgg2rd/" target="_blank" rel="noopener">小爱同学，打开我的三菱空调——米家空调伴侣2使用分享_智能家居_什么值得买</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>
🔖 <a href="https://sspai.com/post/73829" target="_blank" rel="noopener">用 59 分钟，找到工具的效率之源 - 少数派</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>
🔖 <a href="https://cloud.tencent.com/developer/article/1879646" target="_blank" rel="noopener">tcpdump是在哪儿抓到的包？ - 腾讯云开发者社区-腾讯云</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>
🔖 <a href="https://www.jianshu.com/p/79bcf09aed25" target="_blank" rel="noopener">IPTables五----ebtables - marshalzxy - 简书</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a><br>
🔖 <a href="https://david-waiting.medium.com/a-beginners-guide-to-generic-routing-encapsulation-fb2b4fb63abb" target="_blank" rel="noopener">A Beginner’s Guide to Generic Routing Encapsulation</a>
-&gt;<a href="C%E6%97%A5%E5%B8%B8/2022-W26.md">C日常/2022-W26.md</a></p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样成为一名优秀的算法工程师</title>
    <url>/public/2018/10/01/AI/how_algorithm_engineer/</url>
    <content><![CDATA[<blockquote>
<p>转载 原创： AI学习与实践平台
TODO: 看完里面的文章，对每篇文章做个总结，实验+文章。</p>
</blockquote>
<h2 id="1-导言"><a class="header-anchor" href="#1-导言">¶</a>1. 导言</h2>
<p>怎样成为一名优秀的算法工程师？这是很多从事人工智能学术研究和产品研发的同学都关心的一个问题。面对市场对人才的大量需求与供给的严重不足，以及高薪水的诱惑，越来越多的人开始学习这个方向的技术，或者打算向人工智能转型。市面上各种鱼龙混杂的培训班以及误导人的文章会把很多初学者带入歧途，浮躁的跟风将会让你最后收获甚微，根本达不到企业的用人要求。为了更好的帮助大家学习和成长，少走弯路，在今天的文章里，<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485551&amp;idx=2&amp;sn=a6689528f10aedab3fce91857eec877b&amp;chksm=fdb695f8cac11cee025ad6d8d77ed90f7169142d6b20b2f5a6945b58edd97c27225f4a2eba91&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SIGAI</a> 的作者以自己的亲身经历和思考，为大家写下对这一问题的理解与答案。</p>
<p>首先来看一个高度相关的问题：一个优秀的算法工程师必须具备哪些素质？我们给出的答案是这样的：</p>
<ul>
<li>数学知识</li>
<li>编程能力</li>
<li>机器学习与深度学习的知识</li>
<li>应用方向的知识</li>
<li>对自己所做的问题的思考和经验</li>
</ul>
<p>除去教育背景，逻辑思维，学习能力，沟通能力等其他方面的因素，大多数公司在考察算法工程师的技术水平时都会考虑上面这几个因素。接下来我们将按照这几个方面进行展开，详细的说明如何学习这些方面的知识以及积累经验。</p>
<a id="more"></a>
<h2 id="2-数学知识"><a class="header-anchor" href="#2-数学知识">¶</a>2. 数学知识</h2>
<p>与其他工作方向如app、服务器开发相比，以及与计算机科学的其他方向如网络，数据库，分布式计算等相比，人工智能尤其是机器学习属于数学知识密集的方向。在各种书籍，论文，算法中都充斥着大量的数学公式，这让很多打算入门的人或者开始学习的人感到明显的压力。首先我们考虑一个最核心的问题：机器学习和深度学习究竟需要哪些数学知识？在<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485551&amp;idx=2&amp;sn=a6689528f10aedab3fce91857eec877b&amp;chksm=fdb695f8cac11cee025ad6d8d77ed90f7169142d6b20b2f5a6945b58edd97c27225f4a2eba91&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SIGAI</a>之前的公众号文章“<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483713&amp;idx=1&amp;sn=1e7c81381d16806ac73e15691fe17aec&amp;chksm=fdb69cd6cac115c05f1f90b0407e3f8ae9be8719e454f908074ac0d079885b5c134e2d60fd64&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">学好机器学习需要哪些数学知识</a>”里，我们已经给出了答案。先看下面这张表：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image003.gif" alt="EB5E93E91C3643F991C93D61F363373E.jpeg"></p>
<p>更多算法工程师的必读文章，请关注SIGAICN公众号</p>
<p>上面的表给出了各种典型的机器学习算法所用到的数学知识点。我们之前已经总结过，理解绝大多数算法和理论，有微积分/高等数学，线性代数，概率论，最优化方法的知识就够了。除流形学习需要简单的微分几何概念之外，深层次的数学知识如实变函数，泛函分析等主要用在一些基础理论结果的证明上，即使不能看懂证明过程，也不影响我们使用具体的机器学习算法。概率图模型、流形学习中基于图的模型会用到图论的一些基本知识，如果学习过离散数学或者数据结构，这些概念很容易理解。除此之外，某些算法会用到离散数学中的树的概念，但很容易理解。</p>
<h3 id="2-1-高等数学"><a class="header-anchor" href="#2-1-高等数学">¶</a>2.1 高等数学</h3>
<p>如果你已经学过这些大学数学课，只要把所需的知识点复习一遍就够了。对于微积分，通俗易懂而又被广为采用的是同济版的高等数学：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image005.gif" alt="88F2EB8BDFE1448EBD2DF61848E355FD.jpeg"></p>
<p>在机器学习中主要用到了微分部分，积分用的非常少。具体的，用到了下面的概念：</p>
<ul>
<li>导数和偏导数的定义与计算方法，与函数性质的关系</li>
<li>梯度向量的定义</li>
<li>极值定理，可导函数在极值点处导数或梯度必须为0</li>
<li>雅克比矩阵，这是向量到向量映射函数的偏导数构成的矩阵，在求导推导中会用到</li>
<li>Hessian矩阵，这是2阶导数对多元函数的推广，与函数的极值有密切的联系</li>
<li>凸函数的定义与判断方法</li>
<li>泰勒展开公式</li>
<li>拉格朗日乘数法，用于求解带等式约束的极值问题</li>
</ul>
<p>其中最核心的是多元函数的泰勒展开公式，根据它我们可以推导出梯度下降法，牛顿法，拟牛顿法等一系列最优化方法。</p>
<p>如果你想要深入的学习微积分，可以阅读数学系的教程，称为数学分析：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image007.gif" alt="DEB5F0D2FC584E0B96B263FE1D559AFF.jpeg"></p>
<p>与工科的高等数学偏重计算不同，它里面有大量的理论证明，对于锻炼数学思维非常有帮助。北大张筑生先生所著的数学分析可谓是国内这方面教材的精品。</p>
<h3 id="2-2-线性代数"><a class="header-anchor" href="#2-2-线性代数">¶</a>2.2 线性代数</h3>
<p>下面来看线性代数，同样是同济版的教材：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image009.gif" alt="48D5E515A7144CE6A9CB78162F6ECAAF.jpeg"></p>
<p>如果想更全面系统的学习线性代数，可以看这本书：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image011.gif" alt="BF71AB68DB2B4D71AC8D2B3263C197E5.jpeg"></p>
<p>相比之下，线性代数用的更多。具体用到的知识点有：</p>
<ul>
<li>向量和它的各种运算，包括加法，减法，数乘，转置，内积</li>
<li>向量和矩阵的范数，L1范数和L2范数</li>
<li>矩阵和它的各种运算，包括加法，减法，乘法，数乘</li>
<li>逆矩阵的定义与性质</li>
<li>行列式的定义与计算方法</li>
<li>二次型的定义</li>
<li>矩阵的正定性</li>
<li>特征值与特征向量</li>
<li>奇异值分解</li>
<li>线性方程组的数值解</li>
</ul>
<p>机器学习算法处理的数据一般都是向量、矩阵或者张量。经典的机器学习算法输入的数据都是特征向量，深度学习算法在处理图像时输入的2维的矩阵或者3维的张量。掌握这些概念是你理解机器学习和深度学习算法的基础。</p>
<h3 id="2-3-概率论"><a class="header-anchor" href="#2-3-概率论">¶</a>2.3 概率论</h3>
<p>概率论国内理工科专业使用最多的是浙大版的教材：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image013.gif" alt="91E918CF7ED84C7488BDDFFC7594E0D4.jpeg"></p>
<p>如果把机器学习所处理的样本数据看作随机变量/向量，就可以用概率论的方法对问题进行建模，这代表了机器学习中很大一类方法。在机器学习里用到的概率论知识点有:</p>
<ul>
<li>随机事件的概念，概率的定义与计算方法</li>
<li>随机变量与概率分布，尤其是连续型随机变量的概率密度函数和分布函数</li>
<li>条件概率与贝叶斯公式</li>
<li>常用的概率分布，包括正态分布，伯努利二项分布，均匀分布</li>
<li>随机变量的均值与方差，协方差</li>
<li>随机变量的独立性</li>
<li>最大似然估计</li>
</ul>
<p>这些知识不超出普通理工科概率论教材的范围。</p>
<h3 id="最优化"><a class="header-anchor" href="#最优化">¶</a>最优化</h3>
<p>最后来说最优化，几乎所有机器学习算法归根到底都是在求解最优化问题。求解最优化问题的指导思想是在极值点出函数的导数/梯度必须为0。因此你必须理解梯度下降法，牛顿法这两种常用的算法，它们的迭代公式都可以从泰勒展开公式而得到。</p>
<p>凸优化是机器学习中经常会提及的一个概念，这是一类特殊的优化问题，它的优化变量的可行域是凸集，目标函数是凸函数。凸优化最好的性质是它的所有局部最优解就是全局最优解，因此求解时不会陷入局部最优解。如果一个问题被证明为是凸优化问题，基本上已经宣告此问题得到了解决。在机器学习中，线性回归、岭回归、支持向量机、logistic回归等很多算法求解的都是凸优化问题。</p>
<p>拉格朗日对偶为带等式和不等式约束条件的优化问题构造拉格朗日函数，将其变为原问题，这两个问题是等价的。通过这一步变换，将带约束条件的问题转换成不带约束条件的问题。通过变换原始优化变量和拉格朗日乘子的优化次序，进一步将原问题转换为对偶问题，如果满足某种条件，原问题和对偶问题是等价的。这种方法的意义在于可以将一个不易于求解的问题转换成更容易求解的问题。在支持向量机中有拉格朗日对偶的应用。</p>
<p>KKT条件是拉格朗日乘数法对带不等式约束问题的推广，它给出了带等式和不等式约束的优化问题在极值点处所必须满足的条件。在支持向量机中也有它的应用。</p>
<p>如果你没有学过最优化方法这门课也不用担心，这些方法根据微积分和线性代数的基础知识可以很容易推导出来。如果需要系统的学习这方面的知识，可以阅读《凸优化》，《非线性规划》两本经典教材。</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image015.gif" alt="B00246CBCFB446789B2F7F63F3292099.jpeg"></p>
<h2 id="3-编程能力"><a class="header-anchor" href="#3-编程能力">¶</a>3. 编程能力</h2>
<p>编程能力是学好机器学习和深度学习的又一大基础。对于计算机类专业的学生，由于本科已经学了c语言，c++，数据结构与算法，因此这方面一般不存在问题。对于非计算机专业的人来说，要真正学好机器学习和深度学习，这些知识是绕不开的。</p>
<h3 id="3-1-C"><a class="header-anchor" href="#3-1-C">¶</a>3.1 C++</h3>
<p>虽然现在大家热衷于学习python，但要作为一名真正的算法工程师，还是应该好好学习一下c++，至少，机器学习和深度学习的很多底层开源库都是用它写的；很多公司线上的产品，无论是运行在服务器端，还是嵌入式端，都是用c++写的。此外，如果你是应届生，在校园招聘时不少公司都会面试你c++的知识。</p>
<p>C++最经典的教材无疑是c++ primer：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image017.gif" alt="3E0DE0E336474B81A2F89F2190628186.jpeg"></p>
<p>对做算法的人来说，这本书其实不用全部看，把常用的点学完就够了。对于进阶，Effective c++是很好的选择，不少公司的面试题就直接出自这本书的知识点：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image019.gif" alt="DDCC32DD5E6D405588CB4B6F4A94BFE5.jpeg"></p>
<p>接下来说python，相比c++来说，学习的门槛要低很多，找一本通俗易懂的入门教程学习一遍即可。</p>
<h3 id="3-2-数据结构和算法"><a class="header-anchor" href="#3-2-数据结构和算法">¶</a>3.2 数据结构和算法</h3>
<p>数据结构和算法是编写很多程序的基础，对于机器学习和深度学习程序也不例外。很多算法的实现都依赖于数组，链表，数，排序，查找之类的数据结构和基础算法。如果有时间和精力，把算法导论啃一遍，你会有不一样的感受：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image021.gif" alt="E077608423D7473ABF1DBF75C482E060.jpeg"></p>
<p>对于应届生来说，学完它对于你通过大互联网和人工智能公司校园招聘的技术面试也非常有用。</p>
<p>上面说的只是编程语言的程序设计的理论知识，我们还要考虑实际动手能力。对于开发环境如gcc/g++，visual studio之类的工具，以及gdb之类的调试工具需要做到熟练使用。如果是在linux上开发，对linux的常用命令也要熟记于心。这方面的知识看各种具体的知识点和教程即可。另外，对于编程的一些常识，如进程，线程，虚拟内存，文件系统等，你最好也要进行了解。</p>
<h2 id="4-机器学习与深度学习的知识"><a class="header-anchor" href="#4-机器学习与深度学习的知识">¶</a>4. 机器学习与深度学习的知识</h2>
<p>在说完了数学和编程基础之后，下面我来看核心的内容，机器学习和深度学习知识。机器学习是现阶段解决很多人工智能问题的核心方法，尤其是深度学习，因此它们是算法工程师的核心知识。在这里有一个问题：是否需要先学机器学习，还是直接学深度学习？如果是一个专业的算法工程师，我的建议是先学机器学习。至少，你要知道机器学习中的基本概念， 过拟合，生成模型，ROC曲线等，上来就看深度学习，如没有背景知识你将不知所云。另外，神经网络只是机器学习中的一类方法，对于很多问题，其他机器学习算法如logistic回归，随机森林，GBDT，决策树等还在被大规模使用，因此你不要把自己局限在神经网络的小圈子里。</p>
<h3 id="4-1-ML和DP的教材"><a class="header-anchor" href="#4-1-ML和DP的教材">¶</a>4.1 ML和DP的教材</h3>
<p>首先来看机器学习，这方面的教材很多，周志华老师的机器学习，李航老师的统计学习方法是国内的经典。这里我们介绍国外的经典教材，首先是PRML：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image023.gif" alt="BE2D3D5817344DE0831B718D3F891899.jpeg"></p>
<p>PRML 下载地址 <a href="https://www.microsoft.com/en-us/research/publication/pattern-recognition-machine-learning/" target="_blank" rel="noopener">link</a></p>
<p>此书深厚，内容全面，涵盖了有监督学习，无监督学习的主要方法，理论推导和证明详细深入，是机器学习的经典。此外还有模式分类这本书，在这里不详细介绍。</p>
<p>本书主要内容包括：
<strong>第一章：简介</strong>
概率论、模型选择、决策理论、信息理论</p>
<p><strong>第二章：概率分布</strong>
二元变量、多项变量、高斯分布、指数分布族、非参数方法</p>
<p><strong>第三章：线性模型回归问题</strong>
线性基函数模型、偏置方差分解、贝叶斯线性回归、贝叶斯模型比较、The Evidence Approximation、固定基函数的局限性</p>
<p><strong>第四章：线性模型分类问题</strong>
判别函数、概率生成模型、概率判别模型、拉普拉斯逼近、贝叶斯逻辑回归</p>
<p><strong>第五章：神经网络</strong>
前馈神经网络、网络训练、误差反向传播、Hessian矩阵、神经网络的正则化、混合密度网络、贝叶斯神经网络</p>
<p><strong>第六章：Kernel方法</strong>
对偶表示、构造核、径向基函数网络、高斯过程</p>
<p><strong>第七章：Sparse Kernel Machines</strong>
最大边缘分类器、相关向量机</p>
<p><strong>第八章：图模型</strong>
贝叶斯网络、条件独立性、马尔科夫随机场、图模型的推理</p>
<p><strong>第九章：混合模型和EM</strong>
K-means聚类、高斯混合、EM算法</p>
<p><strong>第十章：近似推断</strong>
变分推断、高斯的变分混合、变分线性回归、指数族分布、局部变分方法、变分logistic回归、Expectation Propagation</p>
<p><strong>第十一章：采样方法</strong>
基本采样算法、马尔科夫链蒙特卡洛、吉布斯采样、切片采样、混合蒙特卡洛算法、估计划分函数</p>
<p><strong>第十二章：连续潜在变数</strong>
主成分分析，Probabilistic PCA，Kernel PCA，非线性潜变量模型</p>
<p><strong>第十三章：序列数据</strong>
马尔可夫模型，隐马尔可夫模型，Linear Dynamical Systems</p>
<p><strong>第十四章：混合模型</strong>
贝叶斯模型平均法，Committees，Boosting，基于树的模型，条件混合模型</p>
<p>深度学习目前最权威的教程是下面这本书：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image025.gif" alt="A39AD50565E141F89B08C93CCD7DEDFC.jpeg"></p>
<p>它涵盖了深度学习的方方面面，从理论到工程，但美中不足的是对应于介绍的相对较少。</p>
<p>强化学习是机器学习很独特的一个分支，大多数人对它不太了解，这方面的教程非常少，我们推荐下面这本书：</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image027.gif" alt="115B0E32F06F4538A76CB9B610F63B8C.jpeg"></p>
<p>美中不足的是这本书对深度强化学习没有介绍，因为出版的较早。不知最新的版本有没有加上这方面的内容。</p>
<p>在这里需要强调的是，你的知识要系统化，有整体感。很多同学都感觉到自己学的机器学习太零散，缺乏整体感。这需要你多思考算法之间的关系，演化历史之类的问题，这样你就做到胸中有图-机器学习算法地图。其实，<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485551&amp;idx=2&amp;sn=a6689528f10aedab3fce91857eec877b&amp;chksm=fdb695f8cac11cee025ad6d8d77ed90f7169142d6b20b2f5a6945b58edd97c27225f4a2eba91&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SIGAI</a>在之前的公众号文章“<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485306&amp;idx=1&amp;sn=fc8cc8de313bdb61dcd39c1dedb240a4&amp;chksm=fdb69aedcac113fb4b18c74248a313536ded50bade0e66b26f332ab247b148519da71ff2a3c0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">机器学习算法地图</a>”里已经给你总结出来了。</p>
<h3 id="4-2-开源库"><a class="header-anchor" href="#4-2-开源库">¶</a>4.2 开源库</h3>
<p>上面介绍了机器学习和深度学习的理论教材，下面来说实践问题。我们无需重复造车轮子，熟练的使用主流的开源库是需要掌握的一项技能。对于经典的机器学习，常用的库的有:</p>
<ul>
<li>libsvm</li>
<li>liblinear</li>
<li>XGBoost</li>
<li>OpenCV</li>
<li>HTK</li>
<li>Weka</li>
</ul>
<p>在这里我们不一一列举。借助于这些库，我们可以方便的完成自己的实验，或是研发自己的产品。对于深度学习，目前常用的有：</p>
<ul>
<li>Caffe</li>
<li>TensorFlow</li>
<li>MXNet</li>
</ul>
<p>除此之外，还有其他的。对于你要用到的开源库，一定要理解它的原理，以及使用中的一些细节问题。例如很多算法要求输入的数据先做归一化，否则效果会非常差，而且面临浮点数溢出的问题，这些实际经验需要你在使用中摸索。如果有精力把这些库的核心代码分析一遍，你对实现机器学习算法将会更有底气。以深度学习为例，最核心的代码无非是实现：</p>
<ul>
<li>各种层，包括它们的正向传播和反向传播</li>
<li>激活函数的实现</li>
<li>损失函数的实现</li>
<li>输入数据的处理</li>
<li>求解器，实现各种梯度下降法</li>
</ul>
<p>这些代码的量并不大，沉下心来，我相信一周之内肯定能分析完。看完之后你会有一种豁然开朗的感觉。</p>
<h2 id="5-应用方向的知识"><a class="header-anchor" href="#5-应用方向的知识">¶</a>5. 应用方向的知识</h2>
<p>接下来是各个方向的知识，与机器学习有关的应用方向当前主要有：</p>
<ul>
<li>机器视觉</li>
<li>语音识别</li>
<li>自然语言处理</li>
<li>数据挖掘</li>
<li>知识图谱</li>
<li>推荐系统</li>
</ul>
<p>除此之外，还有其他一些特定小方向，在这里不一一列举。这些具体的应用方向一般都有自己的教材，如果你以后要从事此方向的研究，系统的学习一遍是必须的。</p>
<h2 id="6-实践经验与思考"><a class="header-anchor" href="#6-实践经验与思考">¶</a>6. 实践经验与思考</h2>
<p>在说完理论与实践知识之后，最后我们来说经验与思考。在你确定要做某一个方向之后，对这个方向的方法要有一个全面系统的认识，很多方法是一脉相承的，如果只追求时髦看最新的算法，你很难做出学术上的创新，以及工程上的优化。对于本问题所有的经典论文，都应该化时间细度，清楚的理解它们解决了什么问题，是怎么解决的，还有哪些问题没有解决。例如：</p>
<ul>
<li>机器视觉目标检测中的遮挡问题</li>
<li>推荐系统中的冷启动问题</li>
<li>自然语言处理中文分词中的歧义切分问题</li>
</ul>
<p>只有经过大量的编程和实验训练，以及持续的思考，你才能算得上对这个方向深刻理解，以至于有自己的理解。很多同学对自己实现轮上的算法没有底气，解决这个问题最快的途径就是看论文算法的开源代码，在github上有丰富的资源，选择一些合适的，研究一下别人是怎么实现的，你就能明白怎么实现自己的网络结构和损失函数，照葫芦画瓢即可。</p>
<p>计算机以及人工智能是一个偏实践的学科，它的方法和理论既需要我们有扎实的理论功底，又需要有丰富的实践能力与经验。这两个方面构成了算法工程师最主要的素质。科学的学习路径能够让你取得好的学习效果，同时也缩短学习时间。错误和浮躁的做法则会让你最后事倍功半。这是  <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485551&amp;idx=2&amp;sn=a6689528f10aedab3fce91857eec877b&amp;chksm=fdb695f8cac11cee025ad6d8d77ed90f7169142d6b20b2f5a6945b58edd97c27225f4a2eba91&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">SIGAI</a> 对想进入这个领域，或者刚进入这个领域的每个人要说的！</p>
<p><img src="/public/2018/10/01/AI/how_algorithm_engineer/clip_image029.gif" alt="07382DFD55044B48927C8B054DE6F745.png"></p>
<h2 id="7-其他材料"><a class="header-anchor" href="#7-其他材料">¶</a>7. 其他材料</h2>
<h3 id="7-1-科普类"><a class="header-anchor" href="#7-1-科普类">¶</a>7.1 科普类</h3>
<p>【‍获取码】SIGAI0413
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483705&amp;idx=1&amp;sn=c6e7c4a2e14a2469308b41eb60f155ac&amp;chksm=fdb69caecac115b8712653600e526e99a3f6976fdaa2f6b6a09388fa6f9677ccb57b40c40ae3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">机器学习——波澜壮阔四十年 </a></p>
<p>【获取码】SIGAI0620
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484981&amp;idx=1&amp;sn=d3003468b9853851923844812993e060&amp;chksm=fdb69ba2cac112b4dac620d52100ebd033eb679f29340726a67297c4d6980b16c7cc91122028&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解计算：从√2到AlphaGo ——第1季 从√2谈起</a></p>
<p>【获取码】SIGAI0704
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485155&amp;idx=1&amp;sn=990cc7400751c36e9fef0a261e6add2a&amp;chksm=fdb69b74cac112628bdae14c6435120f6fece20dae9bf7b1ffc8b8b25e5496a24160feca0a72&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解计算：从√2到AlphaGo ——第2季 神经计算的历史背景</a></p>
<h3 id="7-2-数学类"><a class="header-anchor" href="#7-2-数学类">¶</a>7.2 数学类</h3>
<p>【获取码】SIGAI0417
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483713&amp;idx=1&amp;sn=1e7c81381d16806ac73e15691fe17aec&amp;chksm=fdb69cd6cac115c05f1f90b0407e3f8ae9be8719e454f908074ac0d079885b5c134e2d60fd64&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">学好机器学习需要哪些数学知识</a></p>
<p>【获取码】SIGAI0511
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484111&amp;idx=1&amp;sn=4ed4480e849298a0aff828611e18f1a8&amp;chksm=fdb69f58cac1164e844726bd429862eb7b38d22509eb4d1826eb851036460cb7ca5a8de7b9bb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解梯度下降法</a></p>
<p>【获取码】SIGAI0518
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484439&amp;idx=1&amp;sn=4fa8c71ae9cb777d6e97ebd0dd8672e7&amp;chksm=fdb69980cac110960e08c63061e0719a8dc7945606eeef460404dc2eb21b4f5bdb434fb56f92&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解凸优化</a></p>
<p>【获取码】SIGAI0531
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484651&amp;idx=1&amp;sn=a0e4ca5edb868fe3eae9101b71dd7103&amp;chksm=fdb6997ccac1106a61f51fe9f8fd532045cc5d13f6c75c2cbbf1a7c94c58bcdf5f2a6661facd&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解牛顿法 </a></p>
<h3 id="7-3-机器学习类"><a class="header-anchor" href="#7-3-机器学习类">¶</a>7.3 机器学习类</h3>
<p>【获取码】SIGAI0428
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483937&amp;idx=1&amp;sn=84a5acf12e96727b13fd7d456c414c12&amp;chksm=fdb69fb6cac116a02dc68d948958ee731a4ae2b6c3d81196822b665224d9dab21d0f2fccb329&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">用一张图理解SVM的脉络</a></p>
<p>【获取码】SIGAI0505
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483977&amp;idx=1&amp;sn=401b211bf72bc70f733d6ac90f7352cc&amp;chksm=fdb69fdecac116c81aad9e5adae42142d67f50258106f501af07dc651d2c1473c52fad8678c3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解神经网络的激活函数</a></p>
<p>【获取码】SIGAI0522
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484495&amp;idx=1&amp;sn=4f3a6ce21cdd1a048e402ed05c9ead91&amp;chksm=fdb699d8cac110ce53f4fc5e417e107f839059cb76d3cbf640c6f56620f90f8fb4e7f6ee02f9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【实验】理解SVM核函数和参数的作用</a></p>
<p>【获取码】SIGAI0601
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484658&amp;idx=1&amp;sn=f5c9f92c272c75883bf8e6f532559f11&amp;chksm=fdb69965cac11073f49048caef5d7b9129614090a363d9ef7f3d1b9bc59948d2217d2bca7b7b&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【群话题精华】五月集锦—机器学习和深度学习中一些值得思考的问题   </a></p>
<p>【获取码】SIGAI0602
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484692&amp;idx=1&amp;sn=9b389aa65208c778dddf17c601afbee1&amp;chksm=fdb69883cac1119593934734e94c3b71aa68de67bda8a946c1f9f9e1209c3b6f0bf18fed99b8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">大话AdaBoost算法    </a></p>
<p>【获取码】SIGAI0606
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484754&amp;idx=1&amp;sn=b2c0d6798f44e13956bb42373e51d18c&amp;chksm=fdb698c5cac111d3e3dca24c50aafbfb61e5b05c5df5b603067bb7edec8db049370b73046b24&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解主成分分析（PCA）    </a></p>
<p>【获取码】SIGAI0611
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484827&amp;idx=1&amp;sn=043d7d0159baaddfbf92ed78ee5b1124&amp;chksm=fdb6980ccac1111a9faeae7f517fee46a1dfab19612f76ccfe5417487b3f090ab8fc702d18b8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解决策树  </a></p>
<p>【获取码】SIGAI0613
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484859&amp;idx=1&amp;sn=2c4db22fb538953a62a90983e3e1f99d&amp;chksm=fdb6982ccac1113a82e92be325bb07a947d54090274654375f3b50e11e1abd809fb7358bde16&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">用一句话总结常用的机器学习算法</a></p>
<p>【获取码】SIGAI0618
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484954&amp;idx=1&amp;sn=c28b7f07c22466e91b1ef90e9dbe3ad1&amp;chksm=fdb69b8dcac1129bc6e78fca1d550e2b18238ad1c240c73b280d4e529f9f93c4626b3ac45ea2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">理解过拟合</a></p>
<p>【获取码】SIGAI0627
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485074&amp;idx=1&amp;sn=0ebf1bf8f49e9c46075fe3803d04c95d&amp;chksm=fdb69b05cac112132d280c70af3923ca4c3cccfa5fcd8628b79d4b246b3b2decbc80a180abb3&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">k近邻算法</a></p>
<p>【获取码】SIGAI0704
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485306&amp;idx=1&amp;sn=fc8cc8de313bdb61dcd39c1dedb240a4&amp;chksm=fdb69aedcac113fb4b18c74248a313536ded50bade0e66b26f332ab247b148519da71ff2a3c0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">机器学习算法地图</a></p>
<p>【获取码】SIGAI0706
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485446&amp;idx=1&amp;sn=57d7d866443810c20c4ea2c6ee8018cc&amp;chksm=fdb69591cac11c8773638b396abe43c0161e4d339f0fa845e54326be3e8c4933a3b6a2713dae&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">反向传播算法推导—全连接神经网络</a></p>
<h3 id="7-4-深度学习类"><a class="header-anchor" href="#7-4-深度学习类">¶</a>7.4 深度学习类</h3>
<p>【获取码】SIGAI0426
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483816&amp;idx=1&amp;sn=fc52765b012771d4736c9be4109f910e&amp;chksm=fdb69c3fcac115290020c3dd0d677d987086a031c1bde3429339bb3b5bbc0aa154e76325c225&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">卷积神经网络为什么能够称霸计算机视觉领域？</a></p>
<p>【获取码】SIGAI0508
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484037&amp;idx=1&amp;sn=13ad0d521b6a3578ff031e14950b41f4&amp;chksm=fdb69f12cac11604a42ccb37913c56001a11c65a8d1125c4a9aeba1aed570a751cb400d276b6&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">深度卷积神经网络演化历史及结构改进脉络-40页长文全面解读 </a></p>
<p>【获取码】SIGAI0515
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484310&amp;idx=1&amp;sn=0fc55a2784a894100a1ae64d7dbfa23d&amp;chksm=fdb69e01cac1171758cb021fc8779952e55de41032a66ee5417bd3e826bf703247e243654bd0&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">循环神经网络综述—语音识别与自然语言处理的利器</a></p>
<p>【获取码】SIGAI0625
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485042&amp;idx=1&amp;sn=cdcf8d4b07acf64c7a6f5f7c1a731a12&amp;chksm=fdb69be5cac112f377766984afb87313c1e1c58d94c80005f0f6f6af61ee5a4bd1bf6c6157b6&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">卷积神经网络的压缩与加速</a></p>
<p>【获取码】SIGAI0709
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485551&amp;idx=1&amp;sn=213f48c4e55bee688cf0731097bb832c&amp;chksm=fdb695f8cac11ceef3ef246c54d811dd64d8cc45fc75488c374c7aa95f72c1abfb55555ef0b7&amp;scene=21#wechat_redirect" target="_blank" rel="noopener"> 生成式对抗网络模型综述</a></p>
<h3 id="7-5-机器视觉类"><a class="header-anchor" href="#7-5-机器视觉类">¶</a>7.5 机器视觉类</h3>
<p>【获取码】SIGAI0420
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483726&amp;idx=1&amp;sn=9fef4cc1766ea4258749f8d40cc71a6e&amp;chksm=fdb69cd9cac115cf4eba16081780c3b64c75e1e55a40bf2782783d5c28f00c6f143426e6f0aa&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">人脸识别算法演化史</a></p>
<p>【获取码】SIGAI0424
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483731&amp;idx=1&amp;sn=237c52bc9ddfe65779b73ef8b5507f3c&amp;chksm=fdb69cc4cac115d2ca505e0deb975960a792a0106a5314ffe3052f8e02a75c9fef458fd3aca2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">基于深度学习的目标检测算法综述</a></p>
<p>【获取码】SIGAI0503
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483950&amp;idx=1&amp;sn=a3a5b7907b2552c233f654a529931776&amp;chksm=fdb69fb9cac116af5dd237cf987e56d12b0d2e54c5c565aab752f3e366c0c45bfefa76f5ed16&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">人脸检测算法综述</a></p>
<p>【获取码】SIGAI0525
<a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247483950&amp;idx=1&amp;sn=a3a5b7907b2552c233f654a529931776&amp;chksm=fdb69fb9cac116af5dd237cf987e56d12b0d2e54c5c565aab752f3e366c0c45bfefa76f5ed16&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【SIGAI综述】行人检测算法   </a></p>
<p>【获取码】SIGAI0604
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484711&amp;idx=1&amp;sn=bb7644e101b5924f54d6800b952dc3aa&amp;chksm=fdb698b0cac111a6605f5b9b6f0478bf21a8527cfad2342dbaaf624b4e9dcc43c0d85ae06deb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">FlowNet到FlowNet2.0：基于卷积神经网络的光流预测算法 </a></p>
<p>【获取码】SIGAI0608
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484784&amp;idx=1&amp;sn=ceafb54203f4e930ae457ad392b9f89c&amp;chksm=fdb698e7cac111f13d8229d7dcc00b4a7305d66de3da1bd41e7ecc1d29bfa7be520d205c53e9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">人体骨骼关键点检测综述 </a></p>
<p>【获取码】SIGAI0615
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247484909&amp;idx=1&amp;sn=c02ee17e5175230ed39ad63e73249f5c&amp;chksm=fdb6987acac1116c0108ec28424baf4ea16ca11d2b13f20d4a825d7b2b82fb8765720ebd1063&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">目标检测算法之YOLO</a></p>
<p>【获取码】SIGAI0622
​    <a href="https://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485005&amp;idx=1&amp;sn=0d4fb43b8db2a8046c64a9cfcbf3f478&amp;chksm=fdb69bdacac112cce05c8b735b4f8b1ccf2348bea55a30af2055fc328958bb8f1ffd0f819bd2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">场景文本检测——CTPN算法介绍</a></p>
<p>【获取码】SIGAI0629
​    <a href="http://mp.weixin.qq.com/s?__biz=MzU4MjQ3MDkwNA==&amp;mid=2247485142&amp;idx=1&amp;sn=c0e01da30eb5e750be453eabe4be2bf4&amp;chksm=fdb69b41cac11257ae22c7dac395e9651dab628fc35dd6d3c02d9566a8c7f5f2b56353d58a64&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">自然场景文本检测识别技术综述</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>人工智能</tag>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>《形象美学》摘录笔记</title>
    <url>/public/2019/07/21/readings/xingxiangmeixue/</url>
    <content><![CDATA[<p><strong>前言</strong></p>
<p><img src="/public/2019/07/21/readings/xingxiangmeixue/book_cover.png" alt="book_cover"></p>
<p><a href="https://book.douban.com/subject/30434860/" target="_blank" rel="noopener">《形象美学》</a>这本书是我偶然间看到的，本人很少买衣服，自认为衣品极差，被老妈诟病。以前的观点是多买，买一些品牌好的。每当要去买衣服的时候（计划一年两次），总是有很多困扰。图书馆看到此书，恰合我意，翻阅全书，或许有望提高衣品，提升人生品味了，哈哈哈。</p>
<p>此书的作者是一位研究人物形象设计的大学教师，并有着多年服装顾问的实战经验。书前四章有很多服装的基础理论，搭配等技巧，书后两章给出驭装的细节方法和一个必备的衣服仓库的采购整理建议。本博文中将整理书中的重点，供各位同好们参考。</p>
<p>此书历经10 年完成（书中官方介绍），分为<strong>塑型、悦色、妆饰、驭装、理橱、博雅</strong>六个章节。书本主要分析了衣服的材质、款式、色彩、场合，以期帮助读者从尊重、认识、爱上自己的长相与身材开始，到认识与识别商品进行实践，最终达到人衣匹配，内外合一的境界。</p>
<a id="more"></a>
<p>本博文将此书内容分为两个部分阐述。博文第一部分为塑型、悦色、妆饰、驭装，代表着从材质、款式、色彩和场合四个角度分析衣服，为衣服的基本原理；博文第二部分理橱、博雅，为实践部分，即整理衣服鞋帽，合理配置。</p>
<h2 id="一、基本理论"><a class="header-anchor" href="#一、基本理论">¶</a>一、基本理论</h2>
<p>衣服的基本理论分为材质、款式、色彩和场合四个方面。</p>
<h3 id="1-材质"><a class="header-anchor" href="#1-材质">¶</a>1. 材质</h3>
<p><strong>按面料材质分</strong>：天然纤维面料、化学纤维、混纺面料。</p>
<table>
<thead>
<tr>
<th>天然纤维面料</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>棉织物</td>
<td>易掉色</td>
<td>日常休闲、随和温柔、平实、易于亲近</td>
</tr>
<tr>
<td>麻织物</td>
<td>易折皱</td>
<td>随性率真、污垢易除</td>
</tr>
<tr>
<td>丝织物</td>
<td>比较难打理</td>
<td></td>
</tr>
<tr>
<td>毛织物</td>
<td>毛衣</td>
<td>丝毛洗涤剂</td>
</tr>
<tr>
<td>丝织物</td>
<td>少见</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>化学纤维</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>再生纤维</td>
<td>易掉色</td>
<td></td>
</tr>
<tr>
<td></td>
<td>天丝纤维</td>
<td>随性率真、污垢易除</td>
</tr>
<tr>
<td></td>
<td>莫代尔纤维</td>
<td>木材、内衣</td>
</tr>
<tr>
<td></td>
<td>醋酯纤维</td>
<td>光泽感、[天鹅绒织锦]</td>
</tr>
<tr>
<td>合成纤维</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>混纺面料</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>比如</td>
<td>毛衣</td>
<td>涤纶（30%-40%）、氨纶（3%-7%）</td>
</tr>
</tbody>
</table>
<p><strong>按纺织工艺分</strong>：梭织、针织。</p>
<table>
<thead>
<tr>
<th>纺织工艺</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>梭织</td>
<td></td>
<td>斜纹、平纹、缎纹</td>
</tr>
<tr>
<td>针织</td>
<td></td>
<td>手感好，不保形，挺括</td>
</tr>
</tbody>
</table>
<p><strong>面料档次</strong></p>
<table>
<thead>
<tr>
<th>档</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>低</td>
<td></td>
<td>普通化学</td>
</tr>
<tr>
<td>普通</td>
<td></td>
<td>棉、麻</td>
</tr>
<tr>
<td>中档</td>
<td></td>
<td>天丝、氨纶</td>
</tr>
<tr>
<td>高档</td>
<td></td>
<td>羊毛织物、桑蚕丝织物、小牛皮、小羊皮</td>
</tr>
<tr>
<td>顶级</td>
<td></td>
<td>羊绒织物、羊驼毛织物</td>
</tr>
</tbody>
</table>
<p><strong>材料小结</strong>：相近材料越轻越好（羊毛&lt;羊绒），材料对齐格子和条纹。</p>
<blockquote>
<p>Tip: 与其花便宜价钱买回一堆无用的东西，不如花一些心思在辨别服装的档次和价值上。购回衣服一定要试穿（材质和版型）。</p>
</blockquote>
<h3 id="2-款式"><a class="header-anchor" href="#2-款式">¶</a>2. 款式</h3>
<p>款式，即衣服的型。包括轮廓、量感、比例。</p>
<h4 id="2-1-轮廓"><a class="header-anchor" href="#2-1-轮廓">¶</a>2.1 轮廓</h4>
<table>
<thead>
<tr>
<th>轮廓</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>直线</td>
<td>粗：力量，霸气 细：秀气，敏锐灵动</td>
<td></td>
</tr>
<tr>
<td>直线+曲线</td>
<td></td>
<td></td>
</tr>
<tr>
<td>曲线</td>
<td>大曲线：浪漫、妩媚、经典、奢华、或熟惑。小曲线：可爱、秀美、温柔、年轻化。</td>
<td></td>
</tr>
</tbody>
</table>
<p>配饰、衣物上图案中也有直 中 曲。</p>
<ul>
<li>直线：格子、条纹、几何形。</li>
<li>中：动物纹、字母、波普艺术图案。</li>
<li>曲：波点（圆点）、花卉、波纹线，佩花纹理线</li>
</ul>
<h4 id="2-2-量感"><a class="header-anchor" href="#2-2-量感">¶</a>2.2 量感</h4>
<table>
<thead>
<tr>
<th>描述</th>
<th>面料</th>
<th>配饰</th>
</tr>
</thead>
<tbody>
<tr>
<td>重型 多变</td>
<td>牛仔布/皮革</td>
<td>夸张</td>
</tr>
<tr>
<td>适中 线形柔和</td>
<td>棉麻、针织、磨砂皮</td>
<td>适中</td>
</tr>
<tr>
<td>轻 平实 常见 变化少</td>
<td>真丝、纱、薄针织</td>
<td>小巧可爱</td>
</tr>
</tbody>
</table>
<h4 id="2-3-比例"><a class="header-anchor" href="#2-3-比例">¶</a>2.3 比例</h4>
<p><strong>服装轮廓对应身材，服装图案和装饰对应人脸。</strong></p>
<p>“型”形式美法则</p>
<ol>
<li>统一与变化</li>
<li>节奏与韵律。宽窄：上宽下窄。长短：内外。上长下短，不要一样。</li>
</ol>
<p>经典款式上融入当季流行的元素。</p>
<h3 id="3-色彩"><a class="header-anchor" href="#3-色彩">¶</a>3. 色彩</h3>
<h4 id="3-1-色彩分类"><a class="header-anchor" href="#3-1-色彩分类">¶</a>3.1 色彩分类</h4>
<table>
<thead>
<tr>
<th>色彩分类</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>无彩色</td>
<td>黑白灰</td>
<td></td>
</tr>
<tr>
<td>有彩色</td>
<td>红橙黄绿蓝紫</td>
<td>明快艳丽</td>
</tr>
<tr>
<td></td>
<td>+白</td>
<td>轻快爽朗</td>
</tr>
<tr>
<td></td>
<td>+灰</td>
<td>优雅含蓄</td>
</tr>
<tr>
<td></td>
<td>+黑</td>
<td>沉稳庄重</td>
</tr>
<tr>
<td>独立色</td>
<td>金银</td>
<td>不建议日常</td>
</tr>
</tbody>
</table>
<p><strong>色彩三要素</strong>：色相、明度（亮度）、纯色（彩度）</p>
<p>色相：基础色，色系。冷暖。 <a href="http://blog.sina.com.cn/s/blog_4b933df90102x35r.html" target="_blank" rel="noopener">伊登色相环</a> 色立体</p>
<p>明度：加白色，亮暗，浅深。</p>
<p>纯度：色彩饱和和纯净程度。常用鲜艳，浑浊或艳。鲜与灰。</p>
<blockquote>
<p>平常说的亮，指的是明度而非纯度。
色相，冷与暖；明度，亮与暗（浅与深）；纯度，鲜艳与浑浊（鲜与灰）。</p>
</blockquote>
<p><img src="/public/2019/07/21/readings/xingxiangmeixue/sexianghuan.png" alt="sexianghuan"></p>
<h4 id="3-2-肤色"><a class="header-anchor" href="#3-2-肤色">¶</a>3.2 肤色</h4>
<table>
<thead>
<tr>
<th>肤色</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>肤色色相</td>
<td>冷暖</td>
<td>冷：泛青，或黄至青灰的肤色，如小麦色，古铜色，橄榄色。暖：偏黄或偏红的肤色，如象牙色，黄橙色，咖啡色</td>
</tr>
<tr>
<td>肤色色明</td>
<td>黑白</td>
<td>高明度：偏白偏亮。低明度：偏黑偏暗。</td>
</tr>
<tr>
<td>肤色纯度</td>
<td>轻薄透明，密实紧致</td>
<td>低纯度：；皮肤较薄，晶莹剔透，面部较易泛红印。高纯度：密实紧致，给人厚重感，光泽度较强。</td>
</tr>
</tbody>
</table>
<p><a href="https://jingyan.baidu.com/article/020278116a838c1bcc9ce529.html" target="_blank" rel="noopener">肤色选颜色</a> 肤色的四季理论。此部分来自百度。</p>
<p><strong>Spring 春季型</strong></p>
<p>肤色特征：浅象牙色，暖米色，细腻而有透明感。
眼睛特征：眼珠为亮茶色，黄玉色，眼白感觉有湖兰色。
发色特征：明亮如绢的茶色，柔和的棕黄色、栗色。发质柔软。</p>
<p>春季型人的色彩搭配原则——最适合自己颜色的要点是：不能太旧，太暗。春季型人的服饰基调属于暖色系中的明亮色调，在色彩搭配上应遵循鲜明、对比的突出自己的俏丽。使用范围最广的颜色是黄色，选择红色时，以橙红、桔红为主。
特别提示：对春季型人来说，黑色是最不适合的颜色，过深过重的颜色会与春季型人白色的肌肤、飘逸的黄发出现不和谐音，会使春季型人看上去显得暗淡。春季型人的特点是明亮、鲜艳。属于春季型的人用明亮、鲜艳的颜色打扮自己，会比实际年龄显得年轻。</p>
<p><strong>Summer 夏季型</strong></p>
<p>肤色特征：粉白，乳白色皮肤，带蓝色调的褐色皮肤，小麦色皮肤。
眼睛特征：目光柔和，眼珠呈焦茶色，深棕色。
发色特征：轻柔的黑色、灰黑色，柔和的棕色或深棕色。</p>
<p>夏季型人的色彩搭配原则——拥有健康的肤色，水粉色的红晕，浅玫瑰色的嘴唇，柔软的黑发，给人以非常柔和优雅的整体印象。夏季型人适合以蓝色为底调的柔和淡雅的颜色，这样才能衬托出她们温柔、恬静的个性。夏季型人适合穿深浅不同的各种粉色、蓝色和紫色，以及有朦胧感的色调，在色彩搭配上，最好避免反差大的色调，适合在同一色相里进行浓淡搭配。</p>
<p>特别提示：选择适合自己的颜色的要点是：颜色一定要柔和、淡雅。夏季型人不适合穿黑色，过深的颜色会破坏夏季型人的柔美，可用一些浅淡的灰蓝色、蓝灰色、紫色来代替黑色。夏季型人穿灰色会非常高雅，但注意选择浅至中度的灰，但注意夏季型人不太适合藏蓝色。</p>
<p><strong>Autumn 秋季型</strong></p>
<p>肤色特征：瓷器般的象牙色皮肤，深桔色、暗驼色或黄橙色。肤色匀整，色泽偏橘，无透明感，肤质密实，肤质的纯度较高。不易出现红晕，肤色偏深，也有少部分人肤色呈现瓷器般浅象牙白色
眼睛特征：深棕色、焦茶色、眼白呈暖白色。
发色特征：有光泽的褐色、棕色或者铜色、巧克力色。</p>
<p>秋季型人的色彩搭配原则—— 是四季色中最成熟而华贵的代表，最适合的颜色是金色，苔绿色，橙色等深而华丽的颜色。选择红色时，一定要选择砖红色和与暗桔红相近的颜色。秋季型人的服饰基调是暖色系中的沉稳色调。浓郁而华丽的颜色可衬托出秋季型人成熟高贵的气质，越浑厚的颜色也越能衬托秋季型人陶瓷般的皮肤。</p>
<p>特别提示：选择适合自己的颜色的要点是：颜色要温暖，浓郁。秋季型人穿黑色会显得皮肤发黄，可用深棕色来代替。</p>
<p>最佳用色：金色，姜黄，橄榄绿，土红，土黄，咖啡色，深褐色，等浓郁而温暖的色彩。</p>
<p><strong>Winter 冬季型</strong></p>
<p>肤色特征：青白或略带橄榄色，带青色的黄褐色。冷调的看不到红晕的肤色。
眼睛特征：眼睛黑白分明，目光锐利，眼珠为深黑色，焦茶色。
发色特征：乌黑发亮，黑褐色，银灰、深酒红。</p>
<p>冬季型人的色彩搭配原则—— 最适合纯色，选择红色时，可选正红、酒红和纯正的玫瑰红。在四季颜色中，只有冬季型人最适合使用黑、纯白、灰这三种颜色，藏蓝色也是冬季型人的专利色。但在选择深重颜色的时候一定要有对比色出现。</p>
<p>特别提示：选择适合自己的颜色的要点是：颜色要鲜明，光泽度高。冬季型人着装一定要注意色彩的对比，只有对比搭配才能显得惊艳、脱俗</p>
<blockquote>
<p>如何确定自己的肤色为冷暖色？
找一个审美较好的朋友陪着去逛街，试穿五件以上不同暖色调的衣服，再试穿五件以上不同冷色调的衣服。</p>
</blockquote>
<h4 id="3-3-色彩的错觉"><a class="header-anchor" href="#3-3-色彩的错觉">¶</a>3.3 色彩的错觉</h4>
<ul>
<li>色彩的膨胀与收缩。冷，暗，低纯度收缩。暖，亮，高纯度膨胀。</li>
<li>色彩的硬和软。灰黑，深蓝，是硬朗，坚强的色彩，用于职场谈判，强调严谨，强势，理性的态度。粉红，粉黄，为相对温和柔软的色彩，与朋友约会，家庭亲子活动，强调关心，关怀。同时与面料的质感有很大关系。当然也要善用流行色。</li>
</ul>
<h4 id="3-4-衣服配色原理"><a class="header-anchor" href="#3-4-衣服配色原理">¶</a>3.4 衣服配色原理</h4>
<ol>
<li>色相和谐法。色相类似，明纯改变。冷暖一样，上明下暗。</li>
<li>明度和谐法。明度类似，色相纯度改变。上冷下暖。</li>
<li>纯度和谐法。纯度相近。色相明度不同。</li>
<li>有色彩，无彩搭配。黑白灰</li>
<li>色彩面积大小和谐法。主次，点缀。</li>
<li>色彩的呼应。A、图案与服装色彩的呼应，外花内单，外单内花，单是花中的一个颜色。花色：花卉，格子，条纹，圆点，动物纹，火腿纹，电脑抽像图。B、配饰，帽子与上衣颜色一致，领带、围巾也相呼应。</li>
<li>面料质地与色彩。同色不同质。同质不同色。</li>
<li>面料与肤质。面料粗细，与脸部很相关。</li>
</ol>
<h3 id="4-场合"><a class="header-anchor" href="#4-场合">¶</a>4. 场合</h3>
<p>TPO法则：Time Place Object。Time主要为季节。Place为地点，室内还是室外，办公场所还是在家里。Object 穿着的目的，为了什么事情而穿。接下来两个常用场景来说一说。</p>
<h4 id="职场"><a class="header-anchor" href="#职场">¶</a>职场</h4>
<p>与个人职业气质相契合，与个人年龄相契合，与工作环境、工作特点、行业要求相契合。</p>
<p>领带分为小中大结，身材瘦小适合小结，身材适中适合中结，身材高大适合大结。领结搭配礼服多一点。衬衫要过腕，斜纹代表勇敢，波纹线代表活泼跳跃，圆点代表关怀。带鞋带的皮鞋很正式。</p>
<h4 id="休闲"><a class="header-anchor" href="#休闲">¶</a>休闲</h4>
<ol>
<li>旅游：舒适。颜色红黄绿，游山玩水；颜色黑白，城市。</li>
<li>逛街，访友，约会。不穿太正式，体现自我风格。遇见春节等喜庆节日穿红色。</li>
<li>日常运动健身</li>
<li>家居：休闲家居服，睡衣。圆点卡通，有利于休息，全家尽量一致，和谐。</li>
</ol>
<h2 id="二、理橱博雅"><a class="header-anchor" href="#二、理橱博雅">¶</a>二、理橱博雅</h2>
<h3 id="衣服类别："><a class="header-anchor" href="#衣服类别：">¶</a>衣服类别：</h3>
<ol>
<li>
<p>职业装
上班或适合上班，商务，公务活动穿着的服装，多为正装，套装。</p>
</li>
<li>
<p>便装
逛街，聚会，旅行，郊游时穿着的服装，比正装、套装稍显随意，休闲些的服装。</p>
</li>
<li>
<p>家居休闲服
买菜，散步，接送孩子时穿着轻松自在的外出服。</p>
</li>
<li>
<p>运动服
打球、跑步、游泳、健身时穿着的服装，因运动的不同而具有不同功能和特性的服装。</p>
</li>
<li>
<p>礼仪服
参加典礼、庆功宴、年会、酒会，音乐会，高规格的戏剧演出等社交活动时穿着的服装。</p>
</li>
<li>
<p>睡衣
睡眠时穿着的有利于人身心放松的服装。</p>
</li>
<li>
<p>内衣</p>
</li>
</ol>
<blockquote>
<p>周一至周五的上班族，衣橱中一半为职业服，平时注意将各类服装备齐。</p>
</blockquote>
<h3 id="整理技巧"><a class="header-anchor" href="#整理技巧">¶</a>整理技巧</h3>
<ol>
<li>清理衣橱中现存的服饰，旧的打包。</li>
<li>检查衣橱中留下的服饰，检查是否污渍，掉色，掉线。</li>
<li>系统、规律地吊挂，摆放衣服饰品。比如：按 春夏 秋冬，按上下装，按功能分。</li>
</ol>
<blockquote>
<p>大而厚的衣服要用大衣架。裤子用夹。丝质用有海绵垫肩的衣架。针织服装不用吊挂，容易变形。</p>
</blockquote>
<ol start="4">
<li>为衣橱中现有的服饰做搭配。发现新搭配。</li>
<li>列出衣橱中缺少的单品清单。在搭配时发现缺少的清单。列出购物时的清单。（在商场中可以带上自己想要搭配的衣物，或者存在手机上）</li>
<li>将衣橱中的服装拍照留存，求助一些专业的朋友，或者设计师。</li>
</ol>
<blockquote>
<p>洗涤时，检查口袋！！！分开洗涤！！！
棉麻反面晒，拉平一下。
羽绒服晒到一半干，要拍打一下。
买一些合适的晾衣架。</p>
</blockquote>
<h3 id="理智购买"><a class="header-anchor" href="#理智购买">¶</a>理智购买</h3>
<ol>
<li>购买服装需定位。衣橱中缺少的是哪一种类型，哪一个季节，哪一种场合穿着的衣服鞋帽。</li>
<li>买衣之前试穿。</li>
<li>不买贵的或便宜的，只买合适的。</li>
<li>贵精不贵多，重质不重量。</li>
<li>购衣时，检查衣服。是否需要“干洗”，比如正装。颜色，条纹是否对齐，勾线齐整等等</li>
</ol>
<blockquote>
<p>怎样才能避免使白衬衫的领口，腋下因汗渍而发黄？穿衬衫前将蜡质止汗膏涂抹在衬衫领口及腋下部位，可以隔绝汗液侵蚀，延长白衬衫的寿命。油渍，用纸巾吸一下，然后用牙膏处理一哈。</p>
</blockquote>
<h3 id="博雅-明礼修身提升综合素养"><a class="header-anchor" href="#博雅-明礼修身提升综合素养">¶</a>博雅 明礼修身提升综合素养</h3>
<blockquote>
<p>“若要有优美的嘴唇，请讲亲切的话；若要有优雅的姿态，请记住走路时行人不止你一个。“
---奥黛丽·赫本</p>
</blockquote>
<p>走路可选择带节奏感的旋律，如414拍的音乐，踏着音乐不停地练习，增强走路的节奏感和律动。</p>
<p>心中盛满美好之人，脚步时轻盈的；心理盛满爱心的人，脚步是温柔的；心理盛满阳光的人，脚步是快乐的；心里盛满信念之人，步伐也会因此而变得坚定。</p>
<p>适宜香水：闻香识人，听语知人。</p>
<p>读万卷书，行万里路，与万人谈。</p>
<p>美不自美，因人而彰。</p>
<p>世物自美，需要生活的艺术家运用慧眼发现美。通过丰富多彩的载体创造美，在人和人之间传递美。</p>
<h2 id="三、总结"><a class="header-anchor" href="#三、总结">¶</a>三、总结</h2>
<p>买衣服考虑四个方面，材质（棉麻为主要）、款式（轮廓、量感、比例）、颜色（色相、明度、纯度）、场合（工作、休闲）。<a href="#%E6%95%B4%E7%90%86%E6%8A%80%E5%B7%A7">整理衣橱</a>，<a href="#%E7%90%86%E6%99%BA%E8%B4%AD%E4%B9%B0">理智购买</a>。</p>
<p><strong>最后，真诚地感谢《形象美学》的作者，黄焱冰老师！！！也希望自己有更好的衣品</strong></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>个人管理</tag>
        <tag>《形象美学》</tag>
      </tags>
  </entry>
  <entry>
    <title>茅盾文学奖、诺贝尔文学奖</title>
    <url>/public/2019/02/05/readings/nobel_maodun_literature/</url>
    <content><![CDATA[<p><strong>前言</strong>
世界和民族的优秀作品。
漫漫长路，读书成长。</p>
<h2 id="茅盾文学奖"><a class="header-anchor" href="#茅盾文学奖">¶</a>茅盾文学奖</h2>
<p><strong>第十届茅盾文学奖获奖篇目 (2015—2018)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《人世间》</td>
<td>梁晓声</td>
<td>中国青年出版社</td>
</tr>
<tr>
<td>《牵风记》</td>
<td>徐怀中</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《北上》</td>
<td>徐则臣</td>
<td>北京十月文艺出版社</td>
</tr>
<tr>
<td>《主角》</td>
<td>陈 彦</td>
<td>北京十月文艺出版社</td>
</tr>
<tr>
<td>《应物兄》</td>
<td>李 洱</td>
<td>人民文学出版社</td>
</tr>
</tbody>
</table>
<p><a href="https://mp.weixin.qq.com/s/j-siAAyFx2wa2sc4k0qZyQ" target="_blank" rel="noopener"> 中国作家网 第十届茅盾文学奖揭晓（附5位获奖作家介绍）</a></p>
<a id="more"></a>
<p><strong>第九届茅盾文学奖获奖篇目 (2011—2014)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《江南三部曲》</td>
<td>格　非</td>
<td>上海文艺出版社</td>
</tr>
<tr>
<td>《这边风景》</td>
<td>王　蒙</td>
<td>花城出版社</td>
</tr>
<tr>
<td>《生命册》</td>
<td>李佩甫</td>
<td>作家出版社</td>
</tr>
<tr>
<td>《繁花》</td>
<td>金宇澄</td>
<td>上海文艺出版社</td>
</tr>
<tr>
<td>《黄雀记》</td>
<td>苏　童</td>
<td>作家出版社</td>
</tr>
</tbody>
</table>
<p><strong>第八届茅盾文学奖获奖篇目 (2007—2010)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《你在高原》</td>
<td>张　炜</td>
<td>作家出版社</td>
</tr>
<tr>
<td>《天行者》</td>
<td>刘醒龙</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《蛙》</td>
<td>莫　言</td>
<td>上海文艺出版社</td>
</tr>
<tr>
<td>《推拿》</td>
<td>毕飞宇</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《一句顶一万句》</td>
<td>刘震云</td>
<td>长江文艺出版社</td>
</tr>
</tbody>
</table>
<p><strong>第七届茅盾文学奖获奖篇目 (2003—2006)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《秦腔》</td>
<td>贾平凹</td>
<td>作家出版社</td>
</tr>
<tr>
<td>《额尔古纳河右岸》</td>
<td>迟子建</td>
<td>北京十月文艺出版社</td>
</tr>
<tr>
<td>《湖光山色》</td>
<td>周大新</td>
<td>作家出版社</td>
</tr>
<tr>
<td>《暗算》</td>
<td>麦　家</td>
<td>世界知识出版社、人民文学出版社</td>
</tr>
</tbody>
</table>
<p><strong>第六届茅盾文学奖获奖篇目 (1999—2002)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《张居正》</td>
<td>熊召政</td>
<td>长江文艺出版社</td>
</tr>
<tr>
<td>《无字》</td>
<td>张　洁</td>
<td>北京十月文艺出版社</td>
</tr>
<tr>
<td>《历史的天空》</td>
<td>徐贵祥</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《英雄时代》</td>
<td>柳建伟</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《东藏记》</td>
<td>宗　璞</td>
<td>人民文学出版社</td>
</tr>
</tbody>
</table>
<p><strong>第五届茅盾文学奖获奖篇目 (1995—1998)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《抉择》</td>
<td>张　平</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《尘埃落定》</td>
<td>阿　来</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《长恨歌》</td>
<td>王安忆</td>
<td>作家出版社</td>
</tr>
<tr>
<td>《茶人三部曲》(一、二)</td>
<td>王旭烽</td>
<td>浙江文艺出版社</td>
</tr>
</tbody>
</table>
<p><strong>第四届茅盾文学奖获奖篇目 (1989—1994)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《战争和人》(一、二、三)</td>
<td>王　火</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《白鹿原》（修订本）</td>
<td>陈忠实</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《白门柳》(一、二)</td>
<td>刘斯奋</td>
<td>中国青年出版社</td>
</tr>
<tr>
<td>《骚动之秋》</td>
<td>刘玉民</td>
<td>人民文学出版社</td>
</tr>
</tbody>
</table>
<p><strong>第三届茅盾文学奖获奖篇目 (1985—1988)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《平凡的世界》</td>
<td>路　遥</td>
<td>中国文联出版公司</td>
</tr>
<tr>
<td>《少年天子》</td>
<td>凌　力</td>
<td>北京十月文艺出版社</td>
</tr>
<tr>
<td>《都市风流》</td>
<td>孙力、余小惠</td>
<td>浙江文艺出版社</td>
</tr>
<tr>
<td>《第二个太阳》</td>
<td>刘白羽</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《穆斯林的葬礼》</td>
<td>霍　达</td>
<td>北京十月文艺出版社</td>
</tr>
<tr>
<td>荣　誉　奖</td>
<td></td>
<td></td>
</tr>
<tr>
<td>《浴血罗霄》</td>
<td>萧　克</td>
<td>解放军文艺出版社</td>
</tr>
<tr>
<td>《金瓯缺》</td>
<td>徐兴业</td>
<td>海峡文艺出版社</td>
</tr>
</tbody>
</table>
<p><strong>第二届茅盾文学奖获奖篇目 (1982—1984)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《黄河东流去》</td>
<td>李　准</td>
<td>北京出版社</td>
</tr>
<tr>
<td>《沉重的翅膀》（修订本）</td>
<td>张　洁</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《钟鼓楼》</td>
<td>刘心武</td>
<td>人民文学出版社</td>
</tr>
</tbody>
</table>
<p><strong>第一届茅盾文学奖获奖篇目 (1977—1981)</strong></p>
<table>
<thead>
<tr>
<th>作品</th>
<th>作者</th>
<th>出版单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>《许茂和他的女儿们》</td>
<td>周克芹</td>
<td>百花文艺出版社</td>
</tr>
<tr>
<td>《东方》</td>
<td>魏　巍</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《将军吟》</td>
<td>莫应丰</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《李自成》 （第二卷）</td>
<td>姚雪垠</td>
<td>中国青年出版社</td>
</tr>
<tr>
<td>《芙蓉镇》</td>
<td>古　华</td>
<td>人民文学出版社</td>
</tr>
<tr>
<td>《冬天里的春天》</td>
<td>李国文</td>
<td>人民文学出版社</td>
</tr>
</tbody>
</table>
<h2 id="诺贝尔文学奖"><a class="header-anchor" href="#诺贝尔文学奖">¶</a>诺贝尔文学奖</h2>
<p><a href="https://zh.wikipedia.org/wiki/%E8%AB%BE%E8%B2%9D%E7%88%BE%E6%96%87%E5%AD%B8%E7%8D%8E%E5%BE%97%E4%B8%BB%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">link</a></p>
<p>2017年得主：黑石一雄</p>
<p>日裔英国作家</p>
<p>代表作：《长日留痕》《无可慰藉》《上海孤儿》《被掩埋的巨人》</p>
<p>获奖理由：他的小说带有强大的情感力量，解开了我们与世界连接的虚幻深渊。</p>
<p>2016年得主：鲍勃·迪伦</p>
<p>美国作家</p>
<p>代表作：《答案在风中飘》、《像一块滚石》、《时光慢慢流逝》</p>
<p>获奖理由：在伟大的美国民谣传统中创造出新的诗歌意境</p>
<p>2015年</p>
<p>得主：斯韦特兰娜·阿列克谢耶维奇（女）</p>
<p>白俄罗斯作家</p>
<p>代表作：《切尔诺贝利的回忆：核灾难口述史》</p>
<p>获奖理由：世界文坛最高水准的感人作品，讲述了这个时代的苦难和勇气。</p>
<p>2014年得主：帕特里克·莫迪亚诺</p>
<p>法国作家</p>
<p>代表作：《暗店街》《星形广场》《青春咖啡馆》</p>
<p>获奖理由：唤醒了对最难以捕捉的人类命运的记忆和揭露了对人类生活的占领。</p>
<p>2013年得主：艾丽斯·芒罗(女)</p>
<p>代表作：《快乐影子舞》《逃离》</p>
<p>获奖理由：当代短篇小说大师。</p>
<p>2012年得主：莫言</p>
<p>中国作家</p>
<p>代表作：《红高粱》《丰乳肥臀》《蛙》</p>
<p>获奖理由：用魔幻现实主义的写作手法，将民间故事、历史事件与当代背景融为一体。</p>
<p>2011年得主：托马斯·特兰斯特勒默</p>
<p>瑞典诗人</p>
<p>代表作：《十七首诗》《途中的秘密》</p>
<p>获奖理由：他以凝炼、简洁的形象，以全新视角带我们接触现实。</p>
<p>2010年得主：马里奥·巴尔加斯·略萨</p>
<p>秘鲁与西班牙双重国籍的作家及诗人</p>
<p>代表作：《绿房子》《世界末日之战》《城市与狗》</p>
<p>获奖理由：他“对权力结构的制图般的描绘和对个人反抗的精致描写”。</p>
<p>2009年得主：赫塔·米勒</p>
<p>罗马尼亚裔的德国女性小说家、诗人、散文家。</p>
<p>代表作：《呼吸钟摆》《河水奔流》《行走界线》《狐狸那时已是猎人》</p>
<p>获奖理由：专注于诗歌以及散文的率真，描写了失业人群的生活图景。</p>
<p>2008年得主：勒·克莱齐奥</p>
<p>代表作：《战争》</p>
<p>获奖理由：展现了新的起点、诗意的冒险和感官狂喜；作为探险者，发掘了隐藏于主流文明底部和外部的人性。</p>
<p>2007年得主：多丽丝·莱辛（女）</p>
<p>英国作家</p>
<p>代表作：《金色笔记》</p>
<p>获奖理由：她用怀疑、热情、构想的力量来审视一个分裂的文明，其作品如同一部女性经验的史诗。</p>
<p>2006年得主：奥尔罕·帕慕克</p>
<p>土耳其作家</p>
<p>代表作：《我的名字叫红》</p>
<p>获奖理由：在寻找故乡的忧郁灵魂时，发现了文化碰撞和融合中的新象征。</p>
<p>2005年得主：哈罗德·品特</p>
<p>英国剧作家。</p>
<p>代表作：《看房者》《生日晚会》《归家》</p>
<p>获奖理由：他的戏剧以诗和画的创造性，深入表现了人类长期置身其中的处境。</p>
<p>2004年得主：埃尔弗里德·耶利内克（女）</p>
<p>奥地利女作家。</p>
<p>代表作：《钢琴教师》《死者的孩子》</p>
<p>获奖理由：因为她的小说和戏剧具有音乐般的韵律，她的作品以非凡的充满激情的语言揭示了社会上的陈腐现象及其禁锢力的荒诞不经。</p>
<p>2003年得主：约翰·马克斯韦尔·库切</p>
<p>南非作家。</p>
<p>代表作：《耻》《幽暗之乡》</p>
<p>获奖理由：精准地刻画了众多假面具下的人性本质。</p>
<p>2002年得主：凯尔泰斯·伊姆雷</p>
<p>匈牙利作家。</p>
<p>代表作：《无形的命运》</p>
<p>获奖理由：表彰他对脆弱的个人在对抗强大的野蛮强权时痛苦经历的深刻刻画以及他独特的自传体文学风格。</p>
<p>2001年得主：维·苏·奈保尔</p>
<p>印度裔英国作家</p>
<p>代表作：《神秘的按摩师》《米格尔街》</p>
<p>获奖理由：其著作将极具洞察力的叙述与不为世俗左右的探索融为一体，是驱策我们从扭曲的历史中探寻真实的动力。</p>
<p>2000年得主：高行健</p>
<p>法籍华人，剧作家、小说家。</p>
<p>代表作：《灵山》</p>
<p>获奖理由：其作品的普遍价值，刻骨铭心的洞察力和语言的丰富机智，为中文小说和艺术戏剧开辟了新的道路。</p>
<p>1999年得主：君特·格拉斯</p>
<p>德国作家。</p>
<p>代表作：《铁皮鼓》</p>
<p>获奖理由：其嬉戏之中蕴含悲剧色彩的寓言描摹出了人类淡忘的历史面目。</p>
<p>1998年得主：若泽·萨拉马戈</p>
<p>葡萄牙记者、作家</p>
<p>代表作：《失明症漫记》</p>
<p>获奖理由：由于他那极富想象力、同情心和颇具反讽意味的作品,我们得以反复重温那一段难以捉摸的历史。</p>
<p>1997年得主：达里奥·福</p>
<p>意大利讽刺剧作家</p>
<p>代表作：《喜剧的神秘》《一个无政府主义者的死亡》</p>
<p>获奖理由：其在鞭笞权威，褒扬被蹂躏者可贵的人格品质方面所取得的成就堪与中世纪《弄臣》一书相媲美。</p>
<p>1996年得主：维斯瓦娃·辛波丝卡（女）</p>
<p>波兰诗人</p>
<p>代表作：《向自己提出问题》《呼唤雪人》</p>
<p>获奖理由：由于其在诗歌艺术中警辟精妙的反讽，挖掘出了人类一点一滴的现实生活背后历史更迭与生物演化的深意。</p>
<p>1995年得主：谢默斯·希尼</p>
<p>爱尔兰诗人</p>
<p>代表作：《通向黑暗之门》《在外过冬》</p>
<p>获奖理由：由于其作品洋溢着抒情之美,包容着深邃的伦理,揭示出日常生活和现实历史的奇迹。</p>
<p>1994年得主：大江健三郎</p>
<p>日本小说家</p>
<p>代表作：《个人的体验》《万延元年的足球队》</p>
<p>获奖理由：通过诗意的想象力,创造出一个把现实与神话紧密凝缩在一起的想象世界，描绘现代的芸芸众生相，给人们带来了冲击。</p>
<p>1993年得主：托妮·莫里森（女）</p>
<p>美国作家</p>
<p>代表作：《最蓝的眼睛》《所罗门之歌》</p>
<p>获奖理由：其作品想象力丰富,富有诗意，显示了美国现实生活的重要方面。</p>
<p>1992年得主：德里克·沃尔科特</p>
<p>圣卢西亚诗人</p>
<p>代表作：《西印度群岛》</p>
<p>获奖理由：他的作品具有巨大的启发性和广阔的历史视野，是其献身多种文化的结果。</p>
<p>1991年得主：纳丁·戈迪默（女）</p>
<p>南非作家</p>
<p>代表作：《七月的人民》</p>
<p>获奖理由：以强烈而直接的笔触，描写周围复杂的人际与社会关系，其史诗般壮丽的作品，对人类大有裨益。</p>
<p>1990年得主：奥克塔维奥·帕斯</p>
<p>墨西哥诗人</p>
<p>代表作：《太阳石》</p>
<p>获奖理由：他的作品充满激情，视野开阔，渗透着感悟的智慧并体现了完美的人道主义。</p>
<p>1989年得主：卡米洛·何塞·塞拉</p>
<p>代表作：《为亡灵弹奏》</p>
<p>获奖理由：带有浓郁情感的丰富而精简的描写，对人类弱点达到的令人难以企及的想象力。</p>
<p>1988年得主：纳吉布·马哈富兹</p>
<p>埃及作家。</p>
<p>代表作：《街魂》</p>
<p>获奖理由：他通过大量刻画入微的作品—洞察一切的现实主义，唤起人们树立雄心—形成了全人类所欣赏的阿拉伯语言艺术。</p>
<p>1987年得主：约瑟夫·布罗茨基</p>
<p>苏裔美籍诗人</p>
<p>代表作：《从彼得堡到斯德哥尔摩》</p>
<p>获奖理由：他的作品超越时空限制，无论在文学上或是敏感问题方面都充分显示出他广阔的思想及浓郁的诗意。</p>
<p>1986年得主：沃莱·索因卡</p>
<p>尼日利亚剧作家、诗人、小说家、评论家</p>
<p>代表作：《雄狮与宝石》</p>
<p>获奖理由：他以广博的文化视野创作了富有诗意的关于人生的戏剧。</p>
<p>1985年得主：克洛德·西蒙</p>
<p>法国小说家</p>
<p>代表作：《弗兰德公路·农事诗》</p>
<p>获奖理由：由于他善于把诗人和画家的丰富想象与深刻的时间意识融为一 体，对人类的生存状况进行了深入的描写。</p>
<p>1984年得主：雅罗斯拉夫·塞弗尔特</p>
<p>捷克诗人</p>
<p>代表作：《紫罗兰》</p>
<p>获奖理由：他的诗富于独创性、新颖、栩栩如生，表现了人的不屈不挠精神和多才多艺的渴求解放的形象。</p>
<p>1983年得主：威廉·戈尔丁</p>
<p>英国作家</p>
<p>代表作：《蝇王·金字塔》</p>
<p>获奖理由：具有清晰的现实主义叙述技巧以及虚构故事的多样性与普遍性，阐述了今日世界人类的状况。</p>
<p>1982年得主：加夫列尔·加西亚·马尔克斯</p>
<p>哥伦比亚记者、作家</p>
<p>代表作：《百年孤独》《霍乱时期的爱情》</p>
<p>获奖理由：由于其长篇小说以结构丰富的想象世界，其中糅混着魔幻与现实，反映出一整个大陆的生命矛盾。</p>
<p>1981年得主：埃利亚斯·卡内蒂</p>
<p>英国德语作家</p>
<p>代表作：《迷茫》</p>
<p>获奖理由：作品具有宽广的视野、丰富的思想和艺术力量。</p>
<p>1980年得主：切斯拉夫·米沃什</p>
<p>波兰诗人</p>
<p>代表作：《拆散的笔记簿》</p>
<p>获奖理由：不妥协的敏锐洞察力，描述了人在激烈冲突的世界中的暴露状态。</p>
<p>1979年得主：奥德修斯·埃里蒂斯</p>
<p>希腊诗人</p>
<p>代表作：《英雄挽歌》</p>
<p>获奖理由：他的诗，以希腊传统为背景，用感觉的力量和理智的敏锐，描写现代人为自由和创新而奋斗。</p>
<p>1978年得主：艾萨克·巴什维斯·辛格</p>
<p>美国作家</p>
<p>代表作：《魔术师·原野王》</p>
<p>获奖理由：他的充满激情的叙事艺术，这种既扎根于波兰人的文化传统，又反映了人类的普遍处境。</p>
<p>1977年得主：阿莱克桑德雷·梅洛</p>
<p>西班牙诗人</p>
<p>代表作：《天堂的影子》</p>
<p>获奖理由：他的作品继承了西班牙抒情诗的传统和吸取了今天流派的风格，描述了人在宇宙和当今社会中的状况。</p>
<p>1976年得主：索尔·贝娄</p>
<p>美国作家</p>
<p>代表作：《赫索格》</p>
<p>获奖理由：由于他的作品对人性的了解，以及对当代文化的敏锐透视。</p>
<p>1975年得主：埃乌杰尼奥·蒙塔莱</p>
<p>意大利诗人</p>
<p>代表作：《生活之恶》</p>
<p>获奖理由：由于他杰出的诗歌拥有伟大的艺术性，在不适合幻想的人生里，诠释了人类的价值。</p>
<p>1974年得主1：哈里·埃德蒙·马丁逊</p>
<p>瑞典诗人</p>
<p>代表作：《露珠里的世界》</p>
<p>获奖理由：他的作品透过一滴露珠反映出整个世界。</p>
<p>得主2：埃温特·约翰逊</p>
<p>瑞典作家</p>
<p>代表作：《乌洛夫的故事》</p>
<p>获奖理由：以自由为目的，而致力于历史的、现代的广阔观点之叙述艺术。</p>
<p>1973年得主：帕特里克·怀特</p>
<p>澳大利亚小说家、剧作家</p>
<p>代表作：《风暴眼》</p>
<p>获奖理由：由于他史诗与心理叙述艺术，并将一个崭新的大陆带进文学中。</p>
<p>1972年得主： 亨利希·伯尔</p>
<p>德国作家</p>
<p>代表作：《女士及众生相》</p>
<p>获奖理由：为了表扬他的作品，这些作品兼具有对时代广阔的透视和塑造人物的细腻技巧，并有助于德国文学的振兴。</p>
<p>1971年得主： 巴勃鲁·聂鲁达</p>
<p>智利诗人</p>
<p>代表作：《情诗·哀诗·赞诗》</p>
<p>获奖理由：诗歌具有自然力般的作用，复苏了一个大陆的命运与梦想。</p>
<p>1970年得主：亚历山大·索尔仁尼琴</p>
<p>苏联作家</p>
<p>代表作：《癌症楼》《古拉格群岛》</p>
<p>获奖理由：由于他作品中的道德力量，籍著它，他继承了俄国文学不可或缺的传统。</p>
<p>1969年得主：萨缪尔·贝克特</p>
<p>法国作家</p>
<p>代表作：《等待戈多》</p>
<p>获奖理由：他那具有奇特形式的小说和戏剧作品，使现代人从精神困乏中得到振奋。</p>
<p>1968年得主：川端康成</p>
<p>日本小说家</p>
<p>代表作：《雪国·千只鹤·古都》</p>
<p>获奖理由：由于他高超的叙事性作品以非凡的敏锐表现了日本人精神特质。</p>
<p>1967年得主：安赫尔·阿斯图里亚斯</p>
<p>危地马拉诗人、小说家</p>
<p>代表作：《玉米人》</p>
<p>获奖理由：因为他的作品落实于自己的民族色彩和印第安传统，而显得鲜明生动。</p>
<p>1966年得主1：奈莉·萨克斯（女）</p>
<p>瑞典诗人</p>
<p>代表作：《逃亡》</p>
<p>获奖理由：因为她杰出的抒情与戏剧作品，以感人的力量阐述了以色列的命运。</p>
<p>得主2：萨缪尔·约瑟夫·阿格农以色列作家</p>
<p>代表作：《行为之书》</p>
<p>获奖理由：他的叙述技巧深刻而独特，并从犹太民族的生命汲取主题。</p>
<p>1965年得主：米哈伊尔·亚历山大罗维奇·肖洛霍夫</p>
<p>苏联作家</p>
<p>代表作：《静静的顿河》</p>
<p>获奖理由：由于这位作家在那部关于顿河流域农村之史诗作品中所流露的活力与艺术热忱——他籍这两者在那部小说里描绘了俄罗斯民族生活之某一历史层面。</p>
<p>1964年得主：让·保罗·萨特</p>
<p>法国哲学家、作家</p>
<p>代表作：《词语》</p>
<p>获奖理由：因为他那思想丰富、充满自由气息和探求真理精神的作品对我们时代发生了深远影响。</p>
<p>1963年得主：乔治·塞菲里斯</p>
<p>希腊诗人</p>
<p>代表作：《“画眉鸟”号》</p>
<p>获奖理由：他的卓越的抒情诗作，是对希腊文化的深刻感受的产物。</p>
<p>1962年得主：约翰·斯坦贝克</p>
<p>美国作家</p>
<p>代表作：《人鼠之间》</p>
<p>获奖理由：通过现实主义的、寓于想象的创作，表现出富于同情的幽默和对社会的敏感观察。</p>
<p>1961年得主：伊沃·安德里奇</p>
<p>南斯拉夫小说家</p>
<p>代表作：《桥·小姐》</p>
<p>获奖理由：由于他作品中史诗般的力量——他籍著它在祖国的历史中追寻主题，并描绘人的命运。</p>
<p>1960年得主：圣琼·佩斯</p>
<p>法国诗人和剧作家</p>
<p>代表作：《蓝色恋歌》</p>
<p>获奖理由：由于他高超的飞越与丰盈的想象，表达了一种关于如今这个时代之富于意象的沉思。</p>
<p>1959年得主：萨瓦多尔·夸西莫多</p>
<p>意大利诗人</p>
<p>代表作：《水与土》</p>
<p>获奖理由：由于他的抒情诗，以古典的火焰表达了我们这个时代中，生命的悲剧性体验。</p>
<p>1958年得主：鲍里斯·列昂尼多维奇·帕斯捷尔纳克</p>
<p>苏联俄罗斯诗人、小说家</p>
<p>代表作：《日瓦戈医生》</p>
<p>获奖理由：在当代抒情诗和俄国的史诗传统上，他都获得了极为重大的成就。</p>
<p>1957年得主：阿尔贝·加缪</p>
<p>法国作家</p>
<p>代表作：《局外人》</p>
<p>获奖理由：由于他重要的著作，在这著作中他以明察而热切的眼光照亮了我们这时代人类良心的种种问题。</p>
<p>1956年得主：胡安·拉蒙·希梅内斯</p>
<p>西班牙诗人</p>
<p>代表作：《悲哀的咏叹调》</p>
<p>获奖理由：由于他的西班牙抒情诗，成了高度精神和纯粹艺术的最佳典范。</p>
<p>1955年得主：赫尔多尔·奇里扬·拉斯克内斯</p>
<p>冰岛作家</p>
<p>代表作：《渔家女》</p>
<p>获奖理由：为了他在作品中所流露的生动、史诗般的力量，使冰岛原已十分优秀的叙述文学技巧更加瑰丽多姿。</p>
<p>1954年得主：欧内斯特·海明威</p>
<p>美国作家</p>
<p>代表作：《老人与海》</p>
<p>获奖理由：因为他精通于叙事艺术，突出地表现于其近著《老人与海》之中；同时也因为他对当代文体风格之影响。</p>
<p>1953年得主：温斯顿·丘吉尔</p>
<p>英国政治家、历史学家、传记作家</p>
<p>代表作：《不需要的战争》</p>
<p>获奖理由：由于他在描述历史与传记方面的造诣，同时由于他那捍卫崇高的人的价值的光辉演说。</p>
<p>1952年得主：弗朗索瓦·莫里亚克</p>
<p>法国小说家</p>
<p>代表作：《爱的荒漠》</p>
<p>获奖理由：因为他在他的小说中剖析了人生的戏剧，对心灵的深刻观察和紧凑的艺术。</p>
<p>1951年得主：帕尔·费比安·拉格奎斯特</p>
<p>瑞典诗人、戏剧家、小说家</p>
<p>代表作：《大盗巴拉巴》</p>
<p>获奖理由：由于他在作品中为人类面临的永恒的疑难寻求解答所表现出的艺术活力和真正独立的见解。</p>
<p>1950年得主：帕特兰·亚瑟·威廉·罗素</p>
<p>英国数学家、哲学家</p>
<p>代表作：《哲学—数学—文学》</p>
<p>获奖理由：表彰他所写的捍卫人道主义理想和思想自由的多种多样意义重大的作品。</p>
<p>1949年得主：威廉·福克纳</p>
<p>美国作家</p>
<p>代表作：《我弥留之际》《喧哗与骚动》</p>
<p>获奖理由：因为他对当代美国小说做出了强有力的和艺术上无与伦比的贡献。</p>
<p>1948年得主：托马斯·斯特恩斯·艾略特</p>
<p>英美诗人、剧作家、批评家</p>
<p>代表作：《四个四重奏》</p>
<p>获奖理由：对于现代诗之先锋性的卓越贡献。</p>
<p>1947年得主：安德烈·纪德</p>
<p>法国作家、评论家</p>
<p>代表作：《田园交响曲》《背德者》</p>
<p>获奖理由：为了他广泛的与有艺术质地的著作，在这些著作中，他以无所畏惧的对真理的热爱，并以敏锐的心理学洞察力，呈现了人性的种种问题与处境。</p>
<p>1946年得主：赫尔曼·黑塞</p>
<p>德国作家</p>
<p>代表作：《荒原狼》</p>
<p>获奖理由：他那些灵思盎然的作品——它们一方面具有高度的创意和深刻的洞见，一方面象征古典的人道理想与高尚的风格。</p>
<p>1945年得主：加夫列拉·米斯特拉尔（女）</p>
<p>智利诗人</p>
<p>代表作：《柔情》</p>
<p>获奖理由：她那由强烈感情孕育而成的抒情诗，已经使得她的名字成为整个拉丁美洲世界渴求理想的象征。</p>
<p>1944年得主：约翰内斯·威廉·扬森</p>
<p>丹麦小说家、诗人</p>
<p>代表作：《漫长的旅行》</p>
<p>获奖理由：由于籍著丰富有力的诗意想象，将胸襟广博的求知心和大胆的、清新的创造性风格结合起来。</p>
<p>1940年-1943年   未颁奖</p>
<p>1939年得主：弗兰斯·埃米尔·西兰帕</p>
<p>芬兰作家</p>
<p>代表作：《少女西丽亚》</p>
<p>获奖理由：由于他在描绘两样互相影响的东西——他祖国的本质，以及该国农民的生活时——所表现的深刻了解与细腻艺术。</p>
<p>1938年得主：赛珍珠（女）</p>
<p>美国作家</p>
<p>代表作：《大地》三部曲</p>
<p>获奖理由：她对于中国农民生活的丰富和真正史诗气概的描述，以及她自传性的杰作。</p>
<p>1937年得主：罗杰·马丁·杜·加尔</p>
<p>法国小说家</p>
<p>代表作：《蒂伯—家》</p>
<p>获奖理由：由于在他的长篇小说《蒂伯一家》中表现出来的艺术魅力和真实性。这是对人类生活面貌的基本反映。</p>
<p>1936年得主：尤金·奥尼尔</p>
<p>美国剧作家</p>
<p>代表作：《天边外》</p>
<p>获奖理由：由于他剧作中所表现的力量、热忱与深挚的感情——它们完全符合悲剧的原始概念。</p>
<p>1935年   未颁奖</p>
<p>1934年得主：路伊吉·皮兰德娄</p>
<p>意大利说家、戏剧家</p>
<p>代表作：《寻找自我》《六个寻找剧作家的角色》</p>
<p>获奖理由：他果敢而灵巧地复兴了戏剧艺术和舞台艺术。</p>
<p>1933年得主：伊凡·亚历克塞维奇·蒲宁</p>
<p>俄国作家</p>
<p>代表作：《米佳的爱》</p>
<p>获奖理由：由于他严谨的艺术才能，使俄罗斯古典传统在散文中得到继承。</p>
<p>1932年得主：约翰·高尔斯华绥</p>
<p>英国小说家、剧作家</p>
<p>代表作：《有产者》</p>
<p>获奖理由：为其描述的卓越艺术——这种艺术在《福尔赛世家》中达到高峰。</p>
<p>1931年得主：埃利克·阿克塞尔·卡尔费尔德</p>
<p>瑞典诗人</p>
<p>代表作：《荒原和爱情》</p>
<p>获奖理由：由于他在诗作的艺术价值上，从没有人怀疑过。</p>
<p>1930年得主：辛克莱·刘易斯</p>
<p>美国作家</p>
<p>代表作：《巴比特》</p>
<p>获奖理由：由于他充沛有力、切身和动人的叙述艺术，和他以机智幽默去开创新风格的才华。</p>
<p>1929年得主：保尔·托马斯·曼</p>
<p>德国作家</p>
<p>代表作：《布登勃洛克一家》《魔山》</p>
<p>获奖理由：由于他那在当代文学中具有日益巩固的经典地位的伟大小说《布登勃洛克一家》。</p>
<p>1928年得主：西格里德·温塞特（女）</p>
<p>挪威作家</p>
<p>代表作：《新娘—主人—十字架》</p>
<p>获奖理由：主要是由于她对中世纪北国生活之有力描绘。</p>
<p>1927年得主：亨利·柏格森</p>
<p>法国哲学家</p>
<p>代表作：《创造进化论》</p>
<p>获奖理由：因为他那丰富的且充满生命力的思想，以及所表现出来的光辉灿烂的技巧。</p>
<p>1926年得主：格拉齐亚·黛莱达（女）</p>
<p>意大利作家</p>
<p>代表作：《邪恶之路》</p>
<p>获奖理由：为了表扬她由理想主义所激发的作品，以浑柔的透彻描绘了她所生长的岛屿上的生活；在洞察人类一般问题上，表现的深度与怜悯。</p>
<p>1925年得主：乔治·萧伯纳</p>
<p>爱尔兰戏剧家</p>
<p>代表作：《圣女贞德》</p>
<p>获奖理由：由于他那些充满理想主义及人情味的作品——它们那种激动性讽刺，常涵蕴着一种高度的诗意美。</p>
<p>1924年得主：弗拉迪斯拉夫·莱蒙特</p>
<p>波兰作家</p>
<p>代表作：《福地》《农夫们》</p>
<p>获奖理由：我们颁奖给他，是因为他的民族史诗《农夫们》写得很出色。</p>
<p>1923年得主：威廉·勃特勒·叶芝</p>
<p>爱尔兰诗人、剧作家</p>
<p>代表作：《丽达与天鹅》</p>
<p>获奖理由：由于他那永远充满着灵感的诗，它们透过高度的艺术形式展现了整个民族的精神。</p>
<p>1922年得主：哈辛特·贝纳文特·伊·马丁内斯</p>
<p>西班牙作家</p>
<p>代表作：《不吉利的姑娘》</p>
<p>获奖理由：由于他以适当方式，延续了戏剧之灿烂传统。</p>
<p>1921年得主：阿纳托尔·法郎士</p>
<p>法国作家、文学评论家、社会活动家</p>
<p>代表作：《苔依丝》</p>
<p>获奖理由：他辉煌的文学成就，乃在于他高尚的文体、怜悯的人道同情、迷人的魅力，以及一个真正法国性情所形成的特质。</p>
<p>1920年得主：克努特·汉姆生</p>
<p>挪威小说家、戏剧家、诗人</p>
<p>代表作：《大地硕果—畜牧曲》</p>
<p>获奖理由：为了他划时代的巨著《土地的成长》。</p>
<p>1919年得主：卡尔·施皮特勒</p>
<p>瑞士诗人、小说家</p>
<p>代表作：《奥林帕斯之春》</p>
<p>获奖理由：特别推崇他在史诗《奥林帕斯之春》的优异表现。</p>
<p>1918年  未颁奖</p>
<p>1917年得主1：亨利克·彭托皮丹</p>
<p>丹麦小说家</p>
<p>代表作：《天国》</p>
<p>获奖理由：由于他对当前丹麦生活的忠实描绘。</p>
<p>得主2：卡尔·耶勒鲁普</p>
<p>丹麦作家</p>
<p>代表作：《磨坊血案》</p>
<p>获奖理由：因为他多样而丰富的诗作——它们蕴含了高超的理想。</p>
<p>1916年得主：魏尔纳·海顿斯坦姆</p>
<p>瑞典诗人、小说家</p>
<p>代表作：《朝圣年代》</p>
<p>获奖理由：褒奖他在瑞典文学新纪元中所占之重要代表地位。</p>
<p>1915年得主：罗曼·罗兰</p>
<p>法国作家、音乐评论家</p>
<p>代表作：《约翰·克利斯朵夫》</p>
<p>获奖理由：文学作品中的高尚理想和他在描绘各种不同类型人物时所具有的同情和对真理的热爱。</p>
<p>1914年    未颁奖</p>
<p>1913年得主：罗宾德拉纳特·泰戈尔</p>
<p>印度诗人、社会活动家主</p>
<p>代表作：《吉檀枷利—饥饿石头》</p>
<p>获奖理由：由于他那至为敏锐、清新与优美的诗；这诗出之于高超的技巧，并由于他自己用英文表达出来，使他那充满诗意的思想业已成为西方文学的一部分。</p>
<p>1912年得主：盖哈特·霍普特曼</p>
<p>德国剧作家、诗人</p>
<p>代表作：《群鼠》</p>
<p>获奖理由：欲以表扬他在戏剧艺术领域中丰硕、多样的出色成就。</p>
<p>1911年得主：莫里斯·梅特林克</p>
<p>比利时剧作家、诗人、散文家</p>
<p>代表作：《花的智慧》</p>
<p>获奖理由：由于他在文学上多方面的表现，尤其是戏剧作品，不但想象丰富，充满诗意的奇想，有时虽以神话的面貌出现，还是处处充满了深刻的启示。这种启示奇妙地打动了读者的心弦，并且激发了他们的想象。</p>
<p>1910年得主：保尔·约翰·路德维希·冯·海塞</p>
<p>德国作家</p>
<p>代表作：《特雷庇姑娘》</p>
<p>获奖理由：表扬这位抒情诗人、戏剧家、小说家以及举世闻名的短篇小说家，在他漫长而多产的创作生涯中，所达到的充满理想主义精神之艺术至境。</p>
<p>1909年得主：西尔玛·拉格洛夫(女)</p>
<p>瑞典作家</p>
<p>代表作：《尼尔斯骑鹅旅行记》</p>
<p>获奖理由：由于她作品中特有的高贵的理想主义、丰富的想象力、平易而优美的风格。</p>
<p>1908年得主：鲁道尔夫·欧肯</p>
<p>德国哲学家</p>
<p>代表作：《精神生活漫笔》</p>
<p>获奖理由：他对真理的热切追求、他对思想的贯通能力、他广阔的观察，以及他在无数作品中，辩解并阐释一种理想主义的人生哲学时，所流露的热诚与力量。</p>
<p>1907年得主：约瑟夫·鲁德亚德·吉卜林</p>
<p>英国小说家、诗人</p>
<p>代表作：《老虎！老虎！》</p>
<p>获奖理由：这位世界名作家的作品以观察入微、想象独特、气概雄浑、叙述卓越见长。</p>
<p>1906年得主：乔祖埃·卡尔杜齐</p>
<p>意大利诗人、文艺批评家</p>
<p>代表作：《青春诗》</p>
<p>获奖理由：不仅是由于他精深的学识和批判性的研究，更重要是为了颂扬他诗歌杰作中所具有的特色、创作气势，清新的风格和抒情的魅力。</p>
<p>1905年得主：亨利克·显克维支</p>
<p>波兰小说家</p>
<p>代表作：《第三个女人》《你往何处去》</p>
<p>获奖理由：由于他在历史小说写作上的卓越成就。</p>
<p>1904年得主1：何塞·埃切加赖</p>
<p>西班牙戏剧家、诗人</p>
<p>代表作：《伟大的牵线人》</p>
<p>获奖理由：由于它那独特和原始风格的丰富又杰出，作品恢复了西班牙喜剧的伟大传统。</p>
<p>得主2：弗雷德里克·米斯塔尔</p>
<p>法国诗人</p>
<p>代表作：《金岛》</p>
<p>获奖理由：他的诗作蕴涵之清新创造性与真正的感召力，它忠实地反映了他民族的质朴精神。</p>
<p>1903年得主：比昂斯滕·比昂松</p>
<p>挪威戏剧家、诗人、小说家</p>
<p>代表作：《挑战的手套》</p>
<p>获奖理由：他以诗人鲜活的灵感和难得的赤子之心，把作品写得雍容、华丽而又缤纷。</p>
<p>1902年得主：特奥多尔·蒙森</p>
<p>德国历史学家</p>
<p>代表作：《罗马史》</p>
<p>获奖理由：今世最伟大的纂史巨匠，此点于其巨著《罗马史》中表露无疑。</p>
<p>1901年得主：苏利·普吕多姆</p>
<p>法国诗人</p>
<p>代表作：《孤独与深思》</p>
<p>获奖理由：是高尚的理想、完美的艺术和罕有的心灵与智慧的实证。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>文学</tag>
        <tag>信息类</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」一文看懂Linux内核！Linux内核架构和工作原理详解</title>
    <url>/public/2021/12/23/linux/linux_in_one/</url>
    <content><![CDATA[<p>全文导读</p>
<ul>
<li><a href>Linux 内核预备工作</a></li>
<li><a href>Linux 内核体系结构简析</a></li>
<li><a href>Linux 体系结构和内核结构区别</a></li>
<li><a href>Linux 驱动的 platform 机制</a></li>
<li><a href>Linux 内核体系结构</a></li>
<li><a href>内核模块</a></li>
<li><a href>Linux 内核学习经验总结</a></li>
<li><a href>结尾</a></li>
</ul>
<a id="more"></a>
<h2 id="Linux-内核预备工作"><a class="header-anchor" href="#Linux-内核预备工作">¶</a>Linux 内核预备工作</h2>
<p>理解 Linux 内核最好预备的知识点：</p>
<p>懂 C 语言<br>
懂一点操作系统的知识<br>
熟悉少量相关算法<br>
懂计算机体系结构</p>
<p>Linux 内核的特点：</p>
<p>结合了 unix 操作系统的一些基础概念</p>
<img src="/public/2021/12/23/linux/linux_in_one/174749211_2_20191103041018392.jpeg" alt="174749211_2_20191103041018392" style="zoom:50%;">
<img src="/public/2021/12/23/linux/linux_in_one/174749211_3_20191103041018455.jpeg" alt="174749211_3_20191103041018455" style="zoom:60%;">
<p>Linux 内核的任务：</p>
<ol>
<li>
<p>从技术层面讲，内核是硬件与软件之间的一个中间层。作用是将应用层序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。</p>
</li>
<li>
<p>从应用程序的层面讲，应用程序与硬件没有联系，只与内核有联系，内核是应用程序知道的层次中的最底层。在实际工作中内核抽象了相关细节。</p>
</li>
<li>
<p>内核是一个资源管理程序。负责将可用的共享资源 (CPU 时间、磁盘空间、网络连接等) 分配得到各个系统进程。</p>
</li>
<li>
<p>内核就像一个库，提供了一组面向系统的命令。系统调用对于应用程序来说，就像调用普通函数一样。<br>
内核实现策略：</p>
</li>
<li>
<p>微内核。最基本的功能由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信。</p>
</li>
<li>
<p>宏内核。内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。目前支持模块的动态装卸 (裁剪)。Linux 内核就是基于这个策略实现的。<br>
哪些地方用到了内核机制？</p>
</li>
<li>
<p>进程（在 cpu 的虚拟内存中分配地址空间，各个进程的地址空间完全独立; 同时执行的进程数最多不超过 cpu 数目）之间进行通   信，需要使用特定的内核机制。</p>
</li>
<li>
<p>进程间切换 (同时执行的进程数最多不超过 cpu 数目)，也需要用到内核机制。</p>
</li>
</ol>
<p>进程切换也需要像 FreeRTOS 任务切换一样保存状态，并将进程置于闲置状态 / 恢复状态。</p>
<ol start="3">
<li>
<p>进程的调度。确认哪个进程运行多长的时间。<br>
Linux 进程</p>
</li>
<li>
<p>采用层次结构，每个进程都依赖于一个父进程。内核启动 init 程序作为第一个进程。该进程负责进一步的系统初始化操作。init 进程是进程树的根，所有的进程都直接或者间接起源于该进程。</p>
</li>
<li>
<p>通过 pstree 命令查询。实际上得系统第一个进程是 systemd，而不是 init（这也是疑问点）</p>
</li>
<li>
<p>系统中每一个进程都有一个唯一标识符 (ID), 用户（或其他进程）可以使用 ID 来访问进程。</p>
</li>
</ol>
<p>Linux 内核源代码的目录结构</p>
<p>Linux 内核源代码包括三个主要部分：</p>
<ol>
<li>
<p>内核核心代码，包括第 3 章所描述的各个子系统和子模块，以及其它的支撑子系统，例如电源管理、Linux 初始化等</p>
</li>
<li>
<p>其它非核心代码，例如库文件（因为 Linux 内核是一个自包含的内核，即内核不依赖其它的任何软件，自己就可以编译通过）、固件集合、KVM（虚拟机技术）等</p>
</li>
<li>
<p>编译脚本、配置文件、帮助文档、版权说明等辅助性文件</p>
</li>
</ol>
<p>使用 ls 命令看到的内核源代码的顶层目录结构，具体描述如下。</p>
<p>include/ ---- 内核头文件，需要提供给外部模块（例如用户空间代码）使用。</p>
<p>kernel/ ---- Linux 内核的核心代码，包含了 3.2 小节所描述的进程调度子系统，以及和进程调度相关的模块。</p>
<p>mm/ ---- 内存管理子系统（3.3 小节）。</p>
<p>fs/ ---- VFS 子系统（3.4 小节）。</p>
<p>net/ ---- 不包括网络设备驱动的网络子系统（3.5 小节）。</p>
<p>ipc/ ---- IPC（进程间通信）子系统。</p>
<p>arch// ---- 体系结构相关的代码，例如 arm, x86 等等。<br>
    arch//mach- ---- 具体的 machine/board 相关的代码。<br>
    arch//include/asm ---- 体系结构相关的头文件。<br>
    arch//boot/dts ---- 设备树（Device Tree）文件。</p>
<p>init/ ---- Linux 系统启动初始化相关的代码。<br>
block/ ---- 提供块设备的层次。<br>
sound/ ---- 音频相关的驱动及子系统，可以看作 “音频子系统”。<br>
drivers/ ---- 设备驱动（在 Linux kernel 3.10 中，设备驱动占了 49.4 的代码量）。</p>
<p>lib/ ---- 实现需要在内核中使用的库函数，例如 CRC、FIFO、list、MD5 等。<br>
crypto/ ----- 加密、解密相关的库函数。<br>
security/ ---- 提供安全特性（SELinux）。<br>
virt/ ---- 提供虚拟机技术（KVM 等）的支持。<br>
usr/ ---- 用于生成 initramfs 的代码。<br>
firmware/ ---- 保存用于驱动第三方设备的固件。</p>
<p>samples/ ---- 一些示例代码。<br>
tools/ ---- 一些常用工具，如性能剖析、自测试等。</p>
<p>Kconfig, Kbuild, Makefile, scripts/ ---- 用于内核编译的配置文件、脚本等。</p>
<p>COPYING ---- 版权声明。<br>
MAINTAINERS ---- 维护者名单。<br>
CREDITS ---- Linux 主要的贡献者名单。<br>
REPORTING-BUGS ---- Bug 上报的指南。</p>
<p>Documentation, README ---- 帮助、说明文档。</p>
<h2 id="Linux-内核体系结构简析"><a class="header-anchor" href="#Linux-内核体系结构简析">¶</a>Linux 内核体系结构简析</h2>
<p><img src="/public/2021/12/23/linux/linux_in_one/174749211_4_20191103041018502.jpeg" alt="174749211_4_20191103041018502"></p>
<p>图 1 Linux 系统层次结构</p>
<p>最上面是用户（或应用程序）空间。这是用户应用程序执行的地方。用户空间之下是内核空间，Linux 内核正是位于这里。GNU C Library （glibc）也在这里。它提供了连接内核的系统调用接口，还提供了在用户空间应用程序和内核之间进行转换的机制。这点非常重要，因为内核和用户空间的应用程序使用的是不同的保护地址空间。每个用户空间的进程都使用自己的虚拟地址空间，而内核则占用单独的地址空间。</p>
<p>Linux 内核可以进一步划分成 3 层。最上面是系统调用接口，它实现了一些基本的功能，例如 read 和 write。系统调用接口之下是内核代码，可以更精确地定义为独立于体系结构的内核代码。这些代码是 Linux 所支持的所有处理器体系结构所通用的。在这些代码之下是依赖于体系结构的代码，构成了通常称为 BSP（Board Support Package）的部分。这些代码用作给定体系结构的处理器和特定于平台的代码。</p>
<p>Linux 内核实现了很多重要的体系结构属性。在或高或低的层次上，内核被划分为多个子系统。Linux 也可以看作是一个整体，因为它会将所有这些基本服务都集成到内核中。这与微内核的体系结构不同，后者会提供一些基本的服务，例如通信、I/O、内存和进程管理，更具体的服务都是插入到微内核层中的。每种内核都有自己的优点，不过这里并不对此进行讨论。</p>
<p>随着时间的流逝，Linux 内核在内存和 CPU 使用方面具有较高的效率，并且非常稳定。但是对于 Linux 来说，最为有趣的是在这种大小和复杂性的前提下，依然具有良好的可移植性。Linux 编译后可在大量处理器和具有不同体系结构约束和需求的平台上运行。一个例子是 Linux 可以在一个具有内存管理单元（MMU）的处理器上运行，也可以在那些不提供 MMU 的处理器上运行。</p>
<p>Linux 内核的 uClinux 移植提供了对非 MMU 的支持。</p>
<p>图 2 是 Linux 内核的体系结构</p>
<p><img src="/public/2021/12/23/linux/linux_in_one/174749211_5_20191103041018549.jpeg" alt="174749211_5_20191103041018549"></p>
<p>图 2 Linux 内核体系结构</p>
<p>Linux 内核的主要组件有：系统调用接口、进程管理、内存管理、虚拟文件系统、网络堆栈、设备驱动程序、硬件架构的相关代码。</p>
<p>（1）系统调用接口</p>
<p>SCI 层提供了某些机制执行从用户空间到内核的函数调用。正如前面讨论的一样，这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。SCI 实际上是一个非常有用的函数调用多路复用和多路分解服务。在 ./linux/kernel 中您可以找到 SCI 的实现，并在 ./linux/arch 中找到依赖于体系结构的部分。</p>
<p>（2）进程管理</p>
<p>进程管理的重点是进程的执行。在内核中，这些进程称为线程，代表了单独的处理器虚拟化（线程代码、数据、堆栈和 CPU 寄存器）。在用户空间，通常使用进程 这个术语，不过 Linux 实现并没有区分这两个概念（进程和线程）。内核通过 SCI 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSIX] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSIX 机制）。</p>
<p>进程管理还包括处理活动进程之间共享 CPU 的需求。内核实现了一种新型的调度算法，不管有多少个线程在竞争 CPU，这种算法都可以在固定时间内进行操作。这种算法就称为 O(1) 调度程序，这个名字就表示它调度多个线程所使用的时间和调度一个线程所使用的时间是相同的。O(1) 调度程序也可以支持多处理器（称为对称多处理器或 SMP）。您可以在 ./linux/kernel 中找到进程管理的源代码，在 ./linux/arch 中可以找到依赖于体系结构的源代码。</p>
<p>（3）内存管理</p>
<p>内核所管理的另外一个重要资源是内存。为了提高效率，如果由硬件管理虚拟内存，内存是按照所谓的内存页 方式进行管理的（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。</p>
<p>（4）虚拟文件系统</p>
<p>虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 SCI 和内核所支持的文件系统之间提供了一个交换层（请参看图 4）。</p>
<p><img src="/public/2021/12/23/linux/linux_in_one/174749211_6_20191103041018596.jpeg" alt="174749211_6_20191103041018596"></p>
<p>图 3 Linux 文件系统层次结构</p>
<p>在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。它们是给定文件系统（超过 50 个）的插件。文件系统的源代码可以在 ./linux/fs 中找到。文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集（与具体文件系统无关）。这个缓存层通过将数据保留一段时间（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。</p>
<p>（5）网络堆栈</p>
<p>网络堆栈在设计上遵循模拟协议本身的分层体系结构。回想一下，Internet Protocol (IP) 是传输协议（通常称为传输控制协议或 TCP）下面的核心网络层协议。TCP 上面是 socket 层，它是通过 SCI 进行调用的。socket 层是网络子系统的标准 API，它为各种网络协议提供了一个用户接口。从原始帧访问到 IP 协议数据单元（PDU），再到 TCP 和 User Datagram Protocol (UDP)，socket 层提供了一种标准化的方法来管理连接，并在各个终点之间移动数据。内核中网络源代码可以在 ./linux/net 中找到。</p>
<p>（6）设备驱动程序</p>
<p>Linux 内核中有大量代码都在设备驱动程序中，它们能够运转特定的硬件设备。Linux 源码树提供了一个驱动程序子目录，这个目录又进一步划分为各种支持设备，例如 Bluetooth、I2C、serial 等。设备驱动程序的代码可以在 ./linux/drivers 中找到。</p>
<p>（7）依赖体系结构的代码</p>
<p>尽管 Linux 很大程度上独立于所运行的体系结构，但是有些元素则必须考虑体系结构才能正常操作并实现更高效率。./linux/arch 子目录定义了内核源代码中依赖于体系结构的部分，其中包含了各种特定于体系结构的子目录（共同组成了 BSP）。对于一个典型的桌面系统来说，使用的是 x86 目录。每个体系结构子目录都包含了很多其他子目录，每个子目录都关注内核中的一个特定方面，例如引导、内核、内存管理等。这些依赖体系结构的代码可以在 ./linux/arch 中找到。</p>
<p>如果 Linux 内核的可移植性和效率还不够好，Linux 还提供了其他一些特性，它们无法划分到上面的分类中。作为一个生产操作系统和开源软件，Linux 是测试新协议及其增强的良好平台。Linux 支持大量网络协议，包括典型的 TCP/IP，以及高速网络的扩展（大于 1 Gigabit Ethernet [GbE] 和 10 GbE）。Linux 也可以支持诸如流控制传输协议（SCTP）之类的协议，它提供了很多比 TCP 更高级的特性（是传输层协议的接替者）。</p>
<p>Linux 还是一个动态内核，支持动态添加或删除软件组件。被称为动态可加载内核模块，它们可以在引导时根据需要（当前特定设备需要这个模块）或在任何时候由用户插入。</p>
<p>Linux 最新的一个增强是可以用作其他操作系统的操作系统（称为系统管理程序）。最近，对内核进行了修改，称为基于内核的虚拟机（KVM）。这个修改为用户空间启用了一个新的接口，它可以允许其他操作系统在启用了 KVM 的内核之上运行。除了运行 Linux 的其他实例之外， Microsoft Windows 也可以进行虚拟化。惟一的限制是底层处理器必须支持新的虚拟化指令。</p>
<h2 id="Linux-体系结构和内核结构区别"><a class="header-anchor" href="#Linux-体系结构和内核结构区别">¶</a>Linux 体系结构和内核结构区别</h2>
<p>1．当被问到 Linux 体系结构（就是 Linux 系统是怎么构成的）时，我们可以参照下图这么回答：<br>
从大的方面讲，Linux 体系结构可以分为两块：<br>
（1）用户空间：用户空间中又包含了，用户的应用程序，C 库<br>
（2）内核空间：内核空间包括，系统调用，内核，以及与平台架构相关的代码</p>
<p><img src="/public/2021/12/23/linux/linux_in_one/174749211_7_20191103041018642.jpeg" alt="174749211_7_20191103041018642"></p>
<p>2．Linux 体系结构要分成用户空间和内核空间的原因：</p>
<p>1）现代 CPU 通常都实现了不同的工作模式。</p>
<p>以 ARM 为例：ARM 实现了 7 种工作模式，不同模式下 CPU 可以执行的指令或者访问的寄存器不同：<br>
（1）用户模式  usr<br>
（2）系统模式  sys<br>
（3）管理模式  svc<br>
（4）快速中断  fiq<br>
（5）外部中断  irq<br>
（6）数据访问终止 abt<br>
（7）未定义指令异常</p>
<p>以（2）X86 为例：X86 实现了 4 个不同级别的权限，Ring0—Ring3 ;Ring0 下可以执行特权指令，可以访问 IO 设备；Ring3 则有很多的限制</p>
<p>2）所以，Linux 从 CPU 的角度出发，为了保护内核的安全，把系统分成了 2 部分；</p>
<p>3．用户空间和内核空间是程序执行的两种不同状态，我们可以通过 “系统调用” 和“硬件中断“来完成用户空间到内核空间的转移</p>
<p>4．Linux 的内核结构（注意区分 LInux 体系结构和 Linux 内核结构）</p>
<p><img src="/public/2021/12/23/linux/linux_in_one/174749211_8_20191103041018705.jpeg" alt="174749211_8_20191103041018705"></p>
<h2 id="Linux-驱动的-platform-机制"><a class="header-anchor" href="#Linux-驱动的-platform-机制">¶</a>Linux 驱动的 platform 机制</h2>
<p>Linux 的这种 platform driver 机制和传统的 device_driver 机制相比，一个十分明显的优势在于 platform 机制将本身的资源注册进内核，由内核统一管理，在驱动程序中使用这些资源时通过 platform_device 提供的标准接口进行申请并使用。这样提高了驱动和资源管理的独立性，并且拥有较好的可移植性和安全性。下面是 SPI 驱动层次示意图，Linux 中的 SPI 总线可理解为 SPI 控制器引出的总线：</p>
<p><img src="/public/2021/12/23/linux/linux_in_one/174749211_9_20191103041018752.jpeg" alt="174749211_9_20191103041018752"></p>
<p>和传统的驱动一样，platform 机制也分为三个步骤：</p>
<p>1、总线注册阶段：</p>
<p>内核启动初始化时的 main.c 文件中的 kernel_init()→do_basic_setup()→driver_init()→platform_bus_init()→bus_register(&amp;platform_bus_type)，注册了一条 platform 总线（虚拟总线，platform_bus）。</p>
<p>2、添加设备阶段：</p>
<p>设备注册的时候 Platform_device_register()→platform_device_add()→(pdev→dev.bus = &amp;platform_bus_type)→device_add()，就这样把设备给挂到虚拟的总线上。</p>
<p>3、驱动注册阶段：</p>
<p>Platform_driver_register()→driver_register()→bus_add_driver()→driver_attach()→bus_for_each_dev(), 对在每个挂在虚拟的 platform bus 的设备作__driver_attach()→driver_probe_device(), 判断 drv→bus→match() 是否执行成功，此时通过指针执行 platform_match→strncmp(pdev→name , drv→name , BUS_ID_SIZE), 如果相符就调用 really_probe(实际就是执行相应设备的 platform_driver→probe(platform_device)。) 开始真正的探测，如果 probe 成功，则绑定设备到该驱动。</p>
<p>从上面可以看出，platform 机制最后还是调用了 bus_register() , device_add() , driver_register() 这三个关键的函数。</p>
<p>下面看几个结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span>           </span></span><br><span class="line"><span class="class">(/<span class="title">include</span>/<span class="title">linux</span>/<span class="title">Platform_device</span>.<span class="title">h</span>)</span></span><br><span class="line"><span class="class">&#123;</span>        </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>    * name;        </span><br><span class="line"><span class="keyword">int</span>        id;        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span>    <span class="title">dev</span>;</span>        </span><br><span class="line">u32        num_resources;        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span>    * <span class="title">resource</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Platform_device 结构体描述了一个 platform 结构的设备，在其中包含了一般设备的结构体 struct device  dev; 设备的资源结构体 struct resource   * resource; 还有设备的名字 const char * name。（注意，这个名字一定要和后面 platform_driver.driver àname 相同，原因会在后面说明。）</p>
<p>该结构体中最重要的就是 resource 结构，这也是之所以引入 platform 机制的原因。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span>                            </span></span><br><span class="line"><span class="class">( /<span class="title">include</span>/<span class="title">linux</span>/<span class="title">ioport</span>.<span class="title">h</span>)</span></span><br><span class="line"><span class="class">&#123;</span>        </span><br><span class="line"><span class="keyword">resource_size_t</span> start;        </span><br><span class="line"><span class="keyword">resource_size_t</span> end;        </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;        </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">parent</span>, *<span class="title">sibling</span>, *<span class="title">child</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">其中 flags位表示该资源的类型，start和end分别表示该资源的起始地址和结束地址(/include/linux/Platform_device.h)：</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span>              </span></span><br><span class="line"><span class="class">&#123;</span>        </span><br><span class="line"><span class="keyword">int</span> (*probe)(struct platform_device *);        </span><br><span class="line"><span class="keyword">int</span> (*remove)(struct platform_device *);        </span><br><span class="line"><span class="keyword">void</span> (*shutdown)(struct platform_device *);        </span><br><span class="line"><span class="keyword">int</span> (*suspend)(struct platform_device *, <span class="keyword">pm_message_t</span> state);        </span><br><span class="line"><span class="keyword">int</span> (*suspend_late)(struct platform_device *, <span class="keyword">pm_message_t</span> state);        </span><br><span class="line"><span class="keyword">int</span> (*resume_early)(struct platform_device *);        </span><br><span class="line"><span class="keyword">int</span> (*resume)(struct platform_device *);        </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_driver</span> <span class="title">driver</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line">Platform_driver结构体描述了一个platform结构的驱动。其中除了一些函数指针外，还有一个一般驱动的device_driver结构。</span><br></pre></td></tr></table></figure>
<p>名字要一致的原因：</p>
<p>上面说的驱动在注册的时候会调用函数 bus_for_each_dev(), 对在每个挂在虚拟的 platform bus 的设备作__driver_attach()→driver_probe_device(), 在此函数中会对 dev 和 drv 做初步的匹配，调用的是 drv-&gt;bus-&gt;match 所指向的函数。platform_driver_register 函数中 drv-&gt;driver.bus = &amp;platform_bus_type，所以 drv-&gt;bus-&gt;match 就为 platform_bus_type→match, 为 platform_match 函数，该函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">platform_match</span><span class="params">(struct device * dev, struct device_driver * drv)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">pdev</span> = <span class="title">container_of</span>(<span class="title">dev</span>, <span class="title">struct</span> <span class="title">platform_device</span>, <span class="title">dev</span>);</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">strncmp</span>(pdev-&gt;name, drv-&gt;name, BUS_ID_SIZE) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是比较 dev 和 drv 的 name，相同则会进入 really_probe（）函数，从而进入自己写的 probe 函数做进一步的匹配。所以 dev→name 和 driver→drv→name 在初始化时一定要填一样的。</p>
<p>不同类型的驱动，其 match 函数是不一样的，这个 platform 的驱动，比较的是 dev 和 drv 的名字，还记得 usb 类驱动里的 match 吗？它比较的是 Product ID 和 Vendor ID。</p>
<p>个人总结 Platform 机制的好处：</p>
<p>1、提供 platform_bus_type 类型的总线，把那些不是总线型的 soc 设备都添加到这条虚拟总线上。使得，总线——设备——驱动的模式可以得到普及。</p>
<p>2、提供 platform_device 和 platform_driver 类型的数据结构，将传统的 device 和 driver 数据结构嵌入其中，并且加入 resource 成员，以便于和 Open Firmware 这种动态传递设备资源的新型 bootloader 和 kernel 接轨。</p>
<h2 id="Linux-内核体系结构"><a class="header-anchor" href="#Linux-内核体系结构">¶</a>Linux 内核体系结构</h2>
<p>因为 Linux 内核是单片的，所以它比其他类型的内核占用空间最大，复杂度也最高。这是一个设计特性，在 Linux 早期引起了相当多的争论，并且仍然带有一些与单内核固有的相同的设计缺陷。</p>
<img src="/public/2021/12/23/linux/linux_in_one/174749211_10_20191103041018783.jpeg" alt="174749211_10_20191103041018783" style="zoom:50%;">
<p>为了解决这些缺陷，Linux 内核开发人员所做的一件事就是使内核模块可以在运行时加载和卸载，这意味着您可以动态地添加或删除内核的特性。这不仅可以向内核添加硬件功能，还可以包括运行服务器进程的模块，比如低级别虚拟化，但也可以替换整个内核，而不需要在某些情况下重启计算机。<br>
想象一下，如果您可以升级到 Windows 服务包，而不需要重新启动……</p>
<h2 id="内核模块"><a class="header-anchor" href="#内核模块">¶</a>内核模块</h2>
<p>如果 Windows 已经安装了所有可用的驱动程序，而您只需要打开所需的驱动程序怎么办? 这本质上就是内核模块为 Linux 所做的。内核模块，也称为可加载内核模块 (LKM)，对于保持内核在不消耗所有可用内存的情况下与所有硬件一起工作是必不可少的。</p>
<p><img src="/public/2021/12/23/linux/linux_in_one/174749211_11_20191103041018908.jpeg" alt="174749211_11_20191103041018908"></p>
<p>模块通常向基本内核添加设备、文件系统和系统调用等功能。lkm 的文件扩展名是. ko，通常存储在 / lib/modules 目录中。由于模块的特性，您可以通过在启动时使用 menuconfig 命令将模块设置为 load 或 not load，或者通过编辑 / boot/config 文件，或者使用 modprobe 命令动态地加载和卸载模块，轻松定制内核。</p>
<p>第三方和封闭源码模块在一些发行版中是可用的，比如 Ubuntu，默认情况下可能无法安装，因为这些模块的源代码是不可用的。该软件的开发人员 (即 nVidia、ATI 等) 不提供源代码，而是构建自己的模块并编译所需的. ko 文件以便分发。虽然这些模块像 beer 一样是免费的，但它们不像 speech 那样是免费的，因此不包括在一些发行版中，因为维护人员认为它通过提供非免费软件 “污染” 了内核。</p>
<p>内核并不神奇，但对于任何正常运行的计算机来说，它都是必不可少的。Linux 内核不同于 OS X 和 Windows，因为它包含内核级别的驱动程序，并使许多东西 “开箱即用”。希望您能对软件和硬件如何协同工作以及启动计算机所需的文件有更多的了解。</p>
<h2 id="Linux-内核学习经验总结"><a class="header-anchor" href="#Linux-内核学习经验总结">¶</a>Linux 内核学习经验总结</h2>
<h3 id="开篇"><a class="header-anchor" href="#开篇">¶</a>开篇</h3>
<p>学习内核，每个人都有自己的学习方法，仁者见仁智者见智。以下是我在学习过程中总结出来的东西，对自身来说，我认为比较有效率，拿出来跟大家交流一下。</p>
<p>内核学习，一偏之见；疏漏难免，恳请指正。</p>
<h3 id="为什么写这篇博客"><a class="header-anchor" href="#为什么写这篇博客">¶</a>为什么写这篇博客</h3>
<p>刚开始学内核的时候，不要执着于一个方面，不要专注于一个子系统就一头扎到实际的代码行中去，因为这样的话，牵涉的面会很广，会碰到很多困难，容易产生挫败感，一个函数体中（假设刚开始的时候正在学习某个方面的某个具体的功能函数）很可能掺杂着其他各个子系统方面设计理念（多是大量相关的数据结构或者全局变量，用于支撑该子系统的管理工作）下相应的代码实现，这个时候看到这些东西，纷繁芜杂，是没有头绪而且很不理解的，会产生很多很多的疑问，（这个时候如果对这些疑问纠缠不清，刨根问底，那么事实上就是在学习当前子系统的过程中频繁的去涉足其他子系统，这时候注意力就分散了），而事实上等了解了各个子系统后再回头看这些东西的话，就简单多了，而且思路也会比较清晰。所以，要避免 “只见树木，不见森林”，不要急于深入到底层代码中去，不要过早研究底层代码。</p>
<p>我在大二的时候刚开始接触内核，就犯了这个错误，一头扎到内存管理里头，去看非常底层的实现代码，虽然也是建立在内存管理的设计思想的基础上，但是相对来说，比较孤立，因为此时并没有学习其它子系统，应该说无论是视野还是思想，都比较狭隘，所以代码中牵涉到的其它子系统的实现我都直接跳过了，这一点还算聪明，当然也是迫不得已的。</p>
<h3 id="我的学习方法"><a class="header-anchor" href="#我的学习方法">¶</a>我的学习方法</h3>
<p>刚开始，我认为主要的问题在于你知道不知道，而不是理解不理解，某个子系统的实现采用了某种策略、方法，而你在学习中需要做的就是知道有这么一回事儿，然后才是理解所描述的策略或者方法。</p>
<p>根据自己的学习经验，刚开始学习内核的时候，我认为要做的是在自己的脑海中建立起内核的大体框架，理解各个子系统的设计理念和构建思想，这些理念和思想会从宏观上呈献给你清晰的脉络，就像一个去除了枝枝叶叶的大树的主干，一目了然；当然，肯定还会涉及到具体的实现方法、函数，但是此时接触到的函数或者方法位于内核实现的较高的层次，是主（要）函数，已经了解到这些函数，针对的是哪些设计思想，实现了什么样的功能，达成了什么样的目的，混个脸熟的说法在这儿也是成立的。至于该主函数所调用的其它的辅助性函数就等同于枝枝叶叶了，不必太早就去深究。此时，也就初步建立起了内核子系统框架和代码实现之间的关联，关联其实很简单，比如一看到某个函数名字，就想起这个函数是针对哪个子系统的，实现了什么功能。</p>
<p>我认为此时要看的就是 LKD3，这本书算是泛泛而谈，主要就是从概念，设计，大的实现方法上描述各个子系统，而对于具体的相关的函数实现的代码讲解很少涉及 (对比于 ULK3，此书主要就是关于具体函数代码的具体实现的深入分析，当然，你也可以看，但是过早看这本书，会感觉很痛苦，很枯燥无味，基本上都是函数的实现)，很少，但不是没有，这就很好，满足我们当前的需求，还避免我们过早深入到实际的代码中去。而且本书在一些重要的点上还给出了写程序时的注意事项，算是指导性建议。主要的子系统包括：内存管理，进程管理和调度，系统调用，中断和异常，内核同步，时间和定时器管理，虚拟文件系统，块 I/O 层，设备和模块。（这里的先后顺序其实就是 LKD3 的目录的顺序）。</p>
<p>我学习的时候是三本书交叉着看的，先看 LKD3，专于一个子系统，主要就是了解设计的原理和思想，当然也会碰到对一些主要函数的介绍，但大多就是该函数基于前面介绍的思想和原理完成了什么样的功能，该书并没有就函数本身的实现进行深入剖析。然后再看 ULK3 和 PLKA 上看同样的子系统，但是并不仔细分析底层具体函数的代码，只是粗略地、不求甚解地看，甚至不看。因为，有些时候，在其中一本书的某个点上，卡壳了，不是很理解了，在另外的书上你可能就碰到对同一个问题的不同角度的描述，说不准哪句话就能让你豁然开朗，如醍醐灌顶。我经常碰到这种情况。</p>
<p>并不是说学习过程中对一些函数体的实现完全就忽略掉，只要自己想彻底了解其代码实现，没有谁会阻止你。我是在反复阅读过程中慢慢深入的。比如 VFS 中文件打开需要对路径进行分析，需要考虑的细节不少 (.././ 之类的)，但是其代码实现是很好理解的。再比如，CFS 调度中根据 shedule latency、队列中进程个数及其 nice 值(使用的是动态优先级) 计算出分配给进程的时间片，没理由不看的，这个太重要了，而且也很有意思。</p>
<p>ULK3 也会有设计原理与思想之类的概括性介绍，基本上都位于某个主题的开篇段落。但是更多的是对支持该原理和思想的主要函数实现的具体分析，同样在首段，一句话综述函数的功能，然后对函数的实现以 1、2、3，或者 a、b、c 步骤的形式进行讲解。我只是有选择性的看，有时候对照着用 source insight 打开的源码，确认一下代码大体上确实是按书中所描述的步骤实现的，就当是增加感性认识。由于步骤中掺杂着各种针对不同实现目的安全性、有效性检查，如果不理解就先跳过。这并不妨碍你对函数体功能实现的整体把握。</p>
<p>PLKA 介于 LKD3 和 ULK3 之间。我觉得 PLKA 的作者（看照片，真一德国帅小伙，技术如此了得）肯定看过 ULK，无论他的本意还是有意，总之 PLKA 还是跟 ULK 有所不同，对函数的仔细讲解都做补充说明，去掉函数体中边边角角的情况，比如一些特殊情况的处理，有效性检查等，而不妨碍对整个函数体功能的理解，这些他都有所交代，做了声明；而且，就像 LKD3 一样，在某些点上也给出了指导性编程建议。作者们甚至对同一个主要函数的讲解的着重点都不一样。这样的话，对我们学习的人而言，有助于加深理解。另外，我认为很重要的一点就是 PLKA 针对的 2.6.24 的内核版本，而 ULK 是 2.6.11，LKD3 是 2.6.34。在某些方面 PLKA 比较接近现代的实现。其实作者们之所以分别选择 11 或者 24，都是因为在版本发行树中，这两个版本在某些方面都做了不小的变动，或者说是具有标志性的转折点（这些信息大多是在书中的引言部分介绍的，具体的细节我想不起来了）。</p>
<p>Intel V3，针对 X86 的 CPU，本书自然是系统编程的权威。内核部分实现都可以在本书找到其根源。所以，在读以上三本书某个子系统的时候，不要忘记可以在 V3 中相应章节找到一些基础性支撑信息。</p>
<p>在读书过程中，会产生相当多的疑问，这一点是确信无疑的。大到搞不明白一个设计思想，小到不理解某行代码的用途。各个方面，各种疑问，你完全可以把不理解的地方都记录下来 (不过，我并没有这么做，没有把疑问全部记下来，只标记了很少一部分我认为很关键的几个问题)，专门写到一张纸上，不对，一个本上，我确信会产生这么多的疑问，不然内核相关的论坛早就可以关闭了。其实，大部分的问题（其中很多问题都是你知道不知道有这么一回事的问题）都可以迎刃而解，只要你肯回头再看，书读百遍，其义自现。多看几遍，前前后后的联系明白个七七八八是没有问题的。我也这么做了，针对某些子系统也看了好几遍，切身体会。</p>
<p>当你按顺序学习这些子系统的时候，前面的章节很可能会引用后面的章节，就像 PLKA 的作者说的那样，完全没有向后引用是不可能的，他能做的只是尽量减少这种引用而又不损害你对当前问题的理解。不理解，没关系，跳过就行了。后面的章节同样会有向前章节的引用，不过这个问题就简单一些了 ，你可以再回头去看相应的介绍，当时你不太理解的东西，很可能这个时候就知道了它的设计的目的以及具体的应用。不求甚解只是暂时的。比如说，内核各个子系统之间的交互和引用在代码中的体现就是实现函数穿插调用，比如你在内存管理章节学习了的内存分配和释放的函数，而你是了解内存在先的，在学习驱动或者模块的时候就会碰到这些函数的调用，这样也就比较容易接受，不至于太过茫然；再比如，你了解了系统时间和定时器的管理，再回头看中断和异常中 bottom half 的调度实现，你对它的理解就会加深一层。</p>
<p>子系统进行管理工作需要大量的数据结构。子系统之间交互的一种方式就是各个子系统各自的主要数据结构通过指针成员相互引用。学习过程中，参考书上在讲解某个子系统的时候会对数据结构中主要成员的用途解释一下，但肯定不会覆盖全部（成员比较多的情况，例如 task_struct），对其它子系统基于某个功能实现的引用可能解释了，也可能没做解释，还可能说这个变量在何处会做进一步说明。所以，不要纠结于一个不理解的点上，暂且放过，回头还可以看的。之间的联系可以在对各个子系统都有所了解之后再建立起来。其实，我仍然在强调先理解概念和框架的重要性。</p>
<p>等我们完成了建立框架这一步，就可以选择一个比较感兴趣的子系统，比如驱动、网络，或者文件系统之类的。这个时候你再去深入了解底层代码实现，相较于一开始就钻研代码，更容易一些，而且碰到了不解之处，或者忘记了某个方面的实现，此时你完全可以找到相应的子系统，因为你知道在哪去找，查漏补缺，不仅完成了对当前函数的钻研，而且可以回顾、温习以前的内容，融会贯通的时机就在这里了。</p>
<p>《深入理解 linux 虚拟内存》(2.4 内核版本)，LDD3，《深入理解 linux 网络技术内幕》，几乎每一个子系统都需要一本书的容量去讲解，所以说，刚开始学习不宜对某个模块太过深入，等对各个子系统都有所了解了，再有针对性的去学习一个特定的子系统。这时候对其它系统的援引都可以让我们不再感到茫然、复杂，不知所云。</p>
<p>比如，LDD3 中的以下所列章节：构造和运行模块，并发和竞态，时间、延迟及延缓操作, 分配内存，中断处理等，都属于驱动开发的支撑性子系统，虽说本书对这些子系统都专门开辟一个章节进行讲解，但是详细程度怎么能比得上 PLKA，ULK3，LKD3 这三本书，看完这三本书，你会发现读 LDD3 这些章节的时候简直跟喝白开水一样，太随意了，因为 LDD3 的讲解比之 LKD3 更粗略。打好了基础，PCI、USB、TTY 驱动，块设备驱动，网卡驱动，需要了解和学习的东西就比较有针对性了。这些子系统就属于通用子系统，了解之后，基于这些子系统的子系统的开发—驱动 (需进一步针对硬件特性) 和网络(需进一步理解各种协议)—相对而言，其学习难度大大降低，学习进度大大加快，学习效率大大提升。说着容易做来难。达到这样一种效果的前提就是：必须得静下心来，认真读书，要看得进去，PLKA，ULK3 厚得都跟砖头块儿一样，令人望之生畏，如果没有兴趣，没有热情，没有毅力，无论如何都是不行，因为需要时间，需要很长时间。我并不是说必须打好了基础才可以进行驱动开发，只是说打好了基础的情况下进行开发会更轻松，更有效率，而且自己对内核代码的驾驭能力会更强大。这只是我个人见解，我自己的学习方式，仅供参考。</p>
<h3 id="语言"><a class="header-anchor" href="#语言">¶</a>语言</h3>
<p>PLKA 是个德国人用德语写的，后来翻译成英文，又从英文翻译成中文，我在网上书店里没有找到它的纸质英文版，所以就买了中文版的。ULK3 和 LKD3 都是英文版的。大牛们写的书，遣词造句真的是简洁，易懂，看原版对我们学习计算机编程的程序员来说完全不成问题，最好原汁原味。如果一本书确实翻译地很好，我们当然可以看中文版的，用母语进行学习，理解速度和学习进度当然是很快的，不作他想。看英文的时候不要脑子里想着把他翻译成中文，没必要。</p>
<h3 id="API-感想"><a class="header-anchor" href="#API-感想">¶</a>API 感想</h3>
<p>“比起知道你所用技术的重要性，成为某一个特别领域的专家是不重要的。知道某一个具体 API 调用一点好处都没有，当你需要他的时候只要查询下就好了。” 这句话源于我看到的一篇翻译过来的博客。我想强调的就是，这句话针应用型编程再合适不过，但是内核 API 就不完全如此。</p>
<p>内核相当复杂，学习起来很不容易，但是当你学习到一定程度，你会发现，如果自己打算写内核代码，到最后要关注的仍然是 API 接口，只不过这些 API 绝大部分是跨平台的，满足可移植性。内核黑客基本上已经标准化、文档化了这些接口，你所要做的只是调用而已。当然，在使用的时候，最好对可移植性这一话题在内核中的编码约定烂熟于心，这样才会写出可移植性的代码。就像应用程序一样，可以使用开发商提供的动态库 API，或者使用开源 API。同样是调用 API，不同点在于使用内核 API 要比使用应用 API 了解的东西要多出许多。</p>
<p>当你了解了操作系统的实现—这些实现可都是对应用程序的基础性支撑啊—你再去写应用程序的时候，应用程序中用到的多线程，定时器，同步锁机制等等等等，使用共享库 API 的时候，联系到操作系统，从而把对该 API 的文档描述同自己所了解到的这些方面在内核中的相应支撑性实现结合起来进行考虑，这会指导你选择使用哪一个 API 接口，选出效率最高的实现方式。对系统编程颇有了解的话，对应用编程不无益处，甚至可以说是大有好处。</p>
<h3 id="设计实现的本质，知道还是理解"><a class="header-anchor" href="#设计实现的本质，知道还是理解">¶</a>设计实现的本质，知道还是理解</h3>
<p>操作系统是介于底层硬件和应用软件之间的接口，其各个子系统的实现很大程度上依赖于硬件特性。书上介绍这些子系统的设计和实现的时候，我们读过了，也就知道了，如果再深入考虑一下，为什么整体架构要按照这种方式组织，为什么局部函数要遵循这样的步骤处理，知其然，知其所以然，如果你知道了某个功能的实现是因为芯片就是这么设计的，CPU 就是这么做的，那么你的疑问也就基本上到此为止了。再深究，就是芯片架构方面的设计与实现，对于程序员来讲，无论是系统还是应用程序员，足迹探究到这里，已经解决了很多疑问，因为我们的工作性质偏软，而这些东西实在是够硬。</p>
<p>比如，ULK3 中讲解的中断和异常的实现，究其根源，那是因为 Intel x86 系列就是这么设计的，去看看 Intel V3 手册中相应章节介绍，都可以为 ULK3 中描述的代码实现方式找到注解。还有时间和定时器管理，同样可以在 Intel V3 对 APIC 的介绍中获取足够的信息，操作系统就是依据这些硬件特性来实现软件方法定义的。</p>
<p>又是那句话，不是理解不理解的问题，而是知道不知道的问题。有时候，知道了，就理解了。在整个学习过程中，知道，理解，知道，理解，知道……，交叉反复。为什么开始和结尾都是知道，而理解只是中间步骤呢？世界上万事万物自有其规律，人类只是发现而已，实践是第一位的，实践就是知道的过程，实践产生经验，经验的总结就是理论，理论源于实践，理论才需要理解。我们学习内核，深入研究，搞来搞去，又回到了芯片上，芯片是物质的，芯片的功用基于自然界中物质本有的物理和电子特性。追本溯源，此之谓也。</p>
<h3 id="动手写代码"><a class="header-anchor" href="#动手写代码">¶</a>动手写代码</h3>
<p>纸上得来终觉浅，绝知此事要躬行。只看书是绝对不行的，一定要结合课本给出的编程建议自己敲代码。刚开始就以模块形式测试好了，或者自己编译一个开发版本的内核。一台机器的话，使用 UML 方式调试，内核控制路走到哪一步，单步调试看看程序执行过程，比书上的讲解更直观明了。一定要动手实际操作。</p>
<p>参考书</p>
<p>LDD3          Linux Device Driver 3rd</p>
<p>LKD3          Linux Kernel Development 3rd</p>
<p>ULK3          Understanding the Linux Kernel 3rd</p>
<p>PLKA          Professional Linux Kernel Architecture</p>
<p>UML            User Mode Linux</p>
<p>Intel V3       Intel? 64 and IA-32 Architectures Software Developer’s Manual Volume 3 (3A, 3B &amp; 3C): System Programming Guide</p>
<p>作者在写书的时候，都是以自己的理解组织内容，从自己的观点看待一个主题，关注点跟作者自身有很大的关系。出书的时间有先后，后来人针对同一个主题想要出书而又不落入窠臼，最好有自己的切入方式，从自己的角度讲解相关问题，这才值得出这本书，千篇一律是个掉价的行为，书就不值钱了。</p>
<p>尽信书不如无书。</p>
<p><a href="http://lwn.net/Articles/419855/" target="_blank" rel="noopener">http://lwn.net/Articles/419855/</a> 此处是一篇关于 LKD3 的书评，指出了其中的错误，当你读完的时候，不妨去找找，看一下自己在其中所描述的地方有什么特别的印象。</p>
<p><a href="http://lwn.net/Articles/161190" target="_blank" rel="noopener">http://lwn.net/Articles/161190</a> / 此处是一篇对 ULK3 的介绍，我认为其中很关键的几句话就可以给本书定位：</p>
<blockquote>
<p>Many of the key control paths in the kernel are described, step by step;</p>
<p>一步一步地讲述内核控制路径的实现。</p>
<p>The level of detail sometimes makes it hard to get a sense for the big picture, but it does help somebody trying to figure out how a particular function works.</p>
<p>对代码讲解的详细程度有时候很难让读者把握住它的主旨大意，但是确实有助于读者理解一个特定的函数到底是如何工作的。</p>
<p>Indeed, that is perhaps the key feature which differentiates this book. It is very much a “how it works” book, designed to help people understand the code.</p>
<p>事实上，这也正是本书与众不同的地方。更像一个 “如何工作” 的书，帮助读者理解代码实现。</p>
<p>It presents kernel functions and data structures, steps the reader through them, but does not, for example, emphasize the rules for using them. UTLK is a study guide, not a programming manual.</p>
<p>本书描述了内核函数和数据结构，引导读者穿行于其间，但是，并没有着重强调使用它们的法则。UTLK 是一本学习指南，而不是编程手册。</p>
</blockquote>
<p>这几句话对本书的描述非常到位。基于此，作为指导性原则，我们就可以很有效率地使用它了。</p>
<p>看一本技术书籍，书中的序言部分绝对是首先应该翻阅的，其次就是目录。我发现在阅读过程中我会频繁的查看目录，甚至是喜欢看目录。</p>
<h2 id="结尾"><a class="header-anchor" href="#结尾">¶</a>结尾</h2>
<p>兴趣的力量是无穷的。兴趣能带来激情，如果工作可以和兴趣结合到一起，工作起来才会有热情，那么工作就不只是工作了，更是一种享受。</p>
<p>Linux，我的兴趣，我的动力，我的方向，我的未来！</p>
<h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2>
<p>图片来自：<a href="http://www.360doc.com/content/19/1103/16/36367108_870849346.shtml" target="_blank" rel="noopener">link</a>
部分文章来自：<a href="http://www.openpcba.com/web/contents/get?id=4638&amp;tid=15" target="_blank" rel="noopener">link</a> 已失效</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」琉璃易碎，人言易坠——关于《莺莺传》的叙事</title>
    <url>/public/2017/04/14/readings/yingyingzhuan/</url>
    <content><![CDATA[<blockquote>
<p>《西厢记》的书评:『琉璃易碎，人言易坠——关于《莺莺传》的叙事』转载
…全文:<a href="https://www.douban.com/doubanapp/dispatch?uri=/review/1200691/" target="_blank" rel="noopener">(豆瓣link)</a></p>
</blockquote>
<p>“半欲天明半未明，醉闻花气睡闻莺。 狌儿撼起钟声动，二十年来晓寺情。 ”男人四十的元微之写着酸酸的诗，回忆年少风流。假如我是元微之，我一定会这般写道：天空尚未亮透，微微透着点光，远处传来钟声，让我的思绪一下子回忆到二十年前，也是这样的一个早晨，在那所古寺的西厢，那个散发着鲜花一样香气的女子，用鸟儿般宛转的声音在我耳边低语：“钟声响了，想来我也该回去了。”那声音一直萦绕在耳边，十年、二十年、也许一辈子在我在记忆深处响起……。</p>
<a id="more"></a>
<p>夜宿古刹，偶遇佳人，相伴遥夜，缠绵缱绻，天明而别。这样的际遇，是最最典型的古代书生的爱情幻想。在一个陌生的地方，遇到一个陌生人，发生一段有始无终的感情。书生注定要做个过客，一生漂泊在对那个女子的思念中，却没有勇气长相守。</p>
<p>当我还是一个初中生的时候，我买来人民文学出版社的《西厢记》，上面盖本教科书，堂而皇之的上课看。但是很快，除了王实甫那华丽的辞藻，整个大团圆的故事构架让我兴趣索然，而前言里现代人给它冠上的什么“礼教叛逆者反抗封建卫道士”的宏大内涵更让我倒尽胃口。</p>
<p>在书后还附着元稹的《莺莺传》。《莺莺传》所描写的其实只是两个人的故事，两个恋爱的人后来分开的故事，没有太宏大的叙事，没有那些官腔的说教和露骨的批判。这样的故事是我所喜的；这样的故事，也是中国文人所津津乐道的。关于类似内容的作品也就汗牛充栋，数不胜数。或许从《诗经》的“氓之蚩蚩，抱布贸丝”开始，就没有谁打算给自己的爱情故事赋予太宏大的命题，只是后来的人突然犯失心疯，发现了字里行间的微言大义。所以我很景仰孔夫子他老人家，他的《论语》里每一个字都可以养活一大批的圣贤大师。</p>
<p>元稹的这篇传奇被人考据出是以自己为原型的故事，是一篇忏悔录。忏悔的味道我闻不出来，但是众前辈大师言之凿凿说张生便是元大才子，那我也就相信了罢。</p>
<p>《莺莺传》的开头，交代道“在贞元年间，有位张生，他性格温和而富有感情，风度潇洒，容貌漂亮，意志坚强，脾气孤僻”。古人向来有画脸谱的习惯，只要不是丑的太离谱，一般的名士贤臣都被描写成“性温茂，美风容”之类。但是据说元稹的家族是著名的鲜卑拓跋，鲜卑人的美貌是相当出名的，就好象现在说日本人长的猥亵一样出名，所以我有理由相信，元稹在这点上也许没有吹牛。</p>
<p>文章写道“以是年二十三，未尝近女色”，后面他自己解释道“登徒子非好色者，是有凶行；余真好色者，而适不我值。何以言之？大凡物之尤者，未尝不留连于心，是知其非忘情者也”，就仿佛现在的大学男生在卧谈会上被迫承认自己二十三岁高龄还是个处男，被人取笑之下只好解释“其实我哪里是没能力啊，我只是没遇到真正让我心动的；一般的庸脂俗粉我看不上眼，要是真有出类拔萃的，我也会追的。我是谈感情的，和你们玩肉体的垃圾是不一样的”诸如此类。但是考察元稹的家庭情况，他八岁丧父，在家族里又被同父异母的兄弟欺凌，从小随着母亲投奔舅氏，生活贫困，母亲教她念书。我们可以想象，一个幼年便寄人篱下，遭受贫困欺凌的味道，他只比林黛玉多了一个母亲而已，但是林黛玉在物质生活上绝对比他适意。我们的脑海里可以浮现这样一个人物性格：幼年丧父的人，对于男人所称道的齐家治国平天下之类的宏伟功名有着不同于常人的热情和执著，范仲淹就是很好的例子，所以元稹在事业上一直很上进努力，为达目的不惜代价不择手段，由于尝尽人情冷暖世态炎凉，他很敏感，这样的人物让我想到了《红与黑》里的主人公于连；他自幼由一个母亲抚养成人，一般这样的人具有恋母情结，对于女性有异于常人的喜好，所以他的性格里又有滥情懦弱的一面。多情和薄幸，坚毅和懦弱，正义和无耻都矛盾地体现在他身上，这也就能让我们更好的理解他后来为了追求功名而抛弃莺莺的举动了。由于家境贫寒，极端律己，自卑和敏感的元微之“内秉坚孤，非礼不可入”，就算偶尔参加朋友一起的游宴——古人的游宴和现在去歌舞厅唱歌跳舞一样，一般都安排了色情服务——“扰杂其间，他人皆汹汹拳拳，若将不及”，而他“容顺而已，终不能乱”。我不清楚他是不是冬天还要帮别人洗衣服赚钱，但是可以肯定他不会参与打牌这样不合礼仪的活动，所以也就不会有谁去污蔑他打牌作弊，不会有“樗蒲不胜，槌杀四生”的惨剧了。</p>
<p>在这里他第一次提到“物之尤者”，后面他还有段很著名的话也提到“尤物”，为自己抛弃莺莺的行为做解释“大凡天之所命尤物也，不妖其身，必妖于人”。如此看来，仿佛我们的元大才子是个叶公好龙式的人物，这边在说假如能遇到尤物一定会动真情，那边厢却在说尤物不害她自身，必定祸害他人。没有得到的时候千方百计的追求，到手以后又不迭地甩掉去追求新的目标。人总是这样矛盾的动物，永远不明白自己所追求的到底是什么。我们知道最后元稹娶了豪门韦家的女儿为妻，使得他在仕途平步青云。于此，我们不妨看成是理智和情欲的对立，一边是代表事业投机的豪门韦家联姻的机会，而一边只是爱过的漂亮的女子，理智告诉他应该离开那个女子，但是情欲却欲罢不能，但是最后我们知道理智战胜了情欲，感情只好盘踞在文字里去凭吊，所以元微之为我们贡献了很多首脍炙人口的情诗。</p>
<p>后来，张生，也就是元稹路过蒲州，搭救了寄住在普救寺的崔家寡妇一家。“是岁，浑瑊薨于蒲，有中人丁文雅，不善于军，军人因丧而扰，大掠蒲人。……先是张与蒲将之党有善，请吏护之，遂不及于难。十余日，廉使杜确将天子命以总戎节，令于军，军由是戢。”据《旧唐书·德宗纪》，贞元十五年十二月，河中绛州节度使浑瑊卒，以同州刺史杜确为河中尹、河中绛州观察使。元稹在贞元九年举明经科，并于贞元十五年在河中府任卑职，所以他和蒲将之党有交情，打个招呼关照一下也在情理之中；但据唐代举士制度，士之及第者还需要经过吏部考试才能正式任命官职，所以我们可以推测出在贞元十五年年底的时候，元稹便上路去长安应考，于是在蒲州遇上了莺莺一家。</p>
<p>我们知道这篇传奇是有虚构的成分，就如元稹在里边成了张君瑞，但是有一点细节仍然需要注意的，就是莺莺家族的姓氏。在唐朝时候，年轻人普遍的梦想有两个，金榜题名，娶七姓女；就如同现在的大学生的梦想，考上公务员，讨个有钱人做老婆。娶个有钱人做老婆可以少奋斗十年，这是基于现实利益的考量，而娶七姓女等于瞬间提升了自身家族的社会层次，也是基于现实利益的考量。在中国人的现实生活里，找不到“爱情”这两个字--有时候看历史真的会看到掩卷叹息，中国人过了几千年，还是一点长进都没有啊。唐代的士族世家已经逐渐没落，但是依然地位显赫，其中以陇西李氏、太原王氏、荥阳郑氏、范阳卢氏、清河崔氏、博陵崔氏、赵郡李氏等七姓十族最为著名，一般这些世家大族互为婚姻，自惜羽毛。唐高宗时宰相李义府为子向山东士族求婚不遂，而向朝廷建议禁止七姓十族自为婚姻。可见娶个望族女子为妻，是多么的艰难啊。莺莺是姓崔的，而且“财产甚厚，多奴仆”，很自然的就联想到了清河崔氏、博陵崔氏这些世家大族；但是很奇怪的是元稹描写的张生居然抛弃了莺莺，一个出身寒族的士子抛弃了一个那么美貌温柔的世家女子，仅仅只为了他自己所谓的“予之德不足以胜妖孽，是用忍情”么？考察元某人在政治上趋炎附势的态度，我是不相信他冠冕堂皇的话的。姑且让我用自己邪恶的想法去揣测他：那个被唤作莺莺的女子必定不是什么世家望族，所以元稹为了前途而抛弃了她，之所以故意写成崔氏，只是制造了一种假象，让读者有个印象那个莺莺是世家女子，我元微之离开她只是因为好男儿不该沉溺于爱情，你看为了理想我连世家女都放弃了啊。这便是文人的下作！</p>
<p>为了答谢这位刚认的远亲的救命之恩，于是请吃饭，贞元十五年十二月很快就在危机中渡过，这顿饭的时间也应该在贞元十六年的春天。当贞元十五年的大门“咣当”一声关掉，命运就载着我们的主人公来到了贞元十六年。饭局中张生曾问莺莺的年纪，“郑曰：‘今天子甲子岁之七月，终今贞元庚辰，生年十七矣。’”贞元庚辰，正是贞元十六年，那年元稹二十二岁，莺莺十七岁。</p>
<p>拿破仑指示说“请客的菜一定要好”，这个世间有好多的阴谋和决策在餐桌上议定，有好多缠绵或者惨烈的故事由餐桌上发端。郑国的子宋因为吃饭的时候分不到王八汤，结果一怒就干掉了郑灵公；而我们的张生，也就是元微之同学因为吃饭认识了莺莺姑娘。这表明吃饭是一次冒险，运气好的可以吃出一段情缘，运气不好的就要丢了性命，所以列位正要去吃饭相亲的同学们，你们要小心啊。</p>
<p>吃饭的时候，郑氏让儿子、女儿出来拜会救命恩人。那时侯未出阁的女子特别是大户人家的女子仿佛家之重宝，秘不见人；而郑氏却突然在一个年轻的刚认识不久的远房亲戚面前把女儿拉出来亮相，还要陪吃饭，哪怕这个年轻是救命恩人，这样的行为也是很突兀的，所以莺莺才会推三阻四的不想出来见面。郑氏这般的举动连一千多年后的我也想入非非，无疑也给了元稹兄弟很多假设的可能。不论当初的郑氏出于什么样的考虑做了这个决定，反正莺莺姑娘就此登场了。第一次召唤推说有疾，郑氏看起来很生气的说“张兄保尔之命，不然，尔且掳矣，能复远嫌乎”，这其中的话外之音，只能读者自己体会了。又过了很久，莺莺终于出场了。</p>
<p>“常服睟容，不加新饰，垂鬟接黛，双脸销红而已。颜色艳异，光辉动人”，简直惊为天人啊。我们很可以理解元稹的心情，在记忆里，那个已经离开的初恋情人总是最美丽的，而那第一次的见面总是浪漫得无法言说，第一眼里情人的样貌也是美艳不可方物。但是假如当时有照相的话，看到莺莺的照片也许你会失望，那个时代普遍流行的美女的体态是肥胖丰满的，那个时代美女的画像普遍有双下巴（有些是三下巴或者更多），面颊鼓鼓外凸，因为胖所以嘴巴也被挤的小小的嘟起来，实乃人间惨剧，竟无语凝噎！幸好莺莺不加新饰，保持了一点自然状态，否则那个惨白的面容、用红颜料描出的樱桃小嘴、脸上贴的花状的金钿和浓晕蛾翅眉足足可以把你吓死。</p>
<p>后面一句话很有意思：“张惊，为之礼。”张生看到莺莺那么漂亮，忙起来对她行礼。这个描写很传神，一般男子看到普通的女子，都保持一点点的风度，淡淡的仿佛视若不见；惟独见到美女，眼睛一亮，慌忙起身行礼，态度谦恭。足见莺莺之美。后来她坐到郑氏旁边，因为是郑氏强迫她出见的，所以她“凝睇怨绝，若不胜其体者”，那个样子就是《喜剧之王》里张柏芝所谓的“鹌鹑状”。如此楚楚动人的姿势，叫张生魂不守舍。问了年纪，只有十七岁，正是花季过后，果季之前，鲜脆欲滴，天真纯情的年纪啊！张生想和她找话题说话，但是莺莺就是不理睬他，一直到吃完饭也没有什么好说的。记得以前去参加一个朋友生日活动，饭桌遇上了朋友的表妹，也是一样的年轻明艳，也是一样的不理睬人，和她搭讪也装做没听见，搞得我们很没有面子，所以说，古往今来的好女孩一般都是很矜持的。由于没有机会接触，张生的思念就象潮水一样把他包围，所以他捉摸着要找个机会表白一下。</p>
<p>于是他从莺莺的小伙伴，侍女红娘那边入手。这个策略在以后的无数次实践当中被证明是极端正确的。大学里你要追求某个女生，先要从她寝室的室友下手，打通所有关节，请他们吃喝玩乐，最后那个女孩子身边所有的朋友都在说你好话，那你就成功一大半了。红娘被张生吓了一跳，问了个问题：“你既然那么喜欢，何不凭借你对我们家的恩情向夫人正式提亲呢（何不因其德而求娶焉）？”张生回答的话简直有点无耻了：“我从孩童时候起，性情就不随便附合。有时和妇女们在一起，也不曾看过谁。当年不肯做的事，如今到底还是在习惯上做不来。昨天在宴会上，我几乎不能控制自己。这几天来，走路忘了到什么地方去，吃饭也感觉不出饱还是没饱。恐怕过不了早晚，我就会因相思而死了。如果通过媒人去娶亲，又要‘纳采’，又要‘问名’，手续多得很，少说也得三四个月，那时恐我也就不会在人世了。你说我该怎么办呢？（余始自孩提，性不苟合。或时纨绮闲居，曾莫流盼。不为当年，终有所蔽。昨日一席间，几不自持。数日来，行忘止，食忘饱，恐不能逾旦暮。若因媒氏而娶，纳采问名，则三数月间，索我于枯鱼之肆矣。尔其谓我何？）”先吹捧自己性格不随便，然后表明见到莺莺姑娘连这样的性情也抛掉了，再不快点接近自己，就挂掉了，哪有时间挺到纳采问名啊。我从来不知道爱一个人，居然连三四个月都无法等待，这是赤裸裸的情欲，而非爱情；张生的第一目标是得到莺莺，而非和她相爱。情欲是正常的，但是不正常的是张生光明正大的以自己的情欲作为接近的借口，在一套绚丽机巧的辞藻下，其实裹挟着的不过是阿Q对吴妈的那句“我要跟你困觉”！</p>
<p>但是也许张生妇女工作做的好，红娘还真的帮他出主意，让他摇动笔杆。想来那时躲在深闺的大家闺秀并不知道外边文青的名声有多臭，结果一场悲剧上演了。</p>
<p>亚里士多德《诗学》言道：“性格为悲剧六大要素之一。”毫无疑问，莺莺的性格决定了她的悲剧结局。在她的身上我们看到矜持和热情，顺从和叛逆，坚定和认命矛盾的结合在了一起。前面我们已经注意到莺莺出场时的矜持，和在她母亲召唤下不肯出来见面的叛逆，但是当她看了张生的情诗之后却用那首暧昧的《明月三五夜》作为回应，把张生招来相见。“待月西厢下，迎风户半开。拂墙花影动，疑是玉人来。”这诗不论莺莺怎么强调“犹惧兄之见难,是用鄙靡之词，以求其必至”,都无法掩盖字里行间的情意和期盼。</p>
<p>二月十五的晚上，月亮大的吓人,文学青年元稹踏着美丽的月色，攀着墙边的杏花树翻过墙头投奔他的初恋去了。他来到西厢房,却只看到红娘躺在床上，双方都很奇怪。在红娘通报后，莺莺姑娘这才出现了。可能原本元大才子准备着类似“长夜漫漫，无心睡眠，没想到莺莺姑娘你也睡不着”之类的桥段，可是如此以来完全用不上了，而且莺莺姑娘一身包裹严实，表情严肃，狠狠地训斥了他一顿，然后扬长而去。元大才子只好承认都是月亮惹的祸，那样的月色太美太温柔，于是绝望了。元稹没有写他失恋后寻死觅活，更不像他自己说的“索之于枯鱼之肆”。但是很吊诡的是三天后莺莺就自荐枕席了。鉴于这段情节的突兀，《董解元西厢记诸宫调》里就设计了张生患相思病，莺莺探病的情节，王实甫也继承发扬了这段情节。这段情节看似让整个的故事情节更加合理，也让人物性格和心理有一定的起承转合，但其实是画蛇添足的一笔。</p>
<p>莺莺是一个性格矛盾的人，她对待未知的将来既期待又恐惧，她知道自己所做的是不容于世的，但是她对于爱情满怀憧憬而渴望冒险。在爱情的冲动下，她一步步滑向张生的怀抱。也许从第一次出来见这个救命恩人的时候，她便已经心存好感，起码我们知道张生的相貌世让人赏心悦目，这是爱情的基础；当看到张生的两首诗，更加倾慕于他。唐代的女孩子也和现在的女孩子一样，有自己心目中的白马王子。也许那个时代比较流行的梦中情人形象，就是元稹这样的才子。于是她情不自禁回了一首诗，也许只是想见他一面，但是理智告诉她这样做法的危险性。也许在红娘去通报的时候，她还在那里犹豫到底要不要去见。最后她决定去看一眼那个自己衷情的男子，她穿戴齐整。当爱上一个男人的女子，在那个男人面前总是很低很低,低到尘埃里,尘埃里便开出花来，于是她潜意识的想保持自己的尊严，她不想被他看成是轻薄的女子。她终于见到了他，在月色下，俊朗的男子期盼地看着自己，眼神顾盼之间，让人心旌摇荡；那淡淡的笑容，刚毅的嘴角，也许随着那夜的月色一起留在莺莺地记忆深处。她发觉自己陷入一种前所未有的危机，一种爱上别人为了那男子可以不顾一切的冲动，于是她板下脸来，义正词严地拒绝了那个男子。“非礼之动，能不愧心？特愿以礼自持，毋及于乱！”这些话在我看来倒有一大半是在对自己萌动的心说的，莺莺在警告自己不要逾越了礼，否则将万劫不复。男子一脸地失望，仿佛满地月光都成了严霜。她还是转身离去。但是正如元稹在《会真诗》里所写的“戏调初微拒，柔情已暗通”。我不知道莺莺在这三天里是如何地心情，我也不知道其中红娘起了多大地作用，但是我知道到了十八日的晚上，莺莺终于做了自己一生中最重要的决定。</p>
<p>“数夕，张生临轩独寝，忽有人觉之。惊骇而起，则红娘敛衾携枕而至，抚张曰：‘至矣！至矣！睡何为哉！’并枕重衾而去。张生拭目危坐久之，犹疑梦寐；然而修谨以俟。俄而红娘捧崔氏而至。至，则娇羞融冶，力不能运支体，曩时端庄，不复同矣。是夕，旬有八日也。斜月晶莹，幽辉半床。”唐贞元十六年二月十八日的夜晚，那一夜的经历对于元稹来说是如此的深刻，以至于很久以后依然清楚的记得那天的日期，那夜的月色。元稹在《会真诗》里清楚地描写了缠绵的经过，在千年之后的人们看来，那诗依然写得香艳露骨，荡人心旌：“微月透帘栊，萤光度碧空；遥天初缥缈，低树渐葱茏……低鬟蝉影动，回步玉尘蒙；转面流花雪，登床抱绮丛；鸳鸯交颈舞，翡翠合欢笼；眉黛羞频聚，朱唇暖更融；气清兰蕊馥，肤润玉肌丰；无力慵移腕，多娇爱敛躬；汗光珠点点，发乱绿松松……”。在晶莹的斜月下，天真善良的莺莺投奔了爱情，为了自己心爱的男子，为了梦想中的爱情，抛弃了一切，奉献了一切。也许古往今来有很多的人有这般的经历，曾经真心单纯地去爱一个人，为他（她）付出了一切。不管结果如何，起码在那一刻，付出的人是幸福的，虽然这样的幸福可能是要遭到报应的。</p>
<p>在现代人的眼光来看，莺莺这床也上的太快了些。其实这还不算彻底的，汉代的司马相如不过弹了次琴，卓文君便跟着他私奔了，连富翁老爹也不认了。那个时代，女子应允了一份爱情就等于一生一世，不会再有给你重来改过的机会。那是个严肃的时代，女子地位低下，虽然相对于其他朝代，唐朝的风气算是比较开明宽松，但是逾越礼制的爱情依然不容于世，和一个男子相恋，要么嫁给他，要么就是再也得不到幸福和爱情。如那位被元稹好友白居易赞为“醉娇胜不得，风嫋牡丹花”的徐州名妓关盼盼，在其丈夫徐州守帅张愔死后却被白居易讽刺她不肯殉情，逼得她不得不绝食自尽；又如步非烟，因为父母之命而嫁于功曹参军武公业，毫无爱情可言，于是她红杏出墙，爱上了攻读课业的书生赵象，被丈夫发现后，只是淡淡说了句“生既相爱，死亦何恨”，于是从容淡定，任凭丈夫拷打，不肯开口求饶一句，最后终于被活活打死，以暴疾而亡的名义埋了。那个时代的女子，很少可以拥有幸福的爱情，所以这充分体现了新社会的优越性，起码你谈几场恋爱没有关系，女孩子只要不失身还是会有幸福的。</p>
<p>红娘把枕头也带来了,在古时候,共同倚靠的枕头是充满暗示意味的情物，是在一起温柔缠绵的明证。本朝初年高阳公主嫁于房玄龄之子房遗爱为妻，却不爱房遗爱，在新婚之夜就把新郎拒于洞房之外。高贵的公主爱上了玄奘的高徒、最年轻却最聪慧的高僧辩机和尚，那时高阳公主十六岁，辩机和尚二十一岁。高阳公主送给辩机一个“金玉宝枕”，却被小偷偷出。结果事情因此泄露，高贵的辩机被腰斩于市，而高阳公主也一辈子恨上了自己的家族，“帝崩无哀容”。或许唐代的女子血液里奔流着冒险的因子，所以为了爱情不顾一切，哪怕被抛弃被鄙夷被万夫所指天地不容也再所不惜。于是整个唐朝给我们后人留下了一大堆让人向往的爱情故事。莺莺对待爱情的勇气，无疑是秉承了大唐女子一贯的风气，虽然她的命运因此让人心痛，但是她的形象也因此让人爱怜，在千百年后的今天依然让我爱慕钦佩。</p>
<p>“有顷，寺钟鸣，天将晓。红娘促去。崔氏娇啼宛转，红娘又捧之而去，终夕无一言。”如此“金风玉露一相逢”的时光过的总是很快，古寺的朝钟响起，天快亮了，莺莺也要离去了。对于类似的幽会后的早晨，《诗经》里便有很细致的描述：《郑风·女曰鸡鸣》里写道“女曰鸡鸣，士曰昧旦；子兴视夜，明星有烂”，女子在催促说“鸡已经在打啼了”，男子眷恋枕衾，“天还没全亮；你起身看夜空，启明星还闪闪发光”，然后慢慢谈到工作，谈到两个人的未来，谈到恩爱到白头，“宜言饮酒，与子偕老。琴瑟在御，莫不静好”；《齐风．鸡鸣》里写道“鸡既鸣矣，朝既盈矣。匪鸡则鸣，苍蝇之声。东方明矣，朝既昌矣。匪东方则明，月出之光”，女子催促男子快起身，男子淹留不肯，“那不是鸡叫，是苍蝇嗡嗡声，东边也没亮，那是月亮光而已”，回答言语可爱缠绵。钱钟书说：“莎士比亚剧中写情人欢会，女曰：‘天尚未明，此夜莺啼，非云雀鸣也。’男曰：‘云雀报曙，东方云开透日矣。’女曰：‘此非晨光，乃流星耳。’用以比勘。”但是我们注意到，莺莺和张生一夜缠绵，居然不交一词，只是在天明将别的时候，呜咽哭泣。这个写法相当传神，我们可以从那“山盟海誓”的缺失和离别时的哭泣，感受到莺莺内心的矛盾：她明知道她正在做一件可能万劫不复的错事，但是却无法控制内心对于张生的情意，爱情的那种使双方合二为一的强烈愿望战胜了对命运的恐惧，她不敢说话，因为说话就代表了清醒，她宁愿在一种迷醉的状态下委身于自己的爱人，抛却一切利益的得失、道德的禁梏；当天明将别，她仿佛恍然从梦中惊醒，好象做错了事的孩子一样，为自己的选择和命运哭泣，为自己所失去的哭泣。当然在这眼泪之中，对于离别的伤感，也占了一定的比重，所以在未来的十多天里，她再也没有和张生联系。</p>
<p>直到张生“赋《会真诗》三十韵，未毕，而红娘适至，因授之，以贻崔氏”，才又来与张生相会。想来未完的《会真诗》是个很好的说服自己的借口，只是来探讨文学罢了，但是总免不了“向谁行宿,不如休去”的挽留。于是这样相处了将近一个月。</p>
<p>“张生常诘郑氏之情，则曰：‘我不可奈何矣。’因欲就成之。”这是最常见的断句，莺莺说：“我没有办法告诉她。”于是张生便想亲自和郑氏谈谈，促成这件事。但是见家长的事突然没有下文，很快张生也去了长安，这样的情节安排无论如何都是不通的。幸好还有另外一个版本：“张生常诘郑氏之情，则曰：‘知不可奈何矣，因欲就成之。’”莺莺说她妈知道也没其他办法了，所以想促成我们的婚事。他们相处同居了一个月，而寺院内有崔家那么多的仆役，就算郑氏再昏懵，也应该了解到女儿的事情了。事已既此，无可奈何，女儿大了，心向外人，现在也只能期盼那男人能负责任把她娶去了。这样的心情很可以理解，我的一个朋友，和她女朋友两地分居，而且女孩子在当地做了教师，不错的职业，眼看因为家里反对要分手了，但是有天女孩子的父母偷听他们的电话，知道了女儿已经失身于我的朋友，于是第二天就让女儿把我的朋友叫去见面，很快便结了婚。所以很多时候，我都分不清自己到底是生活在古代还是生活在现代，一千多年下来，对待某些问题的做法还是一点都没变化。</p>
<p>但是张生可能很害怕被一桩寒门的婚姻套牢，一听这话赶快跑路；于是借口“为了梦想中金碧辉煌的长安,都市里充满了神奇的历险,满足一个男儿宏伟的心愿”，西下长安去了。去之前还先告诉了莺莺，“崔氏宛无难词，然而愁怨之容动人矣”。有一种哀伤，是哭不出来的，它会慢慢渗透进你的骨子，日日夜夜一点一滴地侵蚀你的情绪。或许她害怕自己会控制不住自己面对离别的悲伤，所以在张生将要走的第二天晚上，莺莺没有来。我总是不能理解女子的心思，明明想念你的，却不肯见面；明明想把你留下的，却早早地说出一路顺风的祝福；明明在说没有留下更多的甜蜜回忆，却连分手了也不肯来见最后一面，谁都无法想见女子的心里到底在想些什么，或许正是这样的复杂，才成就了莺莺形象的丰满。</p>
<p>但是很快，张生又回到了蒲州，又与莺莺相处了好几个月，也许是他无法放下这段感情，也许是长安尚未有“实现一个男儿宏伟志向”的机会，更可能是长安还没那么早开考，想最后的缠绵一下。莺莺的字和文章写的都很好，却从不给张生看；她写文章的水平很好，但是却好象什么都不懂的样子；她言辞敏捷，但是在外人面前却很少说话。或许这样的女孩子最是让人怜爱。“待张之意甚厚，然未尝以词继之。时愁艳幽邃，恒若不识，喜愠之容，亦罕形见”，莺莺是个内向的女孩子，有了情绪却不轻易流露，她不会口口声声地和你说“我爱你”，但是连她注视你的目光都能让你感到无限柔情，你无法知晓她的想法，但是却沉溺于她时时流露的情意。她喜欢弹琴来抒发情感，可能是心情忧郁，所以弹奏的曲子异常伤感。</p>
<p>不久张生便要去长安应试了，或许是下了决心终要割断前缘，一心功名，所以这个男人连说分手的勇气都没有，只能对着莺莺忧愁哀叹，自然他也是不肯去承诺些什么的。莺莺自然明白他的心思，面对爱人的负心薄情，做为一个弱女子又能说什么呢。莺莺是个坚强而又自尊的女子，她不会低声哀求张生留下，她态度恭敬，声音柔和，慢慢地对张生说：“始乱之，终弃之，固其宜矣，愚不敢恨。必也君乱之，君终之，君之惠也。则没身之誓，其有终矣，又何必深感于此行？然而君既不怿，无以奉宁。君常谓我善鼓琴，向时羞颜，所不能及。今且往矣，既君此诚。” 莺莺平静的面容下说出“始乱之，终弃之，固其宜矣，愚不敢恨”那是怎样的一种心痛呢，假如仅仅是个人爱情的失败也就罢了，但是其中还昭显出整个家族的衰败和老母最后一丝期望的落空。人很多时候并非为自己而活，所以人最不能承受的并非自身的失败，而是自身的失败给自己亲爱之人所带来的伤害。张生挥一挥衣袖，固然不带走一片云彩，还可以得到时人“善补过者”的赞誉，但是对于莺莺来说，不但她这一生的命运已经凄惨无疑，而且也给了她衰颓式微的家族一次重重的羞辱和打击。</p>
<p>她终于明白了“则没身之誓，其有终矣”，古往今来男女说着“山无陵，江水为竭，冬雷阵阵，夏雨雪，天地合，乃敢与君绝”的誓言，可大多数的人言语远比自身华丽，现实远没有恶化到世界末日，便已经支持不住，爱情一如华美的琉璃，碰触现实难免粉碎。</p>
<p>于是她为自己心爱的男子弹了最后一首曲子《霓裳羽衣曲序》，琴声因为心情悲伤而纷乱错杂，旁边的人都听着流泪，她终于弹不下去，扔下琴哭着跑到母亲的房里，再也没出来。在这部作品里，郑氏出场只有一次，侧面描写也并不多，但是我们却依然能想象一千多年前那位母亲的悲痛，为自己的命运，为家族的命运，更为自己女儿的命运感到悲伤。</p>
<p>第二天我们的元大才子便神清气爽地踏上西去长安的路途，但是那年他没有考中。于是他留在了长安，从莺莺的信中我们了解到，这个鄙薄的文青曾托人给莺莺寄去一封信，让她看开些，“以广其意”，顺便送去“花胜一合、口脂五寸”做为分手礼物。唐代女子喜欢用绢纸、金银等材料做出一朵朵花形的小物件，贴在脸上，唐代就称之为“花胜”或者“花钿”。元稹很潇洒地给分手后的情人送去长安最时尚的化妆品和首饰，想以此来弥补内心的愧疚。但凡女子都爱最新潮时尚的化妆品，犹以情人所赠为甚；但是我不知道淹留蒲州普救寺的母女，在这个穷乡僻壤突然看到负心的男人送来长安的时尚货色，会是怎样的心情，或许如后世李清照所言“泪融残粉花钿重”。</p>
<p>孤独无望地留在普救寺的莺莺回了一封信，那信却被张生炫耀于长安的朋友之间。就好象胡兰成把曾与他恩爱缠绵的女子都写进《今生今世》，古今文人下作起来都是一样。</p>
<p>对于自己的负心，元稹还借用了《左传》那句“夫有尤物,足以移人,苟非道德,则必有祸”，义正词严地发表了一通高论：“大凡天之所命尤物也，不妖其身，必妖于人。使崔氏子遇合富贵，乘宠娇，不为云为雨，则为蛟为螭，吾不知其变化矣。昔殷之辛，周之幽，据百万之国，其势甚厚。然而一女子败之，溃其众，屠其身，至今为天下戮笑。予之德不足以胜妖孽，是用忍情。”最可怕的是听众的反应，“于时坐者皆为深叹”，大家叹口气，居然没人指责张生的负心薄幸，或者有一点小小的同情给予莺莺。</p>
<p>对于美貌女子的恐惧，其实不过只是自身懦弱的借口罢了，男子严于律女子，宽于律己，实在是很无耻。《世说新语》里记载着石崇宴客让美人劝酒，如客人不饮，便杀掉劝酒的美人。有一次丞相王导和大将军王敦去赴宴，王导不善饮酒，也只好勉强自己喝，以至于喝醉了；而王敦死活不肯给面子，就是不喝，“已斩三人，颜色如故，尚不肯饮”。而此事，却被刘义庆归为“汰侈”，意思是奢侈浪费。在这里我们看到的是人正常情感的缺位，对于爱情和女性的残忍，却成了男子气度的象征。记得唐代曾有一个很出名的事件：军官冯燕，和同事张婴的漂亮老婆私通，张婴酗酒而归，冯燕逃避不及，只好藏到床底，却发觉自己的头巾还留在枕边，幸好张婴喝醉了并没发觉。于是冯燕指指头巾示意张妻把头巾取来免得事情败露，可是张妻会错了意，竟把枕边张婴的佩刀递给了他。冯燕看了张妻几眼，觉得这个女人太狠毒，就一刀砍下了张妻的头，然后戴上头巾走了。张婴于是就被认为杀害自己的妻子，被判死刑；结果在刑场上，冯燕出现了，他宣称张婴是无辜的，张妻是自己杀的。军政长官贾耽将此案据实上奏，并表示，宁愿免去自己的官职，也要为冯燕赎罪。最后皇帝的敕令是，将滑地的全部死刑犯同时赦免。这件案子影响很大，以至于那个时代的流行小说家沈下贤专门为之创作了传奇《冯燕传》；著名诗人司空图则写了长篇叙事诗《冯燕歌》，其中有一句诗写道“已为不平能割爱”，也就是说为了所谓的道德规范，能割舍爱情的才是大英雄。于是世情普遍鄙薄男欢女爱，积极培养冷血寡情的人，于是婚姻便成利益的交换，所谓的爱情只能沦落到勾栏瓦舍里去了。对比西方，希罗多德《历史》曾讲过吕底亚王坎道列斯的故事。坎道列斯认为自己的妻子是世上最美丽的女子，于是他想拿来炫耀了，他强迫他的亲信巨吉斯看王后的身体，以便确认这一点；不得已，巨吉斯只好藏在卧室，看了王后的身体。王后知道此事后，认为是奇耻大辱，就将巨吉斯召来，给他两个选择：要么他杀掉国王，“变成我的丈夫并取得吕底亚的王位”；要么被处死。结果巨吉斯选择了前者，他杀死了国王，并娶了王后，登上了吕底亚的王位。我们从中可以看到东西方文明对待情欲的差别。遗风留至如今，家里关心你的结婚对象，不是双方有多么相爱，感情有多深厚，而是这个人家里怎样，是不是老实，有没有本事赚钱升官；假如你斗胆和他们说起你们的爱情，于是大家都开始哄堂大笑或者不屑一顾，仿佛看你就是一个不成熟的孩子、精神错乱的病人。对于爱情的信仰，或许只存在于看戏的那段辰光。</p>
<p>有了这样一种社会心理氛围，再加上有太子少保韦夏卿的赏识，那么元稹抛弃寒门女子莺莺而迎娶豪门韦家的千金韦丛，也就顺理成章了。但吊诡的是在蒋防写的《霍小玉传》里，元稹的老丈人韦夏卿却对负心薄行的朋友李益这般说：“风光甚丽，草木荣华。伤哉郑卿，衔冤空室！足下终能弃置，实是忍人。丈夫之心，不宜如此。足下宜为思之！”蒋防此人在仕途上得到过元稹的推荐，所以他写及元稹的岳父时总要润色拔高一下，只是他的恩公看到这番话时是否会心头一颤？</p>
<p>或许是虬髯客已没，不会再有人“衔之十年”也要去取“天下负心者”的头颅心肝下酒，所以男人也就越发理直气壮地负心薄幸。负心人元稹没有得到什么报应，又过了一年多后，也就是贞元十九年他登拔萃科，署秘书省校书郎，娶了韦夏卿之女韦丛为妻，并在那一年与同中书判拔萃科的白居易相识订交，从此元白之名满天下。元稹在《梦游春七十韵》中写道：“当年二纪初，嘉节三星度……韦门正全盛，出入多欢裕。”在元稹志得意满，欢娱畅快之时，莺莺也匆匆嫁于他人了。后来元稹偶然路过莺莺居住的地方，以莺莺表兄的身份求见，终不得一见。莺莺的不复相见，是对情人的深深失望，或许她会深深的认同鱼玄机说的“易求无价宝，难得有情郎”；她没有霍小玉那般刚烈，她也许也会哀怜自己“我为女子，薄命如斯，是丈夫负心若此”，但她却说不出“我死之後，必为厉鬼，使君妻妾，终日不安”的话。莺莺只写了首诗给元稹，硬着骨头咬着牙说“弃置今何道，当时且自亲”，既然都已经分开了不爱我了又有什么好说的呢，当时恩爱缠绵也就足够了，让他“还将旧时意，怜取眼前人”，因为懂得，所以慈悲。当爱情归于寂寥，繁华消于落寞，一切都只存在与记忆里，曾经的美好，只能活在心底。“惆怅旧欢如梦，觉来无处追寻”。或许她也明白，往事只能追忆，不可重温。曾经年少单纯的莺莺已经死了，只留下一具逐渐衰老的躯壳和悲伤的灵魂继续苟活。现实那样丑恶，我们却不得不活下去。</p>
<p>我真的怀疑元稹所谓的“曾经沧海难为水，除却巫山不是云”到底指哪一位，是莺莺，还是韦丛，抑或是薛涛？元和四年，韦丛去世，元稹写了三十三篇诗来悼念她，其中最有名的一句：“惟将终夜长开眼，报答平生未展眉。”根据陈寅恪先生的考证，这个“长开眼”不仅仅是睡不着的意思，“所谓‘常开眼’者，自比鳏鱼（有“鳏鱼眼长开”这一说法），即自誓终鳏之义”（陈寅恪《元白诗笺证稿》），元稹信誓旦旦的要为韦丛终生不娶，鳏孤到死了。但事实证明，元稹是个文过饰非的人，在韦丛凑趣去世的那年，他邂逅薛涛，两人相恋了一年后将之抛弃，可怜薛涛为之终身不嫁，“只欲栏边安枕席，夜深闲共说相思”；两年后纳妾安氏，又过数年续弦裴淑。简直是“取次花丛频回顾”啊！所以观陈寅恪先生对其评价“自私自利。综其一生行迹，巧宦固不待言，而巧婚尤为可恶也。岂其多情哉？实多诈而已矣”并不为过。</p>
<p>读《元长庆集》，常免不了痛恨为什么如此深情优美的诗句却出自一个那么薄情负心的伧夫之手。雪莱在《致云雀》中说：“我们最甜美的歌，就是那些倾吐最哀伤的思想的。”不知道元稹所哀伤的到底是什么。贝克尔在《抗拒死亡》中说的：“所有动人心弦的事中，对死的恐惧是首当其冲的。”他的悼亡诗写的那么情深意切，大概是出于对死亡本身的恐惧和悲哀吧。</p>
<p>或许不该过分指责元稹，他也不过是为了功名奔波的庸人，这个世界原本就是为庸人所设的。太过恩爱的情侣总是不容于世：苏东坡与王弗已是“十年生死两茫茫”了；陆游和唐婉儿只能“一怀愁绪，几年离索”；刘克庄在哀叹“旧日风烟草树，而今总断人肠”；冒辟疆和董小宛“一生清福,九年占尽,九年折尽矣”；还有纳兰性德，感慨着“被酒莫惊春睡重，睹书消得泼茶香，当时只道是寻常”。但是起码他们是能真心相爱的，就算不能“执子之手，与子偕老”，起码也是“骨化形销而丹诚不泯”，却可怜了单纯的莺莺，一个人用余生去背负全部的思念、悔恨和指摘。</p>
<p>史籍上再没有关于莺莺以后生活的记载，或许她一生坎坷，慢慢地消磨了纯真善良，成了世间常见的庸俗势利的妇人。但哪怕是这样，我依然相信在她心底的最幽深隐蔽的角落、最柔嫩脆弱的地方，记忆会像一把锯齿慢慢地来回剧着那根最纤细的神经，午夜梦回的时候，依然会为贞元十六年的那个男子泪流满面。</p>
<p>我怕我鄙薄的文字无法完美地译出那女子悲伤的文字，且让我们再细细读一读那信的原文,体会一下她的心情吧：</p>
<p>捧览来问，抚爱过深。儿女之情，悲喜交集。兼惠花胜一合、口脂五寸，致耀首膏唇之饰。虽荷殊恩，谁复为容？睹物增怀，但积悲叹耳。伏承使于京中就业，进修之道，固在便安。但恨僻陋之人，永以遐弃。命也如此，知复何言！自去秋已来，常忽忽如有所失。于喧哗之下，或勉为语笑，闲宵自处，无不泪零。乃至梦寐之间，亦多感咽离忧之思。绸缪缱绻，暂若寻常，幽会未终，惊魂已断。虽半衾如暖，而思之甚遥。一昨拜辞，倏逾旧岁。长安行乐之地，触绪牵情。何幸不忘幽微，眷念无斁，鄙薄之志，无以奉酬。至于终始之盟，则固不忒。鄙昔中表相因，或同宴处。婢仆见诱，遂致私诚。儿女之心，不能自固。君子有援琴之挑，鄙人无投梭之拒。及荐寝席，义盛意深。愚陋之情，永谓终托。岂期既见君子，而不能定情，致有自献之羞，不复明侍巾帻。没身永恨，含叹何言！倘仁人用心，俯遂幽眇，虽死之日，犹生之年。如或达士略情，舍小从大，以先配为丑行，以要盟为可欺，则当骨化形销，丹诚不泯，因风委露，犹托清尘。存没之诚，言尽于此。临纸呜咽，情不能申。千万珍重，珍重千万！玉环一枚，是儿婴年所弄，寄充君子下体所佩。玉取其坚润不渝，环取其终始不绝。兼乱丝一绚、文竹茶碾子一枚。此数物不足见珍，意者欲君子如玉之真，弊志如环不解。泪痕在竹，愁绪萦丝，因物达情，永以为好耳。心迩身遐，拜会无期。幽愤所钟，千里神合。千万珍重！春风多厉，强饭为嘉。慎言自保，无以鄙为深念。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>故事</tag>
        <tag>《莺莺传》</tag>
      </tags>
  </entry>
  <entry>
    <title>「转」连接跟踪（conntrack）：原理、应用及 Linux 内核实现</title>
    <url>/public/2022/12/04/linux_network/conntrack_linux/</url>
    <content><![CDATA[<h2 id="摘要"><a class="header-anchor" href="#摘要">¶</a>摘要</h2>
<p>本文介绍连接跟踪（connection tracking，conntrack，CT）的原理，应用，及其在 Linux 内核中的实现。</p>
<p>代码分析基于内核 <code>4.19</code>。为使行文简洁，所贴代码只保留了核心逻辑，但都给出了代码 所在的源文件，如有需要请查阅。</p>
<p>水平有限，文中不免有错误之处，欢迎指正交流。</p>
<p>连接跟踪是许多网络应用的基础。例如，Kubernetes Service、ServiceMesh sidecar、 软件四层负载均衡器 LVS/IPVS、Docker network、OVS、iptables 主机防火墙等等，都依赖 连接跟踪功能。</p>
<a id="more"></a>
<h2 id="1-1-概念"><a class="header-anchor" href="#1-1-概念">¶</a>1.1 概念</h2>
<p>连接跟踪，顾名思义，就是<strong>跟踪（并记录）连接的状态</strong>。</p>
<p><img src="/public/2022/12/04/linux_network/conntrack_linux/node-conntrack.png" alt></p>
<p>Fig 1.1. 连接跟踪及其内核位置示意图</p>
<p>例如，上图是一台 IP 地址为 <code>10.1.1.2</code> 的 Linux 机器，我们能看到这台机器上有三条 连接：</p>
<ol>
<li>机器访问外部 HTTP 服务的连接（目的端口 80）</li>
<li>外部访问机器内 FTP 服务的连接（目的端口 21）</li>
<li>机器访问外部 DNS 服务的连接（目的端口 53）</li>
</ol>
<p>连接跟踪所做的事情就是发现并跟踪这些连接的状态，具体包括：</p>
<ul>
<li>从数据包中提取<strong>元组</strong>（tuple）信息，辨别<strong>数据流</strong>（flow）和对应的<strong>连接</strong>（connection）</li>
<li>为所有连接维护一个<strong>状态数据库</strong>（conntrack table），例如连接的创建时间、发送 包数、发送字节数等等</li>
<li>回收过期的连接（GC）</li>
<li>为更上层的功能（例如 NAT）提供服务</li>
</ul>
<p>需要注意的是，<strong>连接跟踪中所说的“连接”，概念和 TCP/IP 协议中“面向连接”（ connection oriented）的 “连接” 并不完全相同</strong>，简单来说：</p>
<ul>
<li>TCP/IP 协议中，连接是一个四层（Layer 4）的概念。
<ul>
<li>TCP 是有连接的，或称面向连接的（connection oriented），发送出去的包都要求对端应答（ACK），并且有重传机制</li>
<li>UDP 是无连接的，发送的包无需对端应答，也没有重传机制</li>
</ul>
</li>
<li>CT 中，一个元组（tuple）定义的一条数据流（flow ）就表示一条连接（connection）。
<ul>
<li>后面会看到 UDP 甚至是 <strong>ICMP 这种三层协议在 CT 中也都是有连接记录的</strong></li>
<li>但<strong>不是所有协议都会被连接跟踪</strong></li>
</ul>
</li>
</ul>
<p>本文中用到 “连接” 一词时，大部分情况下指的都是后者，即 “连接跟踪” 中的“连接”。</p>
<h2 id="1-2-原理"><a class="header-anchor" href="#1-2-原理">¶</a>1.2 原理</h2>
<p>了解以上概念之后，我们来思考下连接跟踪的技术原理。</p>
<p>要跟踪一台机器的所有连接状态，就需要</p>
<ol>
<li><strong>拦截（或称过滤）流经这台机器的每一个数据包，并进行分析</strong>。</li>
<li>根据这些信息<strong>建立</strong>起这台机器上的<strong>连接信息数据库</strong>（conntrack table）。</li>
<li>根据拦截到的包信息，不断更新数据库</li>
</ol>
<p>例如，</p>
<ol>
<li>拦截到一个 TCP <code>SYNC</code> 包时，说明正在尝试建立 TCP 连接，需要创建一条新 conntrack entry 来记录这条连接</li>
<li>拦截到一个属于已有 conntrack entry 的包时，需要更新这条 conntrack entry 的收发包数等统计信息</li>
</ol>
<p>除了以上两点功能需求，还要考虑<strong>性能问题</strong>，因为连接跟踪要对每个包进行过滤和分析 。性能问题非常重要，但不是本文重点，后面介绍实现时会进一步提及。</p>
<p>之外，这些功能最好还有配套的管理工具来更方便地使用。</p>
<h2 id="1-3-设计：Netfilter"><a class="header-anchor" href="#1-3-设计：Netfilter">¶</a>1.3 设计：Netfilter</h2>
<p><strong>Linux 的连接跟踪是在 <a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Netfilter</a> 中实现的。</strong></p>
<p><img src="/public/2022/12/04/linux_network/conntrack_linux/netfilter-design.png" alt></p>
<p>Fig 1.2. Netfilter architecture inside Linux kernel</p>
<p><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Netfilter</a> 是 Linux 内核中一个对数据 包进行<strong>控制、修改和过滤</strong>（manipulation and filtering）的框架。它在内核协议 栈中设置了若干 hook 点，以此对数据包进行拦截、过滤或其他处理。</p>
<blockquote>
<p>说地更直白一些，hook 机制就是在数据包的必经之路上设置若干检测点，所有到达这 些检测点的包都必须接受检测，根据检测的结果决定：</p>
<ol>
<li>放行：不对包进行任何修改，退出检测逻辑，继续后面正常的包处理</li>
<li>修改：例如修改 IP 地址进行 NAT，然后将包放回正常的包处理逻辑</li>
<li>丢弃：安全策略或防火墙功能</li>
</ol>
<p>连接跟踪模块只是完成连接信息的采集和录入功能，并不会修改或丢弃数据包，后者是其 他模块（例如 NAT）基于 Netfilter hook 完成的。</p>
</blockquote>
<p>Netfilter 是最古老的内核框架之一，1998 年开始开发，2000 年合并到 <code>2.4.x</code> 内 核主线版本 [5]。</p>
<h2 id="1-4-设计：进一步思考"><a class="header-anchor" href="#1-4-设计：进一步思考">¶</a>1.4 设计：进一步思考</h2>
<p>现在提到连接跟踪（conntrack），可能首先都会想到 Netfilter。但由上节讨论可知， 连接跟踪概念是独立于 Netfilter 的，<strong>Netfilter 只是 Linux 内核中的一种连接跟踪实现</strong>。</p>
<p>换句话说，<strong>只要具备了 hook 能力，能拦截到进出主机的每个包，完全可以在此基础上自 己实现一套连接跟踪</strong>。</p>
<p><img src="/public/2022/12/04/linux_network/conntrack_linux/cilium-conntrack.png" alt></p>
<p>Fig 1.3. Cilium's conntrack and NAT architectrue</p>
<p>云原生网络方案 Cilium 在 <code>1.7.4+</code> 版本就实现了这样一套独立的连接跟踪和 NAT 机制 （完备功能需要 Kernel <code>4.19+</code>）。其基本原理是：</p>
<ol>
<li>基于 BPF hook 实现数据包的拦截功能（等价于 netfilter 里面的 hook 机制）</li>
<li>在 BPF hook 的基础上，实现一套全新的 conntrack 和 NAT</li>
</ol>
<p>因此，即便<a href="https://github.com/cilium/cilium/issues/12879" target="_blank" rel="noopener">卸载 Netfilter</a> ，也不会影响 Cilium 对 Kubernetes ClusterIP、NodePort、ExternalIPs 和 LoadBalancer 等功能的支持 [2]。</p>
<p>由于这套连接跟踪机制是独立于 Netfilter 的，因此它的 conntrack 和 NAT 信息也没有 存储在内核的（也就是 Netfilter 的）conntrack table 和 NAT table。所以常规的 <code>conntrack/netstats/ss/lsof</code> 等工具是看不到的，要使用 Cilium 的命令，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cilium bpf nat list</span><br><span class="line">$ cilium bpf ct list global</span><br></pre></td></tr></table></figure>
<p>配置也是独立的，需要在 Cilium 里面配置，例如命令行选项 <code>--bpf-ct-tcp-max</code>。</p>
<p>另外，本文会多次提到连接跟踪模块和 NAT 模块独立，但<strong>出于性能考虑，具体实现中 二者代码可能是有耦合的</strong>。例如 Cilium 做 conntrack 的垃圾回收（GC）时就会顺便把 NAT 里相应的 entry 回收掉，而非为 NAT 做单独的 GC。</p>
<h2 id="1-5-应用"><a class="header-anchor" href="#1-5-应用">¶</a>1.5 应用</h2>
<p>来看几个 conntrack 的具体应用。</p>
<h3 id="1-5-1-网络地址转换（NAT）"><a class="header-anchor" href="#1-5-1-网络地址转换（NAT）">¶</a>1.5.1 网络地址转换（NAT）</h3>
<p>网络地址转换（NAT），名字表达的意思也比较清楚：对（数据包的）网络地址（<code>IP + Port</code>）进行转换。</p>
<p><img src="/public/2022/12/04/linux_network/conntrack_linux/node-nat.png" alt></p>
<p>Fig 1.4. NAT 及其内核位置示意图</p>
<p>例如上图中，机器自己的 IP <code>10.1.1.2</code> 是能与外部正常通信的，但 <code>192.168</code> 网段是私有 IP 段，外界无法访问，也就是说源 IP 地址是 <code>192.168</code> 的包，其<strong>应答包是无 法回来的</strong>。因此，</p>
<ul>
<li>当源地址为 <code>192.168</code> 网段的包要出去时，机器会先将源 IP 换成机器自己的 <code>10.1.1.2</code> 再发送出去；</li>
<li>收到应答包时，再进行相反的转换。</li>
</ul>
<p>这就是 NAT 的基本过程。</p>
<p>Docker 默认的 <code>bridge</code> 网络模式就是这个原理 [4]。每个容器会分一个私有网段的 IP 地址，这个 IP 地址可以在宿主机内的不同容器之间通信，但容器流量出宿主机时要进行 NAT。</p>
<p>NAT 又可以细分为几类：</p>
<ul>
<li>SNAT：对源地址（source）进行转换</li>
<li>DNAT：对目的地址（destination）进行转换</li>
<li>Full NAT：同时对源地址和目的地址进行转换</li>
</ul>
<p>以上场景属于 SNAT，将不同私有 IP 都映射成同一个 “公有 IP”，以使其能访问外部网络服 务。这种场景也属于正向代理。</p>
<p>NAT 依赖连接跟踪的结果。连接跟踪<strong>最重要的使用场景</strong>就是 NAT。</p>
<h4 id="四层负载均衡（L4LB）"><a class="header-anchor" href="#四层负载均衡（L4LB）">¶</a>四层负载均衡（L4LB）</h4>
<p>再将范围稍微延伸一点，讨论一下 NAT 模式的四层负载均衡。</p>
<p>四层负载均衡是根据包的四层信息（例如 <code>src/dst ip, src/dst port, proto</code>）做流量分发。</p>
<p>VIP（Virtual IP）是四层负载均衡的一种实现方式：</p>
<ul>
<li>多个后端真实 IP（Real IP）挂到同一个虚拟 IP（VIP）上</li>
<li>客户端过来的流量先到达 VIP，再经负载均衡算法转发给某个特定的后端 IP</li>
</ul>
<p>如果在 VIP 和 Real IP 节点之间使用的 NAT 技术（也可以使用其他技术），那客户端访 问服务端时，L4LB 节点将做双向 NAT（Full NAT），数据流如下图所示：</p>
<p><img src="/public/2022/12/04/linux_network/conntrack_linux/nat.png" alt></p>
<p>Fig 1.5. L4LB: Traffic path in NAT mode [3]</p>
<h3 id="1-5-2-有状态防火墙"><a class="header-anchor" href="#1-5-2-有状态防火墙">¶</a>1.5.2 有状态防火墙</h3>
<p>有状态防火墙（stateful firewall）是相对于早期的<strong>无状态防火墙</strong>（stateless firewall）而言的：早期防火墙只能写 <code>drop syn to port 443</code> 或者 <code>allow syn to port 80</code> 这种非常简单直接 的规则，<strong>没有 flow 的概念</strong>，因此无法实现诸如 <strong>“如果这个 ack 之前已经有 syn， 就 allow，否则 drop”</strong> 这样的规则，使用非常受限 [6]。</p>
<p>显然，要实现有状态防火墙，就必须记录 flow 和状态，这正是 conntrack 做的事情。</p>
<p>来看个更具体的防火墙应用：OpenStack 主机防火墙解决方案 —— 安全组（security group）。</p>
<h4 id="OpenStack-安全组"><a class="header-anchor" href="#OpenStack-安全组">¶</a>OpenStack 安全组</h4>
<p>简单来说，安全组实现了<strong>虚拟机级别</strong>的安全隔离，具体实现是：在 node 上连接 VM 的 网络设备上做有状态防火墙。在当时，最能实现这一功能的可能就是 Netfilter/iptables。</p>
<p>回到宿主机内网络拓扑问题： OpenStack 使用 OVS bridge 来连接一台宿主机内的所有 VM。 如果只从网络连通性考虑，那每个 VM 应该直接连到 OVS bridge <code>br-int</code>。但这里问题 就来了 [7]：</p>
<ul>
<li>（较早版本的）OVS 没有 conntrack 模块，</li>
<li>Linux 中有 conntrack 模块，但基于 conntrack 的防火墙<strong>工作在 IP 层</strong>（L3），通过 iptables 控制，</li>
<li>而 <strong>OVS 是 L2 模块</strong>，无法使用 L3 模块的功能，</li>
</ul>
<p>最终结果是：无法在 OVS （连接虚拟机）的设备上做防火墙。</p>
<p>所以，2016 之前 OpenStack 的解决方案是，在每个 OVS 和 VM 之间再加一个 Linux bridge ，如下图所示，</p>
<p><img src="/public/2022/12/04/linux_network/conntrack_linux/ovs-compute.png" alt></p>
<p>Fig 1.6. Network topology within an OpenStack compute node, picture from <a href="https://thesaitech.wordpress.com/2017/09/24/how-to-trace-the-tap-interfaces-and-linux-bridges-on-the-hypervisor-your-openstack-vm-is-on/" target="_blank" rel="noopener">Sai's Blog</a></p>
<p>Linux bridge 也是 L2 模块，按道理也无法使用 iptables。但是，<strong>它有一个 L2 工具 ebtables，能够跳转到 iptables</strong>，因此间接支持了 iptables，也就能用到 Netfilter/iptables 防火墙的功能。</p>
<p>这种暴力堆砌的方式不仅丑陋、增加网络复杂性，而且会导致性能问题。因此， RedHat 在 2016 年提出了一个 OVS conntrack 方案 [7]，从那以后，才有可能干掉 Linux bridge 而仍然具备安全组的功能。</p>
<h2 id="1-6-小结"><a class="header-anchor" href="#1-6-小结">¶</a>1.6 小结</h2>
<p>以上是理论篇，接下来看一下内核实现。</p>
<p>Netfilter 由几个模块构成，其中最主要的是<strong>连接跟踪</strong>（CT）模块和<strong>网络地址转换</strong>（NAT）模块。</p>
<p>CT 模块的主要职责是识别出可进行连接跟踪的包。 CT 模块独立于 NAT 模块，但主要目的是服务于后者。</p>
<h2 id="2-1-Netfilter-框架"><a class="header-anchor" href="#2-1-Netfilter-框架">¶</a>2.1 Netfilter 框架</h2>
<h3 id="5-个-hook-点"><a class="header-anchor" href="#5-个-hook-点">¶</a>5 个 hook 点</h3>
<p><img src="/public/2022/12/04/linux_network/conntrack_linux/hooks.png" alt></p>
<p>图 2.1. The 5 hook points in netfilter framework</p>
<p>如上图所示，Netfilter 在内核协议栈的包处理路径上提供了 5 个 hook 点，分别是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/netfilter_ipv4.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_PRE_ROUTING    0 <span class="comment">/* After promisc drops, checksum checks. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_LOCAL_IN       1 <span class="comment">/* If the packet is destined for this box. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_FORWARD        2 <span class="comment">/* If the packet is destined for another interface. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_LOCAL_OUT      3 <span class="comment">/* Packets coming from a local process. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_POST_ROUTING   4 <span class="comment">/* Packets about to hit the wire. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_IP_NUMHOOKS       5</span></span><br></pre></td></tr></table></figure>
<p>用户可以在这些 hook 点注册自己的处理函数（handlers）。当有数据包经过 hook 点时， 就会调用相应的 handlers。</p>
<blockquote>
<p>另外还有一套 <code>NF_INET_</code> 开头的定义，<code>include/uapi/linux/netfilter.h</code>。 这两套是等价的，从注释看，<code>NF_IP_</code> 开头的定义可能是为了保持兼容性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">enum</span> nf_inet_hooks &#123;</span><br><span class="line">&gt;  NF_INET_PRE_ROUTING,</span><br><span class="line">&gt;  NF_INET_LOCAL_IN,</span><br><span class="line">&gt;  NF_INET_FORWARD,</span><br><span class="line">&gt;  NF_INET_LOCAL_OUT,</span><br><span class="line">&gt;  NF_INET_POST_ROUTING,</span><br><span class="line">&gt;  NF_INET_NUMHOOKS</span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="hook-返回值类型"><a class="header-anchor" href="#hook-返回值类型">¶</a>hook 返回值类型</h3>
<p>hook 函数对包进行判断或处理之后，需要返回一个判断结果，指导接下来要对这个包做什 么。可能的结果有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/uapi/linux/netfilter.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_DROP   0  <span class="comment">// 已丢弃这个包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_ACCEPT 1  <span class="comment">// 接受这个包，结束判断，继续下一步处理</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_STOLEN 2  <span class="comment">// 临时 hold 这个包，不用再继续穿越协议栈了。常见的情形是缓存分片之后的包（等待重组）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_QUEUE  3  <span class="comment">// 应当将包放到队列</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NF_REPEAT 4  <span class="comment">// 当前处理函数应当被再次调用</span></span></span><br></pre></td></tr></table></figure>
<h3 id="hook-优先级"><a class="header-anchor" href="#hook-优先级">¶</a>hook 优先级</h3>
<p>每个 hook 点可以注册多个处理函数（handler）。在注册时必须指定这些 handlers 的<strong>优先级</strong>，这样触发 hook 时能够根据优先级依次调用处理函数。</p>
<h2 id="2-2-过滤规则的组织"><a class="header-anchor" href="#2-2-过滤规则的组织">¶</a>2.2 过滤规则的组织</h2>
<p><code>iptables</code> 是配置 Netfilter 过滤功能的用户空间工具。为便于管理， 过滤规则按功能分为若干 table：</p>
<ul>
<li>raw</li>
<li>filter</li>
<li>nat</li>
<li>mangle</li>
</ul>
<p>这不是本文重点。更多信息可参考 <a href="chrome-extension://ijllcpnolfcooahcekpamkbidhejabll/blog/deep-dive-into-iptables-and-netfilter-arch-zh/" target="_blank" rel="noopener">(译) 深入理解 iptables 和 netfilter 架构</a></p>
<p>连接跟踪模块用于维护<strong>可跟踪协议</strong>（trackable protocols）的连接状态。 也就是说，连接跟踪<strong>针对的是特定协议的包，而不是所有协议的包</strong>。 稍后会看到它支持哪些协议。</p>
<h2 id="3-1-重要结构体和函数"><a class="header-anchor" href="#3-1-重要结构体和函数">¶</a>3.1 重要结构体和函数</h2>
<p>重要结构体：</p>
<ul>
<li><code>struct nf_conntrack_tuple {}</code>: 定义一个 tuple。
<ul>
<li><code>struct nf_conntrack_man {}</code>：tuple 的 manipulable part。
<ul>
<li><code>struct nf_conntrack_man_proto {}</code>：manipulable part 中协议相关的部分。</li>
</ul>
</li>
</ul>
</li>
<li><code>struct nf_conntrack_l4proto {}</code>: 支持连接跟踪的<strong>协议需要实现的方法集</strong>（以及其他协议相关字段）。</li>
<li><code>struct nf_conntrack_tuple_hash {}</code>：哈希表（conntrack table）中的表项（entry）。</li>
<li><code>struct nf_conn {}</code>：<strong>定义一个 flow</strong>。</li>
</ul>
<p>重要函数：</p>
<ul>
<li>
<p><code>hash_conntrack_raw()</code>：根据 tuple 计算出一个 32 位的哈希值（hash key）。</p>
</li>
<li>
<p><code>nf_conntrack_in()</code>：<strong>连接跟踪模块的核心，包进入连接跟踪的地方</strong>。</p>
</li>
<li>
<p><code>resolve_normal_ct() -&gt; init_conntrack() -&gt; ct = __nf_conntrack_alloc(); l4proto-&gt;new(ct)</code></p>
<p>创建一个新的连接记录（conntrack entry），然后初始化。</p>
</li>
<li>
<p><code>nf_conntrack_confirm()</code>：确认前面通过 <code>nf_conntrack_in()</code> 创建的新连接（是否被丢弃）。</p>
</li>
</ul>
<h2 id="3-2-struct-nf-conntrack-tuple-：元组（Tuple）"><a class="header-anchor" href="#3-2-struct-nf-conntrack-tuple-：元组（Tuple）">¶</a>3.2 <code>struct nf_conntrack_tuple {}</code>：元组（Tuple）</h2>
<p>Tuple 是连接跟踪中最重要的概念之一。</p>
<p><strong>一个 tuple 定义一个单向（unidirectional）flow</strong>。内核代码中有如下注释：</p>
<blockquote>
<p>//include/net/netfilter/nf_conntrack_tuple.h</p>
<p>A <code>tuple</code> is a structure containing the information to uniquely identify a connection. ie. if two packets have the same tuple, they are in the same connection; if not, they are not.</p>
</blockquote>
<h3 id="结构体定义"><a class="header-anchor" href="#结构体定义">¶</a>结构体定义</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//include/net/netfilter/nf_conntrack_tuple.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为方便 NAT 的实现，内核将 tuple 结构体拆分为 "manipulatable" 和 "non-manipulatable" 两部分</span></span><br><span class="line"><span class="comment">// 下面结构体中的 _man 是 manipulatable 的缩写</span></span><br><span class="line">                                               <span class="comment">// ude/uapi/linux/netfilter.h</span></span><br><span class="line">                                               <span class="keyword">union</span> nf_inet_addr &#123;</span><br><span class="line">                                                   __u32            all[<span class="number">4</span>];</span><br><span class="line">                                                   __be32           ip;</span><br><span class="line">                                                   __be32           ip6[<span class="number">4</span>];</span><br><span class="line">                                                   <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>   <span class="title">in</span>;</span></span><br><span class="line">                                                   <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span>  <span class="title">in6</span>;</span></span><br><span class="line"><span class="comment">/* manipulable part of the tuple */</span>         /  &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_man</span> &#123;</span>                  /</span><br><span class="line">    <span class="keyword">union</span> nf_inet_addr           u3; --&gt;--/</span><br><span class="line">    <span class="keyword">union</span> nf_conntrack_man_proto u;  --&gt;--\</span><br><span class="line">                                           \   <span class="comment">// include/uapi/linux/netfilter/nf_conntrack_tuple_common.h</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> l3num; <span class="comment">// L3 proto            \  // 协议相关的部分</span></span><br><span class="line">&#125;;                                            <span class="keyword">union</span> nf_conntrack_man_proto &#123;</span><br><span class="line">                                                  __be16 all;<span class="comment">/* Add other protocols here. */</span></span><br><span class="line"></span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; tcp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; udp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 id;   &#125; icmp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; dccp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port; &#125; sctp;</span><br><span class="line">                                                  <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 key;  &#125; gre;</span><br><span class="line">                                              &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> &#123;</span> <span class="comment">/* This contains the information to distinguish a connection. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_man</span> <span class="title">src</span>;</span>  <span class="comment">// 源地址信息，manipulable part</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">union</span> nf_inet_addr u3;</span><br><span class="line">        <span class="keyword">union</span> &#123;</span><br><span class="line">            __be16 all; <span class="comment">/* Add other protocols here. */</span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; tcp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; udp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">u_int8_t</span> type, code; &#125; icmp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; dccp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 port;         &#125; sctp;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span> __be16 key;          &#125; gre;</span><br><span class="line">        &#125; u;</span><br><span class="line">        <span class="keyword">u_int8_t</span> protonum; <span class="comment">/* The protocol. */</span></span><br><span class="line">        <span class="keyword">u_int8_t</span> dir;      <span class="comment">/* The direction (for tuplehash) */</span></span><br><span class="line">    &#125; dst;                       <span class="comment">// 目的地址信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>Tuple 结构体中只有两个字段 src 和 dst</strong>，分别保存源和目的信息。<code>src</code> 和 <code>dst</code> 自身也是结构体，能保存不同类型协议的数据。以 IPv4 UDP 为例，五元组分别保存在如下字段：</p>
<ul>
<li><code>dst.protonum</code>：协议类型</li>
<li><code>src.u3.ip</code>：源 IP 地址</li>
<li><code>dst.u3.ip</code>：目的 IP 地址</li>
<li><code>src.u.udp.port</code>：源端口号</li>
<li><code>dst.u.udp.port</code>：目的端口号</li>
</ul>
<h3 id="CT-支持的协议"><a class="header-anchor" href="#CT-支持的协议">¶</a>CT 支持的协议</h3>
<p>从以上定义可以看到，连接跟踪模块<strong>目前只支持以下六种协议</strong>：TCP、UDP、ICMP、DCCP、SCTP、GRE。</p>
<p><strong>注意其中的 ICMP 协议</strong>。大家可能会认为，连接跟踪模块依据包的三层和四层信息做 哈希，而 ICMP 是三层协议，没有四层信息，因此 ICMP 肯定不会被 CT 记录。但<strong>实际上 是会的</strong>，上面代码可以看到，ICMP 使用了其头信息中的 ICMP <code>type</code>和 <code>code</code> 字段来 定义 tuple。</p>
<h2 id="3-3-struct-nf-conntrack-l4proto-：协议需要实现的方法集合"><a class="header-anchor" href="#3-3-struct-nf-conntrack-l4proto-：协议需要实现的方法集合">¶</a>3.3 <code>struct nf_conntrack_l4proto {}</code>：协议需要实现的方法集合</h2>
<p>支持连接跟踪的协议都需要实现 <code>struct nf_conntrack_l4proto {}</code> 结构体 中定义的方法，例如 <code>pkt_to_tuple()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_l4proto.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_l4proto</span> &#123;</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> l3proto; <span class="comment">/* L3 Protocol number. */</span></span><br><span class="line">    <span class="keyword">u_int8_t</span>  l4proto; <span class="comment">/* L4 Protocol number. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从包（skb）中提取 tuple</span></span><br><span class="line">    <span class="keyword">bool</span> (*pkt_to_tuple)(struct sk_buff *skb, ... struct nf_conntrack_tuple *tuple);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对包进行判决，返回判决结果（returns verdict for packet）</span></span><br><span class="line">    <span class="keyword">int</span> (*packet)(struct nf_conn *ct, <span class="keyword">const</span> struct sk_buff *skb ...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新连接。如果成功返回 TRUE；如果返回的是 TRUE，接下来会调用 packet() 方法</span></span><br><span class="line">    <span class="keyword">bool</span> (*<span class="keyword">new</span>)(struct nf_conn *ct, <span class="keyword">const</span> struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> dataoff);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前数据包能否被连接跟踪。如果返回成功，接下来会调用 packet() 方法</span></span><br><span class="line">    <span class="keyword">int</span> (*error)(struct net *net, struct nf_conn *tmpl, struct sk_buff *skb, ...);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-struct-nf-conntrack-tuple-hash-：哈希表项"><a class="header-anchor" href="#3-4-struct-nf-conntrack-tuple-hash-：哈希表项">¶</a>3.4 <code>struct nf_conntrack_tuple_hash {}</code>：哈希表项</h2>
<p>conntrack 将活动连接的状态存储在一张哈希表中（<code>key: value</code>）。</p>
<p><code>hash_conntrack_raw()</code> 根据 tuple 计算出一个 32 位的哈希值（key）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> u32 <span class="title">hash_conntrack_raw</span><span class="params">(struct nf_conntrack_tuple *tuple, struct net *net)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    get_random_once(&amp;nf_conntrack_hash_rnd, <span class="keyword">sizeof</span>(nf_conntrack_hash_rnd));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The direction must be ignored, so we hash everything up to the</span></span><br><span class="line"><span class="comment">     * destination ports (which is a multiple of 4) and treat the last three bytes manually.  */</span></span><br><span class="line">    u32 seed = nf_conntrack_hash_rnd ^ net_hash_mix(net);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = (<span class="keyword">sizeof</span>(tuple-&gt;src) + <span class="keyword">sizeof</span>(tuple-&gt;dst.u3)) / <span class="keyword">sizeof</span>(u32);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jhash2((u32 *)tuple, n, seed ^ ((tuple-&gt;dst.u.all &lt;&lt; <span class="number">16</span>) | tuple-&gt;dst.protonum));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意其中是如何利用 tuple 的不同字段来计算哈希的。</p>
<p><code>nf_conntrack_tuple_hash</code> 是哈希表中的表项（value）:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_tuple.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每条连接在哈希表中都对应两项，分别对应两个方向（egress/ingress）</span></span><br><span class="line"><span class="comment">// Connections have two entries in the hash table: one for each way</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_nulls_node</span>   <span class="title">hnnode</span>;</span>   <span class="comment">// 指向该哈希对应的连接 struct nf_conn，采用 list 形式是为了解决哈希冲突</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> <span class="title">tuple</span>;</span>    <span class="comment">// N 元组，前面详细介绍过了</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-struct-nf-conn-：连接（connection）"><a class="header-anchor" href="#3-5-struct-nf-conn-：连接（connection）">¶</a>3.5 <code>struct nf_conn {}</code>：连接（connection）</h2>
<p><strong>Netfilter 中每个 flow 都称为一个 connection</strong>，即使是对那些非面向连接的协议（例 如 UDP）。每个 connection 用 <code>struct nf_conn {}</code> 表示，主要字段如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack.h</span></span><br><span class="line"></span><br><span class="line">                                                  <span class="comment">// include/linux/skbuff.h</span></span><br><span class="line">                                        ------&gt;   <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack</span> &#123;</span></span><br><span class="line">                                        |             <span class="keyword">atomic_t</span> use;  <span class="comment">// 连接引用计数？</span></span><br><span class="line">                                        |         &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> &#123;</span>                        |</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack</span>            <span class="title">ct_general</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> <span class="title">tuplehash</span>[<span class="title">IP_CT_DIR_MAX</span>];</span> <span class="comment">// 哈希表项，数组是因为要记录两个方向的 flow</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> status; <span class="comment">// 连接状态，见下文</span></span><br><span class="line">    u32 timeout;          <span class="comment">// 连接状态的定时器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">possible_net_t</span> ct_net;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>    <span class="title">nat_bysource</span>;</span></span><br><span class="line">                                                        <span class="comment">// per conntrack: protocol private data</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">master</span>;</span>                             <span class="keyword">union</span> nf_conntrack_proto &#123;</span><br><span class="line">                                                       /    <span class="comment">/* insert conntrack proto private data here */</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> mark;    <span class="comment">/* 对 skb 进行特殊标记 */</span>      /     <span class="class"><span class="keyword">struct</span> <span class="title">nf_ct_dccp</span> <span class="title">dccp</span>;</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> secmark;                               /      <span class="class"><span class="keyword">struct</span> <span class="title">ip_ct_sctp</span> <span class="title">sctp</span>;</span></span><br><span class="line">                                                    /       <span class="class"><span class="keyword">struct</span> <span class="title">ip_ct_tcp</span> <span class="title">tcp</span>;</span></span><br><span class="line">    <span class="keyword">union</span> nf_conntrack_proto proto; ----------&gt;----/        <span class="class"><span class="keyword">struct</span> <span class="title">nf_ct_gre</span> <span class="title">gre</span>;</span></span><br><span class="line">&#125;;                                                          <span class="keyword">unsigned</span> <span class="keyword">int</span> tmpl_padto;</span><br><span class="line">                                                        &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>连接的状态集合 enum ip_conntrack_status</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// include/uapi/linux/netfilter/nf_conntrack_common.h</span><br><span class="line"></span><br><span class="line">enum ip_conntrack_status &#123;</span><br><span class="line">    IPS_EXPECTED      = (1 &lt;&lt; IPS_EXPECTED_BIT),</span><br><span class="line">    IPS_SEEN_REPLY    = (1 &lt;&lt; IPS_SEEN_REPLY_BIT),</span><br><span class="line">    IPS_ASSURED       = (1 &lt;&lt; IPS_ASSURED_BIT),</span><br><span class="line">    IPS_CONFIRMED     = (1 &lt;&lt; IPS_CONFIRMED_BIT),</span><br><span class="line">    IPS_SRC_NAT       = (1 &lt;&lt; IPS_SRC_NAT_BIT),</span><br><span class="line">    IPS_DST_NAT       = (1 &lt;&lt; IPS_DST_NAT_BIT),</span><br><span class="line">    IPS_NAT_MASK      = (IPS_DST_NAT | IPS_SRC_NAT),</span><br><span class="line">    IPS_SEQ_ADJUST    = (1 &lt;&lt; IPS_SEQ_ADJUST_BIT),</span><br><span class="line">    IPS_SRC_NAT_DONE  = (1 &lt;&lt; IPS_SRC_NAT_DONE_BIT),</span><br><span class="line">    IPS_DST_NAT_DONE  = (1 &lt;&lt; IPS_DST_NAT_DONE_BIT),</span><br><span class="line">    IPS_NAT_DONE_MASK = (IPS_DST_NAT_DONE | IPS_SRC_NAT_DONE),</span><br><span class="line">    IPS_DYING         = (1 &lt;&lt; IPS_DYING_BIT),</span><br><span class="line">    IPS_FIXED_TIMEOUT = (1 &lt;&lt; IPS_FIXED_TIMEOUT_BIT),</span><br><span class="line">    IPS_TEMPLATE      = (1 &lt;&lt; IPS_TEMPLATE_BIT),</span><br><span class="line">    IPS_UNTRACKED     = (1 &lt;&lt; IPS_UNTRACKED_BIT),</span><br><span class="line">    IPS_HELPER        = (1 &lt;&lt; IPS_HELPER_BIT),</span><br><span class="line">    IPS_OFFLOAD       = (1 &lt;&lt; IPS_OFFLOAD_BIT),</span><br><span class="line"></span><br><span class="line">    IPS_UNCHANGEABLE_MASK = (IPS_NAT_DONE_MASK | IPS_NAT_MASK |</span><br><span class="line">                 IPS_EXPECTED | IPS_CONFIRMED | IPS_DYING |</span><br><span class="line">                 IPS_SEQ_ADJUST | IPS_TEMPLATE | IPS_OFFLOAD),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="3-6-nf-conntrack-in-：进入连接跟踪"><a class="header-anchor" href="#3-6-nf-conntrack-in-：进入连接跟踪">¶</a>3.6 <code>nf_conntrack_in()</code>：进入连接跟踪</h2>
<p><img src="/public/2022/12/04/linux_network/conntrack_linux/netfilter-conntrack.png" alt></p>
<p>Fig. Netfilter 中的连接跟踪点</p>
<p>如上图所示，Netfilter 在四个 Hook 点对包进行跟踪：</p>
<ol>
<li>
<p><code>PRE_ROUTING</code> 和 <code>LOCAL_OUT</code>：<strong>调用 nf_conntrack_in() 开始连接跟踪</strong>， 正常情况下会创建一条新连接记录，然后将 conntrack entry 放到 <strong>unconfirmed list</strong>。</p>
<p>为什么是这两个 hook 点呢？因为它们都是<strong>新连接的第一个包最先达到的地方</strong>，</p>
<ul>
<li><code>PRE_ROUTING</code> 是<strong>外部主动和本机建连</strong>时包最先到达的地方</li>
<li><code>LOCAL_OUT</code> 是<strong>本机主动和外部建连</strong>时包最先到达的地方</li>
</ul>
</li>
<li>
<p><code>POST_ROUTING</code> 和 <code>LOCAL_IN</code>：<strong>调用 nf_conntrack_confirm() 将 nf_conntrack_in() 创建的连接移到 confirmed list</strong>。</p>
<p>同样要问，为什么在这两个 hook 点呢？因为如果新连接的第一个包没有被丢弃，那这 是它们<strong>离开 netfilter 之前的最后 hook 点</strong>：</p>
<ul>
<li><strong>外部主动和本机建连</strong>的包，如果在中间处理中没有被丢弃，<code>LOCAL_IN</code> 是其被送到应用（例如 nginx 服务）之前的最后 hook 点</li>
<li><strong>本机主动和外部建连</strong>的包，如果在中间处理中没有被丢弃，<code>POST_ROUTING</code> 是其离开主机时的最后 hook 点</li>
</ul>
</li>
</ol>
<p>下面的代码可以看到<strong>这些 handler 是如何注册到 Netfilter hook 点的</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_proto.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Connection tracking may drop packets, but never alters them, so make it the first hook.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_ops</span> <span class="title">ipv4_conntrack_ops</span>[] = &#123;</span></span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_conntrack_in,       <span class="comment">// 调用 nf_conntrack_in() 进入连接跟踪</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_PRE_ROUTING,     <span class="comment">// PRE_ROUTING hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_conntrack_local,    <span class="comment">// 调用 nf_conntrack_in() 进入连接跟踪</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_LOCAL_OUT,       <span class="comment">// LOCAL_OUT hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_confirm,            <span class="comment">// 调用 nf_conntrack_confirm()</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_POST_ROUTING,    <span class="comment">// POST_ROUTING hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK_CONFIRM,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        .hook        = ipv4_confirm,            <span class="comment">// 调用 nf_conntrack_confirm()</span></span><br><span class="line">        .pf          = NFPROTO_IPV4,</span><br><span class="line">        .hooknum     = NF_INET_LOCAL_IN,        <span class="comment">// LOCAL_IN hook 点</span></span><br><span class="line">        .priority    = NF_IP_PRI_CONNTRACK_CONFIRM,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>nf_conntrack_in()</code> 是<strong>连接跟踪模块的核心</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">nf_conntrack_in(struct net *net, <span class="keyword">u_int8_t</span> pf, <span class="keyword">unsigned</span> <span class="keyword">int</span> hooknum, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">tmpl</span> = <span class="title">nf_ct_get</span>(<span class="title">skb</span>, &amp;<span class="title">ctinfo</span>);</span> <span class="comment">// 获取 skb 对应的 conntrack_info 和连接记录</span></span><br><span class="line">  <span class="keyword">if</span> (tmpl || ctinfo == IP_CT_UNTRACKED) &#123;        <span class="comment">// 如果记录存在，或者是不需要跟踪的类型</span></span><br><span class="line">      <span class="keyword">if</span> ((tmpl &amp;&amp; !nf_ct_is_template(tmpl)) || ctinfo == IP_CT_UNTRACKED) &#123;</span><br><span class="line">          NF_CT_STAT_INC_ATOMIC(net, ignore);     <span class="comment">// 无需跟踪的类型，增加 ignore 计数</span></span><br><span class="line">          <span class="keyword">return</span> NF_ACCEPT;                       <span class="comment">// 返回 NF_ACCEPT，继续后面的处理</span></span><br><span class="line">      &#125;</span><br><span class="line">      skb-&gt;_nfct = <span class="number">0</span>;                             <span class="comment">// 不属于 ignore 类型，计数器置零，准备后续处理</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_l4proto</span> *<span class="title">l4proto</span> = __<span class="title">nf_ct_l4proto_find</span>(...);</span>    <span class="comment">// 提取协议相关的 L4 头信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l4proto-&gt;error != <span class="literal">NULL</span>) &#123;                   <span class="comment">// skb 的完整性和合法性验证</span></span><br><span class="line">      <span class="keyword">if</span> (l4proto-&gt;error(net, tmpl, skb, dataoff, pf, hooknum) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          NF_CT_STAT_INC_ATOMIC(net, error);</span><br><span class="line">          NF_CT_STAT_INC_ATOMIC(net, invalid);</span><br><span class="line">          <span class="keyword">goto</span> out;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">  <span class="comment">// 开始连接跟踪：提取 tuple；创建新连接记录，或者更新已有连接的状态</span></span><br><span class="line">  resolve_normal_ct(net, tmpl, skb, ... l4proto);</span><br><span class="line"></span><br><span class="line">  l4proto-&gt;packet(ct, skb, dataoff, ctinfo); <span class="comment">// 进行一些协议相关的处理，例如 UDP 会更新 timeout</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctinfo == IP_CT_ESTABLISHED_REPLY &amp;&amp; !test_and_set_bit(IPS_SEEN_REPLY_BIT, &amp;ct-&gt;status))</span><br><span class="line">      nf_conntrack_event_cache(IPCT_REPLY, ct);</span><br><span class="line">out:</span><br><span class="line">  <span class="keyword">if</span> (tmpl)</span><br><span class="line">      nf_ct_put(tmpl); <span class="comment">// 解除对连接记录 tmpl 的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致流程：</p>
<ol>
<li>尝试获取这个 skb 对应的连接跟踪记录</li>
<li>判断是否需要对这个包做连接跟踪，如果不需要，更新 ignore 计数（<code>conntrack -S</code> 能看到这个计数）， 返回 <code>NF_ACCEPT</code>；如果需要，就<strong>初始化这个 skb 的引用计数</strong>。</li>
<li>从包的 L4 header 中提取信息，初始化协议相关的 <code>struct nf_conntrack_l4proto {}</code> 变量，其中包含了该协议的<strong>连接跟踪相关的回调方法</strong>。</li>
<li>调用该协议的 <code>error()</code> 方法检查包的完整性、校验和等信息。</li>
<li>调用 <code>resolve_normal_ct()</code> <strong>开始连接跟踪</strong>，它会创建新 tuple，新 conntrack entry，或者更新已有连接的状态。</li>
<li>调用该协议的 <code>packet()</code> 方法进行一些协议相关的处理，例如对于 UDP，如果 status bit 里面设置了 <code>IPS_SEEN_REPLY</code> 位，就会更新 timeout。timeout 大小和协 议相关，越小越越可以防止 DoS 攻击（DoS 的基本原理就是将机器的可用连接耗尽）</li>
</ol>
<h2 id="3-7-init-conntrack-：创建新连接记录"><a class="header-anchor" href="#3-7-init-conntrack-：创建新连接记录">¶</a>3.7 <code>init_conntrack()</code>：创建新连接记录</h2>
<p>如果连接不存在（flow 的第一个包），<code>resolve_normal_ct()</code> 会调用 <code>init_conntrack</code> ，后者进而会调用 <code>new()</code> 方法创建一个新的 conntrack entry。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a new conntrack</span></span><br><span class="line"><span class="keyword">static</span> noinline <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple_hash</span> *</span></span><br><span class="line"><span class="class"><span class="title">init_conntrack</span>(<span class="title">struct</span> <span class="title">net</span> *<span class="title">net</span>, <span class="title">struct</span> <span class="title">nf_conn</span> *<span class="title">tmpl</span>,</span></span><br><span class="line"><span class="class">           <span class="title">const</span> <span class="title">struct</span> <span class="title">nf_conntrack_tuple</span> *<span class="title">tuple</span>,</span></span><br><span class="line"><span class="class">           <span class="title">const</span> <span class="title">struct</span> <span class="title">nf_conntrack_l4proto</span> *<span class="title">l4proto</span>,</span></span><br><span class="line"><span class="class">           <span class="title">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">dataoff</span>, <span class="title">u32</span> <span class="title">hash</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">ct</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 conntrack table 中分配一个 entry，如果哈希表满了，会在内核日志中打印</span></span><br><span class="line">    <span class="comment">// "nf_conntrack: table full, dropping packet" 信息，通过 `dmesg -T` 能看到</span></span><br><span class="line">    ct = __nf_conntrack_alloc(net, zone, tuple, &amp;repl_tuple, GFP_ATOMIC, hash);</span><br><span class="line"></span><br><span class="line">    l4proto-&gt;<span class="keyword">new</span>(ct, skb, dataoff); <span class="comment">// 协议相关的方法</span></span><br><span class="line"></span><br><span class="line">    local_bh_disable();             <span class="comment">// 关闭软中断</span></span><br><span class="line">    <span class="keyword">if</span> (net-&gt;ct.expect_count) &#123;</span><br><span class="line">        <span class="built_in">exp</span> = nf_ct_find_expectation(net, zone, tuple);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>) &#123;</span><br><span class="line">            <span class="comment">/* Welcome, Mr. Bond.  We've been expecting you... */</span></span><br><span class="line">            __set_bit(IPS_EXPECTED_BIT, &amp;ct-&gt;status);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* exp-&gt;master safe, refcnt bumped in nf_ct_find_expectation */</span></span><br><span class="line">            ct-&gt;master = <span class="built_in">exp</span>-&gt;master;</span><br><span class="line">            ct-&gt;mark = <span class="built_in">exp</span>-&gt;master-&gt;mark;</span><br><span class="line">            ct-&gt;secmark = <span class="built_in">exp</span>-&gt;master-&gt;secmark;</span><br><span class="line">            NF_CT_STAT_INC(net, expect_new);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now it is inserted into the unconfirmed list, bump refcount */</span></span><br><span class="line">    <span class="comment">// 至此这个新的 conntrack entry 已经被插入 unconfirmed list</span></span><br><span class="line">    nf_conntrack_get(&amp;ct-&gt;ct_general);</span><br><span class="line">    nf_ct_add_to_unconfirmed_list(ct);</span><br><span class="line"></span><br><span class="line">    local_bh_enable();              <span class="comment">// 重新打开软中断</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">exp</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">exp</span>-&gt;expectfn)</span><br><span class="line">            <span class="built_in">exp</span>-&gt;expectfn(ct, <span class="built_in">exp</span>);</span><br><span class="line">        nf_ct_expect_put(<span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;ct-&gt;tuplehash[IP_CT_DIR_ORIGINAL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每种协议需要实现自己的 <code>l4proto-&gt;new()</code> 方法，代码见：<code>net/netfilter/nf_conntrack_proto_*.c</code>。 例如 TCP 协议对应的 <code>new()</code> 方法是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_proto_tcp.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called when a new connection for this protocol found. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">tcp_new</span><span class="params">(struct nf_conn *ct, <span class="keyword">const</span> struct sk_buff *skb, <span class="keyword">unsigned</span> <span class="keyword">int</span> dataoff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (new_state == TCP_CONNTRACK_SYN_SENT) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;ct-&gt;proto.tcp, <span class="number">0</span>, <span class="keyword">sizeof</span>(ct-&gt;proto.tcp));</span><br><span class="line">        <span class="comment">/* SYN packet */</span></span><br><span class="line">        ct-&gt;proto.tcp.seen[<span class="number">0</span>].td_end = segment_seq_plus_len(ntohl(th-&gt;seq), skb-&gt;len, dataoff, th);</span><br><span class="line">        ct-&gt;proto.tcp.seen[<span class="number">0</span>].td_maxwin = ntohs(th-&gt;window);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前包会影响后面包的状态判断，<code>init_conntrack()</code> 会设置 <code>struct nf_conn</code> 的 <code>master</code> 字段。面向连接的协议会用到这个特性，例如 TCP。</p>
<h2 id="3-8-nf-conntrack-confirm-：确认包没有被丢弃"><a class="header-anchor" href="#3-8-nf-conntrack-confirm-：确认包没有被丢弃">¶</a>3.8 <code>nf_conntrack_confirm()</code>：确认包没有被丢弃</h2>
<p><code>nf_conntrack_in()</code> 创建的新 conntrack entry 会插入到一个 <strong>未确认连接</strong>（ unconfirmed connection）列表。</p>
<p>如果这个包之后没有被丢弃，那它在经过 <code>POST_ROUTING</code> 时会被 <code>nf_conntrack_confirm()</code> 方法处理，原理我们在分析过了 3.6 节的开头分析过了。 <code>nf_conntrack_confirm()</code> 完成之后，状态就变为了 <code>IPS_CONFIRMED</code>，并且连接记录从 <strong>未确认列表</strong>移到<strong>正常</strong>的列表。</p>
<p>之所以把创建一个新 entry 的过程分为创建（new）和确认（confirm）两个阶段 ，是因为<strong>包在经过 nf_conntrack_in() 之后，到达 nf_conntrack_confirm() 之前 ，可能会被内核丢弃</strong>。这样会导致系统残留大量的半连接状态记录，在性能和安全性上都 是很大问题。分为两步之后，可以加快半连接状态 conntrack entry 的 GC。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_conntrack_core.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Confirm a connection: returns NF_DROP if packet must be dropped. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nf_conntrack_confirm</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">ct</span> = (<span class="title">struct</span> <span class="title">nf_conn</span> *)<span class="title">skb_nfct</span>(<span class="title">skb</span>);</span></span><br><span class="line">    <span class="keyword">int</span> ret = NF_ACCEPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ct) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nf_ct_is_confirmed(ct))</span><br><span class="line">            ret = __nf_conntrack_confirm(skb);</span><br><span class="line">        <span class="keyword">if</span> (likely(ret == NF_ACCEPT))</span><br><span class="line">            nf_ct_deliver_cached_events(ct);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>confirm 逻辑，省略了各种错误处理逻辑：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_conntrack_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Confirm a connection given skb; places it in hash table */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__nf_conntrack_confirm(struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conn</span> *<span class="title">ct</span>;</span></span><br><span class="line">    ct = nf_ct_get(skb, &amp;ctinfo);</span><br><span class="line"></span><br><span class="line">    local_bh_disable();               <span class="comment">// 关闭软中断</span></span><br><span class="line"></span><br><span class="line">    hash = *(<span class="keyword">unsigned</span> <span class="keyword">long</span> *)&amp;ct-&gt;tuplehash[IP_CT_DIR_REPLY].hnnode.pprev;</span><br><span class="line">    reply_hash = hash_conntrack(net, &amp;ct-&gt;tuplehash[IP_CT_DIR_REPLY].tuple);</span><br><span class="line"></span><br><span class="line">    ct-&gt;timeout += nfct_time_stamp;   <span class="comment">// 更新连接超时时间，超时后会被 GC</span></span><br><span class="line">    atomic_inc(&amp;ct-&gt;ct_general.use);  <span class="comment">// 设置连接引用计数？</span></span><br><span class="line">    ct-&gt;status |= IPS_CONFIRMED;      <span class="comment">// 设置连接状态为 confirmed</span></span><br><span class="line"></span><br><span class="line">    __nf_conntrack_hash_insert(ct, hash, reply_hash);  <span class="comment">// 插入到连接跟踪哈希表</span></span><br><span class="line"></span><br><span class="line">    local_bh_enable();                <span class="comment">// 重新打开软中断</span></span><br><span class="line"></span><br><span class="line">    nf_conntrack_event_cache(master_ct(ct) ? IPCT_RELATED : IPCT_NEW, ct);</span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<strong>连接跟踪的处理逻辑中需要频繁关闭和打开软中断</strong>，此外还有各种锁， 这是短连高并发场景下连接跟踪性能损耗的主要原因？。</p>
<p>NAT 是与连接跟踪独立的模块。</p>
<h2 id="4-1-重要数据结构和函数"><a class="header-anchor" href="#4-1-重要数据结构和函数">¶</a>4.1 重要数据结构和函数</h2>
<p><strong>重要数据结构：</strong></p>
<p>支持 NAT 的协议需要实现其中的方法：</p>
<ul>
<li><code>struct nf_nat_l3proto {}</code></li>
<li><code>struct nf_nat_l4proto {}</code></li>
</ul>
<p><strong>重要函数：</strong></p>
<ul>
<li><code>nf_nat_inet_fn()</code>：NAT 的核心函数，在<strong>除 NF_INET_FORWARD 之外的其他 hook 点都会被调用</strong>。</li>
</ul>
<h2 id="4-2-NAT-模块初始化"><a class="header-anchor" href="#4-2-NAT-模块初始化">¶</a>4.2 NAT 模块初始化</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_nat_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_hook</span> <span class="title">nat_hook</span> = &#123;</span></span><br><span class="line">    .parse_nat_setup    = nfnetlink_parse_nat_setup,</span><br><span class="line">    .decode_session        = __nf_nat_decode_session,</span><br><span class="line">    .manip_pkt        = nf_nat_manip_pkt,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> __init <span class="title">nf_nat_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nf_nat_bysource = nf_ct_alloc_hashtable(&amp;nf_nat_htable_size, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    nf_ct_helper_expectfn_register(&amp;follow_master_nat);</span><br><span class="line"></span><br><span class="line">    RCU_INIT_POINTER(nf_nat_hook, &amp;nat_hook);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br><span class="line">module_init(nf_nat_init);</span><br></pre></td></tr></table></figure>
<h2 id="4-3-struct-nf-nat-l3proto-：协议相关的-NAT-方法集"><a class="header-anchor" href="#4-3-struct-nf-nat-l3proto-：协议相关的-NAT-方法集">¶</a>4.3 <code>struct nf_nat_l3proto {}</code>：协议相关的 NAT 方法集</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_nat_l3proto.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_l3proto</span> &#123;</span></span><br><span class="line">    u8    l3proto; <span class="comment">// 例如，AF_INET</span></span><br><span class="line"></span><br><span class="line">    u32     (*secure_port    )(<span class="keyword">const</span> struct nf_conntrack_tuple *t, __be16);</span><br><span class="line">    <span class="keyword">bool</span>    (*manip_pkt      )(struct sk_buff *skb, ...);</span><br><span class="line">    <span class="keyword">void</span>    (*csum_update    )(struct sk_buff *skb, ...);</span><br><span class="line">    <span class="keyword">void</span>    (*csum_recalc    )(struct sk_buff *skb, u8 proto, ...);</span><br><span class="line">    <span class="keyword">void</span>    (*decode_session )(struct sk_buff *skb, ...);</span><br><span class="line">    <span class="keyword">int</span>     (*nlattr_to_range)(struct nlattr *tb[], struct nf_nat_range2 *range);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-struct-nf-nat-l4proto-：协议相关的-NAT-方法集"><a class="header-anchor" href="#4-4-struct-nf-nat-l4proto-：协议相关的-NAT-方法集">¶</a>4.4 <code>struct nf_nat_l4proto {}</code>：协议相关的 NAT 方法集</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/net/netfilter/nf_nat_l4proto.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_l4proto</span> &#123;</span></span><br><span class="line">    u8 l4proto; <span class="comment">// Protocol number，例如 IPPROTO_UDP, IPPROTO_TCP</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据传入的 tuple 和 NAT 类型（SNAT/DNAT）修改包的 L3/L4 头</span></span><br><span class="line">    <span class="keyword">bool</span> (*manip_pkt)(struct sk_buff *skb, *l3proto, *tuple, maniptype);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个唯一的 tuple</span></span><br><span class="line">    <span class="comment">// 例如对于 UDP，会根据 src_ip, dst_ip, src_port 加一个随机数生成一个 16bit 的 dst_port</span></span><br><span class="line">    <span class="keyword">void</span> (*unique_tuple)(*l3proto, tuple, struct nf_nat_range2 *range, maniptype, struct nf_conn *ct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the address range is exhausted the NAT modules will begin to drop packets.</span></span><br><span class="line">    <span class="keyword">int</span> (*nlattr_to_range)(struct nlattr *tb[], struct nf_nat_range2 *range);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>各协议实现的方法，见：<code>net/netfilter/nf_nat_proto_*.c</code>。例如 TCP 的实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_nat_proto_tcp.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">nf_nat_l4proto</span> <span class="title">nf_nat_l4proto_tcp</span> = &#123;</span></span><br><span class="line">    .l4proto        = IPPROTO_TCP,</span><br><span class="line">    .manip_pkt        = tcp_manip_pkt,</span><br><span class="line">    .in_range        = nf_nat_l4proto_in_range,</span><br><span class="line">    .unique_tuple        = tcp_unique_tuple,</span><br><span class="line">    .nlattr_to_range    = nf_nat_l4proto_nlattr_to_range,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="4-5-nf-nat-inet-fn-：进入-NAT"><a class="header-anchor" href="#4-5-nf-nat-inet-fn-：进入-NAT">¶</a>4.5 <code>nf_nat_inet_fn()</code>：进入 NAT</h2>
<p>NAT 的核心函数是 <code>nf_nat_inet_fn()</code>，它会在以下 hook 点被调用：</p>
<ul>
<li><code>NF_INET_PRE_ROUTING</code></li>
<li><code>NF_INET_POST_ROUTING</code></li>
<li><code>NF_INET_LOCAL_OUT</code></li>
<li><code>NF_INET_LOCAL_IN</code></li>
</ul>
<p>也就是除了 <code>NF_INET_FORWARD</code> 之外其他 hook 点都会被调用。</p>
<p><strong>在这些 hook 点的优先级</strong>：<strong>Conntrack &gt; NAT &gt; Packet Filtering</strong>。 <strong>连接跟踪的优先级高于 NAT</strong> 是因为 NAT 依赖连接跟踪的结果。</p>
<p><img src="/public/2022/12/04/linux_network/conntrack_linux/hook-to-nat.png" alt></p>
<p>Fig. NAT</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">nf_nat_inet_fn(<span class="keyword">void</span> *priv, struct sk_buff *skb, <span class="keyword">const</span> struct nf_hook_state *state)</span><br><span class="line">&#123;</span><br><span class="line">    ct = nf_ct_get(skb, &amp;ctinfo);</span><br><span class="line">    <span class="keyword">if</span> (!ct)    <span class="comment">// conntrack 不存在就做不了 NAT，直接返回，这也是我们为什么说 NAT 依赖 conntrack 的结果</span></span><br><span class="line">        <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line"></span><br><span class="line">    nat = nfct_nat(ct);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (ctinfo) &#123;</span><br><span class="line">    <span class="keyword">case</span> IP_CT_RELATED:</span><br><span class="line">    <span class="keyword">case</span> IP_CT_RELATED_REPLY: <span class="comment">/* Only ICMPs can be IP_CT_IS_REPLY.  Fallthrough */</span></span><br><span class="line">    <span class="keyword">case</span> IP_CT_NEW: <span class="comment">/* Seen it before? This can happen for loopback, retrans, or local packets. */</span></span><br><span class="line">        <span class="keyword">if</span> (!nf_nat_initialized(ct, maniptype)) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">nf_hook_entries</span> *<span class="title">e</span> = <span class="title">rcu_dereference</span>(<span class="title">lpriv</span>-&gt;<span class="title">entries</span>);</span> <span class="comment">// 获取所有 NAT 规则</span></span><br><span class="line">            <span class="keyword">if</span> (!e)</span><br><span class="line">                <span class="keyword">goto</span> null_bind;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e-&gt;num_hook_entries; i++) &#123; <span class="comment">// 依次执行 NAT 规则</span></span><br><span class="line">                <span class="keyword">if</span> (e-&gt;hooks[i].hook(e-&gt;hooks[i].priv, skb, state) != NF_ACCEPT )</span><br><span class="line">                    <span class="keyword">return</span> ret;                         <span class="comment">// 任何规则返回非 NF_ACCEPT，就停止当前处理</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (nf_nat_initialized(ct, maniptype))</span><br><span class="line">                    <span class="keyword">goto</span> do_nat;</span><br><span class="line">            &#125;</span><br><span class="line">null_bind:</span><br><span class="line">            nf_nat_alloc_null_binding(ct, state-&gt;hook);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// Already setup manip</span></span><br><span class="line">            <span class="keyword">if</span> (nf_nat_oif_changed(state-&gt;hook, ctinfo, nat, state-&gt;out))</span><br><span class="line">                <span class="keyword">goto</span> oif_changed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* ESTABLISHED */</span></span><br><span class="line">        <span class="keyword">if</span> (nf_nat_oif_changed(state-&gt;hook, ctinfo, nat, state-&gt;out))</span><br><span class="line">            <span class="keyword">goto</span> oif_changed;</span><br><span class="line">    &#125;</span><br><span class="line">do_nat:</span><br><span class="line">    <span class="keyword">return</span> nf_nat_packet(ct, ctinfo, state-&gt;hook, skb);</span><br><span class="line">oif_changed:</span><br><span class="line">    nf_ct_kill_acct(ct, ctinfo, skb);</span><br><span class="line">    <span class="keyword">return</span> NF_DROP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先查询 conntrack 记录，如果不存在，就意味着无法跟踪这个连接，那就更不可能做 NAT 了，因此直接返回。</p>
<p>如果找到了 conntrack 记录，并且是 <code>IP_CT_RELATED</code>、<code>IP_CT_RELATED_REPLY</code> 或 <code>IP_CT_NEW</code> 状态，就去获取 NAT 规则。如果没有规则，直接返回 <code>NF_ACCEPT</code>，对包不 做任何改动；如果有规则，最后执行 <code>nf_nat_packet</code>，这个函数会进一步调用 <code>manip_pkt</code> 完成对包的修改，如果失败，包将被丢弃。</p>
<h3 id="Masquerade"><a class="header-anchor" href="#Masquerade">¶</a>Masquerade</h3>
<p>NAT 模块</p>
<ul>
<li>一般配置方式：<code>Change IP1 to IP2 if matching XXX</code>。</li>
<li>高级配置方式：<code>Change IP1 to dev1's IP if matching XXX</code>，这种方式称为 Masquerade。</li>
</ul>
<p>Masquerade 优缺点：</p>
<ul>
<li>优点：<strong>当设备（网卡）的 IP 地址发生变化时，NAT 规则无需做任何修改</strong>。</li>
<li>缺点：<strong>性能比第一种方式要差</strong>。</li>
</ul>
<h2 id="4-6-nf-nat-packet-：执行-NAT"><a class="header-anchor" href="#4-6-nf-nat-packet-：执行-NAT">¶</a>4.6 <code>nf_nat_packet()</code>：执行 NAT</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/netfilter/nf_nat_core.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do packet manipulations according to nf_nat_setup_info. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">nf_nat_packet</span><span class="params">(struct nf_conn *ct, <span class="keyword">enum</span> ip_conntrack_info ctinfo,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">unsigned</span> <span class="keyword">int</span> hooknum, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> nf_nat_manip_type mtype = HOOK2MANIP(hooknum);</span><br><span class="line">    <span class="keyword">enum</span> ip_conntrack_dir dir = CTINFO2DIR(ctinfo);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> verdict = NF_ACCEPT;</span><br><span class="line"></span><br><span class="line">    statusbit = (mtype == NF_NAT_MANIP_SRC? IPS_SRC_NAT : IPS_DST_NAT)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dir == IP_CT_DIR_REPLY)     <span class="comment">// Invert if this is reply dir</span></span><br><span class="line">        statusbit ^= IPS_NAT_MASK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ct-&gt;status &amp; statusbit)     <span class="comment">// Non-atomic: these bits don't change. */</span></span><br><span class="line">        verdict = nf_nat_manip_pkt(skb, ct, mtype, dir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> verdict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">nf_nat_manip_pkt</span><span class="params">(struct sk_buff *skb, struct nf_conn *ct,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">enum</span> nf_nat_manip_type mtype, <span class="keyword">enum</span> ip_conntrack_dir dir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nf_conntrack_tuple</span> <span class="title">target</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We are aiming to look like inverse of other direction. */</span></span><br><span class="line">    nf_ct_invert_tuplepr(&amp;target, &amp;ct-&gt;tuplehash[!dir].tuple);</span><br><span class="line"></span><br><span class="line">    l3proto = __nf_nat_l3proto_find(target.src.l3num);</span><br><span class="line">    l4proto = __nf_nat_l4proto_find(target.src.l3num, target.dst.protonum);</span><br><span class="line">    <span class="keyword">if</span> (!l3proto-&gt;manip_pkt(skb, <span class="number">0</span>, l4proto, &amp;target, mtype)) <span class="comment">// 协议相关处理</span></span><br><span class="line">        <span class="keyword">return</span> NF_DROP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NF_ACCEPT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-1-查看-加载-卸载-nf-conntrack-模块"><a class="header-anchor" href="#5-1-查看-加载-卸载-nf-conntrack-模块">¶</a>5.1 查看 / 加载 / 卸载 nf_conntrack 模块</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ modinfo nf_conntrack</span><br><span class="line">filename:       /lib/modules/5.15.0-46-generic/kernel/net/netfilter/nf_conntrack.ko</span><br><span class="line">license:        GPL</span><br><span class="line"><span class="built_in">alias</span>:          nf_conntrack-10</span><br><span class="line"><span class="built_in">alias</span>:          nf_conntrack-2</span><br><span class="line"><span class="built_in">alias</span>:          ip_conntrack</span><br><span class="line">srcversion:     30B45E5822722ACEDE23A4B</span><br><span class="line">depends:        nf_defrag_ipv6,libcrc32c,nf_defrag_ipv4</span><br><span class="line">retpoline:      Y</span><br><span class="line">intree:         Y</span><br><span class="line">name:           nf_conntrack</span><br><span class="line">vermagic:       5.15.0-46-generic SMP mod_unload modversions</span><br><span class="line">sig_id:         PKCS<span class="comment">#7</span></span><br><span class="line">signer:         Build time autogenerated kernel key</span><br><span class="line">sig_key:        17:6F:92:2F:58:6B:B2:28:13:DC:71:DC:5A:97:EE:BA:D8:4B:C7:DE</span><br><span class="line">sig_hashalgo:   sha512</span><br><span class="line">signature:      0B:32:AA:93:F4:31:52:9C:FE:0D:80:B4:F6:7C:30:63:4C:F6:03:AA:</span><br><span class="line">                ...</span><br><span class="line">                E9:1F:45:C6:77:C2:29:99:B4:3D:1A:D2</span><br><span class="line">parm:           tstamp:Enable connection tracking flow timestamping. (bool)</span><br><span class="line">parm:           acct:Enable connection tracking flow accounting. (bool)</span><br><span class="line">parm:           nf_conntrack_helper:Enable automatic conntrack helper assignment (default 0) (bool)</span><br><span class="line">parm:           expect_hashsize:uint</span><br><span class="line">parm:           enable_hooks:Always <span class="built_in">enable</span> conntrack hooks (bool)</span><br></pre></td></tr></table></figure>
<p>卸载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rmmod nf_conntrack_netlink nf_conntrack</span><br></pre></td></tr></table></figure>
<p>重新加载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ modprobe nf_conntrack</span><br><span class="line"></span><br><span class="line"># 加载时还可以指定额外的配置参数，例如：</span><br><span class="line">$ modprobe nf_conntrack nf_conntrack_helper=1 expect_hashsize=131072</span><br></pre></td></tr></table></figure>
<h2 id="5-2-sysctl-配置项"><a class="header-anchor" href="#5-2-sysctl-配置项">¶</a>5.2 sysctl 配置项</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sysctl -a | grep nf_conntrack</span><br><span class="line">net.netfilter.nf_conntrack_acct = 0</span><br><span class="line">net.netfilter.nf_conntrack_buckets = 262144                 # hashsize = nf_conntrack_max/nf_conntrack_buckets</span><br><span class="line">net.netfilter.nf_conntrack_checksum = 1</span><br><span class="line">net.netfilter.nf_conntrack_count = 2148</span><br><span class="line">... # DCCP options</span><br><span class="line">net.netfilter.nf_conntrack_events = 1</span><br><span class="line">net.netfilter.nf_conntrack_expect_max = 1024</span><br><span class="line">... # IPv6 options</span><br><span class="line">net.netfilter.nf_conntrack_generic_timeout = 600</span><br><span class="line">net.netfilter.nf_conntrack_helper = 0</span><br><span class="line">net.netfilter.nf_conntrack_icmp_timeout = 30</span><br><span class="line">net.netfilter.nf_conntrack_log_invalid = 0</span><br><span class="line">net.netfilter.nf_conntrack_max = 1048576                    # conntrack table size</span><br><span class="line">... # SCTP options</span><br><span class="line">net.netfilter.nf_conntrack_tcp_be_liberal = 0</span><br><span class="line">net.netfilter.nf_conntrack_tcp_loose = 1</span><br><span class="line">net.netfilter.nf_conntrack_tcp_max_retrans = 3</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_close = 10</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_established = 21600</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_last_ack = 30</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_max_retrans = 300</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_syn_recv = 60</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_syn_sent = 120</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120</span><br><span class="line">net.netfilter.nf_conntrack_tcp_timeout_unacknowledged = 300</span><br><span class="line">net.netfilter.nf_conntrack_timestamp = 0</span><br><span class="line">net.netfilter.nf_conntrack_udp_timeout = 30</span><br><span class="line">net.netfilter.nf_conntrack_udp_timeout_stream = 180</span><br></pre></td></tr></table></figure>
<h2 id="5-3-监控"><a class="header-anchor" href="#5-3-监控">¶</a>5.3 监控</h2>
<h3 id="丢包监控"><a class="header-anchor" href="#丢包监控">¶</a>丢包监控</h3>
<p><code>/proc/net/stat</code> 下面有一些关于 conntrack 的详细统计：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /proc/net/stat/nf_conntrack</span><br><span class="line">entries   searched found    new      invalid  ignore   delete   delete_list insert   insert_failed drop     early_drop icmp_error  expect_new expect_create expect_delete search_restart</span><br><span class="line">000008e3  00000000 00000000 00000000 0000309d 001e72d4 00000000 00000000    00000000 00000000      00000000 00000000   000000ee    00000000   00000000      00000000       000368d7</span><br><span class="line">000008e3  00000000 00000000 00000000 00007301 002b8e8c 00000000 00000000    00000000 00000000      00000000 00000000   00000170    00000000   00000000      00000000       00035794</span><br><span class="line">000008e3  00000000 00000000 00000000 00001eea 001e6382 00000000 00000000    00000000 00000000      00000000 00000000   00000059    00000000   00000000      00000000       0003f166</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>此外，还可以用 <code>conntrack</code> 命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ conntrack -S</span><br><span class="line">cpu=0   found=0 invalid=743150 ignore=238069 insert=0 insert_failed=0 drop=195603 early_drop=118583 error=16 search_restart=22391652</span><br><span class="line">cpu=1   found=0 invalid=2004   ignore=402790 insert=0 insert_failed=0 drop=44371  early_drop=34890  error=0  search_restart=1225447</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>ignore：不需要做连接跟踪的包（回忆前面，只有特定协议的包才会做连接跟踪）</li>
</ul>
<h3 id="conntrack-table-使用量监控"><a class="header-anchor" href="#conntrack-table-使用量监控">¶</a>conntrack table 使用量监控</h3>
<p>可以定期采集系统的 conntrack 使用量，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_count</span><br><span class="line">257273</span><br></pre></td></tr></table></figure>
<p>并与最大值比较：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_max</span><br><span class="line">262144</span><br></pre></td></tr></table></figure>
<h2 id="6-1-连接太多导致-conntrack-table-被打爆"><a class="header-anchor" href="#6-1-连接太多导致-conntrack-table-被打爆">¶</a>6.1 连接太多导致 conntrack table 被打爆</h2>
<h3 id="现象"><a class="header-anchor" href="#现象">¶</a>现象</h3>
<h4 id="业务层（应用层）现象"><a class="header-anchor" href="#业务层（应用层）现象">¶</a>业务层（应用层）现象</h4>
<ol>
<li>
<p>存在随机、偶发的<strong>新建连接</strong>超时（connect timeout）。</p>
<p>例如，如果业务用的是 Java，那对应的是 <code>jdbc4.CommunicationsException</code> communications link failure 之类的错误。</p>
</li>
<li>
<p><strong>已有连接</strong>正常。</p>
<p>也就是没有 read timeout 或 write timeout 之类的报错，报错都集中为 connect timeout。</p>
</li>
</ol>
<h4 id="网络层现象"><a class="header-anchor" href="#网络层现象">¶</a>网络层现象</h4>
<ol>
<li>
<p>抓包会看到三次握手的<strong>第一个 SYN 包被宿主机静默丢弃了</strong>。</p>
<p>需要注意的是，常规的网卡统计（<code>ifconfig</code>）和内核统计（<code>/proc/net/softnet_stat</code>） <strong>无法反映出这些丢包</strong>。</p>
</li>
<li>
<p><code>1s+</code> 之后出发 SYN 重传，或者还没重传连接就关闭了。</p>
<p><strong>第一个 SYN 的重传是 1s，这个是内核代码里写死的，不可配置</strong>（具体实现见 <a href="#ch_8.1">附录</a>）。</p>
<p>再考虑到其他一些耗时，第一次重传的实际间隔要大于 1s。 如果客户端设置的超时时间很小，例如 <code>1.05s</code>，那可能来不及重传连接就被关闭了，然后向上层报 connect timeout 错误。</p>
</li>
</ol>
<h4 id="操作系统层现象"><a class="header-anchor" href="#操作系统层现象">¶</a>操作系统层现象</h4>
<p>内核日志中有如下报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ demsg -T</span><br><span class="line">[Tue Apr  6 18:12:30 2021] nf_conntrack: nf_conntrack: table full, dropping packet</span><br><span class="line">[Tue Apr  6 18:12:30 2021] nf_conntrack: nf_conntrack: table full, dropping packet</span><br><span class="line">[Tue Apr  6 18:12:30 2021] nf_conntrack: nf_conntrack: table full, dropping packet</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>另外，<code>cat /proc/net/stat/nf_conntrack</code> 或 <code>conntrack -S</code> 能看到有 drop 统计。</p>
<h3 id="确认-conntrack-table-被打爆"><a class="header-anchor" href="#确认-conntrack-table-被打爆">¶</a>确认 conntrack table 被打爆</h3>
<p>遇到以上现象，基本就是 conntrack 表被打爆了。确认：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_count</span><br><span class="line">257273</span><br><span class="line"></span><br><span class="line">$ cat /proc/sys/net/netfilter/nf_conntrack_max</span><br><span class="line">net.netfilter.nf_conntrack_max = 262144</span><br></pre></td></tr></table></figure>
<p>如果有 conntrack count 监控会看的更清楚，因为我们命令行查看时，高峰可能过了。</p>
<h3 id="解决方式"><a class="header-anchor" href="#解决方式">¶</a>解决方式</h3>
<p>优先级从高到低：</p>
<ol>
<li>
<p>调大 conntrack 表</p>
<p>运行时配置（经实际测试，<strong>不会对现有连接造成影响</strong>）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sysctl -w net.netfilter.nf_conntrack_max=524288</span><br><span class="line">$ sysctl -w net.netfilter.nf_conntrack_buckets=131072 # 推荐配置 hashsize=nf_conntrack_count/4</span><br></pre></td></tr></table></figure>
<p>持久化配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &apos;net.netfilter.nf_conntrack_max = 524288&apos; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">$ echo &apos;net.netfilter.nf_conntrack_buckets = 131072&apos; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>
<p>影响：连接跟踪模块<strong>会多用一些内存</strong>。具体多用多少内存，可参考 <a href="#ch_8.2">附录</a>。</p>
</li>
<li>
<p>减小 GC 时间</p>
<p>还可以调小 conntrack 的 GC（也叫 timeout）时间，加快过期 entry 的回收。</p>
<p><code>nf_conntrack</code> 针对不同 TCP 状态（established、fin_wait、time_wait 等）的 entry 有不同的 GC 时间。</p>
<p>例如，<strong>默认的 established 状态的 GC 时间是 423000s（5 天）</strong>。设置成这么长的 <strong>可能原因</strong>是：TCP/IP 协议中允许 established 状态的连接无限期不发送任何东西（但仍然活着） [8]，协议的具体实现（Linux、BSD、Windows 等）会设置各自允许的最大 idle timeout。为防止 GC 掉这样长时间没流量但实际还活着的连接，就设置一个足够保守的 timeout 时间。[8] 中建议这个值不小于 2 小时 4 分钟（作为对比和参考， <strong>Cilium 自己实现的 CT 中，默认 established GC 是 6 小时</strong>）。 但也能看到一些厂商推荐比这个小得多的配置，例如 20 分钟。</p>
<p>如果对自己的网络环境和需求非常清楚，那可以将这个时间调到一个合理的、足够小的值； 如果不是非常确定的话，还是<strong>建议保守一些，例如设置 6 个小时</strong> —— 这已经比默认值 5 天小多了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sysctl -w net.netfilter.nf_conntrack_tcp_timeout_established = 21600</span><br></pre></td></tr></table></figure>
<p>持久化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo &apos;net.netfilter.nf_conntrack_tcp_timeout_established = 21600&apos; &gt;&gt; /etc/sysctl.conf</span><br></pre></td></tr></table></figure>
<p>其他几个 timeout 值（尤其是 <code>nf_conntrack_tcp_timeout_time_wait</code>，默认 <code>120s</code>）也可以适当调小， 但还是那句话：<strong>如果不确定潜在后果，千万不要激进地调小</strong>。</p>
</li>
</ol>
<p>连接跟踪是一个非常基础且重要的网络模块，但只有在少数场景下才会引起普通开发者的注意。</p>
<p>例如，L4LB 短时高并发场景下，LB 节点每秒接受大量并发短连接，可能导致 conntrack table 被打爆。此时的现象是：</p>
<ul>
<li>客户端和 L4LB 建连失败，失败可能是随机的，也可能是集中在某些时间点。</li>
<li>客户端重试可能会成功，也可能会失败。</li>
<li>在 L4LB 节点抓包看，客户端过来的 TCP SYNC 包 L4LB 收到了，但没有回 ACK。即，包 被静默丢弃了（silently dropped）。</li>
</ul>
<p>此时的原因可能是 conntrack table 太小，也可能是 GC 不够及 时，甚至是 <a href="https://github.com/cilium/cilium/pull/12729" target="_blank" rel="noopener">GC 有 bug</a>。</p>
<h2 id="8-1-第一个-SYN-包的重传间隔计算（Linux-4-19-118-实现）"><a class="header-anchor" href="#8-1-第一个-SYN-包的重传间隔计算（Linux-4-19-118-实现）">¶</a>8.1 第一个 SYN 包的重传间隔计算（Linux 4.19.118 实现）</h2>
<p>调用路径：<code>tcp_connect() -&gt; tcp_connect_init() -&gt; tcp_timeout_init()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp_output.c</span></span><br><span class="line"><span class="comment">/* Do all connect socket setups that can be done AF independent. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcp_connect_init</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    inet_csk(sk)-&gt;icsk_rto = tcp_timeout_init(sk);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/net/tcp.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> u32 <span class="title">tcp_timeout_init</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取 SYN-RTO：如果这个 socket 上没有 BPF 程序，或者有 BPF 程序但执行失败，都返回 -1</span></span><br><span class="line">    <span class="comment">// 除非用户自己编写 BPF 程序并 attach 到 cgroup/socket，否则这里都是没有 BPF 的，因此这里返回 -1</span></span><br><span class="line">    timeout = tcp_call_bpf(sk, BPF_SOCK_OPS_TIMEOUT_INIT, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>)                <span class="comment">// timeout == -1，接下来使用默认值</span></span><br><span class="line">        timeout = TCP_TIMEOUT_INIT;  <span class="comment">// 宏定义，等于系统的 HZ 数，也就是 1 秒，见下面</span></span><br><span class="line">    <span class="keyword">return</span> timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/net/tcp.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_RTO_MAX    ((unsigned)(120*HZ))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_RTO_MIN    ((unsigned)(HZ/5))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_TIMEOUT_MIN    (2U) <span class="comment">/* Min timeout for TCP timers in jiffies */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_TIMEOUT_INIT ((unsigned)(1*HZ))    <span class="comment">/* RFC6298 2.1 initial RTO value    */</span></span></span><br></pre></td></tr></table></figure>
<h2 id="8-2-根据-nf-conntrack-max-计算-conntrack-模块所需的内存"><a class="header-anchor" href="#8-2-根据-nf-conntrack-max-计算-conntrack-模块所需的内存">¶</a>8.2 根据 nf_conntrack_max 计算 conntrack 模块所需的内存</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /proc/slabinfo | head -n2; cat /proc/slabinfo | grep conntrack</span><br><span class="line">slabinfo - version: 2.1</span><br><span class="line"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span><br><span class="line">nf_conntrack      512824 599505    320   51    4 : tunables    0    0    0 : slabdata  11755  11755      0</span><br></pre></td></tr></table></figure>
<p>其中的 <strong>objsize 表示这个内核对象</strong>（这里对应的是 <code>struct nf_conn</code>）的大小， 单位是<strong>字节</strong>，所以以上输出表明<strong>每个 conntrack entry 占用 320 字节的内存空间</strong>。</p>
<p>如果忽略内存碎片（内存分配单位为 slab），那<strong>不同 size 的 conntrack table 占用的内存</strong>如下：</p>
<ul>
<li><code>nf_conntrack_max=512K</code>: <code>512K * 320Byte = 160MB</code></li>
<li><code>nf_conntrack_max=1M</code>: <code>1M * 320Byte = 320MB</code></li>
</ul>
<p>更精确的计算，可以参考 [9]。</p>
<ol>
<li><a href="https://wiki.aalto.fi/download/attachments/69901948/netfilter-paper.pdf" target="_blank" rel="noopener">Netfilter connection tracking and NAT implementation</a>. Proc. Seminar on Network Protocols in Operating Systems, Dept. Commun. and Networking, Aalto Univ. 2013.</li>
<li><a href="https://docs.cilium.io/en/v1.7/gettingstarted/kubeproxy-free/" target="_blank" rel="noopener">Cilium: Kubernetes without kube-proxy</a></li>
<li><a href="chrome-extension://ijllcpnolfcooahcekpamkbidhejabll/blog/k8s-l4lb/" target="_blank" rel="noopener">L4LB for Kubernetes: Theory and Practice with Cilium+BGP+ECMP</a></li>
<li><a href="https://docs.docker.com/network/bridge/" target="_blank" rel="noopener">Docker bridge network mode</a></li>
<li><a href="https://en.wikipedia.org/wiki/Netfilter" target="_blank" rel="noopener">Wikipedia: Netfilter</a></li>
<li><a href="https://blog.cloudflare.com/conntrack-tales-one-thousand-and-one-flows/" target="_blank" rel="noopener">Conntrack tales - one thousand and one flows</a></li>
<li><a href="https://www.redhat.com/en/blog/how-connection-tracking-open-vswitch-helps-openstack-performance" target="_blank" rel="noopener">How connection tracking in Open vSwitch helps OpenStack performance</a></li>
<li><a href="https://tools.ietf.org/html/rfc5382#section-5" target="_blank" rel="noopener">NAT Behavioral Requirements for TCP</a>, RFC5382</li>
<li><a href="https://johnleach.co.uk/posts/2009/06/17/netfilter-conntrack-memory-usage/" target="_blank" rel="noopener">Netfilter Conntrack Memory Usage</a></li>
</ol>
]]></content>
      <categories>
        <category>连接跟踪</category>
      </categories>
      <tags>
        <tag>conntrack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu完全教程</title>
    <url>/public/2022/04/01/linux/ubuntu_tour/</url>
    <content><![CDATA[<blockquote>
<p>ref:<a href="http://www.cnblogs.com/dutlei/archive/2012/11/20/2778327.html" target="_blank" rel="noopener">Ubuntu完全教程，让你成为Ubuntu高手！</a>
todo整理</p>
</blockquote>
<h2 id="Ubuntu的发音"><a class="header-anchor" href="#Ubuntu的发音">¶</a>Ubuntu的发音</h2>
<p>Ubuntu，源于非洲祖鲁人和科萨人的语言，发作 oo-boon-too 的音。了解发音是有意义的，您不是第一个为此困惑的人，当然，也不会是最后一个：）</p>
<p>大多数的美国人读 ubuntu 时，将 u 作为元音发音，类似单词 who 或者 boo ，重音在第二个音节即 u'buntu ，oo-boon-too 。</p>
<p>如果您喜欢撒哈拉，喜欢它令人窒息的温柔、梦幻般的寂寥还有张扬恣肆的旷远，您大可在第一个 u，后面带些嗡嗡声： oom-boon-too。</p>
<p>Ubuntu的中文发音大约为： 乌班图</p>
<h3 id="Ubuntu的涵义"><a class="header-anchor" href="#Ubuntu的涵义">¶</a>Ubuntu的涵义</h3>
<p>Ubuntu这个单词源自非洲，意谓“班图精神”────谁都不是一座孤岛，自成一体。每个人都包孕于人类，因他人存在而存在，因他人幸福而幸福。</p>
<h3 id="Ubuntu当前版本"><a class="header-anchor" href="#Ubuntu当前版本">¶</a>Ubuntu当前版本</h3>
<p>Ubuntu Linux v6.06 LTS (Dapper Drake)</p>
<p>LTS：Long Term Support</p>
<p>Dapper Drake：当前版本的开发代号</p>
<h3 id="Ubuntu的特点"><a class="header-anchor" href="#Ubuntu的特点">¶</a>Ubuntu的特点</h3>
<p>Ubuntu 完全基于 Linux 操作系统， 可以免费得到社区及专业机构的支持。庞大的社区是它成长的沃土，请向这片动人的热忱敞开心扉。</p>
<p>Ubuntu 社区恪守 Ubuntu 理念：自由！软件应是自由的，应尊重人类的自由意志，它与人类之间不应有任何隔膜。本地语种，功能限制，自主改进的权利……都不应成为使用的障碍或负担。</p>
<p>自由，让 Ubuntu 与传统的私有软件从根本上不同: 免费不能用来遮羞，您有权修正它，直到满意为止。</p>
<p>Ubuntu 适合桌面和服务器。当前 Ubuntu 发布版支持 PC (Intel x86), 64-bit PC (AMD64) 和 PowerPC (Apple iBook 和 Powerbook, G4 和 G5) 架构。</p>
<p>Ubuntu 包涵了超过 16,000 种软件， 核心的桌面系统却只有一张光盘， Ubuntu 覆盖了所有的桌面应用程序,</p>
<p>从文字处理，电子表格到 web 服务器和开发设计环境一应俱全。 详情查看 Ubuntu 桌面 和 Ubuntu 服务器的介绍。</p>
<h3 id="Ubuntu相对其它Linux发行版的主要特点"><a class="header-anchor" href="#Ubuntu相对其它Linux发行版的主要特点">¶</a>Ubuntu相对其它Linux发行版的主要特点</h3>
<ul>
<li>
<p>基于Debian/Linux，使用 APT 包管理系统。</p>
</li>
<li>
<p>相对于Fedora Code： APT 包管理系统优雅地解决了依赖问题，并且可以从容的在线安装升级</p>
</li>
<li>
<p>相对于Debian：软件更新积极，而Debian较保守。</p>
</li>
<li>
<p>相对于Gentoo：基本无需编译，省力、省时、省心。</p>
</li>
</ul>
<a id="more"></a>
<h3 id="基本操作"><a class="header-anchor" href="#基本操作">¶</a>基本操作</h3>
<p><strong>进入系统</strong></p>
<p>在登录界面中输入您的用户名，然后系统将提问您的密码</p>
<p>输入您的密码后，回车，稍事等待，您便可以进入Ubuntu系统</p>
<p>点击桌面左上角的图标，您可以打开一个菜单（或者使用 Alt+F1 组合键）</p>
<p>如果您想退出系统，可以点击该图标</p>
<p>在桌面上方启动栏中，包含了一些常用程序的启动图标这些图标也可以在开始菜单中找到</p>
<p>现在点击FireFox图标，您便可以使用FireFox浏览器冲浪</p>
<p>或者按下 Alt+F2 组合键，弹出一个运行命令对话框。输入 firefox 后回车，同样可以启动FireFox</p>
<p>在菜单中找到 终端</p>
<p>点击它便开启了一个终端窗口，您可以在终端窗口中运行命令</p>
<p>也可以在控制台中输入命令。使用 Ctrl+Alt+[F1~F6] ，您可以切换到1~6号控制台</p>
<p>使用 Ctrl+Alt+F7 可以返回图形界面（您可以使用 Ctrl+Alt+BackSpace 将图形界面关闭）</p>
<p>命令行提示符</p>
<p>user@ubuntu:~$ 为命令提示符， @ 之前的部分为当前用户ID， @ 与 : 之间的部分，为您的主机名称， : 与 $ 之间的部分，为当前的路径。</p>
<p><strong>退出系统</strong></p>
<p>您可以点击这一个图标来退出系统</p>
<p>也可以在终端或者控制台中输入命令</p>
<p>sudo halt</p>
<p>系统会提问您密码，输入正确密码，便可以退出系统</p>
<p>在以后的章节中，如果我们提示您输入命令，那么您即可以在终端中输入，也可以在控制台中输入。如果只是启动应用程序，还可以使用 Alt+F2 组合键。</p>
<h2 id="安装"><a class="header-anchor" href="#安装">¶</a>安装</h2>
<h3 id="分区概念"><a class="header-anchor" href="#分区概念">¶</a>分区概念</h3>
<p>首先我们需要知道，硬盘分区的存在，是由硬盘的物理特性决定的，并不会因为不同的操作系统而有所改变。</p>
<p>请您把一块硬盘想象为一本书……即便您不喜欢读书，您也一定非常熟悉它，所有的书都是相同的，包括我们使用的课本……您肯定非常熟悉</p>
<p>一本完整的书，通常包括书名、索引和正文。</p>
<p>如果您需要Linux，您首先需要找到一本书名为《linux》的书，书名相当于硬盘中的MBR，也就是主引导纪录。不同的是，MBR可以是几个书名合在一起，类似于《XX合订本》。这部分内容暂时还没有什么实用价值，您只需要大概的了解。</p>
<p>而正文，就是硬盘中纪录的数据，这也非常容易理解，且对于安装系统并没有什么影响，所以现在我们来了解索引</p>
<p>索引相当于硬盘中的分区表，书中的每一个章节，相当于硬盘中的一个分区，它起始和结束的页次，都可以在索引中找到。试想，如果阅读一本撕掉索引的书，您将很难找到您想阅读的部分。同样，如果没有分区表，操作系统也不能够在硬盘上定位数据的位置。</p>
<p>由于历史的原因，硬盘中的分区表大小受到了限制，最多只可以容纳四个分区（主分区）。如果一本书，它的索引最多只能有四个章节，那不是太可怕了么？很多书的内容远远不止四个章节啊！</p>
<p>于是聪明的人们想到了一个变通的办法，就是利用其中的一个章节，来存储其它部分的索引。比如第一章是前言，第二章是其它部分的索引，我们翻到第二章，呵呵，这里是第二个索引，因为只有第一个索引受四个章节的限制，所以这个索引的内容可以非常的详尽。第二个索引就是分区表中的扩展分区了，其中定义的章节，就是硬盘中的逻辑分区，不是很难理解吧？</p>
<p>明白了这一点，我们来看看Linux和Windows对于分区不同的表示方法：</p>
<p>可能您已经很熟悉Windows了，它使用盘符来表示分区，比如 C: D: E:，每一个分区使用一个盘符来标识，而且顺序可以颠倒， D:并不一定就是您系统中的第二个分区。（如果您给第二个分区分配最后一个硬盘盘符，把所有的盘符按顺序排列好，并且重装一次系统，您就会理解什么叫作“头疼”了：）</p>
<p>而在Linux中，分区是这样表示的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/dev/hda        /dev/hda1      /dev/hda2       /dev/hda5/      dev/sdb1</span><br></pre></td></tr></table></figure>
<p>以 /dev/hda5 为例:</p>
<p>因为在Linux中，每一个设备都是用 /dev/ 文件夹下的一个文件来表示，所以 /dev/hda5 中， /dev/ 表示的是根目录下的dev目录，我们来看剩下的部分 hda5 。</p>
<p>前两位的字母 hd 表示这是一块IDE硬盘，如果是 sd ，则代表SATA硬盘，或者闪存等外设。</p>
<p>第三位的字母 a 表示这是该类型接口上的第一个设备。同理， b、c、d…… 分别代表该类型接口上的第二三四……个设备。例如 hdc 表示第二个IDE接口上的主硬盘（每个IDE接口上允许一个主设备和一个从设备）。</p>
<p>第四位的数字 5，并不表示这是该硬盘中的第5个分区，而是第一个逻辑分区。因为在Linux中，为了避免不必要的混乱，分区的顺序是不能改变的，分区标识则由它们在硬盘中的位置决定。系统又要为所有可能的主分区预留标识，所以 1-4 一定不会是逻辑分区， 5 则是第一个逻辑分区，以此类推。</p>
<h3 id="安装中的注意事项"><a class="header-anchor" href="#安装中的注意事项">¶</a>安装中的注意事项</h3>
<p>在Ubuntu系统的安装过程中，您需要选择系统目录的挂载点。</p>
<p>我们知道，安装Windows时，我们可以选择把系统安装在哪一个分区，把系统挂载到分区上。而在ubuntu/Linux中则相反，我们要把分区挂载到系统中。当我们使用Windows的安装方式，把系统挂载到分区上，我们就不可能把Windows目录放在C盘，而把<code>MyDocuments</code>目录放到其它分区。您或者出于习惯，或者出于数据安全方面的考虑，通常把文档放到其它分区中。但是Windows下很多软件保存文件的默认目录就是<code>MyDocument</code>目录，这就比较不方便。</p>
<p>在系统安装完成后，我们还是可以将<code>MyDocuments</code>目录转移到其它分区中，不过有点麻烦，可能许多朋友还不知道怎么去作……而任何一种Linux系统时，当然包括<code>Ubuntu</code>，我们可以在系统安装时就把分区挂载到目录下， <code>/home</code> 目录相当于Windows的<code>MyDocuments</code> ，我们可以把 <code>/dev/hda5</code> 挂载到此目录下，这样我们往 <code>/home</code>目录里存东西的时候，其实保存在第一个扩展分区中。如果再一次安装系统，只要把这个分区挂载到 <code>/home</code>目录下，那么进入新系统就像回家一样，真是太棒了。</p>
<p>理论上来讲，您可以将分区挂载到任何目录下面，您可以自定义挂载的路径。但是我们并不推荐您这么作，因为那没有任何意义。系统安装程序向您建议的挂载目录，通常也是我们向您建议的，现在我们来了解一下，这些目录通常都是用来作什么的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/    根目录，唯一必须挂载的目录。不要有任何的犹豫，选一个分区，挂载它！（在绝大多数情况下，有2G的容量应该是够用了。当然了，很多东西都是多多益善的：）</span><br><span class="line"></span><br><span class="line">Swap     交换分区，可能不是必须的，不过按照传统，并且照顾到您的安全感，还是挂载它吧。它的容量只要大于您的物理内存就可以了，如果超过了您物理内存两倍的容量，那绝对是一种浪费。</span><br><span class="line"></span><br><span class="line">/home    前面已经介绍过了，这是您的家目录，通常您自己创建的文件，都保存在这里，您最好给它分配一个分区</span><br><span class="line"></span><br><span class="line">/usr  应用程序目录。大部分的软件都安装在这里。如果您计划安装许多软件，建议您也给它分配一个分区</span><br><span class="line"></span><br><span class="line">/var      如果您要作一些服务器方面的应用，可以考虑给它分配一个较大的分区</span><br><span class="line"></span><br><span class="line">/boot     如果您的硬盘不支持LBA模式（我想那不太可能:），您最好挂载它，如果挂载硬盘的第一个分区，应该比较稳妥。一般来说，挂载的分区只要100M大小就足够了</span><br></pre></td></tr></table></figure>
<p>在文件系统这一环节中，我们建议您选择： <code>ReiserFS</code></p>
<p>也许您注意到了，Windows中，盘符既用于表示硬件（硬盘上的分区）,又用于表示系统中的路径。而Linux中，硬件就是硬件，路径就是路径，不会混淆在一起，简单直接！</p>
<h2 id="Linux基础"><a class="header-anchor" href="#Linux基础">¶</a>Linux基础</h2>
<h3 id="Shell"><a class="header-anchor" href="#Shell">¶</a>Shell</h3>
<p>可能您早已能够熟练的使用GUI（图形用户界面），例如您可以使用鼠标双击一个图标，来打开或者执行它。</p>
<p>我们来看这个过程: 您使用鼠标定位桌面上的一个程序图标，按下左键两次。系统读取鼠标指针的位置，并且判断该位置下图标的涵义，根据预设的双击动作，运行程序或者打开文件。</p>
<p>这一套GUI系统，便是一种Shell，它的作用是实现人机交互。如果我们不能够控制电脑，那么电脑还不如电视机好玩，不是么？电视机也可以选择频道（电视机的遥控器，也是一种人机交互的界面，不过相对于电脑，确实是相当简单了：）</p>
<p>易于上手、界面直观是GUI的优点，但是GUI为不意味着简单！或许您有类似经历: 桌面上有几十个程序的启动图标，也知道它们的名字，但是翻出一个来，并不是一件轻松的事情。</p>
<p>我的Windows系统中，桌面上摆满了各种图标，每当启动一个程序的时候，我都很是困扰。后来尝试了 音速启动 这类的程序启动管理器，效果还是差强人意。</p>
<p>在我的不懈努力下，这个难道最终得到了解决： 将快捷方式名称简化，放到特定目录下，使用 Win+R 组合键呼出 运行对话框，键入快捷方式的名称来运行该程序。比如 反恐精英 的快捷方式为 cs ，我把它放在 Windows 目录下; 运行 cs命令，就可以去维护世界和平了。</p>
<p>这么多快捷方式，统统放到 Windows 目录下，非常混乱。因此，我在D盘建立了一个名为 path的目录，并把它的路径加入到环境变量的 path 项中，快捷方式放在 <code>D:\path</code>目录中。即便重装系统，只要在环境变量中重新加入此路径，原来的程序大多可以直接以命令来运行……我的许多朋友强烈要示我帮他们设定这种启动方式，因为这确实很方便：）</p>
<p>其实在Linux下，所有的程序都可以通过命令运行。虽然Linux也有GUI，但是它并不比Windows的GUI更优秀！上面只是简单的介绍了CLI（命令行界面）相对GUI的优越之处，使用CLI还有更多的好处，您会慢慢体会到的。</p>
<p>当然了，在您的印象中，CLI一定非常的不友善，缺少亲和力，冷漠而拒人于千里之外……您和CLI之间甚至有代沟的存在：）</p>
<h4 id="命令"><a class="header-anchor" href="#命令">¶</a>命令</h4>
<p>坦白的说，冷不丁见到那么老长的一串命令，谁都会毛骨悚然。</p>
<p>也许您使用过DOS，留下这种印象：命令先放一边，光是正确的输入目录、文件名都够瞧的。而且DOS不区分大小写，要是像Linux一样区分大小写，那多恐怖啊！！！</p>
<p>其实Linux命令行具有补全功能，非常实用。假设有这样一个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">command</span> path/file</span><br></pre></td></tr></table></figure>
<p>如果只有一个以 c 起始的命令，键入 c ，再按一次 tab 键，系统将自动补全该命令余下的部分。 只要 c tab 两次按键，就可以完成 command 的输入。</p>
<p>如果不只一个 c 起始的命令，那么您可以按两次 tab 键，系统会列出所有符合条件的选项，也就是以 c 起始的所有命令。进一步输入 o ，如果只有一个以 co 起始的命令（一直输入，直到项符合条件的选项唯一），再按一次 tab ，命令就被补全完整。</p>
<p>路径和文件名也可以通过 tab 键来补全。还有一种 遍历补全 的方式，如果您的文件名是中文，而您不想切换输入法；甚至您的文件名中出现乱码，无法输入，这时 遍历补全 就可以大显身手了。这部分内容我们稍后再谈：）</p>
<p>现在我们来了解命令的语法结构，这一部分相当重要，您可得看仔细。</p>
<p>我们知道，任何语言都有特定的语法结构，以我们的中文为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们郑重地推荐您Ubuntu/Linux！</span><br></pre></td></tr></table></figure>
<p>这个句子的语法尽管简单，却是大部分的命令行采用的句型。让我们看一下，这个句子里都有些什么：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们</span><br></pre></td></tr></table></figure>
<p>主语，Linux命令的执行者只有一个，所以主语一概省略。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">推荐</span><br></pre></td></tr></table></figure>
<p>一个动词，作为谓语而存在。Linux命令中，这一部分是必须的。这一部分也是不同命令之间最根本的区别方式，所以它通常作为命令名，写在最前面。键入 date 命令，您可以查看当前的时间日期。（ 应用程序-&gt;附件-&gt;终端 ）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">郑重的</span><br></pre></td></tr></table></figure>
<p>状语，用来修饰谓语。与之相对应，Linux命令可以使用参数来精细调节程序的行为。为了与命令的操作对象相区别，参数前通常要加 - 或者 -- 符号。原则上，在命令名之后，参数的位置可以随意，但是为了养成一个良好的习惯，我们建议您在命令名后直接跟参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">您 Ubuntu/linux</span><br></pre></td></tr></table></figure>
<p>这两个部分都是宾语，它们是命令的操作对象。大部分的命令只有一个操作对象，也有一些命令是双宾语结构的，具有一个直接宾语和一个间接宾语。比如 拷贝 这个命令 cp (copy)</p>
<h4 id="分隔符"><a class="header-anchor" href="#分隔符">¶</a>分隔符</h4>
<p>我们的汉语是象形文字，没有分隔符。但是所有的拼音文字中都有分隔符，来分隔单词。Linux命令中同样使用空格作分隔符。</p>
<p>cp a /home 表示把当前目录下的 a 文件，拷贝到 /home 目录下。（命令的不同部分使用空格分隔，连续的空格视为一个空格）</p>
<p>上面的那句话，翻译成Linux的命令，应该是这个样子的：</p>
<p>推荐 --郑重的 您 Ubuntu/Linux （按照传统，“-”后跟简写为单个字母的参数，“--”后跟完整单词的参数。不过也有例外：）</p>
<p>哈，Linux的命令也蛮简单吧？</p>
<h3 id="Linux程序、进程"><a class="header-anchor" href="#Linux程序、进程">¶</a>Linux程序、进程</h3>
<p>或许您会这样想，Linux命令的句型确实不难，但是那么多命令，我怎么知道它们都是作什么的呢？而且不同的系统中，可以使用的命令似乎也不太一样，这真让人困惑……</p>
<p>其实Linux的命令，运行的是Linux系统中的程序。只要您已安装了程序，您就可以通过命令来运行它，并且可以使用参数来精细的调整它的运行状态。也可以通过点击启动图标来运行，不过启动图标不能够方便的调整参数，并不是很方便。</p>
<p>举一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mplayer -shuffle -loop 3 -playlist mymp3.list</span><br></pre></td></tr></table></figure>
<p>可能您运行上面命令，系统会提示您 无法找到命令，那是因为您没有安装mplayer这个程序。mplayer是我见过的支持格式最多的播放器，几乎任何已知格式的多媒体文件，都可以使用mplayer来播放。它包含一个图形界面的前端，您可以在菜单中找到它，鼠标点击运行;也可以通过执行命令来运行它的命令行版本。</p>
<p>如果您的系统中没有mplayer播放器，我们建议您安装一个。关于程序的安装，请参阅 软件安装 。</p>
<p>上面命令中， mplayer 调用了mplayer播放器程序。参数 -shuffle 表示随机播放， -loop 表示循环播放，后面的3 为循环的次数，如果为 0 ,则一直播放。 -playlist 表示播放列表中的曲目。我们可以把mp3的路径放到 mymp3.list文件中，让mplayer来播放它们。</p>
<p><strong>进程</strong> 为运行中的程序，是程序在内存中的镜像。</p>
<p>好了，现在您已经了解了 Shell 、 命令 、 程序 、 进程 的概念，您基本上也就了解了Linux（Linux系统真是非常简洁，而且容易理解：）。</p>
<p>但只知道这些，您并不能顺畅使用。接下来的章节中，我们来进一步介绍它的细节。</p>
<h2 id="Linux系统简介"><a class="header-anchor" href="#Linux系统简介">¶</a>Linux系统简介</h2>
<h3 id="路径"><a class="header-anchor" href="#路径">¶</a>路径</h3>
<p>路径分为绝对路径和相对路径。</p>
<p><strong>绝对路径</strong>的起始点为根目录 <code>/</code> ，例如 <code>/usr/local/bin</code> 就是绝对路径，它指向系统中一个绝对的位置，不受其它因素影响。</p>
<p><strong>相对路径</strong>的起始点为当前目录，如果您现在位于 /usr 目录，那么相对路径 local/bin 所指示的位置为 <code>/usr/local/bin</code></p>
<p>也就是说，相对路径所指示的位置，除了相对路径本身，还受到当前位置的影响。例如Linux系统中常见的目录 <code>/bin</code> 、 <code>/usr/bin</code>、 <code>/usr/local/bin</code>，如果只有一个相对路径 bin，那么它指示的位置可能上面三个目录中的任意一个，也可能是其它目录。</p>
<p>如果我告诉您到 <code>bin</code> 目录寻找一个文件，您可能搞不清楚是哪一个 <code>bin</code> 目录。只有当前位置确定，相对路径指示的位置才能够确定。</p>
<p>现在我说， <code>/usr/local</code> 目录下，它的相对路径 <code>bin</code> 中有某个文件，这样就比较明确了。</p>
<p>在相对路径中 . 表示当前目录， .. 表示当前目录的上一级目录。</p>
<p>假设您安装了一个程序，它的主程序没有被放置到上面三个 bin 目录中的任何一个，或者其它系统能够找到的地方，您就得告诉系统，它的可执行文件在哪里。</p>
<blockquote>
<p>可以使用绝对路径，例如： <code>/home/user/bin/</code>可执行文件</p>
</blockquote>
<p>或者定位到 <code>/home/user/bin</code> 目录，使用相对目录来定位它 ./可执行文件</p>
<p>如果您定位到了它的子目录，比如 <code>/home/user/bin/gui</code>，您可以使用 <code>..</code> 来表示它的上级目录 <code>../</code>可执行文件</p>
<p>路径相关命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> (change directory) 更改目录。</span><br><span class="line"><span class="built_in">pwd</span> (<span class="built_in">print</span> working directory)显示当前路径。</span><br><span class="line">ls (list) 显示当前目录中的文件列表。</span><br></pre></td></tr></table></figure>
<p>请尝试以下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc 进入“/etc”目录，这里使用的是绝对路径</span><br><span class="line"></span><br><span class="line"><span class="built_in">pwd</span> 显示当前路径，这个命令返回结果“/etc”</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> init.d 进入“/etc”目录的子目录“init.d”，这里使用的是相对路径</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> .. 进入上一级目录“/etc”</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ../home “/etc” 目录的上一级目录为“/”，它的子目录“home”为“/home”</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> - 回到上一次的目录，我们在“/etc”目录跳转到“/home”目录，所以这次是回到“/etc”目录</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~ “~”代表当前用户的“<span class="variable">$HOME</span>”目录，也就是“/home/&#123;用户名&#125;”目录。</span><br><span class="line"></span><br><span class="line">ls 在任何时候，您都可以使用“ls”命令，来了解当前目录下都有哪些文件。</span><br></pre></td></tr></table></figure>
<p>远程路径：</p>
<p>远程路径的表示方法为 <code>协议://用户名:密码@位置/路径:端口</code></p>
<p>大多数的远程路径可以使用默认端口匿名访问，由此用户名、密码、端口通常不需要填写。例如：</p>
<p><code>http://www.ubuntu.org.cn/.../index.html</code></p>
<p>要求身份验证的远程路径，您可以使用下面的方式访问:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ftp://user:passwd@ftp.ubuntu.org.cn:21</span><br></pre></td></tr></table></figure>
<h3 id="软件"><a class="header-anchor" href="#软件">¶</a>软件</h3>
<p>Linux中没有***注册表***这个概念。安装软件，理论上讲，只要拷贝所有相关文件，并运行它的主程序就可以了。</p>
<p>按照传统，一个软件通常分别拷贝到同级目录下的 bin、etc、lib、share等文件夹。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Bin      可执行文件，程序的可执行文件通常在这个目录下。在环境变量中设定搜索路径，就可以直接执行，而不需要定位其路径。</span><br><span class="line"></span><br><span class="line">Etc       配置文件，大部分系统程序的配置文件保存于 /etc 目录，便于集中修改。</span><br><span class="line"></span><br><span class="line">Lib      库文件，集中在一起，方便共享给不同程序。相较不同的软件单独保存库文件，能够节约一些磁盘空间。</span><br><span class="line"></span><br><span class="line">Share    程序运行所需要的其它资源，例如图标、文本。这部分文件是专有的，不需要共享；而且目录结构相对复杂，混放在一起比较混乱，所以单独存放。</span><br></pre></td></tr></table></figure>
<p>还有一些软件，占用一个单独的目录，所有的资源都在这个目录中。类似于Windows下的绿色软件，不推荐在Linux系统下这样作。</p>
<ul>
<li>
<p>执行时，系统找不到可执行文件（搜索所有路径，资源开销过大，是不现实的），需要定位其位置，像这样 /home/user/bin/可执行文件 ，不够方便。</p>
</li>
<li>
<p>许多系统软件需要协作运行，配置文件分别保存，定位它们非常麻烦</p>
</li>
<li>
<p>如果程序使用的库文件，像图形库文件，都单独存放，那么磁盘空间的浪费会非常严重。</p>
</li>
</ul>
<p>有一些大型软件，或者您布署的重要应用，您可以将它们单独安装在一个文件夹下。（通常源码安装支持这种方式，将在 <a href="#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85">软件安装</a> 部分介绍）</p>
<h4 id="配置方式"><a class="header-anchor" href="#配置方式">¶</a>配置方式</h4>
<p>Linux下没有类似 注册表 的系统，系统和软件都可以通过纯文本的配置文件进行设置。</p>
<p>事实上，图形界面的配置工具，通常就是以图形界面的方式修改配置文件，适合设置一些比较简单的程序。如果软件有几千个可以配置的选项，全部作成菜单，想象一下……开始发抖吧……</p>
<p>图形界面的配置工具，可以看作特定配置文件专用编辑器。您一样可以使用通用文本编辑器来编辑配置文件，比如 Nano、Gedit、Knote、Vim或者Emacs等等。不考虑阅读、修改配置文本占用的时间，直接修改配置文件甚至更迅速。</p>
<p>如果只是要修改某一常用选项，而且时常修改，比如主机的IP地址。使用文本编辑器，您要找到相应的配置文件，还要在配置文件中找到相应的选项，会浪费掉您的时间和耐性。</p>
<p>图形配置工具经常会受各种因素制约，比如网络服务器中不提供图形服务，图形界面不够稳定……这时，您可以使用命令行的配置工具来完成这些工作。</p>
<p>例如： 修改主机IP地址，可以使用ifconfig这个程序，执行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 192.168.0.1</span><br></pre></td></tr></table></figure>
<p>在以后的章节中，如果我们提示您修改某一文件，例如 /etc/fstab ，您可以使用任何顺手的文本编辑器打开它。</p>
<h3 id="隐藏文件"><a class="header-anchor" href="#隐藏文件">¶</a>隐藏文件</h3>
<p>Linux下，名称中第一个字符为 . 的文件或者文件夹，系统默认情况下将它们隐藏起来，</p>
<p>您可以尝试以下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~ 进入您的用户目录</span><br><span class="line">ls 查看当前目录下的文件列表</span><br><span class="line">ls -a 查看所有文件的文件列表（包括隐藏文件）。</span><br></pre></td></tr></table></figure>
<p>现在，您可以看到许多文件名以 . 起始的文件或者文件夹了吧？使用 ls 命令无法显示它们</p>
<ul>
<li>
<p>如果您只想查看隐藏文件，而不包括这两个特殊目录，您可以使用 ls 命令的参数 -A （ls -A）</p>
</li>
<li>
<p>每个目录下都包含两个特殊目录 . 和 .. 。您也许猜到了， . 代表当前目录， .. 代表上一级目录。目录是一种特殊类型的文件！</p>
</li>
</ul>
<p>文件类型</p>
<p>Linux系统主要根据文件头信息来判断文件类型，扩展名并非决定因素。</p>
<p>现在使用 ls -l 命令，查看详细信息格式的文件列表，您将会看到如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">total 5</span><br><span class="line">drwxr-x--- 4 user group 4096 Mar 10 00:37 filename</span><br><span class="line">drwxr-xr-x 21 user group 4096 Mar 10 20:16 文件名</span><br><span class="line">-rw------- 1 user group 524 Mar 10 00:40 a</span><br><span class="line">-rw-r--r-- 1 user group 24 Jun 11 2000 b</span><br><span class="line">drwx------ 2 user group 4096 Mar 9 11:06 c</span><br></pre></td></tr></table></figure>
<p>共显示了七列信息，从左至右依次为：权限、文件数、归属用户、归属群组、文件大小、创建日期、文件名称</p>
<p>其中要特别留意的是第一列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x</span><br></pre></td></tr></table></figure>
<p>一共有10个位置，可以分为4组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">d    rwx  r-x  r-x</span><br></pre></td></tr></table></figure>
<p>第一组只有一个字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">** d* *文件夹*     ** -* *普通文件*        ** l* *链接*       ** b* *块设备文件*     ** c* *字符设备文件。*</span><br></pre></td></tr></table></figure>
<p>剩下的3组分别为归属用户、归属群组、其它用户或群组对于该文件的权限。我们看它的格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rwx rwx  rwx</span><br><span class="line"></span><br><span class="line">** r* *可读*       ** w* *可写*      ** x* *可执行*</span><br></pre></td></tr></table></figure>
<p>它们的顺便不能颠倒，某一位置为空(-)，则表示不具有相应的权限。</p>
<p>说明：Linux下的可执行文件并不是由扩展名（例如 .exe ）决定的，而是由其可执行权限位决定。</p>
<p>权限</p>
<p>我们已经知道了，文件的权限分为 <code>r</code> （可读）、 <code>w</code> （可写）、 <code>x </code>（可执行）三种类型，而一个文件可以针对归属用户，归属群组，其它用户用户或群组分别设定权限。</p>
<p>这种权限管理的方式灵活、简单、严密、明晰。尽管如此，在最初的阶段，可能会有一点小小的不适。因为它无所不在，而您习惯了的Windows的权限管理却不是这样（非常混乱，大多数时间形同虚设，偶尔用到却让人伤透脑筋）。</p>
<p>使用 <code>chmod</code> 命令更改文件的权限，使用 <code>chown</code> 来更改文件的归属。例如：</p>
<p>chmod 755 xxx</p>
<p>chmod a+x xxx</p>
<p>chown user:group xxx 用来更改文件的归属用户，也可以同时更改其归属群组</p>
<p>chgrp group xxx 用来更改文件的归属群组</p>
<p>上面命令中的 755 和 a+x 是两种类型的表达式</p>
<p>我们将后面章节中详细介绍 权限管理 用户管理</p>
<p>执行命令的权限</p>
<p>有一些命令，普通用户也可以执行，但是只有root用户才能执行成功，这是为什么呢？</p>
<p>例如在系统中增加一个新用户 useradd</p>
<p>ls -l /usr/sbin/useradd</p>
<p>可以看到：</p>
<p>-rwxr-xr-x 1 root root 56156 2006-04-03 21:37 /usr/sbin/useradd</p>
<p>明明所有的用户都可以执行嘛？</p>
<p>这是因为， useradd 命令是修改 /etc/passwd 文件的一个工具，来看看这个文件：</p>
<p>ls -l /etc/passwd</p>
<p>-rw-r--r-- 1 root root 1835 2006-06-24 17:58 /etc/passwd</p>
<p>原来只有root用户才能写入修改结果，非root用户执行 useradd 命令当然不会有结果。</p>
<p>执行命令的身份</p>
<p>默认情况下，您的命令提示符末位为 $ ，这表示您将以普通用户的身份执行命令。</p>
<p>您可以使用 su （switch user）这个命令来切换其它用户。</p>
<p>例如 su root ，切换到root用户，如果 su 命令后面没有切换目标，那么这个命令默认切换到root用户。</p>
<p>现在您执行 su 这个命令，系统会提示您输入密码，请输入管理员的密码。这个时候，您会发现命令提示符末位变成了 # ，您将以root用户的身份执行命令。</p>
<p>Ubuntu系统默认会随机设定系统的root密码，这样会更安全一些，这个时候您可以执行“sudo”命令，输入当前用户密码后，暂时以root</p>
<p>用户的身份执行命令。（前提是sudoer列表中要包含您的ID。您在安装Ubuntu系统时创建的用户，默认具有“sudo”权限）</p>
<p>如果您能够执行“sudo”命令，那么您也就拥有了root权限。在后面的章节中，如果我们提到了“root权限”，那么您可以通过以上两种方式来实现</p>
<h3 id="命令行"><a class="header-anchor" href="#命令行">¶</a>命令行</h3>
<p>Shell、Console、Terminal</p>
<p>在前面的章节中，我们曾提到，电视机的遥控器，也是一种人机交互的界面，算是一种Shell。</p>
<p>但是这个概念并不准确，遥控器只是向Shell发送指令的工具，Shell接收到遥控器发出指令后，将指令转换为系统命令，由系统来执行。</p>
<p>例如我们按的遥控器上的 数字键1 ,遥控器将 切换为1频道 的指令发送到Shell，Shell将指令转换为系统可以识别的 频道1 ，系统执行它，您就可以观看1频道的电视节目了。</p>
<p>通常每台电视机只有一种Shell，比如有的电视机系统具有“画中画”的功能，那么Shell中便有相应的功能定义，您可以通过遥控器上的“画中画”功能键来开启它。假设您的电视机没有此功能，Shell中也就没有相应的功能定义。拥有一个带“画中画”功能控制键的遥控器，即便信号兼容，您还是不能够使用这一功能：）</p>
<p>不用遥控器也可以控制电视机，假设您的遥控器丢了，您还可以走到电视机前，使用机身上的控制面板来控制它（相当于使用Linux的控制台）。但是您一定不喜欢这种方式，除非您想锻炼身体：）</p>
<p>在Linux系统中，由于图形界面和控制台的分辨率通常不一致，所以切换时要有一个延时。对于我们中文用户来讲，控制台下中文的显示也比较麻烦。而且控制台显示内容通常不如终端显示的全面。</p>
<p>所以我们推荐您使用终端来执行命令，它使用起来感觉很像遥控器：）</p>
<p>rxvt-unicode</p>
<p>通常情况下，您买一台电视机，只能获得一个遥控器。虽然它为您的电视机量身定作，能够最大限度发挥电视机的能力，但您却不一定喜欢它。说不定这个遥控器体形太大，持握不方便;或者它体形太小，容易失踪;又或者它的按键要么太硬，要么太软;它的键盘要么太大，要么太小……您一般也可以容忍，毕竟遥控器使用频率并不算高：）</p>
<p>如果您的终端有些地方不讨您喜欢，比如说响应太慢，或者不能正常显示中文……那就难以忍受了，您应该换一个其它的试试。</p>
<p>在前面的章节，我们介绍您使用的终端为Gnome-Termianl，它是系统默认使用的终端，显示中文不错，不过响应比较慢，您可能已经处于水深火热之中了。。。</p>
<p>我们推荐您使用urxvt（mlterm也是不错的选择）</p>
<p>您可以使用 <code>sudo apt-get install rxvt-unicode</code> 命令来安装它。</p>
<p>urxvt 启动它 （urxvt不支持控制台，您得在图形界面下启动它。终端、Alt+F2，建议您在启动栏里新建一个启动图标）</p>
<p>rxvt-unicode还支持“服务器/客户端”的运行模式：</p>
<p>urxvtd 启动一个守护进程daemon（支持控制台）</p>
<p>urxvtc 启动客户端client。多个客户端可以同时连接到一个urxvtd，以达到节省系统资源的目的。</p>
<p>或许您对rxvt的默认设置不满意，您可以修改用户配置文件 ~/.Xresources 来设定它。修改全局配置文件 /etc/X11/Xresources/Xresources ，则对所有用户生效，只有root才可以修改此文件。</p>
<p>这里有一些简单的选项：（以 ! 起始的行是注释，您可以直接拷贝此文件的内容）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!!=============================================================================</span><br><span class="line">!! RXVT-unicode setting</span><br><span class="line">!!=============================================================================</span><br><span class="line">!设置字体分辨率</span><br><span class="line">Xft.dpi:96</span><br><span class="line"></span><br><span class="line">!窗口大小</span><br><span class="line">Rxvt.geometry: 80x40+80+80</span><br><span class="line"></span><br><span class="line">!颜色</span><br><span class="line">Rxvt.background:#333333</span><br><span class="line">Rxvt.foreground:antiquewhite</span><br><span class="line">Rxvt.inheritPixmap:False</span><br><span class="line">Rxvt.colorBD:yellow</span><br><span class="line">Rxvt.colorUL:antiquewhite</span><br><span class="line"></span><br><span class="line">!滚动条</span><br><span class="line">Rxvt.scrollBar:True</span><br><span class="line">Rxvt.scrollBar_left:True</span><br><span class="line">Rxvt.scrollBar_floating:False</span><br><span class="line">Rxvt.scrollstyle:next</span><br><span class="line">Rxvt.scrollColor:#999999</span><br><span class="line"></span><br><span class="line">!屏幕缓冲</span><br><span class="line">Rxvt.saveLines:30000</span><br><span class="line">Rxvt.color12:DodgerBlue</span><br><span class="line">Rxvt.font:7x14,xft:AR PL New Sung</span><br><span class="line"></span><br><span class="line">!输入法一般设置为xim</span><br><span class="line">!inputMethod:xim;Scim除外</span><br><span class="line">!输入法样式可选:Root(置底) OverTheSpot(跟随) OffTheSpot OnTheSpot，后两种不是所有的都支持</span><br><span class="line">Rxvt.preeditType:Root</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip：右键点击启动栏， 添加自启动器 ， 自定义程序 ，便可以在添加自己的启动图标。</p>
</blockquote>
<h3 id="在线帮助系统"><a class="header-anchor" href="#在线帮助系统">¶</a>在线帮助系统</h3>
<p>您可以使用命令 man 或者 info 来阅读Linux命令的在线文档。命令的格式非常简单：</p>
<p>man xxx</p>
<p>大部分命令手册为英文版，如果您的英文不太好，或许有些困难。在后面的 系统管理 章节中，我们会尽力向您介绍命令的使用方法。</p>
<p>说明：在使用“man”浏览器的时候，一些快捷键您可能会用到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ctrl+f(orward) 向下翻一页 Ctrl+d(own) 向下翻半页</span><br><span class="line">Ctrl+b(ackward) 向上翻一页 Ctrl+u(p) 向上翻半页</span><br><span class="line">/ 查找 q(uit) 退出</span><br></pre></td></tr></table></figure>
<p>以上为VI风格的键绑定。您也可以使用Emacs风格的键绑定</p>
<h3 id="bash"><a class="header-anchor" href="#bash">¶</a>bash</h3>
<p>好了，现在我们换了一个遥控器，感觉顺手多了。现在来操练一下，下载一首mp3：</p>
<p>我们使用 wget 这个程序，它非常可靠，完全值得您信赖。</p>
<p>首先找到一个可以下载的地址，复制链接，在终端窗口内点击鼠标中键，把它粘贴进去。</p>
<p>现在终端中大概是这种情形：</p>
<p><a href="http://www.download.net/xxx.mp3" target="_blank" rel="noopener">http://www.download.net/xxx.mp3</a></p>
<p>按下 Ctrl+a 组合键，我们发现光标移动到了行首。输入 wget 和 空格</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://www.download.net/xxx.mp3</span><br></pre></td></tr></table></figure>
<p>回车后，终端中出现一些信息，不一会儿工夫，mp3便下载完成。</p>
<p>使用 Ctrl+a 组合键，我们就不需要使用方向键来移动光标，方向键每次只能移动一个字符，没有效率</p>
<p>您还可以使用 Ctrl+f 向前移动光标， Ctrl+b 向后移动光标， Ctrl+e 将光标移动到行末……………… （键绑定）</p>
<h3 id="Note"><a class="header-anchor" href="#Note">¶</a>Note</h3>
<p>Linux的图形界面中，鼠标中键通常执行“粘贴”的操作，如果您的鼠标没有中键，您可以左右键同时按下。</p>
<p>中止正在运行的程序</p>
<p>如果一个命令持续时间很长，以致于不能够进行其它操作，可以使用 Ctrl+c 来强行中止它。</p>
<p>Ctrl+s</p>
<p>出于意外，有时您会按下 Ctrl+s 这个组合键，Shell便被冻结。尝试使用 Ctrl+q 组合键，看能否恢复正常。</p>
<h3 id="键绑定"><a class="header-anchor" href="#键绑定">¶</a>键绑定</h3>
<p>等等，有必要记这么多快捷键么？都这么复杂！</p>
<p>我们强烈建议您记住，以大幅度的提高操作效率。而且这是readline控件的键绑定，在任何使用readline控件的程序中，您都可以使用它们。例如bash、lftp、gdb等程序;同时，Linux下最著名的Emacs编辑器，也是这种风格的键绑定（其实是readline使用了Emacs风格的键绑定才对），甚至FireFox中，也可以使用类似风格的快捷键！（Linux下主要有两种风格的键绑定，一种是VI风格，另一种是Emacs风格，我们会在 简明VIM教程中介绍）</p>
<p>现在列举一些ReadLine的键绑定，您可以自行尝试。（运行 man readline 命令，来查看ReadLine手册）</p>
<p>先来了解一些约定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\C<span class="_">-a</span> 表示 Ctrl+a</span><br><span class="line">\M<span class="_">-a</span> 表示 Meta+a Meta键在PC中通常为ALT键</span><br><span class="line"></span><br><span class="line">A 表示 Shift+a</span><br><span class="line">（下面括号中的\A代表Alt，\S代表Shift）</span><br><span class="line"></span><br><span class="line">移动命令：</span><br><span class="line"></span><br><span class="line"> \C<span class="_">-a</span>  移动到行首  Aheah        \C<span class="_">-e</span>  移动到行末  End          \C<span class="_">-f</span>  向前移动一个字符  Forward </span><br><span class="line"></span><br><span class="line">*\C-b* *向后移动一个字符* *Backward        \M<span class="_">-f</span>* *向前移动一个单词*        *\M-b* *向后移动一个单词*</span><br><span class="line"></span><br><span class="line">*\C<span class="_">-l</span>* *清空屏幕* *cLear*      *这两个命令也可以理解为移动命令*        *\C-p* *上翻，前一条命令* *Previous*</span><br><span class="line"></span><br><span class="line">*\C-n* *下翻，后一条命令* *Next*        *编辑命令：*</span><br><span class="line"></span><br><span class="line">*\C<span class="_">-d</span>* *删除光标后的一个字符* *\M<span class="_">-d</span>* *删除光标后的一个单词* *Delete*</span><br><span class="line"></span><br><span class="line">*\BackSpace* *删除光标前的一个字符* *\M-BackSpace* *删除光标前的一个单词*</span><br><span class="line"></span><br><span class="line">*\C-k* *删除光标至行末的部分* *Kill         \C-u* *删除光标至行首的部分* *Unix-line-discard*</span><br><span class="line"></span><br><span class="line">*\C-w* *删除光标前的一个单词* *Word       \C-y* *粘贴（最后删除的对象）* *Yank      \C--* *撤消*</span><br><span class="line"></span><br><span class="line">搜索历史纪录：</span><br><span class="line"></span><br><span class="line">*\C-r* *连续使用* *``C-r``* *可以查找下一个*        *\M-p      \M-n*</span><br><span class="line"></span><br><span class="line">补全：</span><br><span class="line"></span><br><span class="line">*\Tab* *使用频率最高的功能！*        *\C-o* *遍历补全* *（未定义）*</span><br><span class="line"></span><br><span class="line">*\M-? M-=* *列出所有可能选项，相当于按两次**Tab**键（**M-**？* *实际按键为**\A+\S+/**）*</span><br><span class="line"></span><br><span class="line">*\M-<span class="comment">#* *注释掉当前命令，用于将当前命令暂存于历史纪录列表（**\A+\S+3**）*</span></span><br><span class="line"></span><br><span class="line">*\M-!* *补全命令，通常用来补全子命令，例如* *``sudo``* *的子命令（**\A+\S+1**）*</span><br><span class="line"></span><br><span class="line">*\M-~* *补全用户名（**\A+\S+`**）*       *\M-@* *补全主机名（**\A+\S+2**）*</span><br><span class="line"></span><br><span class="line">*\M-$* *补全变量（**\A+\S+4**）*         *\M-_* *补全历史纪录中的纪录（**\A+\S+-**）*</span><br><span class="line"></span><br><span class="line">*\M-** *将所有可能选项放到命令行中（**\A+\S+8**）*</span><br></pre></td></tr></table></figure>
<h4 id="自定义键绑定"><a class="header-anchor" href="#自定义键绑定">¶</a>自定义键绑定</h4>
<p>通过修改 <code>/etc/inputrc</code> 文件，可以更改键绑定。建议您使用默认的键绑定，以避免不必要的烦恼。当然了，Emacs风格的键绑定是通用的，随时都有可能用到。</p>
<p>在文件中添加该行，可以将ReadLine的键绑定设为VI风格。（Bash、Lftp等使用ReadLine的软件同时生效）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set editing-mode vi</span><br></pre></td></tr></table></figure>
<p>找到这一行：</p>
<p>$if mode=emacs</p>
<p>在它的下面添加如下内容</p>
<p>&quot;\C-o&quot;: menu-complete</p>
<p>###这两行不是必须的，视情况而定###</p>
<p>&quot;\c-p&quot;: non-incremental-reverse-search-history</p>
<p>&quot;\c-n&quot;: non-incremental-forward-search-history</p>
<p>重新登录Shell，您就可以使用 \C-o （Ctrl+o）来遍历补全。假如您的文件名为中文，或者出现乱码时，您可以使用 \M-*</p>
<p>将所有文件名放入命令行，再删除多余的，这真是麻烦极了！所以您可以使用 \C-o 遍历补全，将所有可能的选项轮流放入命令行。</p>
<p>或者使用Vim编辑器编辑 /etc/inputrc 文件，在插入模式下使用 Ctrl+v 组合键。按下 Ctrl+o ，这时编辑区新增一个 ^O 字符，等价于 \C-o</p>
<h3 id="通配符"><a class="header-anchor" href="#通配符">¶</a>通配符</h3>
<p>使用 <code>?</code> 代表任意单个字符。例如 <code>???lo</code> ，表示 <code>lo</code> 前有三个字符，它可以匹配 <code>Hello</code></p>
<p>使用 <code>*</code> 代表随意几个任意字符。例如<code>*.iso</code>，代表所有 <code>iso</code> 格式的文件。</p>
<p>说明：您可以将遍历补全和通配符结合使用，以提高效率。</p>
<p>例如：</p>
<p>cd */ 则遍历补全只补全文件夹</p>
<p>chmview *.chm 则遍历补全只补全chm文件</p>
<h3 id="任务管理"><a class="header-anchor" href="#任务管理">¶</a>任务管理</h3>
<p><code>&amp;</code> 在命令的末尾加上一个 <code>&amp;</code> 符号，表示背景任务，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://www.download.net/xxx/mp3 &amp;</span><br></pre></td></tr></table></figure>
<p><code>;</code> 使用 <code>;</code> 将多个命令连结起来，则表示任务按顺序执行</p>
<p><code>&amp;&amp;</code> 使用 <code>&amp;&amp;</code> 将多个命令连结起来，则表示只有前面的命令执行成功，后面的命令才能得以执行</p>
<p>`` `&lt;命令&gt;` ，如果一个命令中包含以 `` （Esc键下方的按键）括起来的子命令，那么子命令将被优先执行，执行结果被代入上一级命令继续执行，例如创建一个以当前时间命名的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch `date +%m.%d_%H:%M:%S`</span><br></pre></td></tr></table></figure>
<p><code>touch</code> 命令能够创建一个文件，它的操作对象，为 <code>date +%m%d%H%M%S 命令的输出 06.06_06:06:60</code></p>
<p>这样，我们创建了一个名为 <code>06.06_06:06:60</code> 的文件（六月六日六时六分刚过六十秒-_-!）</p>
<p>Ctrl+z</p>
<p>将当前Shell中的任务挂起</p>
<p>这个时候任务的状态为</p>
<p>[1]+ Stopped xxx</p>
<p>Bg-------------------------------------------------将挂起的任务背景运行。这时它的状态为[1]+ xxx &amp;</p>
<p>Fg-------------------------------------------------将背景任务调到前台执行jobs</p>
<p>方括号中的数字为命令的任务编号，您可以使用 jobs 命令来查看所有背景任务</p>
<p>如果后台运行多个任务，您可以在 bg 或者 fg 后跟任务编号，作为操作对象，例如：bg 2</p>
<p>管道、重定向</p>
<p>&gt;-----------------------重定向符号，它的作用是将命令的输出重定向到一个文件中。比如我们想把命令 ls 的结果保存为 FileList 文件，作一个清单，我们可以使用重定向符号来完成它：</p>
<p>ls -l &gt; FileList</p>
<p>&gt;&gt;----------------------作用与 &gt; 基本相同，不同点在于， &gt;&gt; 以追加的方式，将命令的输出写入文件的末尾。</p>
<p>&lt;-----------------------是从文件到命令的重定向，将文件的内容作为命令的输入。</p>
<p>|------------------------为管道符号，它的作用是将前一个命令的输出，作为下一个命令的输入。假设一个目录下的文件太多，使用 ls命令不能够在屏幕中完全显示，这个时候您可以将 ls 命令的输出，通过管道符号，作为浏览器 less 的输入。就可以使用浏览器的功能翻页、查找：ls -al | less</p>
<p>说明： less 浏览器的键绑定几乎与 man 相同，请参阅 在线帮助系统</p>
<h3 id="脱字符"><a class="header-anchor" href="#脱字符">¶</a>脱字符</h3>
<p>Shell中的一些功能是通过特殊符号作为控制字符来实现的，上面已经介绍了很多了。这产生一个问题，如果一个文件名中，刚好包含了这些字符，比如 ; ，就很难对它进行操作。使用 less 浏览这个文件</p>
<p>less ;xxx</p>
<p>less 会很快返回一个错误信息，因为并没有一个文件名作为操作对象。接着，Shell会报告，系统中没有 xxx 这个命令。</p>
<p>这是因为Shell将文件名中的 ; 解析为按顺序执行命令。</p>
<p>或者您的文件名以空白起始，而在Shell中，无论多少个空格，都将被解析为一个分隔符。您甚至不是使用命令重命名此文件。</p>
<p>这个时候就要用到脱字符 \ 了，它能够将一个具有特殊涵义的字符转换普通字符。上面的两个任务，可以在文件名中每个特殊字符前加一个 \ ，像这样</p>
<p>less ;xxx</p>
<p>less \ \xxx</p>
<p>less ;\ &amp;\xxx</p>
<p>说明：也可以使用 &quot; 将文件名括起来，例如 less &quot;; &amp;xxx&quot; ，在很多情况下，这样甚至更方便。</p>
<p>脱字符在Shell中也可以作为换行符，在一个命令的末尾添加一个 \ ，然后回车，在下一行继续输入命令剩余的部分，将一个命令拆分为多行且不影响它的执行（如果执行一个很长的命令，请将它拆分为多行以便于阅读）</p>
<p>事实上换行符也符合脱字符的定义。回车键有两个涵义，一个是 执行 （Enter），另一个 换行 （折线箭头）。在Shell中它作为控制字符 执行 ，使用脱字符后，它便代表排版字符 换行 了。</p>
<h3 id="Fish"><a class="header-anchor" href="#Fish">¶</a>Fish</h3>
<p>the friendly interactive shell</p>
<p>正如它的名字，Fish是一款非常友好的Shell，大力推荐！使用命令 sudo apt-get install fish 安装它。完成后，运行命令 fish 切换到fish， exit 返回bash。</p>
<p>简单介绍一下它的优点：</p>
<h4 id="1-自动补全、语法高亮"><a class="header-anchor" href="#1-自动补全、语法高亮">¶</a>1.自动补全、语法高亮</h4>
<p>bash的自动补全默认只是补全命令、路径，如果想补全变量、参数等，通常需要使用复杂的组合键（见上面bash的介绍），即便您能够记住它们，快</p>
<p>速准确的按下这些组合键，也是一种严峻的考验。而FISH的自动补全可以自动识别语法，补全正确的内容。并且具有语法高亮的功能，比如用MPLAYER放</p>
<p>MP3：</p>
<p>mpl<tab>(ayer) -l<tab>(oop) <tab>(0)</tab></tab></tab></p>
<p>-sh<tab>(uffle) -pl<tab>(aylist) <tab>(mp3_playlist)</tab></tab></tab></p>
<p>一阵猛按 <tab> 键，一个蛮长的命令就完成了。</tab></p>
<p>补全结果不唯一时给出的提示中含有简短的说明，这样通常也不用看帮助了：）比如：</p>
<p>mplayer -l</p>
<p><tab> 后，自动将参数补全为 -lo 然后给出提示</tab></p>
<p>-{lo}adidx (Load index from file) -{lo}op (Loop playback) {花括号中为青色文字}</p>
<p>它的语法高亮功能十分有用，如果你输入的命令是正确的，则用青色显示，正确的参数用白色显示，错误的则一律用红色。</p>
<h4 id="2-方便的历史纪录搜索"><a class="header-anchor" href="#2-方便的历史纪录搜索">¶</a>2.方便的历史纪录搜索</h4>
<p>还是上面的那个命令</p>
<p>mplayer -loop 0 -shuffle -playlist mp3_playlist</p>
<p>用上翻配合下翻浏览命令历史，直到找到这个命令，当然那样太慢了。</p>
<p>还可以输入以上命令中的某一部分，如 uffle 只要翻一次就可以找到了</p>
<p>（还可以META＋上翻在已输入部分中插入某一历史单词）</p>
<h4 id="3-文件夹历史纪录"><a class="header-anchor" href="#3-文件夹历史纪录">¶</a>3.文件夹历史纪录</h4>
<p>dirh （dir history）就可以显示当前会话中进入的文件夹纪录</p>
<p>使用 prevd 和 nextd 跳转</p>
<p>假如曾进入过1 2 3 4 5 这几个文件夹， prevd 4 可以让你在 5 中直接跳到 1</p>
<h4 id="4-其它的功能"><a class="header-anchor" href="#4-其它的功能">¶</a>4.其它的功能</h4>
<p>fish基本是兼容bash的。键绑定也非常的相似，少数的键绑定不尽一致，例如：</p>
<p>\C-h 删除光标前的一个字符（bash为退格键，不方便）</p>
<p>修改 /etc/fish_inputrc 这个文件，增加以下行：</p>
<p>&quot;\C-n&quot;: history-search-forward</p>
<p>&quot;\C-p&quot;: history-search-backward</p>
<p>现在使用Ctrl+p上翻，使用Ctrl+n下翻。如果已经在命令行中输入字符，那么Ctrl+p就是在历史纪录向上查找您输入的字符，Ctrl+n为向下查找，非常的方便。</p>
<p>设定您的默认Shell</p>
<p>如果能够拥有root权限，可以直接修改 /etc/passwd 文件。找到您用户ID起始的行</p>
<p>user:x:1000:112:user,,,:/home/user:/bin/bash</p>
<p>最后一个字段为登录后的默认Shell， /bin/bash 是程序 bash 的主程序路径。 fish 主程序的路径通常为 /usr/bin/fish 。</p>
<p>/etc/shells 中列出系统中所有可用Shell（ /bin/false 代表禁用Shell）</p>
<p>也可以使用如下命令更改您的默认Shell</p>
<p>chsh -s /usr/bin/fish</p>
<p>（需要输入您的密码）</p>
<p>Tip：可以使用 whereis xxx 命令，来查找 xxx 程序的安装位置，详见搜索</p>
<p>设定命令的搜索路径</p>
<p>使用 echo $PATH ，可以显示 $PATH 变量，输出如下：</p>
<p>/usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin /usr/bin/X11 /usr/games /usr/X11R6/bin</p>
<p>它是一个环境变量，代表执行命令时，Shell的搜索路径。</p>
<p>执行一个命令时，Shell会到 $PATH 变量定义的路径去搜索，并运行与命令同名的可执行文件。如果程序、脚本等可执行文件并不在上面的路径中，就必须使用绝对路径或者相对路径定位可执行文件。</p>
<p>例如：</p>
<p>/usr/local/mplayer -menu xxx.rmvb</p>
<p>/etc/init.d/powernowd start</p>
<p>cd /usr/local/ &amp;&amp; ./mplayer -menu xxx.rmvb</p>
<p>可以修改 /etc/environment 文件来设定您的命令搜索路径，找到 PATH 起始的行</p>
<p>PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin&quot;</p>
<p>在双引号中添加您的自定义路径，并以 : 分隔。</p>
<h2 id="Ubuntu系统简介"><a class="header-anchor" href="#Ubuntu系统简介">¶</a>Ubuntu系统简介</h2>
<h3 id="Ubuntu系统目录结构"><a class="header-anchor" href="#Ubuntu系统目录结构">¶</a>Ubuntu系统目录结构</h3>
<p>以下为Ubuntu目录的主要目录结构，您稍微了解它们都包含了哪些文件就可以了，不需要记忆。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/ 根目录</span><br><span class="line">│</span><br><span class="line">├boot/ 启动文件。所有与系统启动有关的文件都保存在这里</span><br><span class="line">│ └grub/ Grub引导器相关的文件</span><br><span class="line">│</span><br><span class="line">├dev/ 设备文件</span><br><span class="line">├proc/ 内核与进程镜像</span><br><span class="line">│</span><br><span class="line">├mnt/ 临时挂载</span><br><span class="line">├media/ 挂载媒体设备</span><br><span class="line">│</span><br><span class="line">├root/ root用户的<span class="variable">$HOME</span>目录</span><br><span class="line">├home/</span><br><span class="line">│ ├user/ 普通用户的<span class="variable">$HOME</span>目录</span><br><span class="line">│ └.../</span><br><span class="line">│</span><br><span class="line">├bin/ 系统程序</span><br><span class="line">├sbin/ 管理员系统程序</span><br><span class="line">├lib/ 系统程序库文件</span><br><span class="line">├etc/ 系统程序和大部分应用程序的全局配置文件</span><br><span class="line">│ ├init.d/ SystemV风格的启动脚本</span><br><span class="line">│ ├rcX.d/ 启动脚本的链接，定义运行级别</span><br><span class="line">│ ├network/ 网络配置文件</span><br><span class="line">│ ├X11/ 图形界面配置文件</span><br><span class="line">├usr/</span><br><span class="line">│ ├bin/ 应用程序</span><br><span class="line">│ ├sbin/ 管理员应用程序</span><br><span class="line">│ ├lib/ 应用程序库文件</span><br><span class="line">│ ├share/ 应用程序资源文件</span><br><span class="line">│ ├src/ 应用程序源代码</span><br><span class="line">│ ├<span class="built_in">local</span>/</span><br><span class="line">│ │ ├soft/ 用户程序</span><br><span class="line">│ │ └.../ 通常使用单独文件夹</span><br><span class="line">│ ├X11R6/ 图形界面系统</span><br><span class="line">│</span><br><span class="line">├var/ 动态数据</span><br><span class="line">│</span><br><span class="line">├temp/ 临时文件</span><br><span class="line">├lost+found/ 磁盘修复文件</span><br></pre></td></tr></table></figure>
<h3 id="启动流程"><a class="header-anchor" href="#启动流程">¶</a>启动流程</h3>
<p>Linux系统主要通过以下步骤启动：</p>
<h4 id="1-读取MBR的信息，启动Boot-Manager"><a class="header-anchor" href="#1-读取MBR的信息，启动Boot-Manager">¶</a>1.读取MBR的信息，启动Boot Manager</h4>
<p>Windows使用NTLDR作为Boot</p>
<p>Manager，如果您的系统中安装多个版本的Windows，您就需要在NTLDR中选择您要进入的系统。</p>
<p>Linux通常使用功能强大，配置灵活的GRUB作为Boot Manager，我们将在启动管理章节中向您介绍它的使用方式。</p>
<h4 id="2-加载系统内核，启动init进程"><a class="header-anchor" href="#2-加载系统内核，启动init进程">¶</a>2.加载系统内核，启动init进程</h4>
<p>init进程是Linux的根进程，所有的系统进程都是它的子进程。</p>
<h4 id="3-init进程读取-etc-inittab文件中的信息，并进入预设的运行级别，按顺序运行该运行级别对应文件夹下的脚本。脚本通常以-start-参数启动，并指向一个系统中的程序。"><a class="header-anchor" href="#3-init进程读取-etc-inittab文件中的信息，并进入预设的运行级别，按顺序运行该运行级别对应文件夹下的脚本。脚本通常以-start-参数启动，并指向一个系统中的程序。">¶</a>3.init进程读取 /etc/inittab文件中的信息，并进入预设的运行级别，按顺序运行该运行级别对应文件夹下的脚本。脚本通常以 start 参数启动，并指向一个系统中的程序。</h4>
<p>通常情况下， <code>/etc/rcS.d/</code> 目录下的启动脚本首先被执行，然后是 <code>/etc/rcN.d/</code> 目录。例如您设定的运行级别为<code>3</code>,那么它对应的启动目录为 <code>/etc/rc3.d/</code> 。</p>
<h4 id="4-根据-etc-rcS-d-文件夹中对应的脚本启动-Xwindow服务器-xorg"><a class="header-anchor" href="#4-根据-etc-rcS-d-文件夹中对应的脚本启动-Xwindow服务器-xorg">¶</a>4.根据 /etc/rcS.d/文件夹中对应的脚本启动 Xwindow服务器 xorg</h4>
<p>Xwindow为Linux下的图形用户界面系统。</p>
<h4 id="5-启动登录管理器，等待用户登录"><a class="header-anchor" href="#5-启动登录管理器，等待用户登录">¶</a>5.启动登录管理器，等待用户登录</h4>
<p>Ubuntu系统默认使用GDM作为登录管理器，您在登录管理器界面中输入用户名和密码后，便可以登录系统。（您可以在 <code>/etc/rc3.d/</code> 文件夹中找到一个名为 <code>S13gdm</code> 的链接）</p>
<h3 id="更改运行级别"><a class="header-anchor" href="#更改运行级别">¶</a>更改运行级别</h3>
<p>在 /etc/inittab 文件中找到如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The default runlevel.</span></span><br><span class="line">id:2:initdefault:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一行中的数字 2 ,为系统的运行级别，默认的运行级别涵义如下：</span></span><br><span class="line"><span class="comment"># 0 关机    1 单用户维护模式   2~5 多用户模式  6 重启</span></span><br></pre></td></tr></table></figure>
<h3 id="服务管理"><a class="header-anchor" href="#服务管理">¶</a>服务管理</h3>
<p>更改启动服务</p>
<p>在运行级别对应的文件夹中，您可以看到许多文件名以 <code>S##</code> 和 <code>K##</code> 起始的启动脚本链接。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/rcS.d/S35mountall.sh 挂载文件系统</span><br><span class="line">/etc/rcS.d/S40networking 启用网络支持</span><br><span class="line">/etc/rc2.d/S13gdm 启动登录管理器</span><br><span class="line">/etc/rc2.d/S20makedev 创建设备文件</span><br><span class="line">/etc/rc2.d/S23xinetd 启动超级进程</span><br></pre></td></tr></table></figure>
<p>init进程将以 start 为参数，按文件名顺序执行所有以 S## 起始的脚本。脚本名称中的数字越小，它将被越早执行。例如在</p>
<p>/etc/rc2.d/ 文件夹中， S13gdm 文件名中的数字小于 S23xinetd , S13gdm 将比 S23xinetd 先执行。</p>
<p>如果一个脚本链接，以 K## 起始，表示它将以 stop 参数被执行。如果相应服务没有启动，则不执行该脚本。例如：</p>
<p>/etc/rc2.d/K20powernowd 针对某种硬件的电源管理支持</p>
<p>如果您想禁止某一服务在启动时自动运行，您可以将相应运行级别中的脚本由 S##xxx 重命名为 K##xxx 。</p>
<p>手动控制服务</p>
<p>您也可以手动运行带有以下参数的启动脚本，来控制系统服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- start 启动    - stop 停止    - restart 重启</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/rc2.d/K20powernowd start</span><br></pre></td></tr></table></figure>
<p>有时您并不清楚当前运行级别，该运行级别下未必有相应脚本；而且此类脚本的前三位字符并不固定，不便于记忆。这时，可以直接使用</p>
<p>/etc/init.d/ 文件夹中的启动脚本（ /etc/rcX.d/ 中的启动脚本链接到 /etc/init.d/</p>
<p>文件夹下相应脚本），这也是推荐的方式。</p>
<p>例如：</p>
<p>/etc/init.d/powernowd start</p>
<blockquote>
<p>Note：以上命令的位置并没有包含在环境变量的搜索路径中，所以要输入完整路径。</p>
</blockquote>
<h3 id="常用系统服务"><a class="header-anchor" href="#常用系统服务">¶</a>常用系统服务</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">acpi-support 高级电源管理支持     acpid acpi守护程序.这两个用于电源管理，非常重要</span><br><span class="line"></span><br><span class="line">alsa 声音子系统          alsa-utils</span><br><span class="line"></span><br><span class="line">anacron cron的子系统，将系统关闭期间的计划任务，在下一次系统运行时执行。</span><br><span class="line"></span><br><span class="line">apmd acpi的扩展         atd 类似于cron的任务调度系统。建议关闭</span><br><span class="line"></span><br><span class="line">binfmt-support 核心支持其他二进制的文件格式。建议开启         bluez-utiles 蓝牙设备支持</span><br><span class="line"></span><br><span class="line">bootlogd 启动日志。开启它         cron 任务调度系统，建议开启</span><br><span class="line"></span><br><span class="line">cupsys 打印机子系统。       dbus 消息总线系统(message bus system)。非常重要</span><br><span class="line"></span><br><span class="line">dns-clean 使用拨号连接时，清除dns信息。        </span><br><span class="line"></span><br><span class="line">evms 企业卷管理系统（Enterprise Volumn Management system）</span><br><span class="line"></span><br><span class="line">fetchmail 邮件用户代理守护进程，用于收取邮件         gdm gnome登录和桌面管理器。</span><br><span class="line"></span><br><span class="line">Gdomap       gpm 终端中的鼠标支持。      halt 别动它。</span><br><span class="line"></span><br><span class="line">hdparm 调整硬盘的脚本，配置文件为 /etc/hdparm.conf。       hibernate 系统休眠</span><br><span class="line"></span><br><span class="line">hotkey-setup 笔记本功能键支持。支持类型包括： HP, Acer, ASUS, Sony, Dell, 和IBM</span><br><span class="line"></span><br><span class="line">hotplug and hotplug-net 即插即用支持，比较复杂，建议不要动它</span><br><span class="line"></span><br><span class="line">hplip HP打印机和图形子系统       ifrename 网络接口重命名脚本。如果您有十块网卡，您应该开启它</span><br><span class="line"></span><br><span class="line">inetd 在文件 /etc/inetd.conf 中，注释掉所有你不需要的服务。如果该文件不包含任何服务，那关闭它是很安全的。       klogd 重要。</span><br><span class="line"></span><br><span class="line">linux-restricted-modules-common 受限模块支持。 /lib/linux-restricted-modules/ 文件夹中的模块为受限模块。例如某些驱动程序，如果您没有使用受限模块，就不需要开启它。</span><br><span class="line"></span><br><span class="line">lvm 逻辑卷管理系统支持。         makedev 创建设备文件，非常重要。      mdamd 磁盘阵列</span><br><span class="line"></span><br><span class="line">module-init-tools 从/etc/modules加载扩展模块，建议开启。</span><br><span class="line"></span><br><span class="line">networking 网络支持。按 /etc/network/interfaces 文件预设激活网络，非常重要。</span><br><span class="line"></span><br><span class="line">ntpdate 时间同步服务，建议关闭。      pcmcia pcmcia设备支持。      powernowd 移动CPU节能支持</span><br><span class="line"></span><br><span class="line">ppp and ppp-dns 拨号连接          readahead 预加载库文件。     reboot 别动它      </span><br><span class="line"></span><br><span class="line">resolvconf 自动配置DNS      rmnologin 清除nologin         rsync rsync守护程序</span><br><span class="line"></span><br><span class="line">sendsigs 在重启和关机期间发送信号      single 激活单用户模式         ssh ssh守护程序。建议开启</span><br><span class="line"></span><br><span class="line">stop-bootlogd 在2，3，4，5运行级别中停止bootlogd服务          sudo 检查sudo状态。重要</span><br><span class="line"></span><br><span class="line">sysklogd 系统日志       udev &amp; udev-mab 用户空间dev文件系统（userspace dev filesystem）。重要</span><br><span class="line"></span><br><span class="line">umountfs 卸载文件系统        urandom 随机数生成器        usplash 开机画面支持</span><br><span class="line"></span><br><span class="line">vbesave 显卡BIOS配置工具。保存显卡的状态      xorg-common 设置X服务ICE socket。</span><br><span class="line"></span><br><span class="line">adjtimex 调整核心时钟的工具       dirmngr 证书列表管理工具,和gnupg一起工作。</span><br><span class="line"></span><br><span class="line">hwtools irqs优化工具          libpam-devperm 系统崩溃之后，用于修理设备文件许可的守护程序。</span><br><span class="line"></span><br><span class="line">lm-sensors 板载传感器支持         mdadm-raid 磁盘陈列管理器        </span><br><span class="line"></span><br><span class="line">screen-cleanup 清除开机屏幕的脚本       xinetd 管理其他守护进程的一个inetd超级守护程序</span><br></pre></td></tr></table></figure>
<h3 id="重要配置文件"><a class="header-anchor" href="#重要配置文件">¶</a>重要配置文件</h3>
<blockquote>
<p>无论任何情况下，修改配置文件之前，先备份它！</p>
</blockquote>
<p>建议使用这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp xxx xxx_`date +%y%m%d_%H:%M`</span><br></pre></td></tr></table></figure>
<p>当然这很麻烦，您可以新建一个名为 bak 的文件，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">sudo cp <span class="variable">$1</span> <span class="variable">$1_</span>`date +%y%m%d_%H:%M`</span><br></pre></td></tr></table></figure>
<p>把它放在您能够记住的目录下，比如 <code>/home</code> ，执行命令 <code>sh /home/bak xxx</code> ，就可以将当前文件夹下的文件 <code>xxx</code> 另存为 <code>xxx_yymmdd_HH:MM</code> 的格式了</p>
<p>全局配置文件</p>
<p>系统初始化</p>
<p>/etc/inittab 运行级别、控制台数量        /etc/timezone 时区        /etc/inetd.conf 超级进程</p>
<p>文件系统</p>
<p>/etc/fstab 开机时挂载的文件系统         /etc/mtab 当前挂载的文件系统</p>
<p>用户系统</p>
<p>/etc/passwd 用户信息          /etc/shadow 用户密码          /etc/group 群组信息</p>
<p>/etc/gshadow 群组密码         /etc/sudoers Sudoer列表（请使用“visudo”命令修改此文件，而不要直接编辑）</p>
<p>Shell</p>
<p>/etc/shell 可用Shell列表       /etc/inputrc ReadLine控件设定       /etc/profile 用户首选项</p>
<p>/etc/bash.bashrc bash配置文件</p>
<p>系统环境</p>
<p>/etc/environment 环境变量      /etc/updatedb.conf 文件检索数据库配置信息         /etc/issue 发行信息</p>
<p>/etc/issue.net         /etc/screenrc 屏幕设定</p>
<p>网络</p>
<p>/etc/iftab 网卡MAC地址绑定       /etc/hosts 主机列表       /etc/hostname 主机名</p>
<p>/etc/resolv.conf 域名解析服务器地址       /etc/network/interfaces 网卡配置文件</p>
<p>用户配置文件</p>
<p>/etc/ 目录下的文件，只有root用户才有权修改。应用软件的全局配置文件，通常普通用户也不能够修改，如果要通过配置软件，来适应特殊需求，您可以修改用户配置文件。</p>
<p>用户配置文件通常为全局配置文件的同名隐藏文件，放在$HOME目录下，例如：</p>
<p>/etc/inputrc /home/user/.inputrc</p>
<p>/etc/vim/vimrc /home/user/.vim/vimrc</p>
<p>也有少数例外，通常是系统程序</p>
<h3 id="软件安装"><a class="header-anchor" href="#软件安装">¶</a>软件安装</h3>
<h4 id="DPKG"><a class="header-anchor" href="#DPKG">¶</a>DPKG</h4>
<p>Linux系统中，软件通常以源代码或者预编译包的形式提供。</p>
<p>软件源代码需要编译为二进制的机器代码才能够使用，安装比较耗时，不过您可以自行调节编译选项，决定需要的功能或组件，或者针对硬件平台作一些优化。</p>
<p>预编译的软件包，通常是由软件的发布者进行编译，您只要将软件拷贝到系统中就可以了。考虑到预编译软件包的适用性，预编译软件包通常不会针对某种硬件平台优化。它所包含的功能和组件也是通用的组合。</p>
<p>Ubuntu系统中，软件通常以 deb 格式的包文件发布，它是一种预编译软件包。deb包中除了包含已编译的软件，通常还包括软件的拷贝路径、对其它软件包的依赖关系纪录、比较通用的配置文件以及软件的描述、版本、作者、类别、占用空间等信息。</p>
<p>deb软件包命令遵行如下约定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">soft_ver-rev_arch.deb</span><br><span class="line">soft 软件包名称   ver 软件版本号    revUbuntu 修订版本号   arch 目标架构名称</span><br></pre></td></tr></table></figure>
<p>例如： azureus_2.4.0.2-0ubuntu2_all.deb</p>
<p>您需要使用 <code>dpkg</code> 命令来管理deb软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -i | --install xxx.deb 安装deb软件包</span><br><span class="line"></span><br><span class="line">dpkg -r | --remove xxx.deb 删除软件包</span><br><span class="line"></span><br><span class="line">dpkg -r -P | --purge xxx.deb 连同配置文件一起删除</span><br><span class="line"></span><br><span class="line">dpkg -I | -info xxx.deb 查看软件包信息</span><br><span class="line"></span><br><span class="line">dpkg -L xxx.deb 查看包内文件</span><br><span class="line"></span><br><span class="line">dpkg -l 查看系统中已安装软件包信息</span><br><span class="line"></span><br><span class="line">dpkg-reconfigure xxx 重新配置软件包</span><br></pre></td></tr></table></figure>
<p>有些时候，您使用 dpkg 安装一个软件包，系统会提示您该软件包依赖其它软件包。这时，您先安装其它软件包，直到满足依赖关系为止。或者同时安装多个软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dpkg -i aaa.deb bbb.deb ccc.deb</span><br></pre></td></tr></table></figure>
<h4 id="APT"><a class="header-anchor" href="#APT">¶</a>APT</h4>
<p>如果一个软件依赖关系过于复杂，使用 <code>dpkg</code></p>
<p>来安装它，并不是一个明智的选择，这个时候您就需要用到APT软件包管理系统。APT可以自动的检查依赖关系，通过您预设的方式来获得相关软件包，并自动</p>
<p>安装配置它。事实上，在多数情况下，我们推荐您使用APT软件包管理系统。</p>
<p>APT系统需要一个软件信息数据库和至少一个存放着大量deb包的软件仓库，我们称之为 <code>源</code> 。 <code>源</code> 可以是网络服务器，安装CD或者本地软件仓库。您需要修改 <code>/etc/apt/sources.list</code> 文件，使APT系统能够连接到 <code>源</code>。</p>
<p>从以下页面中获得网络安装源的列表，并且根据您的网络环境，选择速度较快的源。</p>
<p><a href="http://wiki.ubuntu.org.cn/%E5%BF%AB%E9%80%9F%25E" target="_blank" rel="noopener">http://wiki.ubuntu.org.cn/快速%E</a>......%97/DapperDrake</p>
<p>APT系统主要包括 <code>apt-get</code> 和 <code>apt-cache</code> 等命令。通常是复合命令，包含若干个子命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install xxx 安装xxx</span><br><span class="line"> -d 仅下载       -f  强制安装 </span><br><span class="line"></span><br><span class="line">apt-get remove xxx 卸载xxx</span><br><span class="line"></span><br><span class="line">apt-get update 更新软件信息数据库</span><br><span class="line"></span><br><span class="line">apt-get upgrade 进行系统升级</span><br><span class="line"></span><br><span class="line">apt-cache search 搜索软件包</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：建议您经常使用 sudo apt-get update 命令来更新您的软件信息数据库</p>
</blockquote>
<blockquote>
<p>APT系统修复
由于各种意外，APT系统可能会出现问题，使用如下命令，尝试进行修复：apt-get -f install</p>
</blockquote>
<h3 id="源码包"><a class="header-anchor" href="#源码包">¶</a>源码包</h3>
<p>对于绝大多数软件，我们建议您使用APT系统来安装它。在少数情况下，例如某软件没有以deb包的格式发布，或者需要定制适合自己的软件，您可以通过编译源代码的方式安装它。</p>
<p>首先需要下载软件的源码包，并且将它解包为一些源代码文件。并了便于管理，建议将下载的源码包移动到 <code>/usr/local/src/</code> 目录下，并在这里解包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv xxx.tar.gz /usr/<span class="built_in">local</span>/src 移动源码包</span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src 进入“/usr/<span class="built_in">local</span>/src/”目录</span><br><span class="line">sudo tar -xzvf xxx.tar.gz 解包源码</span><br><span class="line"><span class="built_in">cd</span> xxx_ver/ 进行解包后的源码目录</span><br></pre></td></tr></table></figure>
<p>源码目录中通常有一个 <code>configure</code> 脚本，用来配置即将开始的编译过程。您可以执行它</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./configure [--prefix=/usr/loca/xxx ......]</span><br></pre></td></tr></table></figure>
<p>它会自动检测软件的编译环境和依赖关系，并且生成 <code>Makefile</code> 文件。</p>
<p>使用带参数的命令 <code>./configure --help</code> ，或者阅读 <code>INSTALL</code> 文件，查看该脚本允许的参数。例如使用</p>
<p><code>--prefix=/usr/local/xxx</code> 参数，将软件的安装目录设定为 <code>/usr/local/xxx/</code>。（如果一定要将软件安装在单独目录下，建议您安装在这里）</p>
<p>现在执行 <code>make</code> 命令，系统会根据 <code>Makefile</code> 文件中的设定，通过 make 工具调用编译器和所需资源文件，将源代码编译成目标文件。</p>
<p>sudo make</p>
<p>执行 <code>make install</code> 命令， <code>make</code> 工具会自动连接目标文件和库文件，将最终生成的文件拷贝到 <code>Makefile</code> 文件设定的路径中，并且完成更改文件的属性，删除残留文件等活动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p>现在，编译安装已经完成，为了更方便的使用它，需要给程序的可执行文件作一个符号链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ln -sf /usr/<span class="built_in">local</span>/xxx/可执行文件 /usr/<span class="built_in">local</span>/bin/可执行文件</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip:为了顺利的进行编译，至少需要安装 build-essential 软件包。
<code>sudo apt-get install build-essential</code></p>
</blockquote>
<h3 id="Xwindow简介"><a class="header-anchor" href="#Xwindow简介">¶</a>Xwindow简介</h3>
<p>Xwindow是工作站图形系统的工业标准，它有多种不同的实现，Ubuntu系统中使用的为Xorg。</p>
<p>（比较前卫的图形界面系统XGL，实际代替X服务器的作用，另外还有与之配套的窗口管理器）</p>
<h4 id="历史"><a class="header-anchor" href="#历史">¶</a>历史</h4>
<p>当然，Xwindow有悠久的历史和传统，不过那不在我们讨论的范围。您要注意的有两点：</p>
<ul>
<li>
<p>Xwindow 和 Xbox 中的“X”本意是不同的， X 只是 W 后的一个字母，差不多应该这样理解，Xwindow 是 Window 的接班人 （注意，Window不是Windows）</p>
</li>
<li>
<p>同样，也不要把 Xwindow 说成是 Xwindows，那是一种亵渎！一切伟大的创造，都应得到应有的理解和尊重。</p>
</li>
</ul>
<h4 id="架构及原理"><a class="header-anchor" href="#架构及原理">¶</a>架构及原理</h4>
<p>Xwindow使用服务器－客户端架构。无论本地图形界面，还是远程图形界面，都以同样的流程工作。这样便不需要分别进行设计和维护，极大的提高了网络透明性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">本地X客户端 ┐ ┌ 键盘</span><br><span class="line">远程X客户端 ┼ X协议 ─ X服务器 ─ 硬件规范 ┼ 鼠标</span><br><span class="line">远程X客户端 ┘ └ 显示器</span><br></pre></td></tr></table></figure>
<h4 id="Xserver"><a class="header-anchor" href="#Xserver">¶</a>Xserver</h4>
<p>Xwindow系统服务器端，通过驱动程序（硬件规范）来管理硬件资源。</p>
<p>例如：当我们移动鼠标时，通过驱动程序，向 Xserver 发送信息：</p>
<p>“向右移动200点，向上移动100点”（向右上移动）；“按下左键”……</p>
<p>Xserver作出如下响应：</p>
<p>1、上一次鼠标停止的坐标为600,500</p>
<p>2、向右200，向上100。现在鼠标位于坐标800,600</p>
<p>3、坐标800,600处，为窗口Firefox的“关闭”按钮</p>
<p>4、根据预设动作，将 “点击Firefox窗口的关闭按钮” 翻译为 “关闭窗口Firefox”</p>
<p>5、向X客户端Firefox发送一个“退出”消息</p>
<p>6、Xserver通过显示子系统（显卡、显示器），全程显示鼠标的位置和移动</p>
<p>* 事实上，向程序发送“退出”信号，通常窗口管理器完成……为了描述方便，这里暂不区分。稍后，我们将向您介绍 窗口管理器 的其它一些细节。</p>
<p>大多数的鼠标不需要专门的驱动程序，因为它们符合某一硬件规范，例如：有四个移动方向和三个键</p>
<h4 id="Xclient"><a class="header-anchor" href="#Xclient">¶</a>Xclient</h4>
<p>Xwindow系统客户端，通过X协议，实现与Xserver 的交互。</p>
<p>例如：</p>
<p>1、Xclient （假设Firefox） 接收Xserver的消息： 输入焦点在地址栏的范围内，“<a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”，回车</p>
<p>2、Firefox根据预设动作，将这些消息识别为 “打开链接 <a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”</p>
<p>3、Firefox向域名服务器请求 链接 “<a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”。域名服务器将这个请求转换为 “<a href="http://ubuntu.org.cn/%E2%80%9D" target="_blank" rel="noopener">http://ubuntu.org.cn/”</a> 和 IP地址211.148.131.7，发送回 Firefox</p>
<p>4、Firefox将 “<a href="http://ubuntu.org.cn/%E2%80%9D%E6%98%BE%E7%A4%BA%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%EF%BC%88%E5%90%91Xserver%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%9C%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%BD%8D%E7%BD%AE%E6%98%BE%E7%A4%BA%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%EF%BC%89" target="_blank" rel="noopener">http://ubuntu.org.cn/”显示在地址栏（向Xserver发送请求，在地址栏位置显示这个地址）</a></p>
<p>5、Firefox向地址 211.148.131.7 请示显示页面。</p>
<p>6、Firefox将服务器发送回的页面显示在主窗口中</p>
<h4 id="Xprotocol"><a class="header-anchor" href="#Xprotocol">¶</a>Xprotocol</h4>
<p>Xwindow系统协议，Xserver和Xclient之间进行通信的规则</p>
<h4 id="窗口管理器"><a class="header-anchor" href="#窗口管理器">¶</a>窗口管理器</h4>
<p>Window Manager，一种特殊的Xclient。</p>
<p>使用窗口管理器时，Xserver并不直接与其它Xclient通信，而是通过WM中转，当一些消息被定义为WM指令时，它们会被拦截。例如Alt+F4关闭窗口、拖动标题栏……</p>
<p>消息“打开链接 <a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”，具体内容如下：</p>
<p>输入焦点在地址栏的范围内，“<a href="http://ubuntu.org.cn" target="_blank" rel="noopener">ubuntu.org.cn</a>”，回车</p>
<p>Xserver并不能直接判断焦点，而是这样：</p>
<p>1、Xserver向WM发送位置和点击的信息，WM根据当前的“焦点策略”确定激活（最上层）的窗口为Firefox</p>
<p>2、Xserver将Firefox显示在最上层，高亮显示它的标题栏</p>
<p>3、在窗口Firefox内点击地址栏，或者 Ctrl+L，Xserver将位置信息发送给WM，WM再发送给Firefox</p>
<p>4、Firefox判断当前焦点后，显示一个闪动的文字输入光标</p>
<p>5、Firefox将输入光标通过WM发送给Xserver，Xserver在屏幕相应位置进行显示</p>
<p>那么，“窗口管理器”到底能作些什么呢？其实它所作的一切都是管理窗口。例如：</p>
<p>1.最上层的窗口会把其它窗口挡住</p>
<p>2.它通常是一个“已激活窗口”，根据不同的“焦点策略”，窗口管理器确定被激活的窗口。</p>
<p>激活窗口标题栏高亮显示，接收大部分的键盘消息和窗口内的鼠标点击消息。</p>
<p>3.为了美观和容易分辨，大多数窗口都要有标题栏和边框。</p>
<p>为了方便，标题栏上还要有一些按钮，比如：最小化，最大化，关闭（这些按钮是窗口管理器请求的小窗口）</p>
<p>4.一个窗口可以在另一个窗口旁边显示，而不一定完全被遮挡。为了实现这一点，就要控制窗口显示的位置</p>
<p>5.为了控制窗口的显示位置，需要将整个屏幕用座标描述，最好的办法是绘制一个填充整个屏幕的窗口，也就是根窗口。</p>
<p>6.因为根窗口是最大的，所以它可以严严实实的遮挡任何窗口，为了避免这一点，根窗口永远在最底层。</p>
<p>这很形象的说明了为什么它叫作“根窗口” ……root</p>
<p>7.根窗口不一定只有一个，大多数的窗口管理器可以使用 “工作区” ，来切换显示多个根窗口</p>
<p>8.根窗口固定位置上通常放置一些其它Xclient的窗口，例如底部面板，顶部面板，侧面板，程序启动图标</p>
<p>9.面板上又可以放一些其它的Xclient窗口，如任务条，启动栏，菜单……</p>
<p>任务条可以以图标显示正在运行的任务，还可以作其它的杂活，像自动挂载USB设备……</p>
<p>启动流程</p>
<p>我们知道 init 是linux的根进程，是所有进程的父进程。同样， xinit是所有Xwindow进程的根进程</p>
<p>Startx</p>
<p>startx 命令可以在命令行下启动图形界面。执行startx 命令时，实际执行这一命令：</p>
<p>xinit /etc/X11/xinit/xinitrc -- /etc/X11/xinit/xserverrc</p>
<p>根据脚本 /etc/X11/xinit/xserverrc 启动Xserver，同时根据脚本 /etc/X11/xinit/xinitrc 启动指定Xclient进程，例如窗口管理器</p>
<p>脚本 /etc/X11/xinit/xserverrc 以预设的参数运行程序 /usr/bin/X11/X</p>
<p>/etc/X11/xinit/xinitrc 脚本则指向 /etc/X11/Xsession ，依次启动 /etc/X11/Xsession.d 目录中的脚本</p>
<p>* 您可以在用户配置文件 ~/.Xsession 中定义使用的WM，它的优先级高于全局配置文件(对于GDM会话不起作用)</p>
<p>* startx启动时，并不会再进行身份认证。因为它启动的是 /etc/X11/Xsession.d/gnome-session ，而不是 GDM会话</p>
<p>GDM会话</p>
<p>Ubuntu系统启动时自动进入图形界面，不需要运行 startx 命令</p>
<p>在某些启动级别中，包含了gdm的启动脚本，例如 ： /etc/rc2.d/S13gdm</p>
<p>\1. 指向 /etc/gdm/gdm-cdd.conf 文件，加载预设视觉主题，启动 /usr/lib/gdm/gdmgreeter（登录屏幕）</p>
<p>\2. 用户身份认证完成后，启动 /etc/X11/default-display-manager 这个文件中设定的默认窗口管理器 /usr/sbin/gdm</p>
<p>gdm在启动时，会要求用户名和密码，也就是我们看到的登录屏幕（gdmgreeter）</p>
<p>* /usr/share/xsessions 目录下为所有可用登录会话的脚本</p>
<p>配置文件</p>
<p>X服务器</p>
<p>X服务器的主要配置文件为 /etc/X11/xorg.conf</p>
<p>布局</p>
<p>Section &quot;ServerLayout&quot;</p>
<p>Identifier &quot;Default Layout&quot;</p>
<p>Screen &quot;Default Screen&quot; 0 0</p>
<p>InputDevice &quot;Generic Keyboard&quot;</p>
<p>InputDevice &quot;Configured Mouse&quot;</p>
<p>EndSection</p>
<p>* 定义了 布局标识 、 屏幕标识 、 键盘标识 、 鼠标标识</p>
<p>模块</p>
<p>Section &quot;Module&quot;</p>
<p>Load &quot;i2c&quot;</p>
<p>Load &quot;bitmap&quot;</p>
<p>Load &quot;ddc&quot;</p>
<p>Load &quot;dri&quot;</p>
<p>Load &quot;extmod&quot;</p>
<p>Load &quot;freetype&quot;</p>
<p>Load &quot;glx&quot;</p>
<p>Load &quot;int10&quot;</p>
<p>Load &quot;type1&quot;</p>
<p>Load &quot;vbe&quot;</p>
<p>EndSection</p>
<p>X核心字体路径</p>
<p>Section &quot;Files&quot;</p>
<p>FontPath &quot;/usr/share/X11/fonts/75dpi&quot;</p>
<p>FontPath &quot;/usr/share/X11/fonts/100dpi&quot;</p>
<p>FontPath &quot;/usr/share/X11/fonts/misc&quot;</p>
<p>FontPath &quot;/usr/share/X11/fonts/cyrillic&quot;</p>
<p>FontPath &quot;/usr/share/X11/fonts/100dpi/:unscaled&quot;</p>
<p>FontPath &quot;/usr/share/X11/fonts/75dpi/:unscaled&quot;</p>
<p>FontPath &quot;/usr/share/X11/fonts/Type1&quot;</p>
<p>FontPath &quot;/usr/share/fonts/Chinese/wqy-bitmapfont&quot;</p>
<p>EndSection</p>
<p>屏幕</p>
<p>Section &quot;Screen&quot;</p>
<p>Identifier &quot;Default Screen&quot;</p>
<p>Device &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;</p>
<p>Monitor &quot;DELL E176FP&quot;</p>
<p>DefaultDepth 24</p>
<p>SubSection &quot;Display&quot;</p>
<p>Depth 1</p>
<p>Modes &quot;1280x1024&quot; &quot;1152x864&quot; &quot;1024x768&quot; &quot;800x600&quot; &quot;720x400&quot; &quot;640x480&quot;</p>
<p>………………</p>
<p>EndSubSection</p>
<p>EndSection</p>
<p>* DefaultDepth 24 默认色深</p>
<p>* SubSection 可用色深及分辨率</p>
<p>显卡</p>
<p>Section &quot;Device&quot;</p>
<p>Identifier &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;</p>
<p>Driver &quot;fglrx&quot;</p>
<p>Option &quot;KernelModuleParm&quot; &quot;agplock=0&quot;</p>
<p>VideoRam 131072</p>
<p>EndSection</p>
<p>* Identifier 显卡标识</p>
<p>* Driver 显卡驱动（如不同正常启用图形界面，首先尝试&quot;vesa&quot;）</p>
<p>* Option 显卡参数</p>
<p>* VideoRam 显存大小</p>
<p>显示器</p>
<p>Section &quot;Device&quot;</p>
<p>Identifier &quot;ATI Technologies, Inc. RV370 5B62 [Radeon X600 (PCIE)]&quot;</p>
<p>Driver &quot;fglrx&quot;</p>
<p>Option &quot;KernelModuleParm&quot; &quot;agplock=0&quot;</p>
<p>VideoRam 131072</p>
<p>EndSection</p>
<p>配置文件内部结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/</span><br><span class="line">├/ <span class="string">"ServerLayout"</span> 布局</span><br><span class="line">│├ <span class="string">"InputDevice"</span> keyboard 键盘</span><br><span class="line">│├ <span class="string">"InputDevice"</span> mouse 鼠标</span><br><span class="line">││</span><br><span class="line">│└/ <span class="string">"Screen"</span> 显示子系统</span><br><span class="line">│ ├ <span class="string">"Monitor"</span> 显示器</span><br><span class="line">│ ├ <span class="string">"Device"</span> videocard 显卡</span><br><span class="line">│</span><br><span class="line">│</span><br><span class="line">├ <span class="string">"Files"</span> 字体</span><br><span class="line">└ <span class="string">"Module"</span> 模块</span><br></pre></td></tr></table></figure>
<p>X客户端</p>
<p>在 /etc/X11/Xsession 文件中可以发现下列内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OPTIONFILE=/etc/X11/Xsession.options</span><br><span class="line">SYSRESOURCES=/etc/X11/Xresources</span><br><span class="line">USRRESOURCES=<span class="variable">$HOME</span>/.Xresources</span><br><span class="line">SYSSESSIONDIR=/etc/X11/Xsession.d</span><br><span class="line">USERXSESSION=<span class="variable">$HOME</span>/.xsession</span><br><span class="line">ALTUSERXSESSION=<span class="variable">$HOME</span>/.Xsession</span><br><span class="line">ERRFILE=<span class="variable">$HOME</span>/.xsession-errors</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>OPTIONFILE=/etc/X11/Xsession.options</code> 设定X进程的启动参数。例如允许用户进程<code>allow-user-xsession</code></p>
</li>
<li>
<p><code>Xresources X</code>资源文件。许多程序保留了X接口，允许X服务器管理一些视觉选项，例如窗口内的字体，配色等</p>
</li>
<li>
<p><code>xsession X</code>进程。可以设置一些启动时自动运行的程序，也可以用来设定自己的窗口管理器（窗口管理器和桌面环境或者登录管理器是无关的）</p>
</li>
</ul>
<p>字体</p>
<p>freetype渲染引擎</p>
<p>作为Xorg服务器的一个模块，freetype的功能包括读取Truetype字体信息，如大小、分辨率、编码等，并以之为依据渲染字体 -</p>
<p>freetype2.x相对于freetype1.x 增加了抗锯齿等功能 - ( /etc/X11/xorg/conf 的 Module</p>
<p>字段中，可以选择字体渲染模块，建议使用默认的 freetype )</p>
<p>freetype只负责渲染字体。而查找字体，则可以由X服务器、X客户端或者字体服务器来完成。找到字体后，使用freetype引擎就地渲染</p>
<p>X核心字体</p>
<p>X服务器根据X客户端的请求（字符编码），查找字体并进行渲染，然后显示，我们称之为</p>
<p>Xft字体</p>
<p>X客户端自行查找字体并进行渲染，X服务器只负责显示</p>
<p>由于Xft字体的渲染在客户端完成，所以它可以动态的加载，而不需要随同X服务器一同启动</p>
<p>字体服务器</p>
<p>另外还有一种字体服务器模式，例如 XFT字体：当客户端请求字体时，X服务器将请求转发到字体服务器，由字体服务器查找字体，并使用freetype引擎渲染，将结果传回X服务器，X服务器进行显示……</p>
<p>X核心字体</p>
<p>/etc/X11/xorg.conf 中可以配置X核心字体的搜索路径</p>
<p>Section &quot;Files&quot;</p>
<p>FontPath &quot;/usr/X11R6/lib/X11/fonts/misc/&quot;</p>
<p>FontPath &quot;/usr/X11R6/lib/X11/fonts/Type1/&quot;</p>
<p>FontPath &quot;/usr/X11R6/lib/X11/fonts/Speedo/&quot;</p>
<p>FontPath &quot;/usr/X11R6/lib/X11/fonts/100dpi/&quot;</p>
<p>FontPath &quot;/usr/X11R6/lib/X11/fonts/75dpi/&quot;</p>
<p>EndSection</p>
<ul>
<li></li>
</ul>
<p>当X客户端向X服务器请求显示文字的时候，X服务器会按上面列表的先后顺序查找字体</p>
<p>例如显示中文时，如果第一个路径中的字体不包含中文，则查找下面的路径，直到发现中文字体</p>
<ul>
<li></li>
</ul>
<p>请将您偏好的字体放在靠前的位置</p>
<p>要使安装的字体能够作为X核心字体使用，将字体的安装路径添加到上面的列表中，使用 mkfontscale 、 mkfontdir</p>
<p>扫瞄文件夹中的字体，并生成索引，就可以了（建议使用 ttmkfdir 生成 fonts.scale ，将其复制为 fonts.dir ）</p>
<p>字体的选择及显示风格，可以修改GTK1的配置文件，或者在Xresources文件中对程序单独进行定义</p>
<p>事实上，在我们的日常应用中，X核心字体环境并不常见，使用GTK1图形库的程序、某些类型的终端……</p>
<p>* Emacs也是这样一个老派的程序……不过Emacs23中刚刚加入了xft字体的支持</p>
<p>XFT字体</p>
<p>Xft字体相关选项在 /etc/fonts/fonts.conf 文件中配置</p>
<p>可以使用 fc-cache 命令，递归扫瞄以下目录中的字体（包括子文件夹中的字体），建立字体缓存</p>
<p>/usr/share/X11/fonts</p>
<p>/usr/share/fonts</p>
<p>/usr/local/share/fonts</p>
<p>~/.fonts</p>
<p>* /etc/fonts/fonts.conf 文件的 <dir> 字段</dir></p>
<p>多数支持GTK2或者Qt图形库的X客户端能够使用Xft字体渲染技术</p>
<p>* GTK2为Gnome使用的图形库，Qt为KDE使用的图形库。相对来说，GTK2图形库在程序的GUI设计中更加通用</p>
<p>安装字体，只要将字体拷贝到以上任意目录， fc-cache -fv 刷新字体缓存即可 （参数: -f 强制刷新; -v 显示过程）</p>
<p>使用命令 fc-list 列出所有可用字体</p>
<p>字体的选择及显示风格，可以修改GTK2或者Qt的配置文件，建议使用图形界面配置</p>
<p>* 一般情况下，桌面环境中附带了相关程序，例如 gnome-font-properties</p>
<h3 id="系统管理"><a class="header-anchor" href="#系统管理">¶</a>系统管理</h3>
<h4 id="一些细节"><a class="header-anchor" href="#一些细节">¶</a>一些细节</h4>
<ul>
<li>
<p>Linux是大小写敏感的系统，所有的命令、路径、参数、变量……都区分大小写</p>
</li>
<li>
<p>使用 <code>TAB</code> 键补全命令，无论任何时候，多按几次TAB总会有所帮助</p>
</li>
<li>
<p>Shell的功能键能够协助您更高效的编辑命令，请熟悉其键绑定，尽量使用它</p>
</li>
<li>
<p>命令由 <code>命令名</code> 、 <code>分隔符</code> 、 <code>参数</code> 、 <code>操作对象</code> 构成</p>
</li>
</ul>
<h4 id="命令名"><a class="header-anchor" href="#命令名">¶</a>命令名</h4>
<p>标识命令的功能，例如cp(copy)、mv(move)、rm(remove)……</p>
<p>有些命令包含一些子命令，您可以认为它的命令名由两个单词构成，例如<code>apt</code>软件包管理系统：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install <span class="comment"># 安装一个软件</span></span><br><span class="line">apt-get remove  <span class="comment"># 删除一个软件</span></span><br></pre></td></tr></table></figure>
<h4 id="分隔符-2"><a class="header-anchor" href="#分隔符-2">¶</a>分隔符</h4>
<p>通常为空格，<code>多个连续的空格视为一个空格</code>，下面两个命令相同：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp a b</span><br><span class="line">cp   a   b</span><br></pre></td></tr></table></figure>
<p>有一些特殊符号也属于分隔符，例如 <code>管道 | 、重定向 &gt; 、 &gt;&gt; 、 &lt; 、后台运行 &amp; 、序列执行 &amp;&amp; 、 ; </code>。使用这些符号时，您不需要再使用<code>空格作为分隔符</code>，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -al|less</span><br></pre></td></tr></table></figure>
<p>写为以下形式，是为了让您更容易的阅读它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -al | less</span><br></pre></td></tr></table></figure>
<h4 id="参数"><a class="header-anchor" href="#参数">¶</a>参数</h4>
<p>精细调节命令的行为，以 <code>-</code> 引导，通常为参数名的首字母。许多软件都可以使用 <code>-h</code> 参数来阅读使用说明，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get -h</span><br></pre></td></tr></table></figure>
<p>也可以使用参数的全名，一般以 -- 引导，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>多数命令中，使用 - 引导多个字符，将会被视为多个参数，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get -<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>系统会解读为以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get -h -e -l -p</span><br></pre></td></tr></table></figure>
<p>少数命令的参数，不需要以 <code>-</code> 引导，或者使用 <code>-</code> 引导参数全名，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux</span><br><span class="line">/etc/init.d/gdm start</span><br><span class="line">mplayer -loop xxx</span><br></pre></td></tr></table></figure>
<p>需要对多个对象进行操作时，可以使用空格分隔符将它们隔开：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch 1 2 3 4 5 6</span><br></pre></td></tr></table></figure>
<p>使用空格分隔的多个对象，视为一个整体，作为命令的一个操作对象：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv 1 2 3 4 5 6 /home/</span><br></pre></td></tr></table></figure>
<p>这个命令把<code>1 2 3 4 5 6</code>作为一个操作对象，移动到另一个操作对象，<code>/home/</code>目录</p>
<p>递归 表示在子层次中重复相同操作。例如递归复制某目录，不但复制当前目录及其下的所有文件；而且对当前目录的子目录，也进行递归复制的操作。</p>
<h4 id="格式约定"><a class="header-anchor" href="#格式约定">¶</a>格式约定</h4>
<p>使用 <code>[]</code> 表示可选项，实际输入为方括号中的内容，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls [-al]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>ls</code>是必须的，参数不需要以方括号括起来。</p>
</li>
<li>
<p>使用 <code>&lt;&gt;</code> 表示必需项，实际输入为尖括号中的内容</p>
</li>
<li>
<p>使用 | 表示 或 ，以 | 分隔的项目不能同时使用，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar [-z|j c|x vf] &lt;归档文件&gt; [源文件]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参数通常紧跟命令名，除非必要，在命令格式中，我们通常省略它们</p>
<h3 id="系统信息"><a class="header-anchor" href="#系统信息">¶</a>系统信息</h3>
<h4 id="uptime"><a class="header-anchor" href="#uptime">¶</a>uptime</h4>
<p>联机信息-时间，显示如下</p>
<p>11:27pm up 9 days, 7:12, 3 user, load average: 0.07, 0.12, 0.14</p>
<p>当前系统时间 系统运行时间 当前在线用户数 系统负荷 1分钟前 5分钟前 15分钟前</p>
<h4 id="w"><a class="header-anchor" href="#w">¶</a>w</h4>
<p>联机信息-已登录用户，显示如下</p>
<p>01:04:10 up 1:34, 2 users, load average: 0.25, 0.16, 0.11</p>
<p>uptime 信息</p>
<p>USER TTY FROM LOGIN@ IDLE JCPU PCPU WHAT</p>
<p>user tty1 192.168.0.1 23:30 1:33 0.14s 0.12s -bash</p>
<p>用户名 登录方式 来源地址 登录时间 发呆时间 资源占用 当前任务</p>
<p>Tip：w [用户名称] : 显示某一用户相关信息</p>
<h4 id="who"><a class="header-anchor" href="#who">¶</a>who</h4>
<p>联机信息，常用参数</p>
<p>-r 运行级别</p>
<h4 id="whoami"><a class="header-anchor" href="#whoami">¶</a>whoami</h4>
<p>显示当前用户名</p>
<h4 id="last"><a class="header-anchor" href="#last">¶</a>last</h4>
<p>最近用户登录信息
-&lt;数字&gt; 使用数字作为参数，控制显示条目。例如
last -10 显示10条纪录</p>
<h4 id="uname"><a class="header-anchor" href="#uname">¶</a>uname</h4>
<p>系统信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-s 内核名称（默认参数）    -a 全部        -p CPU 信息       -n 主机名     </span><br><span class="line">-r 内核发行信息（版本号）  -v 内核版本信息</span><br></pre></td></tr></table></figure>
<h4 id="date"><a class="header-anchor" href="#date">¶</a>date</h4>
<p>显示、设定系统时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-u 显示格林尼洛时间（UTC）</span><br><span class="line"></span><br><span class="line">MMDDhhmm[[CC]YY][.ss] 设定时间，需要管理员权限。例如： date 12292359</span><br><span class="line"></span><br><span class="line">MM 月份 DD 天数 hh 小时 mm 分钟 CC 年份前两位 YY 年份后两位 ss 秒钟</span><br><span class="line"></span><br><span class="line">秒钟、年份为可选，例如： date 122923592006.59</span><br><span class="line"></span><br><span class="line">+[%X]设定显示格式，以下为date默认输出格式：</span><br><span class="line"></span><br><span class="line">date +%Y年%m月%d日%A%H:%M:%S%Z</span><br><span class="line"></span><br><span class="line">格式控制      %n 换行       %t 制表符</span><br><span class="line"></span><br><span class="line">小时          %H(00~23) %I(01~12) %k(0~23) %l(1~12) %p(AM|PM)</span><br><span class="line"></span><br><span class="line">分、秒        %M分钟(00~59)         %S秒(00..61)       %T(hh:mm:ss) %r(hh:mm:ss [AM|PM])</span><br><span class="line"></span><br><span class="line">%s 从1970年1月1日00:00:00 UTC到目前为止的秒数       %X(%H:%M:%S)         %Z时区</span><br><span class="line"></span><br><span class="line">星期          %a(Sun~Sat) %A(Sunday~Saturday) %w : 一周中的第几天 (0..6)</span><br><span class="line"></span><br><span class="line">年份          %Y(0000~9999) %y(00~99)</span><br><span class="line"></span><br><span class="line">月份          %m(01~12) %b %h(Jan~Dec) %B(January~December)</span><br><span class="line"></span><br><span class="line">日期          %d(01~31) %j(001~366)</span><br><span class="line"></span><br><span class="line">%x(本地格式mm/dd/yy) %D(mm/dd/yy) %c</span><br><span class="line"></span><br><span class="line">一年中的第几周</span><br><span class="line"></span><br><span class="line">%U(00~53)以Sunday为一周的第一天 %W(00~53)以Monday为一周的第一天</span><br></pre></td></tr></table></figure>
<h4 id="cal"><a class="header-anchor" href="#cal">¶</a>cal</h4>
<p>显示日历</p>
<h3 id="文件管理"><a class="header-anchor" href="#文件管理">¶</a>文件管理</h3>
<p>一些细节</p>
<p><code>/</code> 目录为文件系统根目录，所有目录都是它的子目录</p>
<p>绝对路径以 <code>/</code> 起始，相对路径以当前所在目录起始</p>
<p>目录是一种特殊类型的文件，如果没有特别指明， 文件 包括文件和目录</p>
<p><code>..</code> 表示上一级目录， <code>.</code> 表示当前目录，它们是两个特殊目录</p>
<h4 id="链接"><a class="header-anchor" href="#链接">¶</a>链接</h4>
<p>为当前文件建立在其它路径中的访问方法。例如将系统中其它位置的可执行文件，链接到 <code>/usr/local/bin</code> 目录下，使用命令调用。</p>
<p>ls [路径]</p>
<p>显示当前目录文件列表</p>
<p>--color 不同属性以不同颜色显示（默认参数）</p>
<p><em>-a</em> <em>全部显示</em>        <em>-i</em> <em>显示<strong>inode</strong>值</em>     <em>-l</em> <em>详细信息</em></p>
<p><em>-F</em> <em>显示文件类型后缀</em> <em>目录</em>*/* <em>链接</em>*@* <em>可执行文件</em>*** <em>端口文件</em>*=* <em>管道文件</em>*| &gt;*</p>
<p><em>-A</em> <em>显示隐藏文件</em>         <em>-R</em> <em>递归显示子目录文件列表</em>        <em>-S</em> <em>按文件大小排序</em></p>
<p><em>-t</em> <em>按修改时间排序</em>       <em>-u</em> <em>按访问时间排序</em>       <em>-d</em> <em>只显示目录，不递归显示目录下的文件</em></p>
<p>cd [目录路径] | [特殊路径]</p>
<p>切换目录</p>
<p>目录路径可以使用绝对路径或者相对路径特殊路径：</p>
<p><em>~ $HOME**目录（默认值）</em>     <em>-</em> <em>上一次目录</em>       <em>..</em> <em>上一级目录</em>       <em>.</em> <em>当前目录</em></p>
<p>说明：您可以通过修改 /etc/environment 文件，来定义 $CDPATH 变量，设定“cd”命令的搜索路径。</p>
<p>pwd</p>
<p>显示当前路径</p>
<p>file &lt;文件名&gt;</p>
<p>显示文件类型</p>
<p>*<strong>-i*</strong> ***显示mime****<strong>类型*</strong></p>
<p>du [路径]</p>
<p>计算文件或目录空间占用</p>
<p><em>-h</em> <em>人性化显示。自动以<strong>G</strong>、<strong>M</strong>、<strong>K</strong>为单位显示占用空间大小</em>         <em>-l</em> <em>重复计算硬链接文件大小</em></p>
<p><em>-L</em> <em>计算符号链接文件大小</em>     <em>-a</em> <em>显示当前目录子目录中的文件</em>         <em>-c</em> <em>显示文件数</em></p>
<p>less &lt;文件名&gt;</p>
<p>浏览文件，使用VI和Emacs两种风格的键绑定。以下为VI风格键绑定</p>
<p><em>Ctrl+f(orward)</em> <em>向下翻一页</em> <em>Ctrl+d(own)</em> <em>向下翻半页</em></p>
<p><em>Ctrl+b(ackward)</em> <em>向上翻一页</em> <em>Ctrl+u(p)</em> <em>向上翻半页</em>       <em>/</em> <em>查找</em> <em>q(uit)</em> <em>退出</em></p>
<p>touch &lt;目标文件&gt;</p>
<p>触碰，在不修改文件的前提下，更改其时间属性。通常用来创建一个空文件</p>
<p>mkdir &lt;文件夹&gt;</p>
<p>创建文件夹</p>
<p><em>-p &lt;<strong>多级目录</strong>&gt;</em> <em>按路径创建多级目录</em>      <em>-m &lt;<strong>数字权限值</strong>&gt;</em> <em>设定权限</em></p>
<p>cp &lt;源文件&gt; &lt;目标目录|文件&gt;</p>
<p>将源文件复制为目录文件，或者将源文件复制到目标目录。多个源文件使用空格分隔</p>
<p>cp &lt;源目录&gt; &lt;目标目录&gt;</p>
<p>将源目录复制到目标目录中，如果复制多个源目录，需要使用 -R 参数</p>
<p><em>-a</em> <em>相当于</em>*-dpr**参数*       <em>-d</em> <em>保留链接</em>        <em>-f</em> <em>强制复制，覆盖目标文件</em>         <em>-i</em> <em>覆盖时询问用户</em></p>
<p><em>-p</em> <em>保留修改时间和访问权限</em>        <em>-r -R</em> <em>递归复制（目录</em>*=&gt;*<em>目录）</em>     <em>-l</em> <em>创建链接</em></p>
<p><em>-v</em> <em>显示过程</em></p>
<p>rm &lt;目标目录|文件&gt;</p>
<p>删除</p>
<p><em>-r -R</em> <em>递归删除</em>      <em>-f</em> <em>强制删除（无需确认，直接删除。慎用！）</em>        <em>-i</em> <em>交互式删除（询问用户）</em></p>
<p>rmdir &lt;目标目录&gt;</p>
<p>删除目录时，建议您使用“rm -r”命令</p>
<p>mv &lt;源文件&gt; &lt;目标目录|文件&gt;</p>
<p>相当于cp后删除源文件，也可以作为“重命名”使用。</p>
<p>mv &lt;源目录&gt; &lt;目标目录&gt;</p>
<p><em>-r -R</em> <em>递归</em></p>
<p>ln &lt;源文件&gt; &lt;链接&gt;</p>
<p>链接</p>
<p><em>-s</em> <em>符号链接</em>        <em>-f</em> <em>强制链接，覆盖目标文件</em>         <em>-i</em> <em>覆盖前询问用户</em></p>
<h3 id="文件操作"><a class="header-anchor" href="#文件操作">¶</a>文件操作</h3>
<p>nano</p>
<p>一个简单轻便的文本编辑器，使用Emacs风格的键绑定。</p>
<p>split &lt;源文件&gt; [目标文件名前缀]</p>
<p>将源文件按一定规则分割成若干个目标文件。默认文件名前缀为 x</p>
<p><em>-&lt;<strong>行数</strong>&gt;</em> <em>按行数分割文件</em>      <em>-l &lt;<strong>行数</strong>&gt;</em> <em>同上</em></p>
<p><em>-b &lt;<strong>字节</strong>&gt;</em> <em>按大小分割文件。可以使用<strong>b</strong>、<strong>k</strong>、<strong>m</strong>作单位，不指定单位的情况下，默认单位为**b</em></p>
<p><em>-C &lt;<strong>字节</strong>&gt;</em> <em>按大小分割文件，并尽量保持每行的完整</em></p>
<p>示例：split -C 100k file.split x</p>
<p>cat &lt;文件名&gt;</p>
<p>输出文件内容。用空格分隔多个文件名，可以将多个文件内容连接到一起输出。使用重定向合并为一个文件</p>
<p><em>-n</em> <em>在输出中添加行号</em>          <em>-b</em> <em>在输出中添加行号，空行不编号</em></p>
<p><em>-s</em> <em>将两行或以上的空行，合并为一个空行</em></p>
<p>示例：cat xaa xab xac &gt; file.split</p>
<p>sort [-o &lt;输出文件&gt;] [-t &lt;分隔字符&gt;] [+&lt;起始字段&gt; - &lt;结束字段&gt;] [文件]</p>
<p>对文本内容排序</p>
<p><em>-m</em> <em>合并文件</em>        <em>-c</em> <em>检查文件是否已按规则排序</em>      <em>-b</em> <em>忽略行首空格字符</em></p>
<p><em>-u</em> <em>忽略内容重复行</em>       <em>-f</em> <em>忽略大小写</em>       <em>-l</em> <em>忽略非打印字符</em>       <em>-M</em> <em>作为月份比较</em></p>
<p><em>-d</em> <em>按字典顺序排序，按照字母、数字、空格、制表符排序</em>      <em>-r</em> <em>逆序输出</em></p>
<p>more</p>
<p>查看文件内容，我们建议您使用 less</p>
<p>diff &lt;文件名&gt;</p>
<p>比较文件</p>
<p>cksum [文件名]</p>
<p>计算文件的CRC值。不指定文件名则从标准输入设备读入数据，例如：</p>
<p>echo xxx | cksum</p>
<p>md5sum [文件名] 计算文件的md5值。同上</p>
<h3 id="权限管理"><a class="header-anchor" href="#权限管理">¶</a>权限管理</h3>
<p>一些细节</p>
<p>一个文件主要包含下列属性， ls -l</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- rwx rwx rwx user group date filename</span><br><span class="line"></span><br><span class="line">111 101 101</span><br></pre></td></tr></table></figure>
<p>其中，第一组为归属用户的权限，第二组为归属群组的权限，第三组为其它用户群组的权限。user为文件的归属用户，group为文件的归属群组，date为日期信息，filename为文件名。</p>
<p>对于文件夹，必须拥有它的可执行权限，才能够使用 cd 命令进入该文件夹；拥有可读权限，才能够使用 ls 命令查看该文件夹的文件列表。</p>
<p>root用户拥有最高权限。</p>
<p>可以使用3位的二进制数字来描述一组权限，某一权限对应的数字为1,则表示具有该种权限，为0,则不具有该种权限。</p>
<p>使用二进制数字来描述一组权限，虽然非常直观，但是3组权限需要用9位数来表示，使用不够方便。因此我们将三组权限使用3位8进制数字来表示。它们的对应关系为：</p>
<p>r 100 4</p>
<p>w 010 2</p>
<p>x 001 1</p>
<p>将这三位8进制数字相加的结果，就可以表示该组权限的具体内容，例如：</p>
<p>7=4+2+1=rwx</p>
<p>5=4+1=rx</p>
<p>755=4+2+1 4+1 4+1=rwx r-x r-x</p>
<p>还可以使用 a 、 u 、 g 、 o 表示归属关系，使用 = 、 + 、 - 表示权限变化，使用 r 、 w 、 x 表示权限内容，</p>
<p>a 所有用户 u 归属用户 g 归属群组 o 其它用户</p>
<p>= 具有权限 + 增加权限 - 去除权限</p>
<p>r 可读权限 w 可写权限 x 可执行权限</p>
<p>例如：</p>
<p>a+x 给所有用户增加可执行权限</p>
<p>go-wx 将归属群组和其它用户的可写、可执行权限去掉</p>
<p>u=rwx 归属用户具有可读、可写、可执行权限</p>
<p>chmod &lt;权限表达式&gt; &lt;文件|目录&gt;</p>
<p>更改文件的权限。权限的表达式可以使用三位8进制数字表示，或者使用 augo +-= rxw-s 来表示</p>
<p>-R 递归</p>
<p>-v 显示过程</p>
<p>-c 类似“-v”，仅显示更改部分</p>
<p>--reference=&lt;参考文件或目录&gt; 以指定文件为参考更改权限</p>
<p>示例：</p>
<p>chmod -R a+x path</p>
<p>chmod -Rv 755 path</p>
<p>chown &lt;归属用户&gt;[:归属群组] &lt;文件|目录&gt;</p>
<p>更改文件的归属用户。可以使用用户名或者UID</p>
<p><em>-R</em> <em>递归</em>       <em>-v</em> <em>显示过程</em>        <em>-c</em> <em>类似</em> <em>-v</em> <em>，仅显示更改部分</em></p>
<p>--reference=&lt;参考文件或目录&gt; 以指定文件为参考更改权限</p>
<p>示例：</p>
<p>chown user:admin path          chown -R user.admin path       chown user path</p>
<p>chgrp &lt;归属群组&gt; &lt;文件|目录&gt;</p>
<p>更改文件的归属群组。可以使用群组名或者GID</p>
<p>参数同上</p>
<p>SUID、SGID、Sticky bit</p>
<p>某些情况下，需要以可执行文件归属用户的身份执行该文件，可以为该文件设置SUID。同样，设置SGID能够以该文件归属群组的身份执行它。</p>
<p>例如：用户自行设定密码。出于安全方面的考虑， /etc/shadow 只能由root用户直接修改。</p>
<p>-rw------- root root /etc/shadow</p>
<p>这个时候，可以为程序 /usr/bin/passwd</p>
<p>设置SUID，当普通用户执行“passwd”命令时，便能够以该程序归属用户root的身份修改 /etc/shadow</p>
<p>文件。而“passwd”程序自身带有身份验证机制，不能通过验证时拒绝执行，从而保证了安全。</p>
<p>ls -l /usr/bin/passwd</p>
<p>-r-s--x--x root root /usr/bin/passwd</p>
<p>我们发现，归属用户的可执行权限位使用 s ，表示SUID。同样，归属群组的可执行权限位使用 s ，表示SGID。任何用户或群组都拥有</p>
<p>其它用户 的权限，所以不需要以 其它用户 身份执行文件，其它用户的可执行权限位便不会出现 s 。该权限位可能出现的属性为 t</p>
<p>，也就是粘着位Sticky bit。</p>
<p>ls -ld /tmp</p>
<p>drwxrwxrwt root root /tmp</p>
<p>粘着位表示任何用户都可能具有写权限，但只有该归属用户或root用户才能够删除</p>
<p>SUID、SGID、Sticky bit也可以像权限一样，使用一个八进制数表示，如下：</p>
<p>4 SUID</p>
<p>2 SGID</p>
<p>1 Sticky bit</p>
<p>通过在“chmod”命令中使用4个八进制数的表达式，如 4755 ，用第一位表示SUID、SGID、或Sticky bit，便能够为文件设置这些特殊权限。示例：</p>
<p>chmod -R 4755 path</p>
<p>lsattr [路径]</p>
<p>查看文件的特殊属性</p>
<p><em>-a</em> <em>全部显示</em>        <em>-d</em> <em>只显示目录</em>      <em>-R</em> <em>递归</em></p>
<p>特殊属性包括：</p>
<p><em>a</em>*：仅供附加用途*         <em>b</em>*：不更新最后存取时间*       <em>c</em>*：压缩后存放*      <em>d</em>*：排除在倾倒操作之外*</p>
<p><em>i</em>*：不得任意更动文件或目录*        <em>s</em>*：保密性删除文件或目录*     <em>S</em>*：即时更新文件或目录*</p>
<p><em>u</em>*：预防以外删除*</p>
<p>chattr +|-|=&lt;属性&gt; &lt;路径&gt;</p>
<p>更改文件特殊属性</p>
<p><em>-R</em> <em>递归</em>       <em>-V</em> <em>显示过程</em></p>
<h3 id="压缩解压"><a class="header-anchor" href="#压缩解压">¶</a>压缩解压</h3>
<p>tar -c|x|u|r|t[z|j][v] -f &lt;归档文件&gt; [未打包文件]</p>
<p>将多个文件打包为一个归档文件，可以在打包的同时进行压缩。支持的格式为tar（归档）、gz（压缩）、bz2（压缩率更高，比较耗时）</p>
<p><em>-c</em> <em>创建</em>        <em>-x</em> <em>解包</em>        <em>-u</em> <em>更新</em>        <em>-r</em> <em>添加</em>        <em>-t</em> <em>查看</em></p>
<p><em>-d</em> <em>比较压缩包内文件和文件</em>        <em>-A</em> <em>将<strong>tar</strong>文件添加到归档文件中</em>         <em>-z</em> <em>使用<strong>gz</strong>压缩格式</em></p>
<p><em>-j</em> <em>使用<strong>bz2</strong>压缩格式</em>      <em>-v</em> <em>显示过程</em>        <em>-f &lt;<strong>文件名</strong>&gt;</em> <em>归档文件的文件名</em></p>
<p><em>-C &lt;<strong>解压路径</strong>&gt;</em> <em>将压缩包中的文件解压到指定目录</em></p>
<p>[未打包文件] 创建、更新时必须填写</p>
<p>示例：</p>
<p>tar -zcvf xxx.tar.gz xxx/ xxx1 xxx2 xxx3 多个待打包文件以空格分隔</p>
<p>tar -zcvf xxx.tar.gz /home/user/xxx/ 使用绝对路径打包，解包也使用绝对路径</p>
<p>tar -zxvf xxx.tar.gz 按相对路径解包到当前目录下，或按绝对路径解包</p>
<p>tar -zcvf xxx.tar.gz xxx | split -b 1m 打包后，使用split分割为1m大小的多个文件</p>
<p>其它参数</p>
<p><em>-P</em> <em>使用绝对路径压缩时，保留根目录</em>*“/”       -W* <em>校验</em>       <em>-p</em> <em>还原文件权限</em></p>
<p><em>-w</em> <em>询问用户</em>        <em>--totals</em> <em>统计</em>        <em>-T &lt;<strong>表达式</strong>&gt;</em> <em>处理符合条件的文件</em></p>
<p><em>-X &lt;<strong>表达式</strong>&gt;</em> <em>排除符合条件的文件</em></p>
<p>zip [参数] &lt;压缩包&gt; &lt;源文件&gt;</p>
<p>使用zip格式打包文件</p>
<p><em>-r</em> <em>递归，将指定目录下的所有文件和子目录一并处理</em>          <em>-S</em> <em>包含系统和隐藏文件</em></p>
<p><em>-y</em> <em>直接保存符号连接，而非该连接所指向的文件</em>         <em>-X</em> <em>不保存额外的文件属性</em></p>
<p><em>-m</em> <em>将文件压缩并加入压缩文件后，删除源文件</em></p>
<p>-&lt;压缩级别&gt; 1~9，数字越大，压缩率越高</p>
<p><em>-F</em> <em>尝试修复已损坏的压缩文件</em>      <em>-T</em> <em>检查备份文件内的每个文件是否正确无误</em></p>
<p><em>-q</em> <em>不显示指令执行过程</em>        <em>-g</em> <em>将文件压缩后附加在既有的压缩文件之后，而非另行建立新的压缩文件</em></p>
<p><em>-u</em> <em>更新压缩包内文件</em></p>
<p><em>-f</em> <em>更新压缩包内文件。如果符合条件的文件没有包含在压缩包中，则压缩后添加</em></p>
<p><em>-$</em> <em>保存第一个被压缩文件所在磁盘的卷标</em>      <em>-j</em> <em>只保存文件名称及其内容</em></p>
<p><em>-D</em> <em>压缩文件内不建立目录名称</em>      <em>-i &lt;<strong>表达式</strong>&gt;</em> <em>压缩目录时，只压缩符合条件的文件</em></p>
<p><em>-x &lt;<strong>表达式</strong>&gt;</em> <em>排除符合条件的文件</em>        <em>-n &lt;<strong>文件名后缀</strong>&gt;</em> <em>排除指定文件名后缀的文件</em></p>
<p><em>-b &lt;<strong>缓存路径</strong>&gt;</em> <em>指定临时文件目录</em>        <em>-d &lt;<strong>表达式</strong>&gt;</em> <em>从压缩文件内删除指定的文件</em></p>
<p><em>-t &lt;<strong>日期时间</strong>&gt;</em> <em>把压缩文件的日期设成指定的日期</em></p>
<p><em>-o</em> <em>以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同</em></p>
<p><em>-A</em> <em>调整可执行的自动解压缩文件</em>         <em>-c</em> <em>替每个被压缩的文件加上注释</em></p>
<p><em>-z</em> <em>替压缩文件加上注释</em>        <em>-k</em> <em>使用<strong>MS-DOS</strong>兼容格式的文件名称。</em></p>
<p><em>-l</em> <em>压缩文件时，把<strong>LF</strong>字符置换成<strong>LF+CR</strong>字符。</em>         <em>-ll</em> <em>压缩文件时，把<strong>LF+CR</strong>字符置换成<strong>LF</strong>字符。</em></p>
<p>unzip [参数] &lt;压缩文件&gt; [压缩包中将被释放的文件]</p>
<p>解压zip压缩包文件</p>
<p><em>-P &lt;<strong>密码</strong>&gt; zip**压缩包的密码</em>         <em>-d &lt;<strong>路径</strong>&gt;</em> <em>指定解压路径</em>      <em>-n</em> <em>解压缩时不覆盖原有文件</em></p>
<p><em>-f</em> <em>覆盖原有文件</em>         <em>-o</em> <em>不经询问，直接覆盖原有文件</em></p>
<p><em>-u</em> <em>覆盖原有文件，并将压缩文件中的其他文件解压缩到目录中</em></p>
<p><em>-l</em> <em>显示压缩文件内所包含的文件</em>         <em>-t</em> <em>检查压缩文件是否正确</em>      <em>-z</em> <em>显示压缩包注释</em></p>
<p><em>-Z unzip -Z<strong>等于执行</strong>zipinfo**指令</em>          <em>-j</em> <em>不处理压缩文件中原有的目录路径</em></p>
<p><em>-C</em> <em>压缩文件中的文件名称区分大小写</em>         <em>-L</em> <em>将压缩文件中的全部文件名改为小写</em></p>
<p><em>-s</em> <em>将文件名中的空格转换下划线</em>         <em>-X</em> <em>解压缩时保留文件原来的**UID/GID</em></p>
<p><em>-q</em> <em>执行时不显示任何信息</em>               <em>-v</em> <em>执行是时显示详细的信息</em></p>
<p><em>-c</em> <em>将解压缩的结果显示到屏幕上，并对字符做适当的转换</em></p>
<p><em>-p</em> <em>与</em>*-c**参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换*</p>
<p><em>-a</em> <em>对文本文件进行必要的字符转换</em>            <em>-b</em> <em>不要对文本文件进行字符转换</em></p>
<p><em>-x &lt;<strong>表达式</strong>&gt;</em> <em>处理里排除压缩包中的指定文件</em>            <em>-M</em> <em>将输出结果送到<strong>more</strong>程序处理</em></p>
<p>7z|7za &lt;子命令&gt; [参数] &lt;压缩包&gt; [文件]</p>
<p>子命令</p>
<p><em>a</em> <em>添加</em>    <em>d</em> <em>删除</em>    <em>e</em> <em>解压</em>    <em>x</em> <em>带路径解压</em>  <em>l</em> <em>列表查看</em>     <em>t</em> <em>测试</em>    <em>u</em> <em>更新</em></p>
<p>参数</p>
<p><em>-m&lt;<strong>压缩方式</strong>&gt;      -m0=&lt;<strong>压缩算法</strong>&gt;</em> <em>默认使用**lzma         -mx=&lt;1~9&gt;</em> <em>压缩级别</em></p>
<p><em>-mfb=64 number of fast bytes for LZMA = 64      -md=&lt;<strong>字典大小</strong>&gt;</em> <em>设置字典大小，例如</em> <em>-md=32m</em></p>
<p><em>-ms=&lt;on|off&gt;</em> <em>是否固实压缩</em>        <em>-o&lt;<strong>输出目录</strong>&gt;</em> <em>设置输出目录</em>        <em>-p[<strong>密码</strong>]</em> <em>使用密码</em></p>
<p><em>-r[<strong>数字</strong>]</em> <em>递归，使用数字定义递归子目录的深度</em>          <em>-sfx[&lt;<strong>模块名称</strong>&gt;]</em> <em>使用自解压模块</em></p>
<p><em>-si</em> <em>从标准输入设备读入数据</em>        <em>-so</em> <em>将数据写入标准输出设备</em>       <em>-y</em> <em>所有询问均回答**Yes</em></p>
<p><em>-w&lt;<strong>工作目录</strong>&gt;</em></p>
<p>rar &lt;子命令&gt; [参数] &lt;压缩包&gt; [文件|文件列表|路径]</p>
<p>子命令</p>
<p><em>x</em> <em>带路径解压</em>       <em>e</em> <em>解压到当前目录</em>        <em>a</em> <em>将文件添加到压缩包内</em>      <em>d</em> <em>从压缩包中删除文件</em></p>
<p><em>u</em> <em>更新压缩包内文件</em>      <em>f</em> <em>更新压缩包内文件，并添加压缩包内不存在的文件</em>      <em>m</em> <em>添加并删除源文件</em></p>
<p><em>r</em> <em>修复</em>        <em>l</em> <em>列表查看压缩包内文件信息</em> <em>lt</em> <em>更详细信息</em> <em>lb</em> <em>简短信息</em>      <em>c</em> <em>添加压缩包注释</em></p>
<p>cf &lt;文件名&gt; 将文件内容添加为注释</p>
<p>cw &lt;文件名&gt; 将注释保存为文件</p>
<p>t 测试压缩包       rr 添加恢复纪录         rv 恢复到文件</p>
<p>参数</p>
<p>-p&lt;密码&gt; 设置密码</p>
<p>-m&lt;0~5&gt; 设置压缩级别，数字越大，压缩级别越高</p>
<h3 id="搜索"><a class="header-anchor" href="#搜索">¶</a>搜索</h3>
<p>whereis &lt;程序名称&gt;</p>
<p>查找软件的安装路径</p>
<p><em>-b</em> <em>只查找二进制文件</em>          <em>-m</em> <em>只查找帮助文件</em>      <em>-s</em> <em>只查找源代码</em>    <em>-u</em> <em>排除指定类型文件</em></p>
<p><em>-f</em> <em>只显示文件名</em>         <em>-B &lt;<strong>目录</strong>&gt;</em> <em>在指定目录下查找二进制文件</em></p>
<p><em>-M &lt;<strong>目录</strong>&gt;</em> <em>在指定目录下查找帮助文件</em>        <em>-S &lt;<strong>目录</strong>&gt;</em> <em>在指定目录下查找源代码</em></p>
<p>locate &lt;文件名称&gt;</p>
<p>在文件索引数据库中搜索文件</p>
<p>-d &lt;数据库路径&gt; 搜索指定数据库</p>
<p>updatedb 更新文件索引数据库</p>
<p>find [路径] &lt;表达式&gt;</p>
<p>查找文件</p>
<p>-name &lt;表达式&gt; 根据文件名查找文件</p>
<p>-iname &lt;表达式&gt; 根据文件名查找文件，忽略大小写</p>
<p>-path &lt;表达式&gt; 根据路径查找文件</p>
<p>-ipath &lt;表达式&gt; 根据路径查找文件，忽略大小写</p>
<p>-amin &lt;分钟&gt; 过去N分钟内访问过的文件</p>
<p>-atime &lt;天数&gt; 过去N天内访问过的文件</p>
<p>-cmin &lt;分钟&gt; 过去N分钟内修改过的文件</p>
<p>-ctime &lt;天数&gt; 过去N天内修改过的文件</p>
<p>-anewer &lt;参照文件&gt; 比参照文件更晚被读取过的文件</p>
<p>-cnewer &lt;参照文件&gt; 比参照文件更晚被修改过的文件</p>
<p>-size &lt;大小&gt; 根据文件大小查找文件，单位b c w k M G</p>
<p>-type &lt;文件类型&gt; 根据文件类型查找文件。b 块设备 c 字符设备 d 目录 p 管道文件 f 普通文件 l 链接 s 端口文件</p>
<p>-user &lt;用户名&gt; 按归属用户查找文件</p>
<p>-uid <uid> 按UID查找文件</uid></p>
<p>-group &lt;群组名&gt; 按归属群组查找文件</p>
<p>-gid <gid> 按GID查找文件</gid></p>
<p>-empty 查找空文件</p>
<p>grep &lt;字符串&gt;|&quot;&lt;正则表达式&gt;&quot; [文件名]</p>
<h3 id="其它"><a class="header-anchor" href="#其它">¶</a>其它</h3>
<p>echo &lt;字符串&gt;</p>
<p>回显。较复杂的字符串，可以使用 &quot; 括起来。</p>
<p><em>-n</em> <em>输出内容不换行</em>       <em>-E</em> <em>不解析脱字符</em>         <em>-e</em> <em>解析脱字符</em></p>
<p>控制字符</p>
<p>** <em>反斜线</em>       <em>a</em> <em>警告</em>        <em>b</em> <em>退格</em>        <em>n</em> <em>换行</em>        <em>r</em> <em>回车</em>        <em>t</em> <em>水平制表符</em></p>
<p>clear</p>
<p>消除屏幕</p>
<p>alias &lt;输入内容&gt; &lt;实际内容&gt;</p>
<p>别名，为命令指定一个别名，以简化输入。例如：</p>
<p>alias ls='ls --color=auto'</p>
<p>alias ls=&quot;l -CF&quot;</p>
<p>可以将您的定义保存在 ~/.bashrc 文件中。</p>
<p>export &lt;变量名称&gt;</p>
<p>将变量导出为环境变量，常写变量赋值一同使用，例如：</p>
<p>export PATH=&quot;$PATH:xxx&quot;</p>
<p>其中 $PATH 表示变量 PATH 原值</p>
<p>shutdown</p>
<p>关闭计算机，向根进程 init 发送信号，更改 runlevel 为 0 (halt)</p>
<p><em>-h</em> <em>关闭电源</em>        <em>-r</em> <em>重启</em>        <em>-n</em> <em>强行关机，不向</em> <em>init**进程</em> <em>发送信号</em></p>
<p><em>-k</em> <em>模拟关机，向登录者发送关机警告</em>          <em>-t &lt;<strong>秒</strong>&gt; N**秒后关机</em>       <em>time &lt;<strong>时间</strong>&gt;</em> <em>定时关机</em></p>
<p><em>-c [<strong>说明信息</strong>]</em> <em>取消关机</em>        <em>-f</em> <em>重启时忽略检测文件系统</em>         <em>-F</em> <em>重启时强制检测文件系统</em></p>
<p>halt</p>
<p>关闭计算机。 调用 shutdown -h ，结束系统进程，同步文件系统，停止内核。</p>
<p><em>-n</em> <em>不同步文件系统</em>       <em>-w</em> <em>模拟关机，写</em> <em>/var/log/wtmp</em> <em>纪录</em>     <em>-f</em> <em>不调用</em> *shutdown ,*<em>强行关机</em></p>
<p><em>-p</em> <em>默认选项，关机时调用</em> <em>poweroff       -i</em> <em>关机前断开网络</em></p>
<p>reboot</p>
<p>重新启动计算机。参数与 halt 相似</p>
<p>chroot &lt;路径&gt;</p>
<p>Change Root 更改根目录，重新定义会话的运行环境。</p>
<h3 id="用户管理"><a class="header-anchor" href="#用户管理">¶</a>用户管理</h3>
<p>一些细节</p>
<p>root 用户为根用户，也就是 系统管理员 拥有全部权限</p>
<p>一个用户只能拥有一个 GID ，但是还可以归属于其它附加群组</p>
<p>用户管理的重要配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/passwd 用户名 密码位 UID 归属GID 姓名 $HOME目录 登录Shell</span><br><span class="line">/etc/shadow 用户名 已加密密码 密码改动信息 密码策略</span><br><span class="line">/etc/group 群组名 密码位 GID 组内用户</span><br><span class="line">/etc/gshadow 群组密码相关文件，不重要</span><br><span class="line">/etc/sudoers 用户名 权限定义 权限</span><br></pre></td></tr></table></figure>
<p>可以使用 pwconv 命令创建影子密码，将 /etc/passwd 文件中的密码转换到 /etc/shadow 文件</p>
<p>su [用户名]</p>
<p>切换到其它用户，默认切换到root用户。提示密码为将切换用户密码</p>
<p><em>-f</em> <em>快速切换，忽略配置文件</em>         <em>-l</em> <em>重新登录</em>         <em>-m</em> <em>，**-p</em> <em>不更改环境变量</em></p>
<p><em>-c &lt;<strong>命令</strong>&gt;</em> <em>切换后执行命令，并退出切换</em></p>
<p>sudo [命令]</p>
<p>以其它用户的身份执行命令，默认以root的身份执行。提示密码为当前用户密码</p>
<p><em>-s</em> <em>切换为**root shell       -i</em> <em>切换为<strong>root shell</strong>，并初始化</em>       <em>-u &lt;<strong>用户名</strong>|UID&gt;</em> <em>执行命令的身份</em></p>
<p><em>-l</em> <em>显示自己的权限</em></p>
<p>passwd [用户名]</p>
<p>设定用户密码</p>
<p><em>-d</em> <em>清除密码</em>        <em>-l</em> <em>锁定用户</em>         <em>-e</em> <em>使密码过期，在下次登录时更改密码</em></p>
<p><em>-S</em> <em>显示密码认证信息</em>          <em>-x &lt;<strong>天数</strong>&gt;</em> <em>密码过期，最大使用时间</em></p>
<p><em>-n &lt;<strong>天数</strong>&gt;</em> <em>冻结密码，最小使用时间</em>      <em>-s</em> <em>更改登录**Shell         -f</em> <em>更改用户信息</em></p>
<p>示例：</p>
<p>$passwd</p>
<p>Changing password for user</p>
<p>(current) UNIX password: 原密码</p>
<p>Enter new UNIX password: 新密码</p>
<p>Retype new UNIX password: 确认新密码</p>
<p>chsh [-s <shell>] [用户名]</shell></p>
<p>更改登录Shell</p>
<p>usermod &lt;用户名&gt;</p>
<p>修改用户账号</p>
<p><em>-d &lt;<strong>目录</strong>&gt;</em> <em>设定</em>*$HOME<em><em>目录*        <em>-m</em> <em>设定</em></em>$HOME</em>*目录时自动建立*</p>
<p><em>-s <shell></shell></em> <em>修改用户登录**Shell       -l &lt;<strong>新用户名</strong>&gt;</em> <em>修改为新用户名</em></p>
<p><em>-u <uid></uid></em> <em>修改用户**UID           -g &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属群组</em></p>
<p><em>-G &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属附加群组</em>     <em>-L</em> <em>锁定帐户</em>        <em>-U</em> <em>解除锁定</em></p>
<p><em>-e &lt;<strong>过期时间</strong>&gt;</em> <em>设定用户账号过期时间</em>         <em>-f &lt;<strong>缓冲天数</strong>&gt;</em> <em>设定密码过期后多长时间关闭账号</em></p>
<p><em>-c &lt;<strong>字符串</strong>&gt;</em> <em>修改用户备注</em></p>
<p>useradd &lt;用户名&gt;</p>
<p>新建用户</p>
<p><em>-d &lt;<strong>目录</strong>&gt;</em> <em>设定</em>*$HOME<em><em>目录*        <em>-m</em> <em>自动建立</em></em>$HOME</em><em>目录*      <em>-M</em> <em>不自动建立</em></em>$HOME**目录*</p>
<p><em>-s <shell></shell></em> <em>修改用户登录**Shell       -l &lt;<strong>用户名</strong>&gt;</em> <em>修改为新用户名</em>        <em>-u <uid></uid></em> <em>修改用户**UID</em></p>
<p><em>-g &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属群组</em>          <em>-G &lt;<strong>群组名</strong>&gt;</em> <em>修改用户归属附加群组</em></p>
<p><em>-n</em> <em>不建立以用户名为名称的群组</em>         <em>-e &lt;<strong>过期时间</strong>&gt;</em> <em>设定用户账号过期时间</em></p>
<p><em>-f &lt;<strong>缓冲天数</strong>&gt;</em> <em>设定密码过期后多长时间关闭账号</em>        <em>-c &lt;<strong>字符串</strong>&gt;</em> <em>修改用户备注</em></p>
<p><em>-D [<strong>表达式</strong>]</em> <em>更改预设值</em> <em>（预设值保存于</em> <em>/etc/default/useradd</em> <em>文件中）</em></p>
<p>新建用户规则保存于 /etc/login.defs 文件中</p>
<p>新建用户默认文件保存于 /etc/skel/ 目录中。新建用户时，系统自动拷贝此目录下的文件至新建用户的 $HOME 目录</p>
<p>userdel &lt;用户名&gt;</p>
<p>删除用户</p>
<p><em>-r</em> <em>删除用户相关文件和目录</em></p>
<p>id [用户名]</p>
<p>显示用户 UID GID 归属附加群组</p>
<p>finger [用户名]</p>
<p>显示用户信息</p>
<h3 id="进程管理"><a class="header-anchor" href="#进程管理">¶</a>进程管理</h3>
<p>一些细节</p>
<p>进程一般分为交互进程、批处理进程和守护进程三类。</p>
<p>守护进程总是活跃，在系统启动时通过脚本自动启动，或由root启动，通常在后台运行。</p>
<p>一个进程可以拥有子进程。当父进程终止时，它的子进程也随之终止；而子进程终止时，父进程通常可以继续运行。</p>
<p>init 进程为根进程，所有进程都是它的子进程</p>
<p>ps</p>
<p>显示进程信息，参数可省略 -</p>
<p><em>aux</em> <em>以<strong>BSD</strong>风格显示进程**(<strong>常用</strong>)          -efH</em> <em>以<strong>System V</strong>风格显示进程</em></p>
<p><em>-e , -A</em> <em>显示所有进程</em>      <em>a</em> <em>显示终端上所有用户的进程</em>       <em>x</em> <em>显示无终端进程</em></p>
<p><em>u</em> <em>显示详细信息</em>          <em>f</em> <em>树状显示</em>         <em>w</em> <em>完整显示信息</em>         <em>l</em> <em>显示长列表</em></p>
<p>示例：</p>
<p>ps alx 另一种常用输出格式</p>
<p>ps aux | less 将输出通过管道，使用 less 查看</p>
<p>ps aux | grep &lt;关键字&gt; 通过关键字查找进程</p>
<p>输出字段</p>
<p>USER 进程所有者        PID 进程ID        PPID 父进程       %CPU CPU占用率</p>
<p>%MEM 内存占用率      NI 进程优先级。数值越大，占用CPU时间越少         VSZ 进程虚拟大小</p>
<p>RSS 页面文件占用       TTY 终端ID       STAT 进程状态</p>
<p>D 不可中断 Uninterruptible sleep (usually IO)        R 正在运行，或在队列中的进程</p>
<p>S 处于休眠状态          T 停止或被追踪         Z 僵尸进程</p>
<p>W 进入内存交换（从内核2.6开始无效）      X 死掉的进程      &lt; 高优先级         N 低优先级</p>
<p>L 有些页被锁进内存     s 包含子进程       + 位于后台的进程组；</p>
<p>l 多线程，克隆线程 multi-threaded (using CLONE_THREAD, like NPTL pthreads do)</p>
<p>pstree</p>
<p>树状显示进程信息</p>
<p><em>-a</em> <em>显示完整命令及参数</em>        <em>-c</em> <em>重复进程分别显示</em>          <em>-c</em> <em>显示进程**ID PID  -n</em> <em>按</em> <em>PID</em> <em>排列进程</em></p>
<p>pgrep &lt;进程名&gt;</p>
<p>显示进程的PID</p>
<p><em>-l</em> <em>显示进程名和进程**PID      -o</em> <em>进程起始**ID      -n</em> <em>进程终止**ID</em></p>
<p>xkill</p>
<p>在图形界面中点杀进程。执行此命令后，鼠标指针变为骷髅图案（一定看过《加勒比海盗》吧）。在窗口中点击左键杀死进程，右键取消</p>
<p>pkill &lt;进程名&gt;</p>
<p>结束进程族。如果结束单个进程，请用 kill</p>
<p>kill [信号代码] &lt;进程PID&gt;</p>
<p>根据PID向进程发送信号，常用来结束进程，默认信号为 -9</p>
<p>-l [信号数字] 显示、翻译信号代码</p>
<p>-9 , -KILL 发送 kill 信号退出</p>
<p>-6 , -ABRT 发送 abort 信号退出</p>
<p>-15 , -TERM 发送 Termination 信号</p>
<p>-1 , -HUP 挂起</p>
<p>-2 , -INT 从键盘中断，相当于 Ctrl+c</p>
<p>-3 , -QUIT 从键盘退出，相当于 Ctrl+d</p>
<p>-4 , -ILL 非法指令</p>
<p>-11 , -SEGV 内存错误</p>
<p>-13 , -PIPE 破坏管道</p>
<p>-14 , -ALRM</p>
<p>-STOP 停止进程，但不结束</p>
<p>-CONT 继续运行已停止的进程</p>
<p>-9 -1 结束当前用户的所有进程</p>
<p>renice &lt;优先级表达式&gt; &lt;进程表达式&gt;</p>
<p>重新设定进程优先级（无此必要）</p>
<p>优先级表达式：</p>
<p>+|-|= &lt;nice值&gt;</p>
<p>nice取值范围： -20~19</p>
<p>进程表达式：</p>
<p>-p <pid> 通过进程ID进行设定</pid></p>
<p>-g <pgid> 通过进程群组ID</pgid></p>
<p>-u <uid> 通过进程拥有者UID设定</uid></p>
<p>top</p>
<p>动态、交互式进程管理器</p>
<p>-c 显示进程启动状态，包括参数、操作对象等；而不只是进程名</p>
<p>-d &lt;秒&gt; 刷新频率。 -d 5，表示5秒刷新一次</p>
<p>-n &lt;次&gt; 刷新次数，然后退出。 -n 5，表示刷新5次后退出；</p>
<p>-b 以批量模式运行，让输出能够使用管道或重定向。但不能进行交互，最好和 -n &lt;次&gt; 参数一同使用</p>
<p>-i 禁止显示空闲进程或僵尸进程；</p>
<p>-p PID 仅监视指定进程的ID；PID是一个数值；</p>
<p>-s 安全模式运行，禁用一些效互指令；</p>
<p>-S 累积模式，输出每个进程的总的CPU时间，包括已死的子进程；</p>
<p>交互命令：</p>
<p><space> 立即刷新</space></p>
<p>k 交互式杀死进程，提示输入进程 PID （默认发送信号15）</p>
<p>r 设定renice，提示输入PID和renice值</p>
<p>s 改变两次刷新时间间隔，以秒为单位</p>
<p>n 设定显示进程数， 0 为不作限制</p>
<p>i 隐藏空闲进程和僵尸进程</p>
<p>S 切换到累积时间模式</p>
<p>l 开关，在顶部显示 uptime 信息</p>
<p>t 开关，在顶部显示 进程和CPU状态</p>
<p>m 开关，在顶部显示 free 信息</p>
<p>c 显示方式切换： 进程名/进程启动状态</p>
<p>A 按进程启动顺序进行排序。由新到旧</p>
<p>M 按内存占用排序。由大到小</p>
<p>N 以进程ID排序。由大到小</p>
<p>P 按CPU占用排序。由大到小</p>
<p>T 按时间／累积时间排序</p>
<p>f ，F 设定显示字段。设定完成后空格退出</p>
<p>o,O 设定显示字段的排序。大写向前移动，小写向后移动，空格退出</p>
<p>h,? 显示有关安全模式和累积模式的帮助信息</p>
<p>W 把当前的配置写到~/.toprc中；</p>
<p>nohup &lt;命令&gt;</p>
<p>将任务提交到后台，输出附加到 ~/nohup.out 文件。即便用户退出登录，提交的命令仍继续执行。</p>
<p>&lt;命令&gt; &amp;</p>
<p>背景执行此命令，如果用户退出登录，则命令停止执行</p>
<p>&lt;命令1&gt; ; &lt;命令2&gt; ; ......</p>
<p>命令队列，从左向右，依次执行以 ; 分隔的命令</p>
<p>&lt;命令1&gt; &amp;&amp; &lt;命令2&gt; &amp;&amp; ......</p>
<p>命令队列，从左向右，依次执行以 &amp;&amp; 分隔的命令。前一个命令执行成功，后一个命令才能执行</p>
<p>&lt;命令&gt; &lt;Ctrl+z&gt;</p>
<p>&lt;Ctrl+z&gt; 挂起当前Shell中的任务</p>
<p>jobs</p>
<p>显示背景任务</p>
<p>bg [任务编号]</p>
<p>将挂起的任务背景执行</p>
<p>fg [任务编号]</p>
<p>将背景任务调到前台执行</p>
<p>计划任务</p>
<h3 id="磁盘和内存管理"><a class="header-anchor" href="#磁盘和内存管理">¶</a>磁盘和内存管理</h3>
<p>一些细节</p>
<p>Linux中，设备用/dev/目录下的文件表示。例如</p>
<p>/dev/hda1 第一块硬盘的第一主分区</p>
<p>/dev/hdb5 第二块硬盘的第一逻辑分区</p>
<p>/dev/sda4 第一块SATA硬盘的第四主分区，或者扩展分区</p>
<p>/dev/null 黑洞设备</p>
<p>关于磁盘设备，详见 分区概念</p>
<p>mount &lt;设备文件&gt; [挂载路径]</p>
<p>挂载文件系统</p>
<p>-t 指定文件系统的类型。通常不必指定，mount自动检测。下面是常用的格式</p>
<p>reiserfs ReiserFS 3.6版</p>
<p>jfs IBM技术</p>
<p>xfs SGI技术(适合高级服务器，桌面用户慎用)</p>
<p>ext3 Linux传统文件系统</p>
<p>vfat fat fat32</p>
<p>ext2 不带日志的ext3</p>
<p>ntfs WINNT</p>
<p>iso9660 光盘</p>
<p>smbfs Windows文件共享</p>
<p>-o [选项1] [选项2] ......</p>
<p>loop 环设备。光盘、ISO镜像等</p>
<p>ro | rw 只读readonly；可读写read-write</p>
<p>sync | async 同步模式|异步模式。决定修改是否立即写入文件系统</p>
<p>atime | noattime 读取时是否修改访问时间。对于写入敏感设备，例如闪存、软盘，建议使用 <em>noatime</em></p>
<p>auto | noauto 自动挂载模式</p>
<p>exec | noexec 是否允许可执行权限</p>
<p>defaults 使用预设的选项 rw, suid, dev, exec, auto, nouser, async</p>
<p>iocharset=UTF-8 指定字符集，可简写为 utf8</p>
<p>codepage=936 指定代码页，可简写为 cp936 西文系统代码页为 437</p>
<p>umask=&lt;权限掩码&gt; 设定权限掩码</p>
<p>uid=<uid> 设定归属用户</uid></p>
<p>gid=<gid> 设定归属群组</gid></p>
<p>remount 以不同选项重新挂载</p>
<p>-L &lt;卷标&gt; 将带有特殊卷标的分区</p>
<p>Tip</p>
<p>权限掩码</p>
<p>权限=777-权限掩码（三位） | 7777-权限掩码（四位）</p>
<p>假如权限掩码为 022 ，则新建对象权限为 755 rwxr-xr-x</p>
<p>可以使用 umask 命令设置权限掩码</p>
<p>mount -a</p>
<p>挂载 /etc/fstab 文件中定义的所有设备</p>
<p>示例：</p>
<p>sudo mount -t iso9660 -o loop /dev/cdrom0 /media/cdrom</p>
<p>sudo mount -t vfat -o remount iocharset=utf8,codepage=cp936 /dev/hda5 /media/hda5</p>
<p>umount &lt;设备文件&gt; | &lt;挂载路径&gt;</p>
<p>卸载已挂载文件系统</p>
<p>df</p>
<p>查看已挂载文件系统的磁盘空间占用</p>
<p>-a 显示所有文件系统的磁盘使用情况，包括0块（block）的文件系统，如/proc文件系统</p>
<p>-T 显示文件系统类型         -k 以k字节为单位显示        -i 显示i节点信息，而不是磁盘块</p>
<p>-t &lt;文件系统类型&gt; 显示指定类型的文件系统的磁盘空间使用情况</p>
<p>-x &lt;文件系统类型&gt; 列出不是某一指定类型文件系统的磁盘空间使用情况（与t选项相反）。</p>
<p>-l 只显示本地文件系统</p>
<p>free</p>
<p>查看内存、缓冲区、交换空间的占用</p>
<p>-b 以字节为单位显示数值      -k 以千字节为单位显示数值        -m 以兆字节为单位显示数值</p>
<p>-g 以吉字节为单位显示数值        -l 显示内存占用峰值     -o 不显示缓冲区占用          -t 统计结果</p>
<p>-s &lt;秒&gt; 刷新频率</p>
<p>sync</p>
<p>同步文件系统。将缓冲区中的数据写入文件系统</p>
<p>fdisk &lt;磁盘设备文件&gt;</p>
<p>分区表修改工具</p>
<p>交互命令：</p>
<p>m 使用帮助        l 查看已知文件系统类型       p 显示分区信息</p>
<p>n 新建分区 （p:主分区 l:扩展分区 参见 分区概念 )     d 删除分区         t 改变分区类型</p>
<p>w 将改动写入分区表          q 放弃改动并退出</p>
<p>* 磁盘设备名称为整块磁盘，而不是磁盘中的分区。例如 /dev/hda ，而不是 /dev/hda1</p>
<p><strong>fdisk -l</strong></p>
<p>查看所有磁盘分区信息</p>
<p>cfdisk</p>
<p>更加友善的分区表修改工具</p>
<p>mkfs.&lt;文件系统类型&gt; &lt;分区设备文件&gt;</p>
<p>将分区格式化为文件系统。 文件系统类型</p>
<p>示例：</p>
<p>sudo mkfs.reiserfs /dev/hda1</p>
<p>mkfs &lt;分区设备文件&gt;</p>
<p>-t &lt;文件系统类型&gt; 指定文件系统类型         -c 格式化前检查磁盘</p>
<p><strong>mkisofs -o &lt;<strong><strong>镜像文件</strong></strong>&gt; [<strong><strong>源文件目录</strong></strong>]</strong></p>
<p>用光盘或者文件制作iso镜像</p>
<p>-b 可启动镜像</p>
<p>hdparm &lt;磁盘设备文件&gt;</p>
<p>设置硬盘参数</p>
<p>-d &lt;0|1&gt; DMA模式开关       -a &lt;0|1&gt; 预计模式开关         -t 性能测试         -T 缓存性能测试</p>
<p>-c &lt;0|1|3&gt; 32位传输模式开关        -g 显示柱面，扇区等信息      -i -I 显示磁盘信息</p>
<h3 id="网络和硬件管理"><a class="header-anchor" href="#网络和硬件管理">¶</a>网络和硬件管理</h3>
<p>ifconfig</p>
<p>配置网络接口</p>
<p>-a 显示所有网络接口</p>
<p>ifconfig &lt;网卡&gt; up|down</p>
<p>激活|禁用网卡</p>
<p>示例： ::</p>
<p>sudo ifconfig eth0 up</p>
<p>ifconfig &lt;网卡&gt; add &lt;IP地址&gt; [ netmask &lt;子网掩码&gt; ]</p>
<p>给网卡指定IP地址或子网掩码</p>
<p>route</p>
<p>配置路由及网关</p>
<p>route add -net &lt;路由地址&gt; gw &lt;网关地址&gt; [ netmask &lt;子网掩码&gt; ] dev &lt;网卡&gt;</p>
<p>指定路由及网关</p>
<p>route del -net &lt;网关地址&gt; gw &lt;网关地址&gt; [ netmask &lt;子网掩码&gt; ]</p>
<p>删除路由及网关</p>
<p>ip</p>
<p>配置网络</p>
<p>子命令：</p>
<p>link 网卡配置       address 配置地址。相当于 ifconfig        route 配置路由。相当于 route</p>
<p>参数：</p>
<p>show 显示(默认)         set 设置       add 添加      del 删除</p>
<p>示例：</p>
<p>ip link show 显示网卡配置</p>
<p>ip link set eth0 name xxx 重命名网络接口</p>
<p>ping &lt;IP地址&gt;</p>
<p>向目标地址发送ICMP封包，常用来测试网络</p>
<p>-b &lt;广播地址&gt; ping整个网段        -c 发送封包次数         -s &lt;封包大小&gt; 默认为64字节</p>
<p>netstat</p>
<p>网络连接状态</p>
<p>-r 显示路由表，同 route       -a 所有连接        -t 只显示TCP协议      -U 只显示UDP协议</p>
<p>-l 只显示正在监听的端口      -p 显示PID和进程名         -c &lt;秒&gt; 刷新频率</p>
<p>* http/ftp/ssh…… 为应用层协议         * TCP/UDP为传输层协议      * IP/ICMP为网络层协议</p>
<p>lspci</p>
<p>查看PCI总线连接的设备</p>
<p>lsusb</p>
<p>查看USB接口连接的设备</p>
<p>lsmod</p>
<p>查看已加载模块</p>
<p>* /lib/modules/uname -r 目录下为所有可用模块</p>
<p>modprobe &lt;模块名称&gt;</p>
<h2 id="简明VIM教程"><a class="header-anchor" href="#简明VIM教程">¶</a>简明VIM教程</h2>
<h3 id="VIM简介"><a class="header-anchor" href="#VIM简介">¶</a>VIM简介</h3>
<p>我们使用的大多数编辑器，都可以直接在编辑区输入字符，并且能够通过一些快捷键来完成一些控制功能，比如使用方向键移动光标，使用</p>
<p>BackSpack 或者 Delete 键删除文字，使用 PgUp 和 PgDn 翻页，使用 Home 和 End 来定位行首和行末……</p>
<p>而Vim是一个带模式的编辑器，同样的按键，在不同模式下，具有不同的功能定义。例如 h j k l 在 编辑模式 下输入相应的字符，在 普通模式 下却相当于方向键的作用。</p>
<p>由于需要切换模式，Vim的使用起来略显繁琐。不过优点也显而易见：您只要把手安安稳稳的放在打字区就可以了，而不需要使用诸如方向键、排版键、小键盘等</p>
<p>需要挪开双手的键位，从而提高了您的效率和专注程度。事实上，Vim的前身Vi诞生的时候，键盘上还没有方向键、排版键和小键盘：）</p>
<h3 id="命令-2"><a class="header-anchor" href="#命令-2">¶</a>命令</h3>
<p>使用Vim编辑文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi [文件名]</span><br><span class="line">vim [文件名]</span><br></pre></td></tr></table></figure>
<p>教学模式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vimtutor [语言]</span><br></pre></td></tr></table></figure>
<p>vim教程，相当于使用Vim编辑器以只读模式打开教程文件。您无论对这个文件作了什么，都会在退出后恢复原来的样貌。与只读模式的区别在于，它不会没有眼色的提醒您，现在的状态为只读模式。您可以使用它作一些练习</p>
<p>您可以指定教程文件的语言，如果使用本地语言(ZH_cn)出现乱码，您可以尝试使用英语</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vimtutor en</span><br></pre></td></tr></table></figure>
<h3 id="使用Vim比较文件区别"><a class="header-anchor" href="#使用Vim比较文件区别">¶</a>使用Vim比较文件区别</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vimdiff [文件1] [文件2] [其它文件]……</span><br></pre></td></tr></table></figure>
<h3 id="配置文件"><a class="header-anchor" href="#配置文件">¶</a>配置文件</h3>
<p>Vim的全局配置文件为 /etc/vim/vimrc ，用户配置文件为 ~/.vimrc ， &quot; 起始的行为注释行。我们提供的配置项，您直接加入配置文件就可以了</p>
<p>您可以先对Vim进行一些简单的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;设定文件编码</span><br><span class="line">set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span><br><span class="line"></span><br><span class="line">&quot;开启语法加亮</span><br><span class="line">syntax on</span><br><span class="line"></span><br><span class="line">&quot;配色风格</span><br><span class="line">colorscheme pablo</span><br><span class="line"></span><br><span class="line">&quot;设定行距 GUI界面中生效</span><br><span class="line">set linespace=4</span><br><span class="line"></span><br><span class="line">&quot;设定GUI选项</span><br><span class="line">&quot;set guioptions=gmrLtT m:菜单 T:工具栏</span><br><span class="line">set guioptions=gmrLt</span><br><span class="line"></span><br><span class="line">&quot;设定Tab键缩进的空格数</span><br><span class="line">set tabstop=4</span><br><span class="line"></span><br><span class="line">&quot;设定编辑器将多少空格视为一个缩进</span><br><span class="line">set shiftwidth=4</span><br><span class="line"></span><br><span class="line">&quot;将缩进转换为空格</span><br><span class="line">&quot;set expandtab</span><br><span class="line"></span><br><span class="line">&quot;设定折叠方式</span><br><span class="line">&quot;set foldmethod=indent</span><br><span class="line"></span><br><span class="line">&quot;以下字符将被视为单词的一部分 (ASCII)：</span><br><span class="line">&quot;set iskeyword+=33-47,58-64,91-96,123-128</span><br></pre></td></tr></table></figure>
<h3 id="模式介绍"><a class="header-anchor" href="#模式介绍">¶</a>模式介绍</h3>
<p>Vim常见的模式有： <code>普通模式</code> 、 <code>插入模式</code> 、 <code>命令模式</code> ，另外我们也会经常用到 <code>可视模式</code> 。</p>
<p>Vim启动时进入 <code>普通模式</code> ；或者在其它模式下，按下 Esc 键，便可以回到<code>普通模式</code>。</p>
<p>使用 <code>vimtutor en</code> 命令进入教程，现在是普通模式。随便按几下 j 、 k 、 l 、 h 键，您会发现光标的位置发生改变。</p>
<p>按下 i 键，编辑器底部出现了 -- 插入 -- 或者 -- insert -- ，您进入了插入模式。随便按几下 j 、 k 、 l、 h，您会发现相应的字符出现在编辑区，现在还可以通过方向键来移动光标。可能您觉得使用方向键移动光标不是什么问题，但是习惯了Vim后，您会认为方向键太麻烦了，简直不能容忍！好了，现在按下 <code>Esc</code> 键回到普通模式，我们又可以使用 j 、 k 、 l 、 h 来移动光标了。</p>
<p>在<code>普通模式</code>下，按下 : 键（也就是 Shift+; ），在编辑器底部出现了一个 : ，您进入了命令模式。在 : 后输入一个命令 new ，回车后，编辑器被分割为上下两栏。为了方便起见，我们在命令前加一个 : 来表示命令模式下输入的命令，像这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:vnew</span><br></pre></td></tr></table></figure>
<p>一个命令能够以一些规则简化，上面的命令也可以写为这种形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:vne</span><br></pre></td></tr></table></figure>
<p>现在您的编辑区一定弄的四分五裂，您可以使用命令<code>:quit</code>来关闭当前栏，直接用简写就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></table></figure>
<p>这个命令是退出编辑器，如果编辑区被分成多栏，则是退出当前栏。</p>
<p>执行完一个命令（按下回车后），编辑器会自动回到普通模式。如果您想不执行当前命令，直接回到普通模式，您可以按下Esc键。</p>
<p>按下 v 键，您进入了可视模式，可以使用 j 、 k 、 l 、 h 移动光标，高亮选取文本 。</p>
<p>事实上，可视模式相当于高亮选取文本后的普通模式。</p>
<p>可视模式具有子模式，以行为单位进行选取的可视行模式，使用 V 键进入（也就是 Shift+v ）；和以块为单位进行选取的可视块模式，使用 Ctrl+v 键进入。</p>
<h3 id="模式切换"><a class="header-anchor" href="#模式切换">¶</a>模式切换</h3>
<p>好了，现在我们总结一下模式间切换的方法</p>
<p>其它模式==&gt;普通模式</p>
<p>Esc</p>
<p>普通模式==&gt;插入模式</p>
<p>i 在光标前插入 I 在行首插入           a 在光标后插入 A 在行末插入</p>
<p>o 在当前行之下新建行 O 在当前行之上新建行          r 替换当前字符 R 从当前字符开始替换</p>
<p>普通模式==&gt;命令模式         普通模式==&gt;可视模式         v 可视模式         V 可视块模式</p>
<p>&lt;Ctrl+v&gt; 可视块模式</p>
<h3 id="移动"><a class="header-anchor" href="#移动">¶</a>移动</h3>
<p>在普通模式中，您可以使用以下方式移动光标</p>
<p>j 向下         k 向上        l 向右 h l      h 向左 j</p>
<p>您可以使用其它更有效率的方式移动光标</p>
<p>w 下一个单词词首 W 将特殊符号视为单词的一部分           b 上一个单词词首 B 同上</p>
<p>e 单词末尾 E 同上       0 行首 ^ 行首文字（行首空格之后）         $ 行末</p>
<p>H 页面顶部        M 页面中部        L 页面底部</p>
<p>在其它模式中，您可以使用方向键移动光标，不过我们不推荐您那样作，您可以在配置文件中绑定插入模式下的功能键</p>
<p>noremap! <m-j> <down></down></m-j></p>
<p>noremap! <m-k> <up></up></m-k></p>
<p>noremap! <m-h> <left></left></m-h></p>
<p>noremap! <m-l> <right></right></m-l></p>
<p>………………</p>
<p>&lt;作用范围&gt; &lt;键位&gt; &lt;功能&gt;</p>
<p>其中，map!绑定的键盘映射，作用于所有模式；inoremap!绑定的映射，仅作用于插入模式。</p>
<h3 id="数字参数"><a class="header-anchor" href="#数字参数">¶</a>数字参数</h3>
<p>您也可以使用数字参数，来重复执行。例如</p>
<p>100j 执行100次j键，向下100行</p>
<p>或者作为跳转的行号、百分比。见下面的浏览部分</p>
<p>&lt;行号&gt; Ctrl+g 按行号跳转</p>
<h3 id="标记"><a class="header-anchor" href="#标记">¶</a>标记</h3>
<p>您可以在当前光标处作一个标记，以便快速返回</p>
<p>m&lt;标记名称&gt; 定义标记。标记名称为一个字符</p>
<p>`&lt;标记名称&gt; 返回标记</p>
<p>mx 将当前光标处定义为标记 x</p>
<p>`x 返回标记 x</p>
<h3 id="浏览"><a class="header-anchor" href="#浏览">¶</a>浏览</h3>
<p>&lt;Ctrl+f&gt; 下翻一页 &lt;Ctrl+d&gt; 下翻半页        &lt;Ctrl+b&gt; 上翻一页 &lt;Ctrl+u&gt; 上翻半页</p>
<p>gg 文件首行        G 文件末行        &lt;行号&gt;G 按行号转到相应行</p>
<p>&lt;1~100&gt;% 按百分比转到相应的行数      zz 将光标所在行调整至页面中间</p>
<p>&lt;Ctrl+e&gt; 下卷一行       &lt;Ctrl+y&gt; 上卷一行</p>
<p>说明：gg 定位到文件首行， V 进入可视行模式， G 定位到文件末行，实现类似“全选”的功能。依次按下 g g V(Shift+v) G(Shift+g)</p>
<h3 id="编辑"><a class="header-anchor" href="#编辑">¶</a>编辑</h3>
<p>x 剪切当前字符              dd 剪切当前行      y 复制可视模式选取字符      yy 复制当前行</p>
<p>p 在光标后粘贴 P 在光标前粘贴        u 撤消        &lt;trl+r&gt; 重做</p>
<p>&lt;Ctrl+y&gt; 逐字克隆上一行内容           &lt;Ctrl+e&gt; 逐字克隆下一行内容</p>
<h3 id="寄存器操作"><a class="header-anchor" href="#寄存器操作">¶</a>寄存器操作</h3>
<p>Vim可以将不同字段剪切或复制到不同寄存器中，您可以从不同寄存器中取出内容后粘贴</p>
<p>&quot;&lt;寄存器名称&gt; 按下“&quot;”键和另一个字符键，便可以定义一个寄存器。例如：</p>
<p>&quot;a &quot;1</p>
<p>定义寄存器后直接进行操作</p>
<p>&quot;ayy 将当前行复制到寄存器 a 中</p>
<p>&quot;ap 将寄存器 a 中的内容粘贴到光标之后</p>
<p>* 通常情况下，寄存器 + ( &quot; + Shift+= )对应X下的剪贴板。您在其它程序中复制的内容，可以使用 &quot;+p 粘贴到Vim中；您在Vim中，可以使用 &quot;+y 将内容复制到剪贴板，再粘贴到其它程序中</p>
<p>* 没有指定寄存器时，Vim使用“无名寄存器”存储内容</p>
<h3 id="搜索和替换"><a class="header-anchor" href="#搜索和替换">¶</a>搜索和替换</h3>
<p>按下 / 键，编辑器底部会出现 / 符号，接着输入字符串，便可以进行搜索</p>
<p>/ 向下搜索 ? 向上搜索</p>
<p>n 搜索下一个</p>
<p>N 搜索上一个</p>
<p>:s/&lt;源字符串&gt;/&lt;目标字符串&gt; 将源字符串替换为目标字符串</p>
<p>:s/&lt;源字符串&gt;/&lt;目标字符串&gt;/g 替换当前行中所有符合条件的字符串</p>
<p>:&lt;行号1&gt;,&lt;行号2&gt;s/&lt;源字符串&gt;/&lt;目标字符串&gt;/g 在指定行中进行替换</p>
<p>:%s/&lt;源字符串&gt;/&lt;目标字符串&gt;/g 全文替换</p>
<h3 id="正则表达式"><a class="header-anchor" href="#正则表达式">¶</a>正则表达式</h3>
<p>在搜索和替换时，可以使用正则表达式进行匹配</p>
<h3 id="宏"><a class="header-anchor" href="#宏">¶</a>宏</h3>
<p>您可以将一系列的操作录制为一个宏，然后执行它</p>
<p>q&lt;宏名称&gt; 开始录制宏。宏名称为一个字符</p>
<p>q 录制中按下“q”键，结束录制</p>
<p>@&lt;宏名称&gt; 执行宏</p>
<p>插入模式下的快捷键</p>
<p>&lt;Ctrl+r&gt;&lt;寄存器名称&gt; 输入指定寄存器内容</p>
<p>&lt;Ctrl+k&gt;&lt;2个字符&gt; 输入二合字符</p>
<p>&lt;Ctrl+v&gt;&lt;数字&gt; 通过数字编码输入字符</p>
<p>&lt;Ctrl+v&gt;&lt;键位&gt; 输入键位的名称</p>
<h3 id="键绑定、缩写"><a class="header-anchor" href="#键绑定、缩写">¶</a>键绑定、缩写</h3>
<p>前面我们已经向您介绍了键绑定，</p>
<p>map! <m-j> <down></down></m-j></p>
<p>尖括号及其中的内容，为Vim配置文件的约定，分别描述了按键和功能，表示将功能编写到按键上。如果绑定的只是普通字符，例如：</p>
<p>map! xxx XXXXX</p>
<p>表示将 fXXXXX 绑定到 xxx 上。当您键入 xxx 时，编辑器会自动替换为 XXXXX 。</p>
<p>如果您只是想将字符串绑定为缩写，方便输入，我们建议您使用 iabbrev 来绑定。例如：</p>
<p>iabbrev ubt Ubuntu</p>
<p>在插入模式下键入 ubt ，编辑器会自动替换为 Ubuntu 。您可以将 iabbrev 命令缩写为 iab ，例如：</p>
<p>iab ubt Ubuntu</p>
<p>以上命令，您可以直接在命令模式下输入，临时启用。也可以写入配置文件，永久启用。</p>
<h3 id="单词补全"><a class="header-anchor" href="#单词补全">¶</a>单词补全</h3>
<p>&lt;Ctrl+n&gt; 下一个匹配项</p>
<p>&lt;Ctrl+p&gt; 上一个匹配项</p>
<p>您可以在配置文件中定义补全的方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;自动补全方式：(使用逗号分隔)</span><br><span class="line">set complete=k,.</span><br><span class="line"></span><br><span class="line">&quot; . 当前文件</span><br><span class="line">&quot; b 已被装缓冲区,但是没有在窗口内的文件</span><br><span class="line">&quot; d 在当前的文件中定义和由#include包含进来的文件</span><br><span class="line">&quot; i 由#include包含进来的文件</span><br><span class="line">&quot; k 由dictionary选项定义的文件</span><br><span class="line">&quot; kfile 名为&#123;file&#125;的文件</span><br><span class="line">&quot; t 标记(tags)文件</span><br><span class="line">&quot; u 没有载入的缓冲区</span><br><span class="line">&quot; w 在其他窗口中的文件</span><br><span class="line">&quot;设定自动补全字典 ：</span><br><span class="line">set dictionary=path</span><br></pre></td></tr></table></figure>
<h3 id="命令模式"><a class="header-anchor" href="#命令模式">¶</a>命令模式</h3>
<p>前面介绍了普通模式和插入模式。我们发现，普通模式主要用来浏览和修改文本内容，而插入模式则用来向文本中添加内容。</p>
<p>而命令模式则多用于操作文本文件（而不是操作文本文件的内容），例如保存文件；或者用来更改编辑器本身的状态，例如设定多栏窗口、标签或者退出编辑器……</p>
<p>w(rote) 将更改写入文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:w</span><br></pre></td></tr></table></figure>
<p>q(uit) 退出编辑器:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:q</span><br></pre></td></tr></table></figure>
<p>某些情况下，编辑器会阻止命令的执行。例如您修改了文件，而没有保存，那么您使用 :q 命令退出时，编辑器就不会执行这条命令，而是提醒您保存文件。</p>
<p>这个时候，您可以在命令末尾追加 ! 来强制执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:&lt;命令&gt;!</span><br></pre></td></tr></table></figure>
<p>例如 <code>:q!</code> ，即便您没有保存已修改的文件，使用此命令，编辑器也会放弃修改而强行退出</p>
<p>以 ! 引导一个Shell命令，则可以从Vim临时切换到Shell中，执行一个Shell</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:!&lt;命令&gt;</span><br></pre></td></tr></table></figure>
<p>例如 :<code>!ls</code></p>
<h3 id="多栏窗口"><a class="header-anchor" href="#多栏窗口">¶</a>多栏窗口</h3>
<p>您可以使用以下命令，将当前窗口水平分为两栏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:new</span><br></pre></td></tr></table></figure>
<p>新建一栏空白窗口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:split</span><br></pre></td></tr></table></figure>
<p>将当前文件分两栏显示</p>
<p>同理，您可以使用下列命令，将当前窗口垂直分为两栏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:vnew</span><br><span class="line"></span><br><span class="line">:vsplit</span><br></pre></td></tr></table></figure>
<p>先按下 &lt;ctrl+w&gt; 键，再按下方向键 j 、 k 、 l 、 h ，您可以切换到其它栏；在当前栏中使用 :q 命令，可以退出当前栏，也可以使用其它命令，对当前栏作出修改</p>
<p>如果您希望当前命令在所有栏中生效，您可以在命令的末尾追加 all</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:&lt;命令&gt;all</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:qall</span><br></pre></td></tr></table></figure>
<p>如果您希望这条命令强制执行，那么 ! 位于命令的最末</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:&lt;命令&gt;all!</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:qall! 强行退出所有栏窗口</span><br></pre></td></tr></table></figure>
<h3 id="标签页"><a class="header-anchor" href="#标签页">¶</a>标签页</h3>
<p>Vim在7以后的版本，开始支持标签页的功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:tabnew 新建一个标签</span><br><span class="line">:tabnext 转到下一个标签</span><br><span class="line">:tabprevious 转到上一个标签</span><br></pre></td></tr></table></figure>
<p>多数情况下，您可以使用鼠标点击标签进行切换。</p>
<h2 id="引导管理器Grub"><a class="header-anchor" href="#引导管理器Grub">¶</a>引导管理器Grub</h2>
<h3 id="硬件基础"><a class="header-anchor" href="#硬件基础">¶</a>硬件基础</h3>
<p>一块硬盘，它起始的一部分扇区为主引导扇区，包括MBR（主引导纪录）和DPT（分区表，您可以阅读分区概念章节中相关内容）</p>
<p>每个分区起始的一部分扇区，为分区引导扇区。</p>
<p>在分区引导扇区之后的部分，为文件系统的索引，文件系统通过它定位文件在硬盘上的位置。不同的文件系统采用不同的索引，例如FAT文件系统使用文件分配表和目录区。</p>
<p>绝大多数操作系统，对硬盘的读写操作，通过文件系统来完成，因此引导扇区中的内容，我们不能够在文件系统中进行操作，而需要专用软件，比如引导管理器。</p>
<p>我们对文件进行修改后，操作系统会将文件系统索引中的内容同步。</p>
<h3 id="系统引导流程"><a class="header-anchor" href="#系统引导流程">¶</a>系统引导流程</h3>
<p>1.系统启动时，首先引导至MBR，将控制权移交安装在MBR中的引导管理器</p>
<p>（Windows使用NTLDR，Linux通常用Grub）</p>
<p>2.引导管理器读取分区表</p>
<p>3.引导管理器读取分区中的配置文件，并按配置文件中预设的参数运行</p>
<p>例如，Grub读取“/boot/grub/menu.lst”文件中内容，将可引导系统通过菜单显示</p>
<p>4.引导管理器根据您的选择，可能会有如下活动</p>
<p>加载内核，启动Linux系统检查活动分区，并引导它（单一Windows系统）读取相应分区的引导扇区，将控制权移交该扇区中的引导管理器，Ubuntu系统在安装Grub时，会提问您安装在MBR或者分区引导扇区中。如果将Grub安装在分区引导纪录中，您必须确保MBR中的引导管理器能够正确的引导至分区引导扇区。</p>
<p>如果您在MBR中使用的是Windows的引导管理器NTLDR，完成这件工作会非常困难，因而我们推荐您使用Grub。</p>
<h3 id="Grub介绍"><a class="header-anchor" href="#Grub介绍">¶</a>Grub介绍</h3>
<p>Grub主要有以下功能：</p>
<ul>
<li>菜单式选择</li>
<li>命令行模式</li>
<li>支持开机画面</li>
<li>支持大硬盘</li>
</ul>
<p>其它的功能还有很多，就不一一介绍了。</p>
<p>您可以运行命令 grub 启动它。会显示一些版本信息和使用提示，当然还有命令提示符，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GNU GRUB version 0.97 (640K lower / 3072K upper memory)</span><br><span class="line">[ Minimal BASH-like line editing is supported. For the first word, TAB lists possible <span class="built_in">command</span> completions. Anywhere <span class="keyword">else</span> TAB lists the possible completions of a device/filename. ]</span><br><span class="line">grub&gt;</span><br></pre></td></tr></table></figure>
<p>您可以使用 TAB 键补全命令和路径，这非常重要，因为Grub中路径表示方式与操作系统是不同的，您可能比较陌生，所以尽量用TAB补全它，既方便，也不容易出错。</p>
<p>您可以在 grub&gt; 提示符后按 TAB 键，会将所有可用的命令显示出来。</p>
<p>呵呵，是不是有点晕，命令可真不少啊！！！</p>
<p>其实我们会用到的命令只有两个，</p>
<p>root</p>
<p>setup</p>
<h3 id="Grub术语"><a class="header-anchor" href="#Grub术语">¶</a>Grub术语</h3>
<p>在分区概念章节里，我们已经介绍了Linux系统中表示分区的方法 /dev/hda5</p>
<p>/dev/hdMN M为a起始的小写字母，表示硬盘序号；N为1起始的数字，表示分区序号</p>
<p>Grub中使用的表示方法为 hd0,1</p>
<p>hdX,Y X为0起始的数字，表示硬盘序号；Y为0起始的数字，表示分区序号</p>
<p>您得留意它们之间的区别：</p>
<p>N从1开始计数，X和Y从0开始计数</p>
<p>N为1~4，它是一个主分区；N为5或大于5，它是第(N-4)个逻辑分区。Y按分区在硬盘上排列的顺序排列，无论它表示的是主分区还是逻辑分区。</p>
<p>举例来说：</p>
<p>主 主 逻 逻 主</p>
<p>/dev/hdMN hda1 hda2 hda5 hda6 hda3</p>
<p>hdX,Y hd0,0 hd0,1 hd0,2 hd0,3 hd0,4</p>
<p>现在我们来看 root 和 setup 命令的使用：</p>
<p>grub&gt;root (hd0,1)</p>
<p>这个命令将Grub的根分区定位为 “(hd0,1)”</p>
<p>grub&gt;setup (hd0)</p>
<p>这个命令表示将Grub安装在“(hd0)”，因为没有指定安装的分区，所以安装位置为MBR</p>
<p>Grub的根分区 为Grub配置文件 /boot/grub/menu.lst 所在分区。假如您单独为 /boot 目录挂载了一个分区，那么Grub的根分区通常为您系统中 /boot 目录所在的分区。</p>
<p>搞错了根分区，Grub就不能正确读取配置文件，自然不能正确引导。</p>
<p>引导分区 ，Windows等系统的引导分区为它的安装分区，Linux系统的引导分区为它的 /boot 目录所在的分区</p>
<p>系统根目录所在分区 ，Linux根目录 / 的挂载分区。Linux系统的分区挂载信息保存在文件系统分配表 /etc/fstab 文件中</p>
<p>Grub首先读取根分区中的 /boot/grub/menu.lst</p>
<p>文件，并转到引导分区，如果是Windows等系统，则将控制权移动分区引导扇区中的启动管理器。如果是Linux系统，则加载内核和设备，并根据</p>
<p>/etc/fstab 文件的内容挂载文件系统。</p>
<p>看这个例子：（假设Grub安装在MBR中）</p>
<p>title Ubuntu</p>
<p>root (hd0,0)</p>
<p>kernel (hd0,1)/boot/vmlinuz-2.6.15-25-686 root=/dev/sda3 ro splash vga=0x31b</p>
<p>initrd (hd0,1)/boot/initrd.img-2.6.15-25-686</p>
<p>boot</p>
<p>Grub的安装位置为 (hd0)</p>
<p>root (hd0,0) ，这一行表示Grub的根分区为第一块硬盘的第一个分区 (hd0,0) ，它读取该分区中的配置文件 grub/menu.lst</p>
<p>kernel 和 initrd 行中的 (hd0,1) ，表示当前系统的 /boot 目录挂载到第一块硬盘的第二个分区 (hd0,1)</p>
<p>kernel 行的 root=/dev/sda3 ，表示当前系统的 / 目录挂载到第一块硬盘的第三个分区 (hd0,2) ，内核根据该分区中的 /etc/fstab 文件来挂载文件系统</p>
<h3 id="Grub配置文件"><a class="header-anchor" href="#Grub配置文件">¶</a>Grub配置文件</h3>
<p>/boot/grub/menu.lst 文件，主要由一些下面这样的块构成的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title Ubuntu</span><br><span class="line">root (hd0,2)</span><br><span class="line">kernel (hd0,2)/boot/vmlinuz-2.6.15-25-686 root=/dev/sda3 ro splash vga=0x31b</span><br><span class="line">initrd (hd0,2)/boot/initrd.img-2.6.15-25-686</span><br><span class="line">boot</span><br><span class="line">title Windows xp</span><br><span class="line">root (hd0,0)</span><br><span class="line">makeactive</span><br><span class="line">chainloader +1</span><br></pre></td></tr></table></figure>
<p>每一块代表一个操作系统，包含下面里几个部分</p>
<p>title xxx 标题，title和分隔符后的内容为Grub菜单中显示的条目</p>
<p>root (hdX,Y) 引导分区，可以留空，默认为 grub/menu.lst 所在分区（根分区），可以使用 grub&gt;root (hdX,Y) 命令设置，或者在您安装系统时自动设置</p>
<p>如果您计划引导至分区引导扇区，如Windows或者Unix系统（Unix和Linux系统，您需要选择将引导管理器安装到分区中），那么需要这样配置</p>
<p>makeactive 设置活动分区，系统默认设置，可以删除</p>
<p>chainloader +1 链式引导，不要动它。</p>
<p>如果以这种方式引导系统，上面 root (hdX,Y) 这一行通常需要配置， (hdX,Y) 为您的系统所在的分区。假如您的Windows在第一块硬盘的第一个分区，则这样写 root (hd0,0)</p>
<p>如果您引导的是Linux系统（没有在分区中安装引导管理器，而是安装到MBR），则需要这样配置</p>
<p>kernel (hd0,2)/boot/vmlinuz-2.6.15-25-686 root=/dev/sda2 ro splash vga=0x31b</p>
<p>initrd (hd0,2)/boot/initrd.img-2.6.15-25-686 设备镜像文件，与上一行保持一致</p>
<p>boot 不要动它</p>
<p>kernel 这一行最关键，它控制系统内核的加载。行末以 ro 起始的部分为参数（ro只读，splash显示启动画面，vga设定启动屏幕分辨率）</p>
<p>之前的部分可以写为这种形式：</p>
<p>kernel (hdX,Y)/boot/vmlinuz root=/dev/sdMN</p>
<p>(hdX,Y) 通常不是必须的，如果您安装了多个Linux系统，或者 /boot<code>目录与根目录 </code>/ 不在一个分区，则应把它写为 /boot 目录所在分区。而后面的 root=/dev/sdMN 为系统根目录 / 所在的分区。</p>
<p>initrd 这一行的 (hdX,Y) 与上一行保持一致。</p>
<h3 id="Grub安装"><a class="header-anchor" href="#Grub安装">¶</a>Grub安装</h3>
<p>上面已经向您介绍了Grub的安装，不过更多的侧重理论。现在我们来实践一下，假设您的系统不能引导，您可以尝试下面的方法：）</p>
<ol>
<li></li>
</ol>
<ul>
<li>找一张Ubuntu的LiveCD （Knoppix也是不错的选择）</li>
<li>也可以使用安装光盘，启动后在 boot 提示符后输入 linux rescue ，回车进入救援模式。</li>
<li>如果您拥有root权限，命令行提示符为 # ，如果是普通用户，则为 $ 。</li>
</ul>
<blockquote>
<p>在救援模式下，通常你已经具有了root权限</p>
</blockquote>
<blockquote>
<p>如果是LiveCD且没有root权限，请在终端中输入 su命令切换到root，会提问你root的密码。如果不知道root密码，可以使用这个命令 sudo su，只要你知道自己的密码，并且你在ID在sudoer列表中就可以了。</p>
</blockquote>
<ol start="2">
<li>在终端中输入 grub ，会进入到Grub的提示符界面</li>
</ol>
<p>a. 输入命令 root (hd 后按 Tab 键，屏幕上就会列出所有可用选项。比如我的是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Possible disks are: hd0 hd1</span><br></pre></td></tr></table></figure>
<p>这表示我装了两块硬盘，如果你只有一块硬盘的话，那么一定是hd0。</p>
<p>在 root(hd 后输入 0 ,按 Tab ，会自动补上一个 , ，现在你输入的内容成为这样：</p>
<p>root(hd0,</p>
<p>再按 Tab 键，会列出所有可用选项，我的是这样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Possible partitions are:</span><br><span class="line">Partition num: 0, Filesystem type unknown, partition type 0x7</span><br><span class="line">Partition num: 1, Filesystem type is fat, partition type 0xc</span><br><span class="line">Partition num: 2, Filesystem type is reiserfs, partition type 0x83</span><br><span class="line">Partition num: 4, Filesystem type is reiserfs, partition type 0x83</span><br><span class="line">Partition num: 5, Filesystem type unknown, partition type 0x82</span><br><span class="line">Partition num: 6, Filesystem type unknown, partition type 0x7</span><br><span class="line">Partition num: 7, Filesystem type is fat, partition type 0xc</span><br></pre></td></tr></table></figure>
<p>输入你的选择，比如为 1 ， Tab 一次后，结果是这样的：</p>
<p>root (hd1,1)</p>
<p>现在回车</p>
<p>输入命令</p>
<p>setup (hd0)</p>
<p>将grub安装在mbr中</p>
<p>最后，quit 命令退出GRUB</p>
<h3 id="Grub使用"><a class="header-anchor" href="#Grub使用">¶</a>Grub使用</h3>
<p>命令行</p>
<p>在Grub启动菜单中，您可以选择您要的选项，按下 e 键，进入到命令行模式</p>
<p>修改您的启动参数，完成后回车</p>
<p>按 b 键，Grub将以您修改后的参数引导系统。</p>
<h3 id="其它-2"><a class="header-anchor" href="#其它-2">¶</a>其它</h3>
<p>在Grub启动菜单中，按下 c 进入命令行模式</p>
<p>按下 d 删除当前选中的项</p>
<h2 id="FAQ"><a class="header-anchor" href="#FAQ">¶</a>FAQ</h2>
<h3 id="我的D盘到哪里去了？"><a class="header-anchor" href="#我的D盘到哪里去了？">¶</a>我的D盘到哪里去了？</h3>
<p>在使用Linux最初的几天里，我感到有些不安。</p>
<p>Windows下，我可以把系统装在C盘，软件放在D盘，音乐放在E盘……如果系统出现问题，我只要重装系统就可以了，大部分软件都可以直接使用（养成使</p>
<p>用绿色软件是一种好习惯：），而我辛辛苦苦收集起来的电影和音乐，我总是把它们放在一个安全的地方，以免引发失眠的严重后果。</p>
<p>其实Linux下硬盘也具有分区的概念，这一点和Windows没有什么不同（分区的概念是由硬盘的物理特性产生的，而不是操作系统）。不同的是，Linux可以将分区挂载到任意的目录下，而不像Windows，您的分区只能够在“我的电脑”里面：）</p>
<p>那么这么作有什么好处么？</p>
<p>我们来看看Linux和Windows下路径的表示方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows C:\Documents and Settings\Users\Documents\MyDocument</span><br><span class="line"></span><br><span class="line">Linux /home/User/MyDocument</span><br></pre></td></tr></table></figure>
<p>您一定注意到了，在Windows下面，路径中含有盘符“C:”，它通常代表您硬盘上的第一个分区。也就是说，在使用这些文件时，您需要知道它们在硬盘上</p>
<p>存储的相关物理细节。而在Linux下，您不需要知道这些，或者说，只要您设定好了分区挂载的目录，您就不需要再去理会什么分区。</p>
<p>Windows下的路径包含有分区、目录和文件三部分内容;而Linux下的路径则只有目录和文件，不包含任何分区信息，它的硬件抽象度更高！</p>
<p>Linux下的目录用“/”表示，这不标准吧？？</p>
<p>完全相反，这才是标准的体现。您只是习惯了Windows的目录符号，但是那并不意味着它是标准的。</p>
<p>看看Winodws下，各种位置、路径的表示方法：</p>
<p><a href="http://www.ubuntu.org.cn" target="_blank" rel="noopener">http://www.ubuntu.org.cn</a></p>
<p><a href="ftp://192.168.0.1" target="_blank" rel="noopener">ftp://192.168.0.1</a></p>
<p>c:\Windows\</p>
<p>file:///C:/Windows/</p>
<p>\127.0.0.1$C</p>
<h3 id="操作系统是一种非常精密的高科技产品，怎么可能如此混乱！！！他们是怎么作到的？？？"><a class="header-anchor" href="#操作系统是一种非常精密的高科技产品，怎么可能如此混乱！！！他们是怎么作到的？？？">¶</a>操作系统是一种非常精密的高科技产品，怎么可能如此混乱！！！他们是怎么作到的？？？</h3>
<p>Linux下的病毒少，是因为Linux的使用者少，骇客显然不愿意浪费气力去攻击没有人使用的操作系统。</p>
<p>您可能已经知道了，互联网上用作重要用途的服务器，其中很大一部分是Linux系统，另外的一部分是Unix系统：）如果骇客能够搞掉Linux系统的话，那么整个互联网就会陷于瘫痪！效果似乎更好一些。</p>
<p>当然了，您一定会想：骇客也是人，他们也喜欢上网，兔子还不吃窝边草呢……兔子那么笨，连乌龟都跑不过……骇客们可比兔子要聪明的多了！</p>
<p>是的，我承认这一点……不过他们也不一定非得把互联网干掉。很多骇客作梦都想入侵美国军方的服务器，美军服务器中的绝密数据，只要1kb，应该就可以买一台顶级的个人电脑了：）</p>
<p>如果可以的话，骇客为什么不去入侵美军的服务器，而要入侵您的电脑呢？</p>
<p>这是一个很有意思的观点，与之相映成趣，另一种论调也使人侧目：Windows服务器占到了服务器操作系统xx%的份额。</p>
<p>或许这个现象可以用80：20法则来解释：）</p>
<p>占服务器总数80%的Windows提供了服务总量的20%！</p>
<p>请您务必注意，这只是举一个例子，Windows服务器可能永远也不会占到服务器总数的80%！它提供的服务，以我个人的角度，我不认为可以达到20%，而且永远不会有那一天。</p>
<h3 id="软件安装繁琐"><a class="header-anchor" href="#软件安装繁琐">¶</a>软件安装繁琐</h3>
<p>或许您已经看过一些关于Linux软件安装的文章，但是您也不要忽略，此类文章的数量，是不能够和同类Windows文章相比的。</p>
<p>当然，使用源码包安装软件确实有点麻烦，但却不一定比Windows下的某些软件复杂。特别要提到，Ubuntu的包管理系统，为您提供了一种高效快捷的</p>
<p>软件管理方式，您只要知道您需要什么软件就可以了，甚至不需要关心它存放在网络上的哪一台服务器中，而且绝大多数的软件都可以使用这种方式来安装。</p>
<p>详情请参阅 APT</p>
<p>如果您有如下需求，您也可以尝试以源码的形式安装软件：</p>
<p>您需要某些软件的技术预览版本</p>
<p>您想测试您的机器的运算能力</p>
<p>您找不到一种比安装软件更好的方式来消磨时间 | （试图通过编译源码安装来大幅提高系统性能，其结果很可能会让您失望）</p>
<h3 id="源码保密性不强，存在安全隐患"><a class="header-anchor" href="#源码保密性不强，存在安全隐患">¶</a>源码保密性不强，存在安全隐患</h3>
<p>既然Linux下软件都开放源代码，那么会不会造成一些安全隐患呢？比如说一名骇客会发现其中的漏洞，并利用它？</p>
<p>事实刚好相反，一个软件，即便它不开放源码，骇客一样可以找到其中的漏洞，雷蒙德的软件巨头就是最好的佐证。就像一把锁，无论如何坚固，它总是能被撬开！它的作用无外乎“聊备一格，以防君子”：）</p>
<p>而这把锁，防住的恰恰是能够改进它的工程师！工程师知道了它的漏洞，却不能够去改进它;骇客知道了它的漏洞，却可以利用它……这把锁正是封闭源码！</p>
<p>这岂不是不妙？</p>
<h3 id="软件功能不够强"><a class="header-anchor" href="#软件功能不够强">¶</a>软件功能不够强</h3>
<p>虽然您很愿意使用Linux系统，但是它的软件并不能使您满意，甚至使您多愁善感的心灵又蒙上了一层阴影，“长太息以掩涕……”</p>
<p>首先您别忘了，《泰坦尼克》的特效就是在Linux系统下完成的，连业界巨头SGI都在向Linux迁移（尽管SGI的IRIX本来就是一种Unix系统）。如果您不知道SoftImage，那么Maya您总听说过吧？它最初就是多平台的。</p>
<p>对于电影特效处理时需要的高吞吐量的数据（以TB计）和运算能力，Windows系统恐怕连崩溃的机会都没有=_=#(最新统计资料显示，Top500计算机中，使用Linux的占到73.4%，包括最快的前两名。其中Linux系统367部，Unix系统98部，混合操作系统24部，AppleMacOS系统5部,BSD系统4部，Windows系统，2部）类似于大气模拟、基因解码等等真正的科学运算……Windows……前几天我还在verycd.com上看到一套欧洲某天文台的天文学软件，只有Linux版！</p>
<p>当然了，Linux下功能强大的软件大多是命令行的，图形界面的程序只能视觉上强大，外强中干！建议您多使用man这个命令来查询各类软件的使用方法，它排版美观，格式工整，语法简明，意韵流畅，实在是学习英语难得的教材。</p>
<h3 id="界面不友好"><a class="header-anchor" href="#界面不友好">¶</a>界面不友好</h3>
<p>如果您指的是系统的美观程度。Gnome默认效果我认为与Windows处于同一水平线，而KDE的效果就要略好一点，很多高手用FVWM可以作出让人眼花瞭乱的效果来……而Novell的XGL，更是可以用“惊艳”来形容。</p>
<p>如果您指的是操作，这属于“易于上手难于精通”与“难于上手易于精通”两种理念的冲撞。</p>
<p>当然了，我指的精通主要针对效率而言。如果您经常玩Blizzard出品的游戏，您对于“易于上手难于精通”这种理念或许相当了解，甚至非常欣赏。</p>
<p>不过这一理念只适用于竞技游戏！竞技游戏要球能够吸引大量的玩家，所以要易于上手。但是竞技游戏是为竞技而生的，所以不可能人人是高手 ────事实上高手只是一小部分人！</p>
<p>而操作系统是给人们来用的，最好人人都成为高手，所以易于精通是很重要的……当然最好也能够易于上手。但是考虑到效率的问题，这很难解决……</p>
<h3 id="Linux怎么占用这么多内存？"><a class="header-anchor" href="#Linux怎么占用这么多内存？">¶</a>Linux怎么占用这么多内存？</h3>
<p>Linux会最大程度的利用物理内存，避免使用交换空间;而不是尽量的回收内存，使用页面文件。</p>
<p>又因为Linux系统的内存管理非常优秀，程序退出时可以高效的回收内存，所以更加没有必要在程序运行时就回收内存！</p>
<p>因此，Linux系统表面看来内存开销很大，实际上系统运行是很稳定的──Linux不会时而流畅，时而瘫痪。事实上，在正常情况下，它运行是非常流畅的。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
</search>
