<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[人脸识别]]></title>
    <url>%2Fpublic%2F2017%2F05%2F22%2Fopencv%2Fface_recognition%2F</url>
    <content type="text"><![CDATA[概要：人脸识别项目，利用opencv。 要求：利用线性回归模型实现人脸识别任务，需有GUI界面输入人脸图像，返回对应的人的名字。指导教师提供基础代码学生需依据教师指导完成系统其他部分。学生需具备一定的线性代数基础及程序设计经验，难度较低。代码放在百度网盘了见https://pan.baidu.com/s/1mgFVOEW 链接（SRC）基于稀疏表示的人脸识别 人脸识别技术大总结——Face Detection &amp; Alignment http://www.leiphone.com/news/201608/MFDbG6TghCWDDOHq.html http://www.36dsj.com/archives/27284 初步设想概念线性回归模型给的论文阅读笔记]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>人脸识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu完全教程]]></title>
    <url>%2Fpublic%2F2017%2F05%2F22%2Fopencv%2Fubuntu%2F</url>
    <content type="text"><![CDATA[概要：一个好的Ubuntu教程，选取重要的记录原文链接]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kinect开发]]></title>
    <url>%2Fpublic%2F2017%2F05%2F22%2Fkinect%2F</url>
    <content type="text"><![CDATA[概要：Kinect SDK V2.0重点记录 微软官方ReferenceKinect for Windows C++ Reference CameraSpacePointA 3D location in camera space. defined12345typedef struct _CameraSpacePoint &#123; float X; float Y; float Z;&#125; CameraSpacePoint; Members Members X component in camera space. Y component in camera space. Z component in camera space. RemarksCamera space refers to the 3D coordinate system used by Kinect. The coordinate system is defined as follows: The origin (x=0, y=0, z=0) is located at the center of the IR sensor on Kinect X grows to the sensor’s left Y grows up (note that this direction is based on the sensor’s tilt) Z grows out in the direction the sensor is facing 1 unit = 1 meter MapColorFrameToCameraSpace MethodICoordinateMapper-&gt;MapColorFrameToCameraSpace Method Uses the color frame data to map the entire frame from color space to camera space. Syntax1234567public:HRESULT MapColorFrameToCameraSpace( UINT depthDataPointCount, const UINT16 *depthFrameData, UINT cameraPointCount, CameraSpacePoint *cameraSpacePoints) Parameters Parameters Type depthDataPointCount UINT The number of depth data points. depthFrameData UINT16 [in] The full image data from a depth frame. cameraPointCount UINT The number of camera points. cameraSpacePoints CameraSpacePoint [out] The array of mapped camera points that will be filled. Return value HRESULT Returns S_OK if successful; otherwise, returns a failure code. RemarksThe cameraPoints array should be the same size of the number of color frame pixels. 1920x1080 IDepthFrame::AccessUnderlyingBuffer MethodGets a pointer to the depth frame data. link Syntax12345public:HRESULT AccessUnderlyingBuffer( UINT *capacity, UINT16 **buffer) Parameters Parameters Type capacity UINT [out] When this method returns, contains the size of the frame data buffer in bytes. buffer UINT16 [out] When this method returns, contains the pointer to the depth frame data. Return value HRESULT Returns S_OK if successful; otherwise, returns a failure code. RemarksThe capcity is not size in bytes, it is the count of UINT16. 1*(((DWORD *)(m_pDepthRGBX))+i) = *(pBuffer+i);]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>Kinect</tag>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【翻译】daugman算法]]></title>
    <url>%2Fpublic%2F2017%2F05%2F21%2Ftranslations%2Fdaugman%2F</url>
    <content type="text"><![CDATA[概要：daugman算法是虹膜是识别的经典算法。 John.Daugman的 剑桥主页虹膜识别介绍 Introduction to Iris Recognition 文章Daugman, J. (1993) “High confidence visual recognition of persons by a test of statistical independence.” IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 15(11), pp. 1148-1161. PDF link 翻译High Confidence Visual Recognition of Persons by a Test of Statistical IndependenceJohn G. Daugman 通过统计独立实验的高可信的人类视觉识别算法 摘要 - 基于独立性统计检验的失败，描述了快速视觉认知个人身份的方法。人脸上最独特的表型特征是眼睛上虹膜的细致纹理：对人类样本样本中的统计学复杂性的估计显示出与几百个独立自由度的变化。虹膜小梁网纹理表现形态学随机性确保了来自不同眼睛的两种编码图案的统计学独立性测试几乎可以肯定地通过，当比较的代码来源于同一只眼睛时，相同的测试几乎肯定失败。一个人的可见纹理“ 实时视频图像中的虹膜被编码成多尺度正交2-D Gabor小波系数的紧凑序列，其最高有效位包括256字节的“虹膜代码”。统计学决策理论根据独家对比完整的虹膜代码，以每秒4000次的速度生成识别决策，包括决定置信水平的计算。在这种比较中经验观察到的分布意味着当采用一种能够使错误接受和错误拒绝率相等的决策标准时，理论上的“交叉”错误率为131 000。在典型情况下，考虑到虹膜代码协议的平均观察程度，决策置信水平正式对应于约 $10^{31}$ 中的条件假接受概率 关键字 - 图像分析，统计模式识别，生物识别，统计判定理论，2-D Gabor滤波器，小波，纹理分析，形态发生。 介绍设计可靠的生物特征识别的机械方法已经有一段历史了。在维多利亚女王那个时代举例， 图像分析A 标定虹膜的操作B Assessing Image Quality, Eyelid Occlusion, and Possibility of ArtificeC 2-D Gabor滤波器D Doubly Dimensionless Projected Polar Coordinate System]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>虹膜识别</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程心得记录]]></title>
    <url>%2Fpublic%2F2017%2F05%2F21%2Fprograming%2F</url>
    <content type="text"><![CDATA[概要：记录编程路上的小坑大坑【原创】 资料Google 开源项目风格指南 (中文版) link]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程心得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虹膜识别基于opencv]]></title>
    <url>%2Fpublic%2F2017%2F05%2F15%2Fopencv%2Firis_opencv%2F</url>
    <content type="text"><![CDATA[概要：虹膜识别项目，利用opencv。 资料1.利用MFC及OpenCV读入摄像头并显示画面link2.利用opencv的objdetect模块检测摄像头中的人脸3.虹膜图像分割（一）内圆检测link4.虹膜图像分割（二）外圆检测link 虹膜识别系统包含硬件和软件两大模块虹膜图像获取装置和虹膜识别算法,分别对应于图像获取和模式匹配这两个基本问题。 发展历程追溯至19世纪80年代。1885年，Alphonsebertillon将利用生物特征识别个体的思路应用在巴黎的刑事监狱中，当时所用的生物特征包括：耳朵的大小、脚的长度、虹膜等。1987年，眼科专家Aran Safir和Leonardflom首次提出利用虹膜图像进行自动虹膜识别的概念，到1991年，美国洛斯阿拉莫斯国家实验室的Johnson实现了一个自动虹膜识别系统。1993年，John Daugman实现了一个高性能的自动虹膜识别原型系统。 DAUGMAN算法今天，大部分的自动虹膜识别系统使用DAUGMAN核心算法。虹膜是位于眼睛黑色瞳孔和白色巩膜之间的圆环状部分，总体上呈现一种由里到外的放射状结构，由相当复杂的纤维组织构成，包含有很多相互交错的类似于斑点、细丝、冠状、条纹、隐窝等细节特征，这些特征在出生之前就以随机组合的方式确定下来了，一旦形成终生不变。 虹膜识别的准确性是各种生物识别中最高的。采集从直径11mm的虹膜上，Dr.Daugman的算法用3.4个字节的数据来代表每平方毫米的虹膜信息，这样，一个虹膜约有266个量化特征点，而一般的生物识别技术只有13个到60个特征点。266个量化特征点的虹膜识别算法在众多虹膜识别技术资料中都有讲述，在算法和人类眼部特征允许的情况下，Dr.Daugman指出，通过他的算法可获得173个二进制自由度的独立特征点。在生物识别技术中，这个特征点的数量是相当大的。 算法第一步是通过一个距离眼睛3英寸的精密相机来确定虹膜的位置。当相机对准眼睛后，算法逐渐将焦距对准虹膜左右两侧，确定虹膜的外沿，这种水平方法受 到了眼睑的阻碍。算法同时将焦距对准虹膜的内沿（即瞳孔）并排除眼液和细微组织的影响。 单色相机利用可见光和红外线，红外线定位在700-900mm的范围内（这是IR技术的低限，美国眼科学会在他们对macularcysts研究中使用同样的范围。） 在虹膜的上方，算法通过二维Gabor子波的方法来细分和重组虹膜图象，第一个细分的部分被称为phasor，要理解二维gabor子波的原理需要很深的数学知识。 精确度虹膜识别技术是精确度最高的生物识别技术，具体描述如下：两个不同的虹膜信息有75%匹配信息的可能性是1:106等错率：1:1200000两个不同的虹膜产生相同虹膜代码的可能性是1:1052 录入和识别虹膜的定位可在1秒钟之内完成，产生虹膜代码的时间也仅需1秒的时间，数据库的检索时间也相当快。处理器速度是大规模检索的一个瓶颈，另外网络和硬件设备的性能也制约着检索的速度。由于虹膜识别技术采用的是单色成像技术，因此一些图像很难把它从瞳孔的图像中分离出来。但是虹膜识别技术所采用的算法允许图像质量在某种程度上有所变化。相同的虹膜所产生的虹膜代码也有25%的变化，这听起来好像是这一技术的致命弱点，但在识别过程中，这种虹膜代码的变化只占整个虹膜代码的10%，它所占代码的比例是相当小的。]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>虹膜识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学问题]]></title>
    <url>%2Fpublic%2F2017%2F05%2F05%2Fmath%2Fmath_q1%2F</url>
    <content type="text"><![CDATA[概要：一个数学问题，我有空试着练习一下，顺便练习一下Latex输入公式。如果有错误或更好的解答，欢迎在下面回复。【原创】 问题为什么会经过这个空隙？ 解答首先建立空间直角坐标系，$P$ 点为水平杆与斜杆的交点，$Q$点为垂直杆与水平杆的交点，将斜杆标记为 $L$，假设 $OQ=q$ ，$QP=r$ 。 设水平杆$QP$绕$z$轴以$\omega\, rad/s$ 的角速度旋转，并设开始旋转的时间长度为$t$ 秒，则$P(r\cos{\omega t}, r\sin{\omega t}, q)$ $$\overrightarrow{OQ}=(0, 0, q) \qquad \overrightarrow{QP}=(r\cos{\omega t}, r\sin{\omega t}, 0)$$ 我们知道 $\overrightarrow{QP}$ 与斜杆 $L$ 垂直，假设 $\overrightarrow{OQ}$ 与斜杆 $L$ 成固定角 $\theta$ ，设 $L$ 的方向向量 $\overrightarrow{s}=(A, B, C)$ 斜杆 $L$ 代表的直线：$$\frac{x-r\cos{\omega t}}{A}=\frac{y-r\sin{\omega t}}{B}=\frac{z-q}{C}$$ $$\begin{cases}0=\overrightarrow{QP} \cdot \overrightarrow{s} \\\cos{\theta}=\frac{\overrightarrow{OQ} \cdot \overrightarrow{s}}{\left|\overrightarrow{OQ}\right| \left| \overrightarrow{s}\right|}\end{cases}$$ $$\frac{A}{C}=\frac{-\sin{\omega t}}{\cos{\omega t}}$$ $$B^{2}(\tan{\theta})^{2}=A^{2}+C^{2}$$ $$\frac{B^{2}}{C^{2}}=\frac{1}{(\tan{\theta})^{2}(\cos{\omega t})^{2}}$$ 为了求直线组$L$与$xoy$平面相交的图形，我们令$z=0$$$\frac{x-r\cos{\omega t}}{A}=\frac{y-q}{B}=\frac{-r\sin{\omega t}}{C}$$ $$\begin{cases}\frac{A}{C}=\frac{1}{(\tan{\theta})^{2}(\cos{\omega t})^{2}}\\\frac{x-r\cos{\omega t}}{A}=\frac{-r\sin{\omega t}}{C}\end{cases}$$ $$\cos{tx}=r$$$$(\cos{\omega t})^{2}=\frac{r^{2}}{x^{2}}$$$$(\sin{\omega t})^{2}=\frac{x^{2}-r^{2}}{x^{2}}$$ $$\begin{cases}\frac{B^{2}}{C^{2}}=\frac{1}{(\tan{\theta})^{2}(\cos{\omega t})^{2}}\\\frac{y-q}{B}=\frac{-r\sin{\omega t}}{C}\end{cases}$$ 消去 $(\cos{\omega t})^{2}$ 和 $(\sin{\omega t})^{2}$得 $x^{2}-(\tan{\theta})^{2}(y-q)^{2}=r^{2}$易知为双曲线方程，所以在 $xoy$ 平面相交得图形为双曲线。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学问题</tag>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人主页搭建]]></title>
    <url>%2Fpublic%2F2016%2F12%2F22%2Fbuild_blog%2F</url>
    <content type="text"><![CDATA[概要：博客搭建的记录与分享，主要用了Hexo和NexT主题。 小技巧，在文章中使用&lt;!-- more --&gt;手动进行截断，Hexo 提供的方式。下面就是用这个截断的～～ Hexo中文网站https://hexo.io/zh-cn/ NexT相关 NexT的Github项目https://github.com/iissnan/hexo-theme-next NexT安装教程http://theme-next.iissnan.com NexT开发者的博客http://notes.iissnan.com 图标网站http://fontawesome.io local searchhttp://theme-next.iissnan.com/third-party-services.html npm install hexo-generator-searchdb --save MathJax$\frac{d}{dx}c^n=nx^{n-1}$ 网易云跟帖https://gentie.163.com/ 登陆 网易云跟帖 获取你的 Product Key 。 编辑 主题配置文件， 编辑 gentie_productKey 字段，设置如下：1gentie_productKey: #your-gentie-product-key 图片存储原则 github上有项目图片就从项目中链接过来，比如头像就是我github的头像 非常重要的图片就存在本项目，然后链接过来 编写规范以后再补充～ CopyLeft Here]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阅读Progit]]></title>
    <url>%2Fpublic%2F2016%2F12%2F01%2Fproject_github%2Fread_progit%2F</url>
    <content type="text"><![CDATA[概要：git官方教程书籍，有空的时候阅读一下并做笔记供以后参考。书的链接：中文V2英文V2本文中的链接多为中文版。 暂停一下。我已经完成了初步了解。手机上用 pocket git 和MarkDownX 1. 起步1.1 关于版本控制1.2 Git 简史版本控制有单机版本控制、集中版本控制、分布式版本控制。git简史诞生于 2005 年。 1.3 Git 基础Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于对待数据的方法。直接快照，而非差异比较。Git使用SHA-1 散列保证项目完整性。一般只增加内容。文件三个状态 ：已提交（committed）、已修改（modified）和已暂存（staged) 三个工作区域：Git 仓库、工作目录以及暂存区域。 1.4 命令行1.5 安装 Git官网windows官网下载github客户端windows github 1.6 初次运行 Git 前的配置检查配置。可以使用 git config –list 命令来列出所有 Git 当时能找到的配置。由于存在全局、用户、项目多个地方配置。Git 会使用它找到的每一个变量的最后一个配置。 Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。全局、用户、项目三级。项目的配置权利最大。 一般配置用户的配置。 一定要配置，所有操作都会被记录。12$ git config --global user.name &quot;John Doe&quot;$ git config --global user.email johndoe@example.com 选择文本编辑器，当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器，通常是 Vim。 如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：12$ git config --global core.editor emacs全部输出 12345678910$ git config --list user.name=John Doe user.email=johndoe@example.com color.status=auto color.branch=auto color.interactive=auto color.diff=auto单独检查 git config &lt;key&gt;$ git config user.name John Doe 1.7 获取帮助获取帮助。如果你觉得手册或者本书的内容还不够用，你可以尝试在 Freenode IRC 服务器（ irc.freenode.net ）的 #git 或 #github 频道寻求帮助。这些频道经常有上百人在线，他们都精通 Git 并且乐于助人。123$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt; 1.8 总结git下载与配置12git configgit help 2. Git 基础 阐述 Git 的基本使用——包含你在使用 Git 时可能遇到的 80% 的情形。能够克隆仓库、查看项目历史、修改文件和贡献更改。 2.1 获取 Git 仓库git本地初始化进入项目目录并输入：1$ git init 该命令将创建一个名为 .git 的子目录，仅仅初始化，项目里的文件还没被跟踪。 2.2 记录每次更新到仓库 通过 git add 命令来实现对指定文件的跟踪，然后执行 git commit 提交：123$ git add *.c$ git add LICENSE$ git commit -m &apos;initial project version&apos; git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的 所有文件 。 克隆现有的库。克隆仓库的命令格式是 git clone [url] 。 比如，1$ git clone https://github.com/libgit2/libgit2 这会在当前目录下创建名为 “libgit2” 的目录。 自定义本地仓库名字 ，可以使用如下命令：1$ git clone https://github.com/libgit2/libgit2 mylibgit 例子使用的是 https:// 协议，不过也可使用 git:// 协议或者 SSH 传输协议，如 user@server:path/to/repo.git 。 Git 时文件的生命周期 2.3 查看提交历史 检查当前文件状态1git status 在使用命令 git add 开始跟踪一个文件后。在 Changes to be committed 这行下面的，就说明是已暂存状态。 状态简览123456$ git status -s M README MM Rakefile A lib/git.rb M lib/simplegit.rb ?? LICENSE.txt 新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。M 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。 2.4 撤消操作2.5 远程仓库的使用2.7 Git 别名2.8 总结配置并初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit)更改。 配置 Git 来忽略指定的文件和文件模式、迅速而简单地撤销错误操作、浏览项目的历史版本以及不同提交（commits）间的差异、向远程仓库推送（push）以及从远程仓库拉取（pull）文件。1234$ git init$ git add *.c$ git commit -m &apos;initial project version&apos;$ git clone &lt;remote dir&gt; &lt;本地文件夹名&gt; 3. Git 分支3.1 分支简介3.2 分支的新建与合并3.3 分支管理3.4 分支开发工作流3.5 远程分支3.6 变基3.7 总结4. 服务器上的 Git4.1 协议4.2 在服务器上搭建 Git4.3 生成 SSH 公钥4.4 配置服务器4.5 Git 守护进程4.6 Smart HTTP4.7 GitWeb4.8 GitLab4.9 第三方托管的选择4.10 总结 5. 分布式 Git5.1 分布式工作流程5.2 向一个项目贡献5.3 维护项目5.4 总结 6. GitHub6.1 账户的创建和配置6.2 对项目做出贡献6.3 维护项目6.4 管理组织6.5 脚本 GitHub6.6 总结 7. Git 工具7.1 选择修订版本7.2 交互式暂存7.3 储藏与清理7.4 签署工作7.5 搜索7.6 重写历史7.7 重置揭密7.8 高级合并7.9 Rerere7.10 使用 Git 调试7.11 子模块7.12 打包7.13 替换7.14 凭证存储7.15 总结 8. 自定义 Git8.1 配置 Git8.2 Git 属性8.3 Git 钩子8.4 使用强制策略的一个例子8.5 总结 9. Git 与其他系统9.1 作为客户端的 Git9.2 迁移到 Git9.3 总结 10. Git 内部原理10.1 底层命令和高层命令10.2 Git 对象10.3 Git 引用10.4 包文件10.5 引用规格10.6 传输协议10.7 维护与数据恢复10.8 环境变量10.9 总结 附录A1. 其它环境中的 GitA1.1 图形界面A1.2 Visual Studio 中的 GitA1.3 Eclipse 中的 GitA1.4 Bash 中的 GitA1.5 Zsh 中的 GitA1.6 Powershell 中的 GitA1.7 总结A2. 将 Git 嵌入你的应用A2.1 命令行 Git 方式A2.2 Libgit2A2.3 JGitA3. Git 命令A3.1 设置与配置A3.2 获取与创建项目A3.3 快照基础A3.4 分支与合并A3.5 项目分享与更新A3.6 检查与比较A3.7 调试A3.8 补丁A3.9 邮件A3.10 外部系统A3.11 管理A3.12 底层命令 版权说明The entire Pro Git book, written by Scott Chacon and Ben Straub and published by Apress, is available here. All content is licensed under the Creative Commons Attribution Non Commercial Share Alike 3.0 license. Print versions of the book are available on Amazon.com.]]></content>
      <categories>
        <category>技术书籍阅读</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Progit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DSP滤波程序]]></title>
    <url>%2Fpublic%2F2015%2F06%2F14%2FDSP%2Fdsp_filter%2F</url>
    <content type="text"><![CDATA[通过matlab对数字信号进行滤波器的设计后，我们要将设计好的参数放到嵌入式系统中进行滤波。IIR滤波器FIR滤波器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;//z变换转成差分方程然后迭代//Talen @UESTC 2015.6.5//打印数组void print(float *x,int len);//取后第1-n个float* aminusone(float* a,int ar);//差分中间值float gtcet(float *t,float *x,int xr,int s,int d);//主要滤波函数float* gfilter(float *b,int br,float *a,int ar,float *x,int xr);void print(float *x,int len)&#123; for(int i=0;i&lt;len;i++) &#123;printf("%9.3f ",x[i]); if((i%7)==6) printf("\n");&#125; printf("\n");&#125;float* aminusone(float* a,int ar)&#123; float* am = (float *)malloc((ar-1) * sizeof(float)); for(int i=0;i&lt;ar-1;i++) am[i]=a[i+1]; return am;&#125;float gtcet(float *t,float *x,int xr,int s,int d) //x[]数据源 r数据源长度 s开始点(0开始) d数据长度 //t可以是a[] b[] 长度与d一样&#123; float sum=0; float* w = (float *)malloc(d * sizeof(float)); for(int i=0;i&lt;d;i++) &#123; int temp=s-i; if(temp&gt;=0&amp;&amp;temp&lt;xr) w[i]=x[temp]; else w[i]=0; //核心语句 sum=sum+w[i]*t[i]; &#125; return sum;&#125;float* gfilter(float *b,int br,float *a,int ar,float *x,int xr) //b a x br b的长度 ar a的长度 xr数据长度 //use本程序定义的gtcet()和aminusone() //输入数据，b，a，x得出滤波后的y&#123; float* y = (float *)malloc(xr* sizeof(float)); for(int ti=0;ti&lt;xr;ti++) y[ti]=0; for(int i=0;i&lt;xr;i++) &#123; //最核心语句，此处迭代 y[i]=gtcet(b,x,xr,i,br)-gtcet(aminusone(a,ar),y,xr,i-1,ar-1); &#125; return y;&#125;int main()&#123; //input 源数据 可修改 //////////////////////////////////////////////////////////////// float x[120]=&#123;-4, -2, 0, -4, -6, -4, -2, -4, -6, -6, -4, -4,\ -6, -6, -2, 6, 12, 8, 0, -16, -38, -60, -84,\ -90, -66, -32, -4, 2, -4, 8, 12, 12, 10, 6,\ 6, 6, 4, 0, 0, 0, 0, 0, -2, -4, 0, 0, 0, -2,\ -2, 0, 0, -2, -2, -2, -2, 0, -2, -4, -2, 0,\ -2, -4, -4, 2, 0, 0, -2, -4, -2, 0, 0, -2,\ -4, -2, 0, 0, -4, -4, -2, -2, -4, -6, -6,\ -4, -4, 8, -10, -8, -6, -6, -8, -12, -10,\ -8, -8, -10, -12, -10, -8, -8, -10, -10,\ -8, -6, -6, -8, -8, -4, -2, -4, -4, -4,\ 0, 0, -2, -4, -2, -2, 0, -4&#125;; //参数 float b[7]=&#123; 0.0007,0.0044,0.0111,0.0148,0.0111,0.0044,0.0007&#125;; float a[7]=&#123; 1.0000,-3.1836,4.6222,-3.7795,1.8136,-0.4800,0.0544&#125;; ////////////////////////////////////////////////////////////////// //不要修改 int xr=sizeof(x)/sizeof(float); int br=sizeof(b)/sizeof(float); int ar=sizeof(a)/sizeof(float); //output 滤波后数据 float *y; printf("参数b：\n");print(b,br); printf("参数a：\n");print(a,ar); printf("原数据：\n");print(x,xr); y=gfilter(b,br,a,ar,x,xr); printf("滤波后数据：\n");print(y,xr); getchar(); return 0;&#125;]]></content>
      <categories>
        <category>数字信号处理</category>
      </categories>
      <tags>
        <tag>DSP</tag>
        <tag>滤波程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows笔记本开共享wifi]]></title>
    <url>%2Fpublic%2F2015%2F04%2F14%2Fshare_win_wifi%2F</url>
    <content type="text"><![CDATA[网上有很多用笔记本设置无线热点的批处理，我中和了一下。复制下面代码到记事本，改后缀为bat就行了。[改一下你自己定义的ssid和key] 12345678910111213141516171819202122232425@echo offset mssid=GTC::网络名字set mkey=123456789::大于八位密码echo ***********************************************echo 打开承载网络 1echo 关闭承载网络 2echo 承载网络信息 3echo 设置网络信息 setecho 退出 eecho （网络名字、密码可在源文件中改）echo （请以管理员身份打开!!!）echo ***********************************************:startset /p var=请选择:if %var%==1 netsh wlan start hostednetwork &amp;&amp; echo 网络名字:%mssid% 密码:%mkey% &amp;&amp; GOTO startif %var%==2 netsh wlan stop hostednetwork &amp;&amp; GOTO startif %var%==3 netsh wlan show hostednetwork &amp;&amp; echo 网络名字:%mssid% 密码:%mkey% &amp;&amp; GOTO startif %var%==set netsh wlan set hostednetwork mode=allow ssid=%mssid% key=%mkey% &amp;&amp; echo 网络名字:%mssid% 密码:%mkey% &amp;&amp; GOTO startif %var%==e pause]]></content>
      <categories>
        <category>Windows脚本</category>
      </categories>
      <tags>
        <tag>共享wifi</tag>
        <tag>cmd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fpublic%2F2015%2F01%2F01%2FAbout%2F</url>
    <content type="text"><![CDATA[欢迎来到这里～ 不忘初心活波严谨感谢The Internet And The World. 联系方式 QQmail: tianchenggu@qq.com Gmail: talenapp@gmail.com]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>About</tag>
      </tags>
  </entry>
</search>