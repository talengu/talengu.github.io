<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>软件运行 on 一塘</title>
    <link>http://localhost:1313/tags/%E8%BD%AF%E4%BB%B6%E8%BF%90%E8%A1%8C/</link>
    <description>Recent content in 软件运行 on 一塘</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 15 Apr 2022 12:39:04 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E8%BD%AF%E4%BB%B6%E8%BF%90%E8%A1%8C/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>「转」window软件运行时间</title>
      <link>http://localhost:1313/post/soft_run_time/</link>
      <pubDate>Fri, 15 Apr 2022 12:39:04 +0000</pubDate>
      <guid>http://localhost:1313/post/soft_run_time/</guid>
      <description>&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;&#xA;&lt;p&gt;对关注性能的程序开发人员而言，一个好的计时部件既是益友，也是良师。计时器既可以作为程序组件帮助程序员精确的控制程序进程，又是一件有力的调试武器，在有经验的程序员手里可以尽快的确定程序的性能瓶颈，或者对不同的算法作出有说服力的性能比较。&lt;/p&gt;&#xA;&lt;!-- more --&gt;&#xA;&lt;p&gt;在Windows平台下，常用的计时器有两种，一种是&lt;code&gt;timeGetTime&lt;/code&gt;多媒体计时器，它可以提供毫秒级的计时。但这个精度对很多应用场合而言还是太粗糙了。另一种是&lt;code&gt;QueryPerformanceCount&lt;/code&gt;计数器，随系统的不同可以提供微秒级的计数。对于实时图形处理、多媒体数据流处理、或者实时系统构造的程序员，善用&lt;code&gt;QueryPerformanceCount/QueryPerformanceFrequency&lt;/code&gt;是一项基本功。&lt;/p&gt;&#xA;&lt;p&gt;本文要介绍的，是另一种直接利用&lt;code&gt;Pentium CPU&lt;/code&gt;内部时间戳进行计时的高精度计时手段。以下讨论主要得益于&lt;code&gt;《Windows图形编程》&lt;/code&gt;一书，第15页－17页，有兴趣的读者可以直接参考该书。关于RDTSC指令的详细讨论，可以参考Intel产品手册。本文仅仅作抛砖之用。&lt;/p&gt;&#xA;&lt;p&gt;在 &lt;code&gt;Intel Pentium&lt;/code&gt;以上级别的CPU中，有一个称为“时间戳（Time   Stamp）”的部件，它以64位无符号整型数的格式，记录了自CPU上电以来所经过的时钟周期数。由于目前的CPU主频都非常高，因此这个部件可以达到纳秒级的计时精度。这个精确性是上述两种方法所无法比拟的。&lt;/p&gt;&#xA;&lt;p&gt;在Pentium以上的CPU中，提供了一条机器指令RDTSC（Read Time   Stamp Counter）来读取这个时间戳的数字，并将其保存在EDX:EAX寄存器对中。由于&lt;code&gt;EDX:EAX&lt;/code&gt;寄存器对恰好是Win32平台下C++语言保存函数返回值的寄存器，所以我们可以把这条指令看成是一个普通的函数调用。像这样：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  inline   unsigned   __int64   GetCycleCount()   &#xA;  {   &#xA;    __asm   RDTSC   &#xA;  }   &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是不行，因为RDTSC不被C++的内嵌汇编器直接支持，所以我们要用_emit伪指令直接嵌入该指令的机器码形式&lt;code&gt;0X0F&lt;/code&gt;、&lt;code&gt;0X31&lt;/code&gt;，如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  inline   unsigned   __int64   GetCycleCount()   &#xA;  {   &#xA;    __asm   _emit   0x0F   &#xA;    __asm   _emit   0x31   &#xA;  }   &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以后在需要计数器的场合，可以像使用普通的Win32   API一样，调用两次GetCycleCount函数，比较两个返回值的差，像这样：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  unsigned   long   t;   &#xA;  t   =   (unsigned   long)GetCycleCount();   &#xA;  //Do   Something   time-intensive   ...   &#xA;  t   -=   (unsigned   long)GetCycleCount();   &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;《Windows图形编程》&lt;/code&gt;第15页编写了一个类，把这个计数器封装起来。有兴趣的读者可以去参考那个类的代码。作者为了更精确的定时，做了一点小小的改进，把执行&lt;code&gt;RDTSC&lt;/code&gt;指令的时间，通过连续两次调用&lt;code&gt;GetCycleCount&lt;/code&gt;函数计算出来并保存了起来，以后每次计时结束后，都从实际得到的计数中减掉这一小段时间，以得到更准确的计时数字。但我个人觉得这一点点改进意义不大。在我的机器上实测，这条指令大概花掉了几十到100多个周期，在&lt;code&gt;Celeron 800MHz&lt;/code&gt;的机器上，这不过是十分之一微秒的时间。对大多数应用来说，这点时间完全可以忽略不计；而对那些确实要精确到纳秒数量级的应用来说，这个补偿也过于粗糙了。&lt;/p&gt;&#xA;&lt;p&gt;这个方法的优点是：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;高精度。可以直接达到纳秒级的计时精度（在1GHz的CPU上每个时钟周期就是一纳秒），这是其他计时方法所难以企及的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;成本低。&lt;code&gt;timeGetTime&lt;/code&gt;函数需要链接多媒体库 &lt;code&gt;winmm.lib&lt;/code&gt;，&lt;code&gt;QueryPerformance*&lt;/code&gt;函数根据MSDN的说明，需要硬件的支持（虽然我还没有见过不支持的机器）和KERNEL库的支持，所以二者都只能在Windows平台下使用（关于DOS平台下的高精度计时问题，可以参考&lt;code&gt;《图形程序开发人员指南》&lt;/code&gt;，里面有关于控制定时器8253的详细说明）。但&lt;code&gt;RDTSC&lt;/code&gt;指令是一条CPU指令，凡是i386平台下Pentium以上的机器均支持，甚至没有平台的限制（我相信i386版本UNIX和Linux下这个方法同样适用，但没有条件试验），而且函数调用的开销是最小的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;具有和CPU主频直接对应的速率关系。一个计数相当于1/(CPU主频Hz数)秒，这样只要知道了CPU的主频，可以直接计算出时间。这和   &lt;code&gt;QueryPerformanceCount&lt;/code&gt;不同，后者需要通过&lt;code&gt;QueryPerformanceFrequency&lt;/code&gt;获取当前计数器每秒的计数次数才能换算成时间。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这个方法的缺点是：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;现有的C/C++编译器多数不直接支持使用RDTSC指令，需要用直接嵌入机器码的方式编程，比较麻烦。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据抖动比较厉害。其实对任何计量手段而言，精度和稳定性永远是一对矛盾。如果用低精度的&lt;code&gt;timeGetTime&lt;/code&gt;来计时，基本上每次计时的结果都是相同的；而&lt;code&gt;RDTSC&lt;/code&gt;指令每次结果都不一样，经常有几百甚至上千的差距。这是这种方法高精度本身固有的矛盾。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;关于这个方法计时的最大长度，我们可以简单的用下列公式计算：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;自CPU上电以来的秒数   =   RDTSC读出的周期数   /   CPU主频速率（Hz）   &#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;64位无符号整数所能表达的最大数字是&lt;code&gt;1.8×10^19&lt;/code&gt;，在我的&lt;code&gt;Celeron   800&lt;/code&gt;上可以计时大约700年（书中说可以在200MHz的Pentium上计时117年，这个数字不知道是怎么得出来的，与我的计算有出入）。无论如何，我们大可不必关心溢出的问题。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
