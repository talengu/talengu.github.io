<!doctype html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/public/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/public/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/public/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="软件运行,"><link rel="alternate" href="/public/atom.xml" title="一塘" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/public/images/favicon_blog.png?v=5.1.0"><meta name="description" content="¶背景 对关注性能的程序开发人员而言，一个好的计时部件既是益友，也是良师。计时器既可以作为程序组件帮助程序员精确的控制程序进程，又是一件有力的调试武器，在有经验的程序员手里可以尽快的确定程序的性能瓶颈，或者对不同的算法作出有说服力的性能比较。"><meta name="keywords" content="软件运行"><meta property="og:type" content="article"><meta property="og:title" content="「转」window软件运行时间"><meta property="og:url" content="https://talengu.github.io/2022/04/15/soft_run_time/index.html"><meta property="og:site_name" content="一塘"><meta property="og:description" content="¶背景 对关注性能的程序开发人员而言，一个好的计时部件既是益友，也是良师。计时器既可以作为程序组件帮助程序员精确的控制程序进程，又是一件有力的调试武器，在有经验的程序员手里可以尽快的确定程序的性能瓶颈，或者对不同的算法作出有说服力的性能比较。"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2022-04-27T12:39:04.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="「转」window软件运行时间"><meta name="twitter:description" content="¶背景 对关注性能的程序开发人员而言，一个好的计时部件既是益友，也是良师。计时器既可以作为程序组件帮助程序员精确的控制程序进程，又是一件有力的调试武器，在有经验的程序员手里可以尽快的确定程序的性能瓶颈，或者对不同的算法作出有说服力的性能比较。"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/public/",scheme:"Pisces",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!0},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://talengu.github.io/2022/04/15/soft_run_time/"><title> 「转」window软件运行时间 | 一塘</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="https://github.com/talengu" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/public/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">一塘</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/public/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-archives"><a href="/public/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 往期</a></li><li class="menu-item menu-item-categories"><a href="/public/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-tags"><a href="/public/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://talengu.github.io/public/2022/04/15/soft_run_time/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="一塘"><meta itemprop="description" content><meta itemprop="image" content="https://avatars1.githubusercontent.com/u/10290923?v=3&s=460"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一塘"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 「转」window软件运行时间</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-15T12:39:04+00:00">2022-04-15</time> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <time title="更新于" itemprop="dateModified" datetime="2022-04-27T12:39:04+00:00">2022-04-27</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/public/categories/编程/" itemprop="url" rel="index"><span itemprop="name">编程</span></a></span></span> <span class="post-meta-divider">|</span><span class="page-pv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span title="字数统计">1.9k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span title="阅读时长">7</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="背景"><a class="header-anchor" href="#背景">¶</a>背景</h2><p>对关注性能的程序开发人员而言，一个好的计时部件既是益友，也是良师。计时器既可以作为程序组件帮助程序员精确的控制程序进程，又是一件有力的调试武器，在有经验的程序员手里可以尽快的确定程序的性能瓶颈，或者对不同的算法作出有说服力的性能比较。</p><a id="more"></a><p>在Windows平台下，常用的计时器有两种，一种是<code>timeGetTime</code>多媒体计时器，它可以提供毫秒级的计时。但这个精度对很多应用场合而言还是太粗糙了。另一种是<code>QueryPerformanceCount</code>计数器，随系统的不同可以提供微秒级的计数。对于实时图形处理、多媒体数据流处理、或者实时系统构造的程序员，善用<code>QueryPerformanceCount/QueryPerformanceFrequency</code>是一项基本功。</p><p>本文要介绍的，是另一种直接利用<code>Pentium CPU</code>内部时间戳进行计时的高精度计时手段。以下讨论主要得益于<code>《Windows图形编程》</code>一书，第15页－17页，有兴趣的读者可以直接参考该书。关于RDTSC指令的详细讨论，可以参考Intel产品手册。本文仅仅作抛砖之用。</p><p>在 <code>Intel Pentium</code>以上级别的CPU中，有一个称为“时间戳（Time Stamp）”的部件，它以64位无符号整型数的格式，记录了自CPU上电以来所经过的时钟周期数。由于目前的CPU主频都非常高，因此这个部件可以达到纳秒级的计时精度。这个精确性是上述两种方法所无法比拟的。</p><p>在Pentium以上的CPU中，提供了一条机器指令RDTSC（Read Time Stamp Counter）来读取这个时间戳的数字，并将其保存在EDX:EAX寄存器对中。由于<code>EDX:EAX</code>寄存器对恰好是Win32平台下C++语言保存函数返回值的寄存器，所以我们可以把这条指令看成是一个普通的函数调用。像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline   unsigned   __int64   GetCycleCount()   </span><br><span class="line">&#123;   </span><br><span class="line">  __asm   RDTSC   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是不行，因为RDTSC不被C++的内嵌汇编器直接支持，所以我们要用_emit伪指令直接嵌入该指令的机器码形式<code>0X0F</code>、<code>0X31</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  inline   unsigned   __int64   GetCycleCount()   </span><br><span class="line">  &#123;   </span><br><span class="line">    __asm   _emit   0x0F   </span><br><span class="line">    __asm   _emit   0x31   </span><br><span class="line">  &#125;   </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">以后在需要计数器的场合，可以像使用普通的Win32   API一样，调用两次GetCycleCount函数，比较两个返回值的差，像这样：</span><br></pre></td></tr></table></figure><p>unsigned long t;<br> t = (unsigned long)GetCycleCount();<br> //Do Something time-intensive ...<br> t -= (unsigned long)GetCycleCount();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`《Windows图形编程》`第15页编写了一个类，把这个计数器封装起来。有兴趣的读者可以去参考那个类的代码。作者为了更精确的定时，做了一点小小的改进，把执行`RDTSC`指令的时间，通过连续两次调用`GetCycleCount`函数计算出来并保存了起来，以后每次计时结束后，都从实际得到的计数中减掉这一小段时间，以得到更准确的计时数字。但我个人觉得这一点点改进意义不大。在我的机器上实测，这条指令大概花掉了几十到100多个周期，在`Celeron 800MHz`的机器上，这不过是十分之一微秒的时间。对大多数应用来说，这点时间完全可以忽略不计；而对那些确实要精确到纳秒数量级的应用来说，这个补偿也过于粗糙了。   </span><br><span class="line">    </span><br><span class="line">  这个方法的优点是：   </span><br><span class="line">    </span><br><span class="line">  1. 高精度。可以直接达到纳秒级的计时精度（在1GHz的CPU上每个时钟周期就是一纳秒），这是其他计时方法所难以企及的。   </span><br><span class="line">    </span><br><span class="line">  2. 成本低。`timeGetTime`函数需要链接多媒体库 `winmm.lib`，`QueryPerformance*`函数根据MSDN的说明，需要硬件的支持（虽然我还没有见过不支持的机器）和KERNEL库的支持，所以二者都只能在Windows平台下使用（关于DOS平台下的高精度计时问题，可以参考`《图形程序开发人员指南》`，里面有关于控制定时器8253的详细说明）。但`RDTSC`指令是一条CPU指令，凡是i386平台下Pentium以上的机器均支持，甚至没有平台的限制（我相信i386版本UNIX和Linux下这个方法同样适用，但没有条件试验），而且函数调用的开销是最小的。   </span><br><span class="line">    </span><br><span class="line">  3. 具有和CPU主频直接对应的速率关系。一个计数相当于1/(CPU主频Hz数)秒，这样只要知道了CPU的主频，可以直接计算出时间。这和   `QueryPerformanceCount`不同，后者需要通过`QueryPerformanceFrequency`获取当前计数器每秒的计数次数才能换算成时间。   </span><br><span class="line">    </span><br><span class="line">  这个方法的缺点是：   </span><br><span class="line">    </span><br><span class="line">  1. 现有的C/C++编译器多数不直接支持使用RDTSC指令，需要用直接嵌入机器码的方式编程，比较麻烦。   </span><br><span class="line">    </span><br><span class="line">  2. 数据抖动比较厉害。其实对任何计量手段而言，精度和稳定性永远是一对矛盾。如果用低精度的`timeGetTime`来计时，基本上每次计时的结果都是相同的；而`RDTSC`指令每次结果都不一样，经常有几百甚至上千的差距。这是这种方法高精度本身固有的矛盾。   </span><br><span class="line">    </span><br><span class="line">  关于这个方法计时的最大长度，我们可以简单的用下列公式计算：</span><br></pre></td></tr></table></figure><p>自CPU上电以来的秒数 = RDTSC读出的周期数 / CPU主频速率（Hz）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">64位无符号整数所能表达的最大数字是`1.8×10^19`，在我的`Celeron   800`上可以计时大约700年（书中说可以在200MHz的Pentium上计时117年，这个数字不知道是怎么得出来的，与我的计算有出入）。无论如何，我们大可不必关心溢出的问题。   </span><br><span class="line">    </span><br><span class="line">下面是几个小例子，简要比较了三种计时方法的用法与精度   </span><br><span class="line"> ```c</span><br><span class="line">//Timer1.cpp   使用了RDTSC指令的Timer类//KTimer类的定义可以参见《Windows图形编程》P15   </span><br><span class="line">//编译行：CL Timer1.cpp   /link   USER32.lib   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">#include   &quot;KTimer.h&quot;   </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  unsigned   t;   </span><br><span class="line">  KTimer   timer;   </span><br><span class="line">  timer.Start();   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  t   =   timer.Stop();   </span><br><span class="line">  printf(&quot;Lasting   Time:   %d\n&quot;,t);   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">//Timer2.cpp   使用了timeGetTime函数   </span><br><span class="line">//需包含&lt;mmsys.h&gt;，但由于Windows头文件错综复杂的关系   </span><br><span class="line">//简单包含&lt;windows.h&gt;比较偷懒：）   </span><br><span class="line">//编译行：CL   timer2.cpp   /link   winmm.lib     </span><br><span class="line">#include   &lt;windows.h&gt;   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">  </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  DWORD   t1,   t2;   </span><br><span class="line">  t1   =   timeGetTime();   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  t2   =   timeGetTime();   </span><br><span class="line">  printf(&quot;Begin   Time:   %u\n&quot;,   t1);   </span><br><span class="line">  printf(&quot;End   Time:   %u\n&quot;,   t2);   </span><br><span class="line">  printf(&quot;Lasting   Time:   %u\n&quot;,(t2-t1));   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">//Timer3.cpp   使用了QueryPerformanceCounter函数   </span><br><span class="line">//编译行：CL   timer3.cpp   /link   KERNEl32.lib   </span><br><span class="line">#include   &lt;windows.h&gt;   </span><br><span class="line">#include   &lt;stdio.h&gt;   </span><br><span class="line">  </span><br><span class="line">main()   </span><br><span class="line">&#123;   </span><br><span class="line">  LARGE_INTEGER   t1,   t2,   tc;   </span><br><span class="line">  QueryPerformanceFrequency(&amp;tc);   </span><br><span class="line">  printf(&quot;Frequency:   %u\n&quot;,   tc.QuadPart);   </span><br><span class="line">  QueryPerformanceCounter(&amp;t1);   </span><br><span class="line">  Sleep(1000);   </span><br><span class="line">  QueryPerformanceCounter(&amp;t2);   </span><br><span class="line">  printf(&quot;Begin   Time:   %u\n&quot;,   t1.QuadPart);   </span><br><span class="line">  printf(&quot;End   Time:   %u\n&quot;,   t2.QuadPart);   </span><br><span class="line">  printf(&quot;Lasting   Time:   %u\n&quot;,(   t2.QuadPart-   t1.QuadPart));   </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line">////////////////////////////////////////////////   </span><br><span class="line">//以上三个示例程序都是测试1秒钟休眠所耗费的时间   </span><br><span class="line">//测试环境：Celeron   800MHz   /   256M   SDRAM       </span><br><span class="line">//         Windows   2000   Professional   SP2   </span><br><span class="line">//         Microsoft   Visual   C++   6.0   SP5   </span><br><span class="line">////////////////////////////////////////////////</span><br></pre></td></tr></table></figure><p>以下是Timer1的运行结果，使用的是高精度的<code>RDTSC</code>指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lasting   Time:   804586872</span><br></pre></td></tr></table></figure><p>以下是Timer2的运行结果，使用的是最粗糙的<code>timeGetTime API</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Begin   Time:   20254254   </span><br><span class="line">End   Time:   20255255   </span><br><span class="line">Lasting   Time:   1001</span><br></pre></td></tr></table></figure><p>以下是Timer3的运行结果，使用的是<code>QueryPerformanceCount API</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Frequency:   3579545   </span><br><span class="line">Begin   Time:   3804729124   </span><br><span class="line">End   Time:   3808298836   </span><br><span class="line">Lasting   Time:   3569712</span><br></pre></td></tr></table></figure><p>古人说，触类旁通。从一本介绍图形编程的书上得到一个如此有用的实时处理知识，我感到非常高兴。有美不敢自专，希望大家和我一样喜欢这个轻便有效的计时器。</p></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-tags"> <a href="/public/tags/软件运行/" rel="tag"># 软件运行</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/public/2022/04/14/anki_tips/" rel="next" title="知识记忆软件anki的使用"><i class="fa fa-chevron-left"></i> 知识记忆软件anki的使用</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/public/2022/04/16/rss_local_install/" rel="prev" title="本地安装rss">本地安装rss<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="gitalk-container"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://avatars1.githubusercontent.com/u/10290923?v=3&s=460" alt="一塘"><p class="site-author-name" itemprop="name">一塘</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/public/archives"><span class="site-state-item-count">83</span> <span class="site-state-item-name">博客</span></a></div><div class="site-state-item site-state-categories"> <a href="/public/categories/index.html"><span class="site-state-item-count">58</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/public/tags/index.html"><span class="site-state-item-count">128</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/public/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/talengu" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="/public/2015/01/01/About" target="_blank" title="About"><i class="fa fa-fw fa-globe"></i> About</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#背景"><span class="nav-text">¶背景</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2015 - <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">一塘</span></div><div class="timemark"> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("01/01/2015 17:38:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="powered-by"> 由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info"> 主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div><div class="busuanzi-count"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span><span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/public/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/public/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/public/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/public/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/public/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/public/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/public/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/public/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/public/js/src/affix.js?v=5.1.0"></script><script type="text/javascript" src="/public/js/src/schemes/pisces.js?v=5.1.0"></script><script type="text/javascript" src="/public/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/public/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/public/js/src/bootstrap.js?v=5.1.0"></script><link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.6.2/gitalk.min.css"><script src="//cdn.bootcss.com/gitalk/1.6.2/gitalk.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"315ada12fed7a0ffb6b7",clientSecret:"5f15e644005fabee93cc7f50d70c78c57dce0e86",repo:"talengu.github.io",owner:"talengu",admin:["talengu"],id:location.pathname,labels:["Gitalk"],perPage:15,pagerDirection:"last",createIssueManually:!0,distractionFreeMode:!1,proxy:"https://gitalk.talengu.workers.dev/?https://github.com/login/oauth/access_token"});gitalk.render("gitalk-container")</script><script type="text/javascript">var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/public/"+search_path;function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".popup").toggle()}var searchFunc=function(e,c,s){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(c),r=document.getElementById(s);a.addEventListener("input",function(){var u=0,d='<ul class="search-result-list">',f=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",1<this.value.trim().length&&t.forEach(function(e){var a=!1,r=e.title.trim().toLowerCase(),c=e.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),t=decodeURIComponent(e.url),s=-1,o=-1,n=-1;if(""!=r&&f.forEach(function(e,t){s=r.indexOf(e),o=c.indexOf(e),(0<=s||0<=o)&&(a=!0,0==t&&(n=o))}),a){u+=1,d+="<li><a href='"+t+"' class='search-result-title'>"+r+"</a>";var i=e.content.trim().replace(/<[^>]+>/g,"");if(0<=n){var l=n-20,p=n+80;l<0&&(l=0),0==l&&(p=50),p>i.length&&(p=i.length);var h=i.substring(l,p);f.forEach(function(e){var t=new RegExp(e,"gi");h=h.replace(t,'<b class="search-keyword">'+e+"</b>")}),d+='<p class="search-result">'+h+"...</p>"}d+="</li>"}}),d+="</ul>",0==u&&(d='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==f&&(d='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),r.innerHTML=d}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script type="text/javascript" src="/public/js/src/clipboard.min.js"></script><script type="text/javascript" src="/public/js/src/clipboard-use.js"></script></body></html>