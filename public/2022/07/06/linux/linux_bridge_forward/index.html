<!doctype html><html class="theme-next pisces use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/public/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/public/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/public/css/main.css?v=5.1.0" rel="stylesheet" type="text/css"><meta name="keywords" content="bridge,netfilter,"><link rel="alternate" href="/public/atom.xml" title="一塘" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/public/images/favicon_blog.png?v=5.1.0"><meta name="description" content="原文地址 blog.csdn.net @hhhhhyyyyy8 @4.15.1  ¶前言 linux 内核源代码变动怎么这么大，handle_bridge 函数居然没有了，本来接着准备以 3.9.1 分析的，但发现和后面的又变了，还是以 4.15.1 现在电脑上用的版本分析吧。 linux kernel：4.15.1 best of best [link](https://upload.wiki"><meta name="keywords" content="bridge,netfilter"><meta property="og:type" content="article"><meta property="og:title" content="「转」Linux内核数据包bridge上转发流程"><meta property="og:url" content="https://talengu.github.io/2022/07/06/linux/linux_bridge_forward/index.html"><meta property="og:site_name" content="一塘"><meta property="og:description" content="原文地址 blog.csdn.net @hhhhhyyyyy8 @4.15.1  ¶前言 linux 内核源代码变动怎么这么大，handle_bridge 函数居然没有了，本来接着准备以 3.9.1 分析的，但发现和后面的又变了，还是以 4.15.1 现在电脑上用的版本分析吧。 linux kernel：4.15.1 best of best [link](https://upload.wiki"><meta property="og:locale" content="zh-Hans"><meta property="og:image" content="https://talengu.github.io/public/2022/07/06/linux/linux_bridge_forward/Netfilter-packet-flow5.svg"><meta property="og:image" content="https://talengu.github.io/public/2022/07/06/linux/linux_bridge_forward/20191005153149853.jpg"><meta property="og:image" content="https://talengu.github.io/public/2022/07/06/linux/linux_bridge_forward/t_70.png"><meta property="og:image" content="https://talengu.github.io/public/2022/07/06/linux/linux_bridge_forward/netfilter.png"><meta property="og:updated_time" content="2022-07-06T16:00:04.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="「转」Linux内核数据包bridge上转发流程"><meta name="twitter:description" content="原文地址 blog.csdn.net @hhhhhyyyyy8 @4.15.1  ¶前言 linux 内核源代码变动怎么这么大，handle_bridge 函数居然没有了，本来接着准备以 3.9.1 分析的，但发现和后面的又变了，还是以 4.15.1 现在电脑上用的版本分析吧。 linux kernel：4.15.1 best of best [link](https://upload.wiki"><meta name="twitter:image" content="https://talengu.github.io/public/2022/07/06/linux/linux_bridge_forward/Netfilter-packet-flow5.svg"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/public/",scheme:"Pisces",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!0},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://talengu.github.io/2022/07/06/linux/linux_bridge_forward/"><title> 「转」Linux内核数据包bridge上转发流程 | 一塘</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div> <a href="https://github.com/talengu" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/public/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">一塘</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/public/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-archives"><a href="/public/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 往期</a></li><li class="menu-item menu-item-categories"><a href="/public/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-tags"><a href="/public/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocapitalize="off" autocomplete="off" autocorrect="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://talengu.github.io/public/2022/07/06/linux/linux_bridge_forward/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="一塘"><meta itemprop="description" content><meta itemprop="image" content="https://avatars1.githubusercontent.com/u/10290923?v=3&s=460"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一塘"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"> 「转」Linux内核数据包bridge上转发流程</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-07-06T16:00:04+00:00">2022-07-06</time> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <time title="更新于" itemprop="dateModified" datetime="2022-07-06T16:00:04+00:00">2022-07-06</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/public/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a></span></span> <span class="post-meta-divider">|</span><span class="page-pv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i></span> <span title="字数统计">3.5k</span> <span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i></span> <span title="阅读时长">17</span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>原文地址 <a href="https://blog.csdn.net/hhhhhyyyyy8/article/details/102133863" target="_blank" rel="noopener">blog.csdn.net</a> @hhhhhyyyyy8 @4.15.1</p></blockquote><h2 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h2><p>linux 内核源代码变动怎么这么大，handle_bridge 函数居然没有了，本来接着准备以 3.9.1 分析的，但发现和后面的又变了，还是以 4.15.1 现在电脑上用的版本分析吧。</p><p><strong>linux kernel：4.15.1</strong></p><p>best of best [<a href="url">link</a>](<a href="https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg" target="_blank" rel="noopener">https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg</a>)</p><p><img src="/public/2022/07/06/linux/linux_bridge_forward/Netfilter-packet-flow5.svg" alt></p><p>先看三张图片</p><p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76153027" target="_blank" rel="noopener">IMG skb桥转发蓝图</a> <img src="/public/2022/07/06/linux/linux_bridge_forward/20191005153149853.jpg" alt></p><p><a href="https://blog.csdn.net/u012247418/article/details/90137663" target="_blank" rel="noopener">IMG linux TCP/IP L2层数据包接收流程</a> <img src="/public/2022/07/06/linux/linux_bridge_forward/t_70.png" alt></p><p><a href="https://www.cnblogs.com/xuanxuanBOSS/p/11424290.html" target="_blank" rel="noopener">IMG 浅析ebtables的概念和一些基本应用</a> <img src="/public/2022/07/06/linux/linux_bridge_forward/netfilter.png" alt></p><blockquote><p>tips: linux 内核版本不一样，流程函数会发生细微改变。</p></blockquote><a id="more"></a><h2 id="1-br-handle-frame"><a class="header-anchor" href="#1-br-handle-frame">¶</a>1. br_handle_frame()</h2><p>作用：</p><ol><li><p>对于需要转发的报文，调用 <code>NF_BR_PRE_ROUTING</code> 处钩子函数，结束后，进入 <code>br_handle_frame_finish()</code> 函数；</p></li><li><p>对于 STP 报文，调用 <code>NF_BR_LOCAL_IN</code> 处钩子函数，结束后，进入 <code>br_handle_local_finish()</code> 函数，在 <code>br_handle_local_finish()</code> 函数中会调用 <code>br_pass_frame_up()</code> 函数。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Return NULL if skb is handled</span></span><br><span class="line"><span class="comment"> * note: already called with rcu_read_lock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">rx_handler_result_t</span> <span class="title">br_handle_frame</span><span class="params">(struct sk_buff **pskb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span> = *<span class="title">pskb</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line">	<span class="keyword">br_should_route_hook_t</span> *rhook;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*如果是环回地址，直接返回RX_HANDLER_PASS*/</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(skb-&gt;pkt_type == PACKET_LOOPBACK))</span><br><span class="line">		<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*判断源MAC地址是否是有效的地址，不是直接丢弃，源MAC地址不能是多播地址和全0地址*/</span></span><br><span class="line">	<span class="keyword">if</span> (!is_valid_ether_addr(eth_hdr(skb)-&gt;h_source))</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	<span class="comment">/*判断是否是共享数据包，若是则clone该数据包；若clone时分配内存出错，返回NULL*/</span></span><br><span class="line">	skb = skb_share_check(skb, GFP_ATOMIC);</span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*获取dev对应的网桥端口*/</span></span><br><span class="line">	p = br_port_get_rcu(skb-&gt;dev);</span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; BR_VLAN_TUNNEL) &#123;</span><br><span class="line">		<span class="keyword">if</span> (br_handle_ingress_vlan_tunnel(skb, p,</span><br><span class="line">						  nbp_vlan_group_rcu(p)))</span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*特殊MAC地址处理*/</span></span><br><span class="line">	<span class="comment">//如果目的mac地址是本地链路地址link local reserved addr (01:80:c2:00:00:0X) STP报文</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(is_link_local_ether_addr(dest))) &#123;</span><br><span class="line">		u16 fwd_mask = p-&gt;br-&gt;group_fwd_mask_required;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * See IEEE 802.1D Table 7-10 Reserved addresses</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Assignment		 		Value</span></span><br><span class="line"><span class="comment">		 * Bridge Group Address		01-80-C2-00-00-00</span></span><br><span class="line"><span class="comment">		 * (MAC Control) 802.3		01-80-C2-00-00-01</span></span><br><span class="line"><span class="comment">		 * (Link Aggregation) 802.3	01-80-C2-00-00-02</span></span><br><span class="line"><span class="comment">		 * 802.1X PAE address		01-80-C2-00-00-03</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * 802.1AB LLDP 		01-80-C2-00-00-0E</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Others reserved for future standardization</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		fwd_mask |= p-&gt;group_fwd_mask;</span><br><span class="line">		<span class="keyword">switch</span> (dest[<span class="number">5</span>]) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x00</span>:	<span class="comment">/* Bridge Group Address */</span></span><br><span class="line">			<span class="comment">/* If STP is turned off,</span></span><br><span class="line"><span class="comment">			   then must forward to keep loop detection */</span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;br-&gt;stp_enabled == BR_NO_STP ||</span><br><span class="line">			    fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line">				<span class="keyword">goto</span> forward;</span><br><span class="line">			*pskb = skb;</span><br><span class="line">			__br_handle_local_finish(skb);</span><br><span class="line">			<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x01</span>:	<span class="comment">/* IEEE MAC (Pause) */</span></span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">case</span> <span class="number">0x0E</span>:	<span class="comment">/* 802.1AB LLDP */</span></span><br><span class="line">			fwd_mask |= p-&gt;br-&gt;group_fwd_mask;</span><br><span class="line">			<span class="keyword">if</span> (fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line">				<span class="keyword">goto</span> forward;</span><br><span class="line">			*pskb = skb;</span><br><span class="line">			__br_handle_local_finish(skb);</span><br><span class="line">			<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">/* Allow selective forwarding for most other protocols */</span></span><br><span class="line">			fwd_mask |= p-&gt;br-&gt;group_fwd_mask;</span><br><span class="line">			<span class="keyword">if</span> (fwd_mask &amp; (<span class="number">1u</span> &lt;&lt; dest[<span class="number">5</span>]))</span><br><span class="line">				<span class="keyword">goto</span> forward;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/* Deliver packet to local host only */</span></span><br><span class="line">		<span class="comment">/*调用NF_BR_LOCAL_IN处钩子函数，结束后，进入br_handle_local_finish函数*/</span></span><br><span class="line">		NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, dev_net(skb-&gt;dev),</span><br><span class="line">			<span class="literal">NULL</span>, skb, skb-&gt;dev, <span class="literal">NULL</span>, br_handle_local_finish);</span><br><span class="line">		<span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">forward:</span><br><span class="line">	<span class="keyword">switch</span> (p-&gt;state) &#123;</span><br><span class="line">	<span class="comment">//网桥端口处于转发状态</span></span><br><span class="line">	<span class="keyword">case</span> BR_STATE_FORWARDING:</span><br><span class="line">		rhook = rcu_dereference(br_should_route_hook);</span><br><span class="line">		<span class="keyword">if</span> (rhook) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((*rhook)(skb)) &#123;</span><br><span class="line">				*pskb = skb;</span><br><span class="line">				<span class="keyword">return</span> RX_HANDLER_PASS;</span><br><span class="line">			&#125;</span><br><span class="line">			dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* fall through */</span></span><br><span class="line">	<span class="comment">/*网桥端口处于学习状态，处于转发状态也会执行下面的代码，因为上面的case没有break。*/</span></span><br><span class="line">	<span class="keyword">case</span> BR_STATE_LEARNING:</span><br><span class="line">	<span class="comment">/*数据包目的MAC为网桥的Mac，发往本地的数据包*/</span></span><br><span class="line">		<span class="keyword">if</span> (ether_addr_equal(p-&gt;br-&gt;dev-&gt;dev_addr, dest))</span><br><span class="line">			skb-&gt;pkt_type = PACKET_HOST;</span><br><span class="line">		<span class="comment">/*调用NF_BR_PRE_ROUTING处钩子函数，结束后进入br_handle_frame_finish函数*/</span></span><br><span class="line">		NF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,</span><br><span class="line">			dev_net(skb-&gt;dev), <span class="literal">NULL</span>, skb, skb-&gt;dev, <span class="literal">NULL</span>,</span><br><span class="line">			br_handle_frame_finish);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">drop:</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> RX_HANDLER_CONSUMED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关函数</p><h3 id="rx-handler-result-t-枚举类型"><a class="header-anchor" href="#rx-handler-result-t-枚举类型">¶</a><code>rx_handler_result_t</code> 枚举类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> rx_handler_result &#123;</span><br><span class="line">	RX_HANDLER_CONSUMED,</span><br><span class="line">	RX_HANDLER_ANOTHER,</span><br><span class="line">	RX_HANDLER_EXACT,</span><br><span class="line">	RX_HANDLER_PASS,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> rx_handler_result <span class="keyword">rx_handler_result_t</span>;</span><br></pre></td></tr></table></figure><h3 id="is-valid-ether-addr"><a class="header-anchor" href="#is-valid-ether-addr">¶</a><code>is_valid_ether_addr()</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * is_valid_ether_addr - Determine if the given Ethernet address is valid</span></span><br><span class="line"><span class="comment"> * @addr: Pointer to a six-byte array containing the Ethernet address</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Check that the Ethernet address (MAC) is not 00:00:00:00:00:00, is not</span></span><br><span class="line"><span class="comment"> * a multicast address, and is not FF:FF:FF:FF:FF:FF.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return true if the address is valid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Please note: addr must be aligned to u16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_valid_ether_addr</span><span class="params">(<span class="keyword">const</span> u8 *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* FF:FF:FF:FF:FF:FF is a multicast address so we don't need to</span></span><br><span class="line"><span class="comment">	 * explicitly check for it here. */</span></span><br><span class="line">	<span class="keyword">return</span> !is_multicast_ether_addr(addr) &amp;&amp; !is_zero_ether_addr(addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="br-handle-local-finish"><a class="header-anchor" href="#br-handle-local-finish">¶</a><code>br_handle_local_finish()</code></h3><p><code>br_handle_local_finish()</code> 函数中调用 <code>br_pass_fame_up()</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/* note: already called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">br_handle_local_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span> = <span class="title">br_port_get_rcu</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line"> </span><br><span class="line">	__br_handle_local_finish(skb);</span><br><span class="line"> </span><br><span class="line">	BR_INPUT_SKB_CB(skb)-&gt;brdev = p-&gt;br-&gt;dev;</span><br><span class="line">	br_pass_frame_up(skb);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-br-handle-frame-finish"><a class="header-anchor" href="#2-br-handle-frame-finish">¶</a>2. br_handle_frame_finish()</h2><p>作用：</p><p>网桥设备是否处于混杂模式，如果是，则会发一份到本地进行处理</p><p>如果是广播包，则会进行广播洪泛，并会发一份到本地处理</p><p>如果是组播包，则根据组播表进行组播转发，并发一份数数包到本地处理</p><p>如果是单播包，发往本地的单播包则送到本地处理，在 fdb 表中可以找到转发表项的单播包则进行转发，未知单播包在广播域内进行洪泛</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="comment">/* note: already called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_handle_frame_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span> = <span class="title">br_port_get_rcu</span>(<span class="title">skb</span>-&gt;<span class="title">dev</span>);</span></span><br><span class="line">	<span class="keyword">enum</span> br_pkt_type pkt_type = BR_PKT_UNICAST;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_fdb_entry</span> *<span class="title">dst</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_mdb_entry</span> *<span class="title">mdst</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> local_rcv, mcast_hit = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *dest;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span>;</span></span><br><span class="line">	u16 vid = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*如果网桥端口不存在或者网桥端口状态为BR_STATE_DISABLED，则丢弃*/</span></span><br><span class="line">	<span class="keyword">if</span> (!p || p-&gt;state == BR_STATE_DISABLED)</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	<span class="comment">/*判断是否允许进入桥内，如果没有开启VLAN则所有数据包都可以进入，</span></span><br><span class="line"><span class="comment">	如果开启了VLAN,则根据VLAN相应的规则，从桥上进行数据包转发。*/</span></span><br><span class="line">	<span class="keyword">if</span> (!br_allowed_ingress(p-&gt;br, nbp_vlan_group_rcu(p), skb, &amp;vid))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line">	nbp_switchdev_frame_mark(p, skb);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* insert into forwarding database after filtering to avoid spoofing */</span></span><br><span class="line">	br = p-&gt;br;</span><br><span class="line">	<span class="comment">/*如果网桥端口标志有BR_LEARNING,则更新fdb表。</span></span><br><span class="line"><span class="comment">    一般新建网桥端口p-&gt;flags=BR_LEARNING| BR_FLOOD | BR_MCAST_FLOOD | BR_BCAST_FLOOD*/</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;flags &amp; BR_LEARNING)</span><br><span class="line">		br_fdb_update(br, p, eth_hdr(skb)-&gt;h_source, vid, <span class="literal">false</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发往本地数据包标记，!!的作用是转换为bool值</span></span><br><span class="line">	local_rcv = !!(br-&gt;dev-&gt;flags &amp; IFF_PROMISC);</span><br><span class="line">	dest = eth_hdr(skb)-&gt;h_dest;</span><br><span class="line">	<span class="comment">/*目的地址为多播地址*/</span></span><br><span class="line">	<span class="keyword">if</span> (is_multicast_ether_addr(dest)) &#123;</span><br><span class="line">		<span class="comment">/* by definition the broadcast is also a multicast address */</span></span><br><span class="line">		<span class="comment">/*如果目的地址是广播地址，将数据包也发往本地一份*/</span></span><br><span class="line">		<span class="keyword">if</span> (is_broadcast_ether_addr(dest)) &#123;</span><br><span class="line">			pkt_type = BR_PKT_BROADCAST;</span><br><span class="line">			local_rcv = <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pkt_type = BR_PKT_MULTICAST;</span><br><span class="line">			<span class="comment">//igmp snooping留给网桥子系统的外部接口函数，</span></span><br><span class="line">			<span class="comment">//当网桥接收了igmp数据包后就会调用该函数进行后续处理</span></span><br><span class="line">			<span class="keyword">if</span> (br_multicast_rcv(br, p, skb, vid))</span><br><span class="line">				<span class="keyword">goto</span> drop;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果网桥端口状态此时还是BR_STATE_LEARNING,则丢弃。</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;state == BR_STATE_LEARNING)</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line">	<span class="comment">//将网桥所属的net_device放入skb的私有数据中（struct br_input_skb_cb）</span></span><br><span class="line">	BR_INPUT_SKB_CB(skb)-&gt;brdev = br-&gt;dev;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_INET) &amp;&amp;</span><br><span class="line">	    (skb-&gt;protocol == htons(ETH_P_ARP) ||</span><br><span class="line">	     skb-&gt;protocol == htons(ETH_P_RARP))) &#123;</span><br><span class="line">		br_do_proxy_suppress_arp(skb, br, vid, p);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ENABLED(CONFIG_IPV6) &amp;&amp;</span><br><span class="line">		   skb-&gt;protocol == htons(ETH_P_IPV6) &amp;&amp;</span><br><span class="line">		   br-&gt;neigh_suppress_enabled &amp;&amp;</span><br><span class="line">		   pskb_may_pull(skb, <span class="keyword">sizeof</span>(struct ipv6hdr) +</span><br><span class="line">				 <span class="keyword">sizeof</span>(struct nd_msg)) &amp;&amp;</span><br><span class="line">		   ipv6_hdr(skb)-&gt;nexthdr == IPPROTO_ICMPV6) &#123;</span><br><span class="line">			struct nd_msg *msg, _msg;</span><br><span class="line"> </span><br><span class="line">			msg = br_is_nd_neigh_msg(skb, &amp;_msg);</span><br><span class="line">			<span class="keyword">if</span> (msg)</span><br><span class="line">				br_do_suppress_nd(skb, br, vid, p, msg);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">switch</span> (pkt_type) &#123;</span><br><span class="line">	<span class="comment">//组播包</span></span><br><span class="line">	<span class="keyword">case</span> BR_PKT_MULTICAST:</span><br><span class="line">		<span class="comment">//获取组播转发项，设置local_rcv为true，组播包也要发往本地一份。</span></span><br><span class="line">		mdst = br_mdb_get(br, skb, vid);</span><br><span class="line">		<span class="keyword">if</span> ((mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) &amp;&amp;</span><br><span class="line">		    br_multicast_querier_exists(br, eth_hdr(skb))) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((mdst &amp;&amp; mdst-&gt;host_joined) ||</span><br><span class="line">			    br_multicast_is_router(br)) &#123;</span><br><span class="line">				local_rcv = <span class="literal">true</span>;</span><br><span class="line">				br-&gt;dev-&gt;stats.multicast++;</span><br><span class="line">			&#125;</span><br><span class="line">			mcast_hit = <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			local_rcv = <span class="literal">true</span>;</span><br><span class="line">			br-&gt;dev-&gt;stats.multicast++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">//单播包</span></span><br><span class="line">	<span class="keyword">case</span> BR_PKT_UNICAST:</span><br><span class="line">		<span class="comment">//根据目的MAC地址查找fdb表，看是否有对应的表项</span></span><br><span class="line">		dst = br_fdb_find_rcu(br, dest, vid);</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果找到目的MAC对应的表项</span></span><br><span class="line">	<span class="keyword">if</span> (dst) &#123;</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> now = jiffies;</span><br><span class="line">		<span class="comment">//送入上层处理</span></span><br><span class="line">		<span class="keyword">if</span> (dst-&gt;is_local)</span><br><span class="line">			<span class="keyword">return</span> br_pass_frame_up(skb);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (now != dst-&gt;used)</span><br><span class="line">			dst-&gt;used = now;</span><br><span class="line">		<span class="comment">//根据fdb转发表项进行转发，若这里local_rcv 为1,（即端口处于混杂模式IFF_PROMISC），则会克隆一份再转发</span></span><br><span class="line">		<span class="comment">//传入的第一个参数dst-&gt;dst 即为要转发的目的端口</span></span><br><span class="line">		br_forward(dst-&gt;dst, skb, local_rcv, <span class="literal">false</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//进行广播或者组播洪泛</span></span><br><span class="line">		<span class="keyword">if</span> (!mcast_hit)</span><br><span class="line">			br_flood(br, skb, pkt_type, local_rcv, <span class="literal">false</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			br_multicast_flood(mdst, skb, local_rcv, <span class="literal">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//local_rcv标记为1，送入上层处理。</span></span><br><span class="line">	<span class="keyword">if</span> (local_rcv)</span><br><span class="line">		<span class="keyword">return</span> br_pass_frame_up(skb);</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">drop:</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-br-pass-frame-up"><a class="header-anchor" href="#3-br-pass-frame-up">¶</a>3.br_pass_frame_up</h2><p>数据包的目的 MAC 是本地的单播报文，广播，组播和网桥处于混杂模式时，报文都会通过 br_pass_frame_up 函数交由上层处理。</p><p>作用：</p><p>调用 NF_BR_LOCAL_IN 处钩子函数，最后调用 br_netif_receive_skb 函数，绕一圈后，交友上层处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">br_pass_frame_up</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">indev</span>, *<span class="title">brdev</span> = <span class="title">BR_INPUT_SKB_CB</span>(<span class="title">skb</span>)-&gt;<span class="title">brdev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span> = <span class="title">netdev_priv</span>(<span class="title">brdev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_vlan_group</span> *<span class="title">vg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pcpu_sw_netstats</span> *<span class="title">brstats</span> = <span class="title">this_cpu_ptr</span>(<span class="title">br</span>-&gt;<span class="title">stats</span>);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//统计网桥设备上的收包流量数据</span></span><br><span class="line">	u64_stats_update_begin(&amp;brstats-&gt;syncp);</span><br><span class="line">	brstats-&gt;rx_packets++;</span><br><span class="line">	brstats-&gt;rx_bytes += skb-&gt;len;</span><br><span class="line">	u64_stats_update_end(&amp;brstats-&gt;syncp);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取网桥设备上的VLAN组</span></span><br><span class="line">	vg = br_vlan_group_rcu(br);</span><br><span class="line">	<span class="comment">/* Bridge is just like any other port.  Make sure the</span></span><br><span class="line"><span class="comment">	 * packet is allowed except in promisc modue when someone</span></span><br><span class="line"><span class="comment">	 * may be running packet capture.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!(brdev-&gt;flags &amp; IFF_PROMISC) &amp;&amp;</span><br><span class="line">	    !br_allowed_egress(vg, skb)) &#123;</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">		<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//记录数据包的收包网络设备</span></span><br><span class="line">	indev = skb-&gt;dev;</span><br><span class="line">	<span class="comment">//将数据包的收包设备改为网桥设备</span></span><br><span class="line">	<span class="comment">//当再次进入__netif_receive_skb_core时就不会再次进入桥处理了，因为网桥上没有注册rx_handler 函数</span></span><br><span class="line">	skb-&gt;dev = brdev;</span><br><span class="line">	<span class="comment">//配置数据包vlan相关信息</span></span><br><span class="line">	skb = br_handle_vlan(br, <span class="literal">NULL</span>, vg, skb);</span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">return</span> NET_RX_DROP;</span><br><span class="line">	<span class="comment">/* update the multicast stats if the packet is IGMP/MLD */</span></span><br><span class="line">	<span class="comment">//如果数据包是组播，更新组播数据包的统计信息</span></span><br><span class="line">	br_multicast_count(br, <span class="literal">NULL</span>, skb, br_multicast_igmp_type(skb),</span><br><span class="line">			   BR_MCAST_DIR_TX);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用NF_BR_LOCAL_IN处钩子函数，最后调用br_netif_receive_skb函数。</span></span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,</span><br><span class="line">		       dev_net(indev), <span class="literal">NULL</span>, skb, indev, <span class="literal">NULL</span>,</span><br><span class="line">		       br_netif_receive_skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次进入 netif_receive_skb，由于 skb-dev 被设置成了 bridge，而 bridge 设备的 rx_handler 函数是没有被设置的，所以就不会再次进入 bridge 逻辑，而直接进入了主机上层协议栈。</p><p>相关函数</p><h3 id="br-netif-receive-skb"><a class="header-anchor" href="#br-netif-receive-skb">¶</a><code>br_netif_receive_skb()</code></h3><p>可以看到在 br_netif_receive_skb() 函数中调用了 netif_receive_skb() 函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">static int</span><br><span class="line">br_netif_receive_skb(struct net *net, struct sock *sk, struct sk_buff *skb)</span><br><span class="line">&#123;</span><br><span class="line">	br_drop_fake_rtable(skb);</span><br><span class="line">	return netif_receive_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-br-forward"><a class="header-anchor" href="#4-br-forward">¶</a>4. br_forward()</h2><p>不是发往本地的数据包，但在 fdb 表中能找到对应的表项，则进行转发 br_forward()，若在 fdb 表中找不到对应表项就进行洪泛 br_blood().</p><p>作用：</p><p>主要是调用__br_forward() 转发报文</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * br_forward - forward a packet to a specific port</span></span><br><span class="line"><span class="comment"> * @to: destination port</span></span><br><span class="line"><span class="comment"> * @skb: packet being forwarded</span></span><br><span class="line"><span class="comment"> * @local_rcv: packet will be received locally after forwarding</span></span><br><span class="line"><span class="comment"> * @local_orig: packet is locally originated</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Should be called with rcu_read_lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_forward</span><span class="params">(<span class="keyword">const</span> struct net_bridge_port *to,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct sk_buff *skb, <span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//should_deliver测试是否应该将该包转发出去</span></span><br><span class="line">	<span class="keyword">if</span> (to &amp;&amp; should_deliver(to, skb)) &#123;</span><br><span class="line">		<span class="comment">//如果local_rcv为1，表明端口为混杂模式，先clone一份数据包再进行转发</span></span><br><span class="line">		<span class="keyword">if</span> (local_rcv)</span><br><span class="line">			deliver_clone(to, skb, local_orig);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			__br_forward(to, skb, local_orig);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (!local_rcv)</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-br-forward"><a class="header-anchor" href="#5-br-forward">¶</a>5. __br_forward()</h2><p>作用:</p><p>__br_forward() 函数根据数据包的来源（local_orig）分别进入不同的钩子点，如果数据包是从本地发出的，则进入 NF_BR_LOCAL_OUT，如果不是本地发出的，则进入 NF_BR_FORWARD 钩子，最后都进入 br_forward_finish() 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __br_forward(<span class="keyword">const</span> struct net_bridge_port *to,</span><br><span class="line">			 struct sk_buff *skb, <span class="keyword">bool</span> local_orig)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_vlan_group</span> *<span class="title">vg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">indev</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net</span> *<span class="title">net</span>;</span></span><br><span class="line">	<span class="keyword">int</span> br_hook;</span><br><span class="line">	<span class="comment">//获取vlan组，这个组中有许多的vlanid，br_handle_vlan函数就是要在这个组中查找自己的vid</span></span><br><span class="line">	vg = nbp_vlan_group_rcu(to);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//添加vlan的相关配置</span></span><br><span class="line">	skb = br_handle_vlan(to-&gt;br, to, vg, skb);</span><br><span class="line">	<span class="keyword">if</span> (!skb)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//记录数据包的原始收包网络设备</span></span><br><span class="line">	indev = skb-&gt;dev;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将skb的dev修改为出口网络设备</span></span><br><span class="line">	skb-&gt;dev = to-&gt;dev;</span><br><span class="line">	<span class="comment">/*如果local_orig标志位(判断是否从本地发出的数据包)为false，就进入NF_BR_FORWARD钩子</span></span><br><span class="line"><span class="comment">	若为true，就进入NF_BR_LOCAL_OUT钩子点*/</span></span><br><span class="line">	<span class="keyword">if</span> (!local_orig) &#123;</span><br><span class="line">		<span class="keyword">if</span> (skb_warn_if_lro(skb)) &#123;</span><br><span class="line">			kfree_skb(skb);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//不是本地发出的数据包，进入NF_BR_FORWARD</span></span><br><span class="line">		br_hook = NF_BR_FORWARD;</span><br><span class="line">		skb_forward_csum(skb);</span><br><span class="line">		net = dev_net(indev);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(netpoll_tx_running(to-&gt;br-&gt;dev))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!is_skb_forwardable(skb-&gt;dev, skb)) &#123;</span><br><span class="line">				kfree_skb(skb);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				skb_push(skb, ETH_HLEN);</span><br><span class="line">				br_netpoll_send_skb(to, skb);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//若是本地发出的数据包，进入NF_BR_LOCAL_OUT处理</span></span><br><span class="line">		br_hook = NF_BR_LOCAL_OUT;</span><br><span class="line">		net = dev_net(skb-&gt;dev);</span><br><span class="line">		indev = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//进入钩子点，最后执行br_forward_finish函数。</span></span><br><span class="line">	NF_HOOK(NFPROTO_BRIDGE, br_hook,</span><br><span class="line">		net, <span class="literal">NULL</span>, skb, indev, skb-&gt;dev,</span><br><span class="line">		br_forward_finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-br-forward-finish"><a class="header-anchor" href="#6-br-forward-finish">¶</a>6. br_forward_finish()</h2><p><code>br_forward_finish()</code> 函数比较简单，调用 <code>NF_BR_POST_ROUTING</code> 处的钩子函数，最后进入 <code>br_dev_queue_push_xmit</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_forward_finish</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> NF_HOOK(NFPROTO_BRIDGE, NF_BR_POST_ROUTING,</span><br><span class="line">		       net, sk, skb, <span class="literal">NULL</span>, skb-&gt;dev,</span><br><span class="line">		       br_dev_queue_push_xmit);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-br-dev-queue-push-xmit"><a class="header-anchor" href="#7-br-dev-queue-push-xmit">¶</a>7. br_dev_queue_push_xmit</h2><p>在 <code>br_dev_queue_push_xmit()</code> 中，会先 <code>skb_push(skb,ETH,HLEN);</code> 将 data 指向二层头部，然后调用 <code>dev_queue_xmit()</code> 发送报文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">br_dev_queue_push_xmit</span><span class="params">(struct net *net, struct sock *sk, struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!is_skb_forwardable(skb-&gt;dev, skb))</span><br><span class="line">		<span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//注意这句操作</span></span><br><span class="line">	skb_push(skb, ETH_HLEN);</span><br><span class="line">	br_drop_fake_rtable(skb);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (skb-&gt;ip_summed == CHECKSUM_PARTIAL &amp;&amp;</span><br><span class="line">	    (skb-&gt;protocol == htons(ETH_P_8021Q) ||</span><br><span class="line">	     skb-&gt;protocol == htons(ETH_P_8021AD))) &#123;</span><br><span class="line">		<span class="keyword">int</span> depth;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> (!__vlan_get_protocol(skb, skb-&gt;protocol, &amp;depth))</span><br><span class="line">			<span class="keyword">goto</span> drop;</span><br><span class="line"> </span><br><span class="line">		skb_set_network_header(skb, depth);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	dev_queue_xmit(skb);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">drop:</span><br><span class="line">	kfree_skb(skb);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-br-flood"><a class="header-anchor" href="#8-br-flood">¶</a>8. br_flood</h2><p><code>br_flood()</code> 也是调用 <code>__br_forward()</code> 函数转发报文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/* called under rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_flood</span><span class="params">(struct net_bridge *br, struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">	      <span class="keyword">enum</span> br_pkt_type pkt_type, <span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 igmp_type = br_multicast_igmp_type(skb);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">p</span>;</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">/*遍历网桥设备的port_list，取出所有的网桥端口*/</span></span><br><span class="line">	list_for_each_entry_rcu(p, &amp;br-&gt;port_list, <span class="built_in">list</span>) </span><br><span class="line">        &#123;</span><br><span class="line">		<span class="comment">/* Do not flood unicast traffic to ports that turn it off, nor</span></span><br><span class="line"><span class="comment">		 * other traffic if flood off, except for traffic we originate</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">switch</span> (pkt_type) </span><br><span class="line">                &#123;</span><br><span class="line">		<span class="keyword">case</span> BR_PKT_UNICAST:</span><br><span class="line">			<span class="keyword">if</span> (!(p-&gt;flags &amp; BR_FLOOD))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> BR_PKT_MULTICAST:</span><br><span class="line">			<span class="keyword">if</span> (!(p-&gt;flags &amp; BR_MCAST_FLOOD) &amp;&amp; skb-&gt;dev != br-&gt;dev)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> BR_PKT_BROADCAST:</span><br><span class="line">			<span class="keyword">if</span> (!(p-&gt;flags &amp; BR_BCAST_FLOOD) &amp;&amp; skb-&gt;dev != br-&gt;dev)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/* Do not flood to ports that enable proxy ARP */</span></span><br><span class="line">                <span class="comment">/*代理arp*/</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;flags &amp; BR_PROXYARP)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> ((p-&gt;flags &amp; (BR_PROXYARP_WIFI | BR_NEIGH_SUPPRESS)) &amp;&amp;</span><br><span class="line">		    BR_INPUT_SKB_CB(skb)-&gt;proxyarp_replied)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">		prev = maybe_deliver(prev, p, skb, local_orig);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(prev))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		<span class="keyword">if</span> (prev == p)</span><br><span class="line">			br_multicast_count(p-&gt;br, p, skb, igmp_type,</span><br><span class="line">					   BR_MCAST_DIR_TX);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (!prev)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (local_rcv)</span><br><span class="line">		deliver_clone(prev, skb, local_orig);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__br_forward(prev, skb, local_orig);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (!local_rcv)</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-br-mulicast-flood"><a class="header-anchor" href="#9-br-mulicast-flood">¶</a>9. br_mulicast_flood()</h2><hr><p>以后再分析，肚子饿了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//linux/net/bridge/br_forward.c</span></span><br><span class="line"><span class="comment">/* called with rcu_read_lock */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">br_multicast_flood</span><span class="params">(struct net_bridge_mdb_entry *mdst,</span></span></span><br><span class="line"><span class="function"><span class="params">			struct sk_buff *skb,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">bool</span> local_rcv, <span class="keyword">bool</span> local_orig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> = <span class="title">BR_INPUT_SKB_CB</span>(<span class="title">skb</span>)-&gt;<span class="title">brdev</span>;</span></span><br><span class="line">	u8 igmp_type = br_multicast_igmp_type(skb);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge</span> *<span class="title">br</span> = <span class="title">netdev_priv</span>(<span class="title">dev</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">prev</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port_group</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> *<span class="title">rp</span>;</span></span><br><span class="line"> </span><br><span class="line">	rp = rcu_dereference(hlist_first_rcu(&amp;br-&gt;router_list));</span><br><span class="line">	p = mdst ? rcu_dereference(mdst-&gt;ports) : <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">while</span> (p || rp) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">net_bridge_port</span> *<span class="title">port</span>, *<span class="title">lport</span>, *<span class="title">rport</span>;</span></span><br><span class="line"> </span><br><span class="line">		lport = p ? p-&gt;port : <span class="literal">NULL</span>;</span><br><span class="line">		rport = rp ? hlist_entry(rp, struct net_bridge_port, rlist) :</span><br><span class="line">			     <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)lport &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)rport) &#123;</span><br><span class="line">			port = lport;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">if</span> (port-&gt;flags &amp; BR_MULTICAST_TO_UNICAST) &#123;</span><br><span class="line">				maybe_deliver_addr(lport, skb, p-&gt;eth_addr,</span><br><span class="line">						   local_orig);</span><br><span class="line">				<span class="keyword">goto</span> delivered;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			port = rport;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		prev = maybe_deliver(prev, port, skb, local_orig);</span><br><span class="line">delivered:</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(prev))</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		<span class="keyword">if</span> (prev == port)</span><br><span class="line">			br_multicast_count(port-&gt;br, port, skb, igmp_type,</span><br><span class="line">					   BR_MCAST_DIR_TX);</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)lport &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)port)</span><br><span class="line">			p = rcu_dereference(p-&gt;next);</span><br><span class="line">		<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)rport &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)port)</span><br><span class="line">			rp = rcu_dereference(hlist_next_rcu(rp));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (!prev)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (local_rcv)</span><br><span class="line">		deliver_clone(prev, skb, local_orig);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__br_forward(prev, skb, local_orig);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (!local_rcv)</span><br><span class="line">		kfree_skb(skb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a class="header-anchor" href="#参考">¶</a>参考</h2><p><a href="http://ebtables.netfilter.org/br_fw_ia/br_fw_ia.html" target="_blank" rel="noopener">ebtables/iptables interaction on a Linux-based bridge</a> @ebtables @2.4.x kernel</p><p><a href="https://blog.csdn.net/sxd2001/article/details/125031113" target="_blank" rel="noopener">Iptables DNAT实现broadcast与unicast之间相互映射</a> @sxd2001 分析ebtables 的redirect 和 iptables 的redirect</p><p><a href="https://blog.csdn.net/Sophisticated_/article/details/87923362" target="_blank" rel="noopener">Linux-4.20.8内核桥收包源码解析（七）--本地（br_pass_frame_up）or 转发（br_forward）</a> @lw_yang @Linux-4.20.8</p><p><a href="http://blog.chinaunix.net/uid-28541347-id-5750406.html" target="_blank" rel="noopener">Linux 3.10 kernel bridge转发逻辑</a> @lvyilong316 @Linux 3.10 kernel</p><p><a href="https://blog.csdn.net/linyt/article/details/5191512" target="_blank" rel="noopener">kernel 网桥代码分析</a> @海枫 @ 2.6.24.4</p><p><a href="https://blog.csdn.net/NW_NW_NW/article/details/76674232" target="_blank" rel="noopener">桥数据包处理函数——br_handle_frame_finish（七）</a> @不留你的名字</p><p><a href="https://www.cnblogs.com/super-king/p/bridge_implement.html" target="_blank" rel="noopener">Bridge实现</a> @SuperKing @linux 2.6.18</p><p><a href="https://www.cnblogs.com/ck1020/p/5894235.html" target="_blank" rel="noopener">LInux下桥接模式详解三</a> @jack.chen @linux 3.10.1</p><p><a href="https://blog.csdn.net/one_clouder/article/details/52877737" target="_blank" rel="noopener">协议栈报文接收之netif_receive_skb函数分析</a> @one_clouder @Linux4.1.12</p></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-tags"> <a href="/public/tags/bridge/" rel="tag"># bridge</a> <a href="/public/tags/netfilter/" rel="tag"># netfilter</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/public/2022/07/01/linux/how_tcpdump/" rel="next" title="「转」tcpdump是在哪儿抓到的包？"><i class="fa fa-chevron-left"></i> 「转」tcpdump是在哪儿抓到的包？</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"> <a href="/public/2022/07/15/test/2022/202207/" rel="prev" title="「202207月度汇报」ttrss">「202207月度汇报」ttrss<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div id="gitalk-container"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> 文章目录</li><li class="sidebar-nav-overview" data-target="site-overview"> 站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="https://avatars1.githubusercontent.com/u/10290923?v=3&s=460" alt="一塘"><p class="site-author-name" itemprop="name">一塘</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/public/archives"><span class="site-state-item-count">79</span> <span class="site-state-item-name">博客</span></a></div><div class="site-state-item site-state-categories"> <a href="/public/categories/index.html"><span class="site-state-item-count">57</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/public/tags/index.html"><span class="site-state-item-count">126</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/public/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/talengu" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="/public/2015/01/01/About" target="_blank" title="About"><i class="fa fa-fw fa-globe"></i> About</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-text">¶前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-br-handle-frame"><span class="nav-text">¶1. br_handle_frame()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rx-handler-result-t-枚举类型"><span class="nav-text">¶rx_handler_result_t 枚举类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#is-valid-ether-addr"><span class="nav-text">¶is_valid_ether_addr()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#br-handle-local-finish"><span class="nav-text">¶br_handle_local_finish()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-br-handle-frame-finish"><span class="nav-text">¶2. br_handle_frame_finish()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-br-pass-frame-up"><span class="nav-text">¶3.br_pass_frame_up</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#br-netif-receive-skb"><span class="nav-text">¶br_netif_receive_skb()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-br-forward"><span class="nav-text">¶4. br_forward()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-br-forward"><span class="nav-text">¶5. __br_forward()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-br-forward-finish"><span class="nav-text">¶6. br_forward_finish()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-br-dev-queue-push-xmit"><span class="nav-text">¶7. br_dev_queue_push_xmit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-br-flood"><span class="nav-text">¶8. br_flood</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-br-mulicast-flood"><span class="nav-text">¶9. br_mulicast_flood()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-text">¶参考</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2015 - <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-heart"></i></span> <span class="author" itemprop="copyrightHolder">一塘</span></div><div class="timemark"> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("01/01/2015 17:38:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}setInterval("createtime()",250)</script></div><div class="powered-by"> 由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info"> 主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a></div><div class="busuanzi-count"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span><span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/public/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/public/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/public/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/public/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/public/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/public/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/public/js/src/utils.js?v=5.1.0"></script><script type="text/javascript" src="/public/js/src/motion.js?v=5.1.0"></script><script type="text/javascript" src="/public/js/src/affix.js?v=5.1.0"></script><script type="text/javascript" src="/public/js/src/schemes/pisces.js?v=5.1.0"></script><script type="text/javascript" src="/public/js/src/scrollspy.js?v=5.1.0"></script><script type="text/javascript" src="/public/js/src/post-details.js?v=5.1.0"></script><script type="text/javascript" src="/public/js/src/bootstrap.js?v=5.1.0"></script><link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.6.2/gitalk.min.css"><script src="//cdn.bootcss.com/gitalk/1.6.2/gitalk.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"315ada12fed7a0ffb6b7",clientSecret:"5f15e644005fabee93cc7f50d70c78c57dce0e86",repo:"talengu.github.io",owner:"talengu",admin:["talengu"],id:location.pathname,labels:["Gitalk"],perPage:15,pagerDirection:"last",createIssueManually:!0,distractionFreeMode:!1,proxy:"https://gitalk.talengu.workers.dev/?https://github.com/login/oauth/access_token"});gitalk.render("gitalk-container")</script><script type="text/javascript">var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/public/"+search_path;function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".popup").toggle()}var searchFunc=function(e,c,s){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var t=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),a=document.getElementById(c),r=document.getElementById(s);a.addEventListener("input",function(){var u=0,d='<ul class="search-result-list">',f=this.value.trim().toLowerCase().split(/[\s\-]+/);r.innerHTML="",1<this.value.trim().length&&t.forEach(function(e){var a=!1,r=e.title.trim().toLowerCase(),c=e.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),t=decodeURIComponent(e.url),s=-1,o=-1,n=-1;if(""!=r&&f.forEach(function(e,t){s=r.indexOf(e),o=c.indexOf(e),(0<=s||0<=o)&&(a=!0,0==t&&(n=o))}),a){u+=1,d+="<li><a href='"+t+"' class='search-result-title'>"+r+"</a>";var i=e.content.trim().replace(/<[^>]+>/g,"");if(0<=n){var l=n-20,p=n+80;l<0&&(l=0),0==l&&(p=50),p>i.length&&(p=i.length);var h=i.substring(l,p);f.forEach(function(e){var t=new RegExp(e,"gi");h=h.replace(t,'<b class="search-keyword">'+e+"</b>")}),d+='<p class="search-result">'+h+"...</p>"}d+="</li>"}}),d+="</ul>",0==u&&(d='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==f&&(d='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),r.innerHTML=d}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script type="text/javascript" src="/public/js/src/clipboard.min.js"></script><script type="text/javascript" src="/public/js/src/clipboard-use.js"></script></body></html>