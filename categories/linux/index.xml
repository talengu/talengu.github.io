<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on 一塘</title><link>https://example.com/categories/linux/</link><description>Recent content in Linux on 一塘</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Thu, 15 Dec 2022 12:00:00 +0000</lastBuildDate><atom:link href="https://example.com/categories/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>「转」Linux 内核精通</title><link>https://example.com/post/%E7%AE%80%E6%82%A6%E5%90%8C%E6%AD%A5md/%E8%82%9D%E4%B8%8B-50-%E4%B8%87%E5%AD%97%E7%9A%84linux-%E5%86%85%E6%A0%B8%E7%B2%BE%E9%80%9A%E7%AC%94%E8%AE%B0%E4%BD%A0%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%B0%B4%E5%B9%B3%E5%B0%86%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%AD%94%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F/</link><pubDate>Thu, 15 Dec 2022 12:00:00 +0000</pubDate><guid>https://example.com/post/%E7%AE%80%E6%82%A6%E5%90%8C%E6%AD%A5md/%E8%82%9D%E4%B8%8B-50-%E4%B8%87%E5%AD%97%E7%9A%84linux-%E5%86%85%E6%A0%B8%E7%B2%BE%E9%80%9A%E7%AC%94%E8%AE%B0%E4%BD%A0%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%B0%B4%E5%B9%B3%E5%B0%86%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%AD%94%E5%BB%BA%E8%AE%AE%E6%94%B6%E8%97%8F/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://zhuanlan.zhihu.com/p/572266986">zhuanlan.zhihu.com&lt;/a>&lt;/p>&lt;/blockquote>
&lt;h2 id="一为什么要学习-linux-内核">一、为什么要学习 Linux 内核&lt;/h2>
&lt;!-- more -->
&lt;p>大部分程序员可能永远没有机会开发 Linux 内核或者驱动 Linux，那么我们为什么还需要学习 Linux 内核呢？Linux 的源代码和架构都是开放的，我们可以学到很多操作系统的概念和实现原理。Linux 的设计哲学体系继承了 UNIX，现在整个设计体系相当稳定和简化，这是大部分服务器使用 Linux 的重要原因。&lt;/p>
&lt;p>&lt;strong>那学习 Linux 内核的原因就在于此。&lt;/strong>&lt;/p>
&lt;p>进一步了解内核的原理，有助于你更好地使用命令和程序设计，让你的面试和开发更上一层楼。但是不建议直接看源代码，因为 Linux 代码太大，容易丢失。&lt;/p>
&lt;p>而最好的办法是，先了解一下 Linux 内核机制，知道基本的原理与流程。&lt;/p>
&lt;p>不过，Linux 内核机制也非常复杂，而且其中互相关联。&lt;/p>
&lt;p>





&lt;div style="text-align: center;">
&lt;img src="https://pic1.zhimg.com/v2-f34e4013f744ab349c160d1b3564f68c_r.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;p>比如说，进程运行要分配内存，内存映射涉及文件的关联，文件的读写需要经过块设备，从文件中加载代码才能运行起来进程。这些知识点要反复对照，才能理清。&lt;/p>
&lt;p>&lt;strong>但是一旦攻克！你会发现 Linux 这个复杂的系统开始透明起来。&lt;/strong>&lt;/p>
&lt;h2 id="二如何学习-linux-内核">二、如何学习 Linux 内核？&lt;/h2>
&lt;p>内核的知识就像下面的绳结一样，一环扣一环，我们要解开它们，就必须要先找到线头也就是内核中的函数接口。初学阶段，我们一般不深入的研究内核代码，会使用内核的接口函数就不错了。&lt;/p>
&lt;p>下面提供了如何学习这些内核函数的方法，就像解绳子一样&lt;/p>
&lt;p>&lt;strong>在我们学习 Linux 内核之前，我们首先需要掌握以下几点：&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/440423464">(1) 如何学习内核，先了解 Linux 内核由哪些组成？&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/440423464">(2) 须知 Linux 内核源码（下载的链接 ）组织结构？&lt;/a>&lt;/p>
&lt;p>(3) &lt;a href="https://zhuanlan.zhihu.com/p/440423464">重点需要学习地知识点有哪些？&lt;/a>&lt;/p>
&lt;p>(4) &lt;a href="https://link.zhihu.com/?target=https%3A//docs.qq.com/doc/DTXFKZlZ4YmFYQWZS">最后依据我为大家提供的的学习资料，开启我们的 Linux 内核学习之旅。&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/437667448">(5) 全网最牛 Linux 内核 Makefile 系统文件详解 (纯文字代码)&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/436340295">(6) 全网最详细的 Intel CPU 体系结构分析 (内核源码)&lt;/a>&lt;/p></description></item><item><title>「转」九张图一览 Linux 性能工具 全景图</title><link>https://example.com/post/linux/linux_tools/</link><pubDate>Sun, 11 Dec 2022 12:00:00 +0000</pubDate><guid>https://example.com/post/linux/linux_tools/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>当今时代，绝大多数企业的应用都是运行在 Linux 操作系统上，所以对应用进行性能诊断和性能优化时，离不开 Linux 的各种性能观测工具和性能优化工具。&lt;/p>
&lt;p>笔者使用过的常见的 Linux 性能观测和性能优化工具有：&lt;/p>
&lt;ul>
&lt;li>top/uptime&lt;/li>
&lt;li>ps/pstree&lt;/li>
&lt;li>df/du/free/lsblk&lt;/li>
&lt;li>ip/ifconfig/ping/telnet&lt;/li>
&lt;li>route/dig/nslookup&lt;/li>
&lt;li>lsof/netstat/ss&lt;/li>
&lt;li>tcpdump/tshark/wireshark&lt;/li>
&lt;li>netstat/vmstat/iostat/pidstat/dstat/mpstat&lt;/li>
&lt;li>sar/sysctl/ethtool&lt;/li>
&lt;/ul>
&lt;p>最近在拜读国际著名的 LINUX 性能专家 Brendan Gregg 的个人博客和技术书籍，摘抄了如下九张图，一览 Linux 性能工具全景图，大家共勉！&lt;/p>
&lt;!-- more -->
&lt;h2 id="2-linux-性能工具全景图">&lt;strong>2. Linux 性能工具全景图&lt;/strong>&lt;/h2>
&lt;ul>
&lt;li>linux performance observability tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-2eadd97c53a3f20f255394c3d90ea914_r.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>linux static performance tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-20032bac53c856c5733259eece5c2f76_r.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>linux performance benchmark tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-de23423f2eb9deb5410b7128c933f9a9_r.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>linux performance tuning tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-cdf37de145763b762ba5af1a620f9686_r.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>linux performance observability: sar&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-eee71a6bf3865367741137da03031411_r.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>linux performance observability: perf-tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-1c0134fefbb04597db98ae455a40fad5_r.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.zhihu.com/search?q=linux%20bcc&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2795830055%7D">linux bcc&lt;/a>/BPF Tracing tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-ffe70303f4d64828ca931d987b12a6d8_r.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p></description></item><item><title>「转」Linux内核数据包bridge上转发流程</title><link>https://example.com/post/linux/linux_bridge_forward/</link><pubDate>Wed, 06 Jul 2022 16:00:04 +0000</pubDate><guid>https://example.com/post/linux/linux_bridge_forward/</guid><description>&lt;blockquote>
&lt;p>原文地址 &lt;a href="https://blog.csdn.net/hhhhhyyyyy8/article/details/102133863">blog.csdn.net&lt;/a>
@hhhhhyyyyy8 @4.15.1&lt;/p>&lt;/blockquote>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>linux 内核源代码变动怎么这么大，handle_bridge 函数居然没有了，本来接着准备以 3.9.1 分析的，但发现和后面的又变了，还是以 4.15.1 现在电脑上用的版本分析吧。&lt;/p>
&lt;p>&lt;strong>linux kernel：4.15.1&lt;/strong>&lt;/p>
&lt;p>best of best [&lt;a href="url">link&lt;/a>](&lt;a href="https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg">https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg&lt;/a>)&lt;/p>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="Netfilter-packet-flow5.svg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;p>先看三张图片&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/NW_NW_NW/article/details/76153027">IMG skb桥转发蓝图&lt;/a>





 


&lt;div style="text-align: center;">
&lt;img src="20191005153149853.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/u012247418/article/details/90137663">IMG linux TCP/IP L2层数据包接收流程&lt;/a>





 


&lt;div style="text-align: center;">
&lt;img src="t_70.png" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/xuanxuanBOSS/p/11424290.html">IMG 浅析ebtables的概念和一些基本应用&lt;/a>





 


&lt;div style="text-align: center;">
&lt;img src="netfilter.png" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;blockquote>
&lt;p>tips: linux 内核版本不一样，流程函数会发生细微改变。&lt;/p>&lt;/blockquote>
&lt;!-- more -->
&lt;h2 id="1-br_handle_frame">1. br_handle_frame()&lt;/h2>
&lt;p>作用：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>对于需要转发的报文，调用 &lt;code>NF_BR_PRE_ROUTING&lt;/code> 处钩子函数，结束后，进入 &lt;code>br_handle_frame_finish()&lt;/code> 函数；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于 STP 报文，调用 &lt;code>NF_BR_LOCAL_IN&lt;/code> 处钩子函数，结束后，进入 &lt;code>br_handle_local_finish()&lt;/code> 函数，在 &lt;code>br_handle_local_finish()&lt;/code> 函数中会调用 &lt;code>br_pass_frame_up()&lt;/code> 函数。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//linux/net/bridge/br_input.c
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Return NULL if skb is handled
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * note: already called with rcu_read_lock
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">rx_handler_result_t&lt;/span> &lt;span style="color:#a6e22e">br_handle_frame&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> sk_buff &lt;span style="color:#f92672">**&lt;/span>pskb)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">struct&lt;/span> net_bridge_port &lt;span style="color:#f92672">*&lt;/span>p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">struct&lt;/span> sk_buff &lt;span style="color:#f92672">*&lt;/span>skb &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>pskb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>dest &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">eth_hdr&lt;/span>(skb)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>h_dest;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">br_should_route_hook_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>rhook;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/*如果是环回地址，直接返回RX_HANDLER_PASS*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">unlikely&lt;/span>(skb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pkt_type &lt;span style="color:#f92672">==&lt;/span> PACKET_LOOPBACK))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> RX_HANDLER_PASS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/*判断源MAC地址是否是有效的地址，不是直接丢弃，源MAC地址不能是多播地址和全0地址*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">is_valid_ether_addr&lt;/span>(&lt;span style="color:#a6e22e">eth_hdr&lt;/span>(skb)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>h_source))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">goto&lt;/span> drop;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/*判断是否是共享数据包，若是则clone该数据包；若clone时分配内存出错，返回NULL*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	skb &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">skb_share_check&lt;/span>(skb, GFP_ATOMIC);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>skb)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> RX_HANDLER_CONSUMED;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/*获取dev对应的网桥端口*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	p &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">br_port_get_rcu&lt;/span>(skb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dev);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">if&lt;/span> (p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>flags &lt;span style="color:#f92672">&amp;amp;&lt;/span> BR_VLAN_TUNNEL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">br_handle_ingress_vlan_tunnel&lt;/span>(skb, p,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>						 &lt;span style="color:#a6e22e">nbp_vlan_group_rcu&lt;/span>(p)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">goto&lt;/span> drop;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/*特殊MAC地址处理*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">//如果目的mac地址是本地链路地址link local reserved addr (01:80:c2:00:00:0X) STP报文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">unlikely&lt;/span>(&lt;span style="color:#a6e22e">is_link_local_ether_addr&lt;/span>(dest))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		u16 fwd_mask &lt;span style="color:#f92672">=&lt;/span> p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>br&lt;span style="color:#f92672">-&amp;gt;&lt;/span>group_fwd_mask_required;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * See IEEE 802.1D Table 7-10 Reserved addresses
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * Assignment		 		Value
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * Bridge Group Address		01-80-C2-00-00-00
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * (MAC Control) 802.3		01-80-C2-00-00-01
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * (Link Aggregation) 802.3	01-80-C2-00-00-02
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * 802.1X PAE address		01-80-C2-00-00-03
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * 802.1AB LLDP 		01-80-C2-00-00-0E
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * Others reserved for future standardization
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		fwd_mask &lt;span style="color:#f92672">|=&lt;/span> p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>group_fwd_mask;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">switch&lt;/span> (dest[&lt;span style="color:#ae81ff">5&lt;/span>]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">0x00&lt;/span>&lt;span style="color:#f92672">:&lt;/span>	&lt;span style="color:#75715e">/* Bridge Group Address */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#75715e">/* If STP is turned off,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">			 then must forward to keep loop detection */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">if&lt;/span> (p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>br&lt;span style="color:#f92672">-&amp;gt;&lt;/span>stp_enabled &lt;span style="color:#f92672">==&lt;/span> BR_NO_STP &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			 fwd_mask &lt;span style="color:#f92672">&amp;amp;&lt;/span> (&lt;span style="color:#ae81ff">1u&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> dest[&lt;span style="color:#ae81ff">5&lt;/span>]))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#66d9ef">goto&lt;/span> forward;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#f92672">*&lt;/span>pskb &lt;span style="color:#f92672">=&lt;/span> skb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#a6e22e">__br_handle_local_finish&lt;/span>(skb);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">return&lt;/span> RX_HANDLER_PASS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">0x01&lt;/span>&lt;span style="color:#f92672">:&lt;/span>	&lt;span style="color:#75715e">/* IEEE MAC (Pause) */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">goto&lt;/span> drop;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">0x0E&lt;/span>&lt;span style="color:#f92672">:&lt;/span>	&lt;span style="color:#75715e">/* 802.1AB LLDP */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fwd_mask &lt;span style="color:#f92672">|=&lt;/span> p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>br&lt;span style="color:#f92672">-&amp;gt;&lt;/span>group_fwd_mask;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">if&lt;/span> (fwd_mask &lt;span style="color:#f92672">&amp;amp;&lt;/span> (&lt;span style="color:#ae81ff">1u&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> dest[&lt;span style="color:#ae81ff">5&lt;/span>]))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#66d9ef">goto&lt;/span> forward;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#f92672">*&lt;/span>pskb &lt;span style="color:#f92672">=&lt;/span> skb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#a6e22e">__br_handle_local_finish&lt;/span>(skb);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">return&lt;/span> RX_HANDLER_PASS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#75715e">/* Allow selective forwarding for most other protocols */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fwd_mask &lt;span style="color:#f92672">|=&lt;/span> p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>br&lt;span style="color:#f92672">-&amp;gt;&lt;/span>group_fwd_mask;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">if&lt;/span> (fwd_mask &lt;span style="color:#f92672">&amp;amp;&lt;/span> (&lt;span style="color:#ae81ff">1u&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> dest[&lt;span style="color:#ae81ff">5&lt;/span>]))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#66d9ef">goto&lt;/span> forward;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">/* Deliver packet to local host only */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">/*调用NF_BR_LOCAL_IN处钩子函数，结束后，进入br_handle_local_finish函数*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">NF_HOOK&lt;/span>(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, &lt;span style="color:#a6e22e">dev_net&lt;/span>(skb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dev),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			NULL, skb, skb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dev, NULL, br_handle_local_finish);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> RX_HANDLER_CONSUMED;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>forward:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">switch&lt;/span> (p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>state) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">//网桥端口处于转发状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#66d9ef">case&lt;/span> BR_STATE_FORWARDING:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		rhook &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">rcu_dereference&lt;/span>(br_should_route_hook);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">if&lt;/span> (rhook) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">if&lt;/span> ((&lt;span style="color:#f92672">*&lt;/span>rhook)(skb)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#f92672">*&lt;/span>pskb &lt;span style="color:#f92672">=&lt;/span> skb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#66d9ef">return&lt;/span> RX_HANDLER_PASS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			dest &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">eth_hdr&lt;/span>(skb)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>h_dest;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">/* fall through */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/*网桥端口处于学习状态，处于转发状态也会执行下面的代码，因为上面的case没有break。*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">case&lt;/span> BR_STATE_LEARNING:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/*数据包目的MAC为网桥的Mac，发往本地的数据包*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">ether_addr_equal&lt;/span>(p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>br&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dev_addr, dest))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			skb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pkt_type &lt;span style="color:#f92672">=&lt;/span> PACKET_HOST;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">/*调用NF_BR_PRE_ROUTING处钩子函数，结束后进入br_handle_frame_finish函数*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">NF_HOOK&lt;/span>(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#a6e22e">dev_net&lt;/span>(skb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dev), NULL, skb, skb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dev, NULL,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			br_handle_frame_finish);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drop:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">kfree_skb&lt;/span>(skb);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">return&lt;/span> RX_HANDLER_CONSUMED;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>相关函数&lt;/p></description></item><item><title>「转」tcpdump是在哪儿抓到的包？</title><link>https://example.com/post/linux/how_tcpdump/</link><pubDate>Fri, 01 Jul 2022 16:00:04 +0000</pubDate><guid>https://example.com/post/linux/how_tcpdump/</guid><description>&lt;blockquote>
&lt;p>原文地址 &lt;a href="https://cloud.tencent.com/developer/article/1879646">cloud.tencent.com&lt;/a>&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对&amp;hellip;&lt;/p>&lt;/blockquote>
&lt;p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对这个问题，我进行了一番学习探究。&lt;/p>
&lt;p>先说结论：通过 PF_PACKET 这个特殊的套接字协议，直接接收来自链路层的帧。数据包&lt;strong>并非没有&lt;/strong>进入内核，而是在进入内核后直接跳过了内核中三层 / 四层的协议栈，直达套接字接口，被应用层的 tcpdump 所使用。实际上，在网卡驱动程序通知内核接受到数据帧的时候，数据包就已经进入了内核处理流程。具体的区别，可以见下图。&lt;/p>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="1620.png" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;p>内核网络协议栈示意图&lt;/p>
&lt;!-- more -->
&lt;p>先来看看，普通的套接字的收包路径在内核中是怎么样。&lt;/p>
&lt;p>以最常见的以太网网卡，当网卡接口接收到了一个帧，那么接受者知道它一定包含了一个 Ethernet 报头。封包在协议栈向上传递过程中，一定会在报头中包含一个字段，指出下一阶段的处理应该使用哪一个协议。 以太网卡拥有特定的 MAC 地址，在监听数据帧的时候，当看到帧的目的 MAC 地址与自己的地址或者链路层广播地址（FF:FF:FF:FF:FF:FF）相匹配，就会通过 DMA 把该帧读取到内存中的 ring buffer。&lt;/p>
&lt;p>当一个数据帧被写入到内存后，将产生一个硬件中断请求，以通知 CPU 收到了数据包。操作系统为了减少硬中断产生的次数，会采用一个软中断 (softirq) 唤醒 NAPI 子系统。这样会产生一个单独的线程，调用网卡驱动注册的 poll 方法收包，同时禁止网卡产生新的硬中断，这样的效果便是一次中断可以接收多个包。一旦软终端代码判断有 softirq 处于 pending 状态，便会调用软终端处理函数 net_rx_action。&lt;/p>
&lt;p>中断处理函数会在处理循环中调用 NAPI poll 来接收数据包。poll 方法会分配一个 sk_buff 数据结构（include/linux/skbuff.h），表示该数据包的内核视图。然后将数据从缓冲区提取到新建的 sk_buff 中，并对其中的 protocol 字段做初始化，该字段用以识别特定的协议。之后这个字段会被 netif_receive_skb 内核函数查询，用来确定该执行哪个函数来处理三层的封包。字段涉及协议的值都列在了 include/uapi/linux/if_ether.h 中，名字形如 ETH_P_XXX，比如 ip 协议为 ETH_P_IP。而有一种特殊情况，单一封包可以传递给多个处理函数，这就是 tcpdump 等网络嗅探应用会用到的 ETH_P_ALL。&lt;/p></description></item><item><title>Ubuntu完全教程</title><link>https://example.com/post/linux/ubuntu_tour/</link><pubDate>Fri, 01 Apr 2022 18:00:04 +0000</pubDate><guid>https://example.com/post/linux/ubuntu_tour/</guid><description>&lt;blockquote>
&lt;p>ref:&lt;a href="http://www.cnblogs.com/dutlei/archive/2012/11/20/2778327.html">Ubuntu完全教程，让你成为Ubuntu高手！&lt;/a>
todo整理&lt;/p>&lt;/blockquote>
&lt;h2 id="ubuntu的发音">Ubuntu的发音&lt;/h2>
&lt;p>Ubuntu，源于非洲祖鲁人和科萨人的语言，发作 oo-boon-too 的音。了解发音是有意义的，您不是第一个为此困惑的人，当然，也不会是最后一个：）&lt;/p>
&lt;p>大多数的美国人读 ubuntu 时，将 u 作为元音发音，类似单词 who 或者 boo ，重音在第二个音节即 u&amp;rsquo;buntu ，oo-boon-too 。&lt;/p>
&lt;p>如果您喜欢撒哈拉，喜欢它令人窒息的温柔、梦幻般的寂寥还有张扬恣肆的旷远，您大可在第一个 u，后面带些嗡嗡声： oom-boon-too。&lt;/p>
&lt;p>Ubuntu的中文发音大约为： 乌班图&lt;/p>
&lt;h3 id="ubuntu的涵义">Ubuntu的涵义&lt;/h3>
&lt;p>Ubuntu这个单词源自非洲，意谓“班图精神”────谁都不是一座孤岛，自成一体。每个人都包孕于人类，因他人存在而存在，因他人幸福而幸福。&lt;/p>
&lt;h3 id="ubuntu当前版本">Ubuntu当前版本&lt;/h3>
&lt;p>Ubuntu Linux v6.06 LTS (Dapper Drake)&lt;/p>
&lt;p>LTS：Long Term Support&lt;/p>
&lt;p>Dapper Drake：当前版本的开发代号&lt;/p>
&lt;h3 id="ubuntu的特点">Ubuntu的特点&lt;/h3>
&lt;p>Ubuntu 完全基于 Linux 操作系统， 可以免费得到社区及专业机构的支持。庞大的社区是它成长的沃土，请向这片动人的热忱敞开心扉。&lt;/p>
&lt;p>Ubuntu 社区恪守 Ubuntu 理念：自由！软件应是自由的，应尊重人类的自由意志，它与人类之间不应有任何隔膜。本地语种，功能限制，自主改进的权利……都不应成为使用的障碍或负担。&lt;/p>
&lt;p>自由，让 Ubuntu 与传统的私有软件从根本上不同: 免费不能用来遮羞，您有权修正它，直到满意为止。&lt;/p>
&lt;p>Ubuntu 适合桌面和服务器。当前 Ubuntu 发布版支持 PC (Intel x86), 64-bit PC (AMD64) 和 PowerPC (Apple iBook 和 Powerbook, G4 和 G5) 架构。&lt;/p></description></item><item><title>「转」一文看懂Linux内核！Linux内核架构和工作原理详解</title><link>https://example.com/post/linux/linux_in_one/</link><pubDate>Thu, 23 Dec 2021 22:45:31 +0000</pubDate><guid>https://example.com/post/linux/linux_in_one/</guid><description>&lt;p>全文导读&lt;/p>
&lt;ul>
&lt;li>&lt;a href="">Linux 内核预备工作&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Linux 内核体系结构简析&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Linux 体系结构和内核结构区别&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Linux 驱动的 platform 机制&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Linux 内核体系结构&lt;/a>&lt;/li>
&lt;li>&lt;a href="">内核模块&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Linux 内核学习经验总结&lt;/a>&lt;/li>
&lt;li>&lt;a href="">结尾&lt;/a>&lt;/li>
&lt;/ul>
&lt;!-- more -->
&lt;h2 id="linux-内核预备工作">Linux 内核预备工作&lt;/h2>
&lt;p>理解 Linux 内核最好预备的知识点：&lt;/p>
&lt;p>懂 C 语言&lt;br>
懂一点操作系统的知识&lt;br>
熟悉少量相关算法&lt;br>
懂计算机体系结构&lt;/p>
&lt;p>Linux 内核的特点：&lt;/p>
&lt;p>结合了 unix 操作系统的一些基础概念&lt;/p>
&lt;img src="linux_in_one/174749211_2_20191103041018392.jpeg" alt="174749211_2_20191103041018392" style="zoom:50%;" />
&lt;img src="linux_in_one/174749211_3_20191103041018455.jpeg" alt="174749211_3_20191103041018455" style="zoom:60%;" />
&lt;p>Linux 内核的任务：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>从技术层面讲，内核是硬件与软件之间的一个中间层。作用是将应用层序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从应用程序的层面讲，应用程序与硬件没有联系，只与内核有联系，内核是应用程序知道的层次中的最底层。在实际工作中内核抽象了相关细节。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内核是一个资源管理程序。负责将可用的共享资源 (CPU 时间、磁盘空间、网络连接等) 分配得到各个系统进程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内核就像一个库，提供了一组面向系统的命令。系统调用对于应用程序来说，就像调用普通函数一样。&lt;br>
内核实现策略：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>微内核。最基本的功能由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>宏内核。内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。目前支持模块的动态装卸 (裁剪)。Linux 内核就是基于这个策略实现的。&lt;br>
哪些地方用到了内核机制？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进程（在 cpu 的虚拟内存中分配地址空间，各个进程的地址空间完全独立; 同时执行的进程数最多不超过 cpu 数目）之间进行通   信，需要使用特定的内核机制。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进程间切换 (同时执行的进程数最多不超过 cpu 数目)，也需要用到内核机制。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>进程切换也需要像 FreeRTOS 任务切换一样保存状态，并将进程置于闲置状态 / 恢复状态。&lt;/p>
&lt;ol start="3">
&lt;li>
&lt;p>进程的调度。确认哪个进程运行多长的时间。&lt;br>
Linux 进程&lt;/p></description></item><item><title>「转」桥初始化（一）</title><link>https://example.com/post/linux_network/br_init/</link><pubDate>Thu, 02 Dec 2021 12:00:00 +0000</pubDate><guid>https://example.com/post/linux_network/br_init/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>注：章节中的源代码，基于 linux 内核 4.7.4&lt;/p>
&lt;p>网桥的背景到处都有，在这里就不浪费的时间说废话了。&lt;/p>
&lt;p>桥接程序的初始化，桥接程序既可以集成在内核中，也可以编译成独立模块。初始化函数br_init和清理函数br_deinit的定义在/net/bridge/br.c中&lt;/p>
&lt;p>在网桥设备初始化的时候，主要是做一些注册和初始化的操作。&lt;/p>
&lt;h2 id="桥初始化">桥初始化&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> __init &lt;span style="color:#a6e22e">br_init&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> err;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*注册协议生成树收包函数*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">stp_proto_register&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>br_stp_proto);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (err &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">pr_err&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;bridge: can&amp;#39;t register sap for STP&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> err;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*转发数据库初始化*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">br_fdb_init&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">goto&lt;/span> err_out;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*在/proc目录下生成任何与bridge相关的目录，如果我们想在/proc下生成bridge相关的子目录或子文件*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">register_pernet_subsys&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>br_net_ops);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">goto&lt;/span> err_out1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*目前好像没有什么实际作用，在内核中所注册的函数为空*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">br_nf_core_init&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">goto&lt;/span> err_out2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*注册相关网络设备的事件通知连*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">register_netdevice_notifier&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>br_device_notifier);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">goto&lt;/span> err_out3;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*注册通知连，主要针对桥转发表事件的相关信息*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">register_switchdev_notifier&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>br_switchdev_notifier);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">goto&lt;/span> err_out4;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*进行netlink的初始化*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">br_netlink_init&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">goto&lt;/span> err_out5;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/*用来处理ioctl命令的函数，比如添加和删除网桥*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">brioctl_set&lt;/span>(br_ioctl_deviceless_stub);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#if IS_ENABLED(CONFIG_ATM_LANE)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> br_fdb_test_addr_hook &lt;span style="color:#f92672">=&lt;/span> br_fdb_test_addr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="具体的">具体的&lt;/h2>
&lt;p>了解了桥初始化大致要做的事情后，我们再来看看这些初始化或者注册的事情到底干了些什么？&lt;/p></description></item><item><title>linux代理的使用</title><link>https://example.com/post/linux/linux_proxy/</link><pubDate>Tue, 24 Jul 2018 22:00:00 +0000</pubDate><guid>https://example.com/post/linux/linux_proxy/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>最近要下载一个在youtube上的数据库，用来训练神经网络。走国内通道下载比较慢。于是，我使用了vps代理方式下载，速度取决于你的机器连接vps的网速。本文的主要内容有，实现shadowsocks 代理 ，tsocks 代理工具使用，可组合使用的一些下载工具如wget 和axel等。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 举个栗子&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tsocks wget -c https://www.dropbox.com/s/minpyv59crdifk9/datasets.zip
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>嗯嗯，这个速度还不错！&lt;/p>
&lt;center>&lt;img src="linux_proxy/1565246896718.png" width="60%">
&lt;/center>
&lt;p>&lt;strong>声明&lt;/strong>：本文以科学研究为目的，请勿滥用。&lt;/p>
&lt;!-- more -->
&lt;h2 id="1-shadowsocks">1 Shadowsocks&lt;/h2>
&lt;p>&lt;strong>Shadowsocks&lt;/strong>是一个轻量级socks5代理工具。在linux平台，我们可使用 python 提供的包管理工具 pip &lt;strong>安装 Shadowsocks&lt;/strong> ，如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># pip 安装 Shadowsocks&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pip install shadowsocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 或者&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pip install git+https://github.com/shadowsocks/shadowsocks.git@master
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>pip安装完之后，可能要重启终端，我们就有ssserver和sslocal小工具了。下面配置server或者client。一般，server配置在国外的vps上，client配置在本地国内机器上。&lt;/p>
&lt;p>PS：其他平台安装 参考 shadowsocks官方 &lt;a href="https://github.com/shadowsocks/shadowsocks/tree/master#install">install&lt;/a>&lt;/p>
&lt;h3 id="11-配置-shadowsocks-server">1.1 配置 Shadowsocks server&lt;/h3>
&lt;p>按下面的三步走，即可。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>通过ssh连接到（Virtual Private Server）vps上，或者本地打开终端。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新建一个&lt;strong>server_shadowsocks.json&lt;/strong>文件，内容如下：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;server&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;0.0.0.0&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;server_port&amp;#34;&lt;/span>:&lt;span style="color:#ae81ff">443&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;local_address&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;127.0.0.1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;local_port&amp;#34;&lt;/span>:&lt;span style="color:#ae81ff">1080&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;password&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;密码&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;timeout&amp;#34;&lt;/span>:&lt;span style="color:#ae81ff">300&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;method&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;aes-256-cfb&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;fast_open&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>执行&lt;code>ssserver -c server_shadowsocks.json&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>说一点: 由于我们的下载任务是临时的，开个screen（终端复用工具）放在后台。当然你也可以设置为开机自启动，这里不再赘述。&lt;/p></description></item><item><title>终端中bash、vim、tmux等的配置</title><link>https://example.com/post/linux/bash_bashrc/</link><pubDate>Thu, 12 Jul 2018 16:00:04 +0000</pubDate><guid>https://example.com/post/linux/bash_bashrc/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>使用终端有一段时间了，现在主力的平台是Ubuntu16.04，本文对bash、vim、tmux配置的一些记录。&lt;/p>
&lt;!-- more -->
&lt;p>在&lt;code>cd ~&lt;/code>下建立talen_bashrc文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span> HOME_BASHRC&lt;span style="color:#f92672">=&lt;/span>xxxx/talen_bashrc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias vimbashrc&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;vim $HOME_BASHRC &amp;amp;&amp;amp; source $HOME_BASHRC&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># files&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias countfiles&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;echo &amp;#34;total num: &amp;#34; &amp;amp;&amp;amp; ls | wc -l &amp;amp;&amp;amp; du -sh&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias ll&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ls -htrlF --time-style=&amp;#34;+%H:%M %Y/%m/%d&amp;#34;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias dum&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;du -a -d 1 -m |sort -nr&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias dug&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;df -h /dev/sdbxxx &amp;amp;&amp;amp; du -BG -d 1 --time |sort -nr&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias pi&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;pip install -i https://pypi.tuna.tsinghua.edu.cn/simple&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias gpuwatch&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;watch -n 1 nvidia-smi&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias gitm&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;git commit -m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias gits&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;git status -s&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> export PYTHONPATH&lt;span style="color:#f92672">=&lt;/span>$PYTHONPATH:xxxxxxx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># vimrc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> export MYVIMRC&lt;span style="color:#f92672">=&lt;/span>xxxx/.vim/.vimrc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> export VIMINIT&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;let &amp;amp;rtp=&amp;#39;xxxx/.vim,&amp;#39; . &amp;amp;rtp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> so &lt;/span>$MYVIMRC&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>python环境使用的是anaconda（或者minicoonda）添加激活环境。
在&lt;code>~/.bashrc&lt;/code>中加入&lt;/p></description></item><item><title>ubuntu引导修复</title><link>https://example.com/post/linux/boot_recovery/</link><pubDate>Wed, 14 Jun 2017 16:00:04 +0000</pubDate><guid>https://example.com/post/linux/boot_recovery/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>本文记录修复ubuntu引导，并修改ubuntu盘的大小过程。
参考：&lt;a href="http://www.cnblogs.com/jloveu/p/Ubuntu-partition-expansion-record.html">http://www.cnblogs.com/jloveu/p/Ubuntu-partition-expansion-record.html&lt;/a>
工具：Ubuntu 的live U盘，带有gparted分区工具，和grub修复工具&lt;/p>
&lt;!-- more -->
&lt;h2 id="修复启动">修复启动&lt;/h2>
&lt;p>对于使用gpt的格式的硬盘，ubuntu不要用uefi来安装。gpt还要生成一个bootgios的分区，很重要。&lt;/p>
&lt;p>执行以下命令（以root身份）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>mkdir /tmp/mydir
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount /dev/sda8 /tmp/mydir &lt;span style="color:#f92672">(&lt;/span>注：其中的&lt;span style="color:#e6db74">`&lt;/span>/dev/sda8&lt;span style="color:#e6db74">`&lt;/span>为我的&lt;span style="color:#e6db74">`&lt;/span>/&lt;span style="color:#e6db74">`&lt;/span>分区标识，根据自己情况修改为自己的&lt;span style="color:#e6db74">`&lt;/span>/&lt;span style="color:#e6db74">`&lt;/span>分区标识&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount /dev/sda11 /tmp/mydir/boot &lt;span style="color:#f92672">(&lt;/span>注：同上，&lt;span style="color:#e6db74">`&lt;/span>/dev/sda11&lt;span style="color:#e6db74">`&lt;/span>为&lt;span style="color:#e6db74">`&lt;/span>/boot&lt;span style="color:#e6db74">`&lt;/span>分区标识&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount --bind /dev /tmp/mydir/dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount --bind /proc /tmp/mydir/proc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount --bind /sys /tmp/mydir/sys
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chroot /tmp/mydir &lt;span style="color:#f92672">(&lt;/span>此步可能输出一些信息，可以无视&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grub-install /dev/sda &lt;span style="color:#f92672">(&lt;/span>注：其中的&lt;span style="color:#e6db74">`&lt;/span>/dev/sda&lt;span style="color:#e6db74">`&lt;/span>为&lt;span style="color:#e6db74">`&lt;/span>/&lt;span style="color:#e6db74">`&lt;/span>分区所在硬盘的标识&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exit
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="修改ubuntu多系统的默认启动顺序">修改Ubuntu多系统的默认启动顺序&lt;/h2>
&lt;p>&lt;a href="http://jingyan.baidu.com/article/f71d60379e16021ab641d1ab.html">link&lt;/a>
打开该配置文件&amp;quot;/etc/default/grub&amp;quot;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo vim /etc/default/grub
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo update-grub
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中的“GRUB_DEFAULT=0”为设置默认启动项。系统启动菜单Windows10的启动项在第5项，修改为4（GRUB启动项是从0开始的）。&lt;br>





 


&lt;div style="text-align: center;">
&lt;img src="boot_file.png" 
 alt="GRUB修改" 
 
/>
&lt;/div>&lt;/p>
&lt;h2 id="去除多余grub启动项直接">去除多余GRUB启动项（直接）&lt;/h2>
&lt;p>&lt;a href="https://zhidao.baidu.com/question/472571337.html">link&lt;/a>&lt;br>
注释掉“/boot/grub/grub.cfg”中对应&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo gedit /boot/grub/grub.cfg
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ubuntu下如何修复grub引导">Ubuntu下如何修复Grub引导&lt;/h2>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/NDZPPA-0FhqSzRndQOhNEw">link&lt;/a>&lt;/p>
&lt;p>本文以 Ubuntu Live CD 修复 Grub 引导为例，已在 /dev/sda3 安装 Fedora。&lt;/p>
&lt;p>首先制作 Ubuntu 启动 USB&lt;/p></description></item><item><title>Ubuntu的优化与设置</title><link>https://example.com/post/linux/ubuntu/</link><pubDate>Mon, 22 May 2017 18:00:04 +0000</pubDate><guid>https://example.com/post/linux/ubuntu/</guid><description>&lt;h1>&lt;/h1>
&lt;h2 id="前言">前言&lt;/h2>
&lt;ul>
&lt;li>
&lt;h2 id="窗口颜色设置浅绿色">窗口颜色设置浅绿色&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cd /usr/share/themes/Ambiance/gtk-3.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo gedit gtk-main.css
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="2--常用环境">2 常用环境&lt;/h2>
&lt;ul>
&lt;li>
&lt;h2 id="安装jdk">安装jdk&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># add java path&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export JAVA_HOME&lt;span style="color:#f92672">=&lt;/span>/usr/local/java/jdk1.7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export JRE_HOME&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>JAVA_HOME&lt;span style="color:#e6db74">}&lt;/span>/jre
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export CLASSPATH&lt;span style="color:#f92672">=&lt;/span>.:&lt;span style="color:#e6db74">${&lt;/span>JAVA_HOME&lt;span style="color:#e6db74">}&lt;/span>/lib:&lt;span style="color:#e6db74">${&lt;/span>JRE_HOME&lt;span style="color:#e6db74">}&lt;/span>/lib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>JAVA_HOME&lt;span style="color:#e6db74">}&lt;/span>/bin:$PATH
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="3-安装软件">3 安装软件&lt;/h2>
&lt;ul>
&lt;li>
&lt;h2 id="在线软件安装">在线软件安装&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 备份源列表地址&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 修改&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo vim /etc/apt/sources.list
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 更新源&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get install xxx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 包search&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-cache search xxx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="deb本地软件安装">deb本地软件安装&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 安装deb包命令&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dpkg -i *.deb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 如果缺少依赖执行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get -f install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="4-常用软件">4 常用软件&lt;/h2>
&lt;ul>
&lt;li>mpv播放器&lt;/li>
&lt;li>有道字典&lt;/li>
&lt;li>
&lt;h2 id="atom">atom&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">atom-pane&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">font-size&lt;/span>: &lt;span style="color:#ae81ff">16&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#a6e22e">command-palette&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">font-size&lt;/span>: &lt;span style="color:#ae81ff">16&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;h2 id="图标设置">图标设置&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cd /usr/share/applications
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vim eclipse.desktop
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/usr/bin/env xdg-open
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Desktop Entry&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version&lt;span style="color:#f92672">=&lt;/span>22.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name&lt;span style="color:#f92672">=&lt;/span>eclipse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Exec&lt;span style="color:#f92672">=&lt;/span>/home/gtc/Android/adt-bundle-linux/eclipse/eclipse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Terminal&lt;span style="color:#f92672">=&lt;/span>false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Icon&lt;span style="color:#f92672">=&lt;/span>/home/gtc/Android/adt-bundle-linux/eclipse/icon.xpm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>Application
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Categories&lt;span style="color:#f92672">=&lt;/span>Development
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="设备使用率指示">设备使用率指示&lt;/h3>
&lt;p>&lt;a href="https://github.com/fossfreedom/indicator-sysmonitor">https://github.com/fossfreedom/indicator-sysmonitor&lt;/a>&lt;/p></description></item></channel></rss>