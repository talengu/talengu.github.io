<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on 一塘</title><link>https://talengu.github.io/categories/linux/</link><description>Recent content in Linux on 一塘</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sun, 11 Dec 2022 12:00:00 +0000</lastBuildDate><atom:link href="https://talengu.github.io/categories/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>「转」九张图一览 Linux 性能工具 全景图</title><link>https://talengu.github.io/post/c5-linux/linux/linux_tools/</link><pubDate>Sun, 11 Dec 2022 12:00:00 +0000</pubDate><guid>https://talengu.github.io/post/c5-linux/linux/linux_tools/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>当今时代，绝大多数企业的应用都是运行在 Linux 操作系统上，所以对应用进行性能诊断和性能优化时，离不开 Linux 的各种性能观测工具和性能优化工具。&lt;/p>
&lt;p>笔者使用过的常见的 Linux 性能观测和性能优化工具有：&lt;/p>
&lt;ul>
&lt;li>top/uptime&lt;/li>
&lt;li>ps/pstree&lt;/li>
&lt;li>df/du/free/lsblk&lt;/li>
&lt;li>ip/ifconfig/ping/telnet&lt;/li>
&lt;li>route/dig/nslookup&lt;/li>
&lt;li>lsof/netstat/ss&lt;/li>
&lt;li>tcpdump/tshark/wireshark&lt;/li>
&lt;li>netstat/vmstat/iostat/pidstat/dstat/mpstat&lt;/li>
&lt;li>sar/sysctl/ethtool&lt;/li>
&lt;/ul>
&lt;p>最近在拜读国际著名的 LINUX 性能专家 Brendan Gregg 的个人博客和技术书籍，摘抄了如下九张图，一览 Linux 性能工具全景图，大家共勉！&lt;/p>
&lt;!-- more -->
&lt;h2 id="2-linux-性能工具全景图">&lt;strong>2. Linux 性能工具全景图&lt;/strong>&lt;/h2>
&lt;ul>
&lt;li>linux performance observability tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-2eadd97c53a3f20f255394c3d90ea914_r.jpg" 
 alt="" 
 
 style="width:80%;" 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>linux static performance tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-20032bac53c856c5733259eece5c2f76_r.jpg" 
 alt="" 
 
 style="width:80%;" 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>linux performance benchmark tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-de23423f2eb9deb5410b7128c933f9a9_r.jpg" 
 alt="" 
 
 style="width:80%;" 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>linux performance tuning tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-cdf37de145763b762ba5af1a620f9686_r.jpg" 
 alt="" 
 
 style="width:80%;" 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>linux performance observability: sar&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-eee71a6bf3865367741137da03031411_r.jpg" 
 alt="" 
 
 style="width:80%;" 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>linux performance observability: perf-tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-1c0134fefbb04597db98ae455a40fad5_r.jpg" 
 alt="" 
 
 style="width:80%;" 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.zhihu.com/search?q=linux%20bcc&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2795830055%7D">linux bcc&lt;/a>/BPF Tracing tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-ffe70303f4d64828ca931d987b12a6d8_r.jpg" 
 alt="" 
 
 style="width:80%;" 
/>
&lt;/div>&lt;/p></description></item><item><title>「转」Linux内核数据包bridge上转发流程</title><link>https://talengu.github.io/post/c5-linux/linux/linux-bridge-forward/</link><pubDate>Wed, 06 Jul 2022 16:00:04 +0000</pubDate><guid>https://talengu.github.io/post/c5-linux/linux/linux-bridge-forward/</guid><description>&lt;blockquote>
&lt;p>原文地址 &lt;a href="https://blog.csdn.net/hhhhhyyyyy8/article/details/102133863">blog.csdn.net&lt;/a>
@hhhhhyyyyy8 @4.15.1&lt;/p>&lt;/blockquote>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>linux 内核源代码变动怎么这么大，handle_bridge 函数居然没有了，本来接着准备以 3.9.1 分析的，但发现和后面的又变了，还是以 4.15.1 现在电脑上用的版本分析吧。&lt;/p>
&lt;p>&lt;strong>linux kernel：4.15.1&lt;/strong>&lt;/p>
&lt;p>best of best [&lt;a href="url">link&lt;/a>](&lt;a href="https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg">https://upload.wikimedia.org/wikipedia/commons/3/37/Netfilter-packet-flow.svg&lt;/a>)&lt;/p>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="Netfilter-packet-flow5.svg" 
 alt="" 
 
 style="width:80%;" 
/>
&lt;/div>&lt;/p>
&lt;p>先看三张图片&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/NW_NW_NW/article/details/76153027">IMG skb桥转发蓝图&lt;/a>





 


&lt;div style="text-align: center;">
&lt;img src="20191005153149853.jpg" 
 alt="" 
 
 style="width:80%;" 
/>
&lt;/div>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/u012247418/article/details/90137663">IMG linux TCP/IP L2层数据包接收流程&lt;/a>





 


&lt;div style="text-align: center;">
&lt;img src="t_70.png" 
 alt="" 
 
 style="width:80%;" 
/>
&lt;/div>&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/xuanxuanBOSS/p/11424290.html">IMG 浅析ebtables的概念和一些基本应用&lt;/a>





 


&lt;div style="text-align: center;">
&lt;img src="netfilter.png" 
 alt="" 
 
 style="width:80%;" 
/>
&lt;/div>&lt;/p>
&lt;blockquote>
&lt;p>tips: linux 内核版本不一样，流程函数会发生细微改变。&lt;/p>&lt;/blockquote>
&lt;!-- more -->
&lt;h2 id="1-br_handle_frame">1. br_handle_frame()&lt;/h2>
&lt;p>作用：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>对于需要转发的报文，调用 &lt;code>NF_BR_PRE_ROUTING&lt;/code> 处钩子函数，结束后，进入 &lt;code>br_handle_frame_finish()&lt;/code> 函数；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对于 STP 报文，调用 &lt;code>NF_BR_LOCAL_IN&lt;/code> 处钩子函数，结束后，进入 &lt;code>br_handle_local_finish()&lt;/code> 函数，在 &lt;code>br_handle_local_finish()&lt;/code> 函数中会调用 &lt;code>br_pass_frame_up()&lt;/code> 函数。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//linux/net/bridge/br_input.c
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Return NULL if skb is handled
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * note: already called with rcu_read_lock
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">rx_handler_result_t&lt;/span> &lt;span style="color:#a6e22e">br_handle_frame&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> sk_buff &lt;span style="color:#f92672">**&lt;/span>pskb)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">struct&lt;/span> net_bridge_port &lt;span style="color:#f92672">*&lt;/span>p;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">struct&lt;/span> sk_buff &lt;span style="color:#f92672">*&lt;/span>skb &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>pskb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>dest &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">eth_hdr&lt;/span>(skb)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>h_dest;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">br_should_route_hook_t&lt;/span> &lt;span style="color:#f92672">*&lt;/span>rhook;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/*如果是环回地址，直接返回RX_HANDLER_PASS*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">unlikely&lt;/span>(skb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pkt_type &lt;span style="color:#f92672">==&lt;/span> PACKET_LOOPBACK))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> RX_HANDLER_PASS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/*判断源MAC地址是否是有效的地址，不是直接丢弃，源MAC地址不能是多播地址和全0地址*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>&lt;span style="color:#a6e22e">is_valid_ether_addr&lt;/span>(&lt;span style="color:#a6e22e">eth_hdr&lt;/span>(skb)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>h_source))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">goto&lt;/span> drop;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/*判断是否是共享数据包，若是则clone该数据包；若clone时分配内存出错，返回NULL*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	skb &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">skb_share_check&lt;/span>(skb, GFP_ATOMIC);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>skb)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> RX_HANDLER_CONSUMED;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/*获取dev对应的网桥端口*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	p &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">br_port_get_rcu&lt;/span>(skb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dev);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">if&lt;/span> (p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>flags &lt;span style="color:#f92672">&amp;amp;&lt;/span> BR_VLAN_TUNNEL) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">br_handle_ingress_vlan_tunnel&lt;/span>(skb, p,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>						 &lt;span style="color:#a6e22e">nbp_vlan_group_rcu&lt;/span>(p)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">goto&lt;/span> drop;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/*特殊MAC地址处理*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">//如果目的mac地址是本地链路地址link local reserved addr (01:80:c2:00:00:0X) STP报文
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">unlikely&lt;/span>(&lt;span style="color:#a6e22e">is_link_local_ether_addr&lt;/span>(dest))) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		u16 fwd_mask &lt;span style="color:#f92672">=&lt;/span> p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>br&lt;span style="color:#f92672">-&amp;gt;&lt;/span>group_fwd_mask_required;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * See IEEE 802.1D Table 7-10 Reserved addresses
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * Assignment		 		Value
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * Bridge Group Address		01-80-C2-00-00-00
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * (MAC Control) 802.3		01-80-C2-00-00-01
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * (Link Aggregation) 802.3	01-80-C2-00-00-02
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * 802.1X PAE address		01-80-C2-00-00-03
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * 802.1AB LLDP 		01-80-C2-00-00-0E
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 * Others reserved for future standardization
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">		 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		fwd_mask &lt;span style="color:#f92672">|=&lt;/span> p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>group_fwd_mask;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">switch&lt;/span> (dest[&lt;span style="color:#ae81ff">5&lt;/span>]) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">0x00&lt;/span>&lt;span style="color:#f92672">:&lt;/span>	&lt;span style="color:#75715e">/* Bridge Group Address */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#75715e">/* If STP is turned off,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">			 then must forward to keep loop detection */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">if&lt;/span> (p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>br&lt;span style="color:#f92672">-&amp;gt;&lt;/span>stp_enabled &lt;span style="color:#f92672">==&lt;/span> BR_NO_STP &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			 fwd_mask &lt;span style="color:#f92672">&amp;amp;&lt;/span> (&lt;span style="color:#ae81ff">1u&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> dest[&lt;span style="color:#ae81ff">5&lt;/span>]))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#66d9ef">goto&lt;/span> forward;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#f92672">*&lt;/span>pskb &lt;span style="color:#f92672">=&lt;/span> skb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#a6e22e">__br_handle_local_finish&lt;/span>(skb);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">return&lt;/span> RX_HANDLER_PASS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">0x01&lt;/span>&lt;span style="color:#f92672">:&lt;/span>	&lt;span style="color:#75715e">/* IEEE MAC (Pause) */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">goto&lt;/span> drop;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">case&lt;/span> &lt;span style="color:#ae81ff">0x0E&lt;/span>&lt;span style="color:#f92672">:&lt;/span>	&lt;span style="color:#75715e">/* 802.1AB LLDP */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fwd_mask &lt;span style="color:#f92672">|=&lt;/span> p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>br&lt;span style="color:#f92672">-&amp;gt;&lt;/span>group_fwd_mask;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">if&lt;/span> (fwd_mask &lt;span style="color:#f92672">&amp;amp;&lt;/span> (&lt;span style="color:#ae81ff">1u&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> dest[&lt;span style="color:#ae81ff">5&lt;/span>]))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#66d9ef">goto&lt;/span> forward;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#f92672">*&lt;/span>pskb &lt;span style="color:#f92672">=&lt;/span> skb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#a6e22e">__br_handle_local_finish&lt;/span>(skb);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">return&lt;/span> RX_HANDLER_PASS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#75715e">/* Allow selective forwarding for most other protocols */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fwd_mask &lt;span style="color:#f92672">|=&lt;/span> p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>br&lt;span style="color:#f92672">-&amp;gt;&lt;/span>group_fwd_mask;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">if&lt;/span> (fwd_mask &lt;span style="color:#f92672">&amp;amp;&lt;/span> (&lt;span style="color:#ae81ff">1u&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> dest[&lt;span style="color:#ae81ff">5&lt;/span>]))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#66d9ef">goto&lt;/span> forward;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">/* Deliver packet to local host only */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">/*调用NF_BR_LOCAL_IN处钩子函数，结束后，进入br_handle_local_finish函数*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">NF_HOOK&lt;/span>(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, &lt;span style="color:#a6e22e">dev_net&lt;/span>(skb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dev),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			NULL, skb, skb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dev, NULL, br_handle_local_finish);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span> RX_HANDLER_CONSUMED;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>forward:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">switch&lt;/span> (p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>state) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">//网桥端口处于转发状态
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#66d9ef">case&lt;/span> BR_STATE_FORWARDING:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		rhook &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">rcu_dereference&lt;/span>(br_should_route_hook);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">if&lt;/span> (rhook) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#66d9ef">if&lt;/span> ((&lt;span style="color:#f92672">*&lt;/span>rhook)(skb)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#f92672">*&lt;/span>pskb &lt;span style="color:#f92672">=&lt;/span> skb;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#66d9ef">return&lt;/span> RX_HANDLER_PASS;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			dest &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">eth_hdr&lt;/span>(skb)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>h_dest;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">/* fall through */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/*网桥端口处于学习状态，处于转发状态也会执行下面的代码，因为上面的case没有break。*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">case&lt;/span> BR_STATE_LEARNING:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">/*数据包目的MAC为网桥的Mac，发往本地的数据包*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#a6e22e">ether_addr_equal&lt;/span>(p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>br&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dev&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dev_addr, dest))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			skb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pkt_type &lt;span style="color:#f92672">=&lt;/span> PACKET_HOST;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#75715e">/*调用NF_BR_PRE_ROUTING处钩子函数，结束后进入br_handle_frame_finish函数*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">NF_HOOK&lt;/span>(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#a6e22e">dev_net&lt;/span>(skb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dev), NULL, skb, skb&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dev, NULL,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			br_handle_frame_finish);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>drop:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">kfree_skb&lt;/span>(skb);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">return&lt;/span> RX_HANDLER_CONSUMED;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>相关函数&lt;/p></description></item><item><title>「转」tcpdump是在哪儿抓到的包？</title><link>https://talengu.github.io/post/c5-linux/linux/how-tcpdump/</link><pubDate>Fri, 01 Jul 2022 16:00:04 +0000</pubDate><guid>https://talengu.github.io/post/c5-linux/linux/how-tcpdump/</guid><description>&lt;blockquote>
&lt;p>原文地址 &lt;a href="https://cloud.tencent.com/developer/article/1879646">cloud.tencent.com&lt;/a>&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对&amp;hellip;&lt;/p>&lt;/blockquote>
&lt;p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对这个问题，我进行了一番学习探究。&lt;/p>
&lt;p>先说结论：通过 PF_PACKET 这个特殊的套接字协议，直接接收来自链路层的帧。数据包&lt;strong>并非没有&lt;/strong>进入内核，而是在进入内核后直接跳过了内核中三层 / 四层的协议栈，直达套接字接口，被应用层的 tcpdump 所使用。实际上，在网卡驱动程序通知内核接受到数据帧的时候，数据包就已经进入了内核处理流程。具体的区别，可以见下图。&lt;/p>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="1620.png" 
 alt="" 
 
 style="width:80%;" 
/>
&lt;/div>&lt;/p>
&lt;p>内核网络协议栈示意图&lt;/p>
&lt;!-- more -->
&lt;p>先来看看，普通的套接字的收包路径在内核中是怎么样。&lt;/p>
&lt;p>以最常见的以太网网卡，当网卡接口接收到了一个帧，那么接受者知道它一定包含了一个 Ethernet 报头。封包在协议栈向上传递过程中，一定会在报头中包含一个字段，指出下一阶段的处理应该使用哪一个协议。 以太网卡拥有特定的 MAC 地址，在监听数据帧的时候，当看到帧的目的 MAC 地址与自己的地址或者链路层广播地址（FF:FF:FF:FF:FF:FF）相匹配，就会通过 DMA 把该帧读取到内存中的 ring buffer。&lt;/p>
&lt;p>当一个数据帧被写入到内存后，将产生一个硬件中断请求，以通知 CPU 收到了数据包。操作系统为了减少硬中断产生的次数，会采用一个软中断 (softirq) 唤醒 NAPI 子系统。这样会产生一个单独的线程，调用网卡驱动注册的 poll 方法收包，同时禁止网卡产生新的硬中断，这样的效果便是一次中断可以接收多个包。一旦软终端代码判断有 softirq 处于 pending 状态，便会调用软终端处理函数 net_rx_action。&lt;/p>
&lt;p>中断处理函数会在处理循环中调用 NAPI poll 来接收数据包。poll 方法会分配一个 sk_buff 数据结构（include/linux/skbuff.h），表示该数据包的内核视图。然后将数据从缓冲区提取到新建的 sk_buff 中，并对其中的 protocol 字段做初始化，该字段用以识别特定的协议。之后这个字段会被 netif_receive_skb 内核函数查询，用来确定该执行哪个函数来处理三层的封包。字段涉及协议的值都列在了 include/uapi/linux/if_ether.h 中，名字形如 ETH_P_XXX，比如 ip 协议为 ETH_P_IP。而有一种特殊情况，单一封包可以传递给多个处理函数，这就是 tcpdump 等网络嗅探应用会用到的 ETH_P_ALL。&lt;/p></description></item><item><title>「转」Ubuntu完全教程</title><link>https://talengu.github.io/post/c5-linux/linux/ubuntu-tour/</link><pubDate>Fri, 01 Apr 2022 18:00:04 +0000</pubDate><guid>https://talengu.github.io/post/c5-linux/linux/ubuntu-tour/</guid><description>&lt;blockquote>
&lt;p>ref:&lt;a href="http://www.cnblogs.com/dutlei/archive/2012/11/20/2778327.html">Ubuntu完全教程，让你成为Ubuntu高手！&lt;/a>
todo整理&lt;/p>&lt;/blockquote>
&lt;h2 id="ubuntu的发音">Ubuntu的发音&lt;/h2>
&lt;p>Ubuntu，源于非洲祖鲁人和科萨人的语言，发作 oo-boon-too 的音。了解发音是有意义的，您不是第一个为此困惑的人，当然，也不会是最后一个：）&lt;/p>
&lt;p>大多数的美国人读 ubuntu 时，将 u 作为元音发音，类似单词 who 或者 boo ，重音在第二个音节即 u&amp;rsquo;buntu ，oo-boon-too 。&lt;/p>
&lt;p>如果您喜欢撒哈拉，喜欢它令人窒息的温柔、梦幻般的寂寥还有张扬恣肆的旷远，您大可在第一个 u，后面带些嗡嗡声： oom-boon-too。&lt;/p>
&lt;p>Ubuntu的中文发音大约为： 乌班图&lt;/p>
&lt;h3 id="ubuntu的涵义">Ubuntu的涵义&lt;/h3>
&lt;p>Ubuntu这个单词源自非洲，意谓“班图精神”────谁都不是一座孤岛，自成一体。每个人都包孕于人类，因他人存在而存在，因他人幸福而幸福。&lt;/p>
&lt;h3 id="ubuntu当前版本">Ubuntu当前版本&lt;/h3>
&lt;p>Ubuntu Linux v6.06 LTS (Dapper Drake)&lt;/p>
&lt;p>LTS：Long Term Support&lt;/p>
&lt;p>Dapper Drake：当前版本的开发代号&lt;/p>
&lt;h3 id="ubuntu的特点">Ubuntu的特点&lt;/h3>
&lt;p>Ubuntu 完全基于 Linux 操作系统， 可以免费得到社区及专业机构的支持。庞大的社区是它成长的沃土，请向这片动人的热忱敞开心扉。&lt;/p>
&lt;p>Ubuntu 社区恪守 Ubuntu 理念：自由！软件应是自由的，应尊重人类的自由意志，它与人类之间不应有任何隔膜。本地语种，功能限制，自主改进的权利……都不应成为使用的障碍或负担。&lt;/p>
&lt;p>自由，让 Ubuntu 与传统的私有软件从根本上不同: 免费不能用来遮羞，您有权修正它，直到满意为止。&lt;/p>
&lt;p>Ubuntu 适合桌面和服务器。当前 Ubuntu 发布版支持 PC (Intel x86), 64-bit PC (AMD64) 和 PowerPC (Apple iBook 和 Powerbook, G4 和 G5) 架构。&lt;/p></description></item><item><title>「转」一文看懂Linux内核！Linux内核架构和工作原理详解</title><link>https://talengu.github.io/post/c5-linux/linux/linux-in-one/</link><pubDate>Thu, 23 Dec 2021 22:45:31 +0000</pubDate><guid>https://talengu.github.io/post/c5-linux/linux/linux-in-one/</guid><description>&lt;p>全文导读&lt;/p>
&lt;ul>
&lt;li>&lt;a href="">Linux 内核预备工作&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Linux 内核体系结构简析&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Linux 体系结构和内核结构区别&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Linux 驱动的 platform 机制&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Linux 内核体系结构&lt;/a>&lt;/li>
&lt;li>&lt;a href="">内核模块&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Linux 内核学习经验总结&lt;/a>&lt;/li>
&lt;li>&lt;a href="">结尾&lt;/a>&lt;/li>
&lt;/ul>
&lt;!-- more -->
&lt;h2 id="linux-内核预备工作">Linux 内核预备工作&lt;/h2>
&lt;p>理解 Linux 内核最好预备的知识点：&lt;/p>
&lt;p>懂 C 语言&lt;br>
懂一点操作系统的知识&lt;br>
熟悉少量相关算法&lt;br>
懂计算机体系结构&lt;/p>
&lt;p>Linux 内核的特点：&lt;/p>
&lt;p>结合了 unix 操作系统的一些基础概念&lt;/p>
&lt;img src="linux_in_one/174749211_2_20191103041018392.jpeg" alt="174749211_2_20191103041018392" style="zoom:50%;" />
&lt;img src="linux_in_one/174749211_3_20191103041018455.jpeg" alt="174749211_3_20191103041018455" style="zoom:60%;" />
&lt;p>Linux 内核的任务：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>从技术层面讲，内核是硬件与软件之间的一个中间层。作用是将应用层序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从应用程序的层面讲，应用程序与硬件没有联系，只与内核有联系，内核是应用程序知道的层次中的最底层。在实际工作中内核抽象了相关细节。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内核是一个资源管理程序。负责将可用的共享资源 (CPU 时间、磁盘空间、网络连接等) 分配得到各个系统进程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内核就像一个库，提供了一组面向系统的命令。系统调用对于应用程序来说，就像调用普通函数一样。&lt;br>
内核实现策略：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>微内核。最基本的功能由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>宏内核。内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。目前支持模块的动态装卸 (裁剪)。Linux 内核就是基于这个策略实现的。&lt;br>
哪些地方用到了内核机制？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进程（在 cpu 的虚拟内存中分配地址空间，各个进程的地址空间完全独立; 同时执行的进程数最多不超过 cpu 数目）之间进行通   信，需要使用特定的内核机制。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进程间切换 (同时执行的进程数最多不超过 cpu 数目)，也需要用到内核机制。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>进程切换也需要像 FreeRTOS 任务切换一样保存状态，并将进程置于闲置状态 / 恢复状态。&lt;/p>
&lt;ol start="3">
&lt;li>
&lt;p>进程的调度。确认哪个进程运行多长的时间。&lt;br>
Linux 进程&lt;/p></description></item><item><title>linux代理的使用</title><link>https://talengu.github.io/post/c5-linux/linux/linux-proxy/</link><pubDate>Tue, 24 Jul 2018 22:00:00 +0000</pubDate><guid>https://talengu.github.io/post/c5-linux/linux/linux-proxy/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>最近要下载一个在youtube上的数据库，用来训练神经网络。走国内通道下载比较慢。于是，我使用了vps代理方式下载，速度取决于你的机器连接vps的网速。本文的主要内容有，实现shadowsocks 代理 ，tsocks 代理工具使用，可组合使用的一些下载工具如wget 和axel等。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 举个栗子&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tsocks wget -c https://www.dropbox.com/s/minpyv59crdifk9/datasets.zip
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>嗯嗯，这个速度还不错！&lt;/p>
&lt;center>&lt;img src="linux_proxy/1565246896718.png" width="60%">
&lt;/center>
&lt;p>&lt;strong>声明&lt;/strong>：本文以科学研究为目的，请勿滥用。&lt;/p>
&lt;!-- more -->
&lt;h2 id="1-shadowsocks">1 Shadowsocks&lt;/h2>
&lt;p>&lt;strong>Shadowsocks&lt;/strong>是一个轻量级socks5代理工具。在linux平台，我们可使用 python 提供的包管理工具 pip &lt;strong>安装 Shadowsocks&lt;/strong> ，如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># pip 安装 Shadowsocks&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pip install shadowsocks
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 或者&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ pip install git+https://github.com/shadowsocks/shadowsocks.git@master
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>pip安装完之后，可能要重启终端，我们就有ssserver和sslocal小工具了。下面配置server或者client。一般，server配置在国外的vps上，client配置在本地国内机器上。&lt;/p>
&lt;p>PS：其他平台安装 参考 shadowsocks官方 &lt;a href="https://github.com/shadowsocks/shadowsocks/tree/master#install">install&lt;/a>&lt;/p>
&lt;h3 id="11-配置-shadowsocks-server">1.1 配置 Shadowsocks server&lt;/h3>
&lt;p>按下面的三步走，即可。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>通过ssh连接到（Virtual Private Server）vps上，或者本地打开终端。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>新建一个&lt;strong>server_shadowsocks.json&lt;/strong>文件，内容如下：&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;server&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;0.0.0.0&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;server_port&amp;#34;&lt;/span>:&lt;span style="color:#ae81ff">443&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;local_address&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;127.0.0.1&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;local_port&amp;#34;&lt;/span>:&lt;span style="color:#ae81ff">1080&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;password&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;密码&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;timeout&amp;#34;&lt;/span>:&lt;span style="color:#ae81ff">300&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;method&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;aes-256-cfb&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;fast_open&amp;#34;&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>执行&lt;code>ssserver -c server_shadowsocks.json&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>说一点: 由于我们的下载任务是临时的，开个screen（终端复用工具）放在后台。当然你也可以设置为开机自启动，这里不再赘述。&lt;/p></description></item><item><title>终端中bash、vim、tmux等的配置</title><link>https://talengu.github.io/post/c5-linux/linux/bash-bashrc/</link><pubDate>Thu, 12 Jul 2018 16:00:04 +0000</pubDate><guid>https://talengu.github.io/post/c5-linux/linux/bash-bashrc/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>使用终端有一段时间了，现在主力的平台是Ubuntu16.04，本文对bash、vim、tmux配置的一些记录。&lt;/p>
&lt;!-- more -->
&lt;p>在&lt;code>cd ~&lt;/code>下建立talen_bashrc文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span> HOME_BASHRC&lt;span style="color:#f92672">=&lt;/span>xxxx/talen_bashrc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias vimbashrc&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;vim $HOME_BASHRC &amp;amp;&amp;amp; source $HOME_BASHRC&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># files&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias countfiles&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;echo &amp;#34;total num: &amp;#34; &amp;amp;&amp;amp; ls | wc -l &amp;amp;&amp;amp; du -sh&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias ll&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;ls -htrlF --time-style=&amp;#34;+%H:%M %Y/%m/%d&amp;#34;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias dum&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;du -a -d 1 -m |sort -nr&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias dug&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;df -h /dev/sdbxxx &amp;amp;&amp;amp; du -BG -d 1 --time |sort -nr&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias pi&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;pip install -i https://pypi.tuna.tsinghua.edu.cn/simple&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias gpuwatch&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;watch -n 1 nvidia-smi&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias gitm&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;git commit -m&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> alias gits&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;git status -s&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> export PYTHONPATH&lt;span style="color:#f92672">=&lt;/span>$PYTHONPATH:xxxxxxx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># vimrc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> export MYVIMRC&lt;span style="color:#f92672">=&lt;/span>xxxx/.vim/.vimrc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> export VIMINIT&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;let &amp;amp;rtp=&amp;#39;xxxx/.vim,&amp;#39; . &amp;amp;rtp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> so &lt;/span>$MYVIMRC&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>python环境使用的是anaconda（或者minicoonda）添加激活环境。
在&lt;code>~/.bashrc&lt;/code>中加入&lt;/p></description></item><item><title>Why Software Should Not Have Owners</title><link>https://talengu.github.io/post/c5-linux/why-gnu/</link><pubDate>Fri, 11 May 2018 12:00:00 +0000</pubDate><guid>https://talengu.github.io/post/c5-linux/why-gnu/</guid><description>&lt;p>&lt;a href="http://www.gnu.org/philosophy/why-free.html">Why Software Should Not Have Owners&lt;/a>
为什么软件不应有主人
作者︰&lt;a href="https://www.stallman.org/">Richard Stallman&lt;/a>&lt;/p>
&lt;!-- more -->
&lt;p>数字资讯科技令大众更容易复制和变更资料。然而不是所有人都希望这样。版权制度容许软件有「主人」。他们主要目的在于从公众夺取软件的潜在利益。他们希望独占这些软件的复制、更改权利。&lt;/p>
&lt;p>版权制度随著印刷技术而发展——印刷是一种大量制作副本的技术。版权很适合这项技术，因为它只限制了大规模的复制。它并没有剥夺图书读者的自由。一般读者没有印刷机，他们只能用笔墨抄写作品，所以很少有读者因此而被控告。&lt;/p>
&lt;p>数字科技比印刷机更灵活：当信息呈数字形式时，你能很容易把它跟别人分享。这种情况不太配合故有的版权制度，所以现在有越来越多日益严厉的措施用来加强软件版权。看看这些软件出版商协会（Software Publishers Association, SPA）的四种惯常说法：&lt;/p>
&lt;ul>
&lt;li>大肆宣传违反版权法去帮助朋友是错误的。&lt;/li>
&lt;li>诱使大家告发违返规定的同事和同僚。&lt;/li>
&lt;li>如果警察协助突击搜查公司和学校，那里的人们必须证明自己没有非法复制。&lt;/li>
&lt;li>因软件出版商协会提出要求，美国政府起诉一些如麻省理工学院的 David LaMacchia的人，不是因为他非法软复制件，而只是因为破解复制工具，从而不能对用户非法复制进行检查。&lt;/li>
&lt;/ul>
&lt;p>这些惯常说法和前苏联曾用过的做法相似，在每一台影印机前都有一个守卫，以防止那些未经许可复印，同时个人只有秘密地复制信息，并像「秘密出版物」一样在手头传播。不同的是，苏联管制信息是政治原因，而美国则是为了经济利益。无论动机如何，我们都受到影响。不管什么原因，任何人企图阻止信息共享，都导致了相同的后果和同样的不便。&lt;/p>
&lt;p>软件所有者用各种理由来控制我们如何使用资讯的权利︰&lt;/p>
&lt;ul>
&lt;li>
&lt;p>中伤
软件所有者使用「盗窃」、「剽窃」这类带有污蔑的词语，或者「知识产权」、「损害」之类专业的术语，向公众暗示他们是合理的——其实，他们是将软件和真实物件混为一谈。
我们对「拿取别人的物件」的概念 ，并不能直接套用在复制这件事，然而软件所有者却迫使我们必须接受他们的想法。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>凭空夸大
软件所有者声称当用户复制他们的程序时，他们受到「伤害」或「经济损失」。但复制并不会对软件所有者造成直接的影响，也没有伤害到任何人。只有在使用复制者不愿意给软件所有者付费时，软件所有者才会受损失。
很明显大多数这样的人不愿意购买这些程序，但是软件所有者会假定所有人都会购买，并以此来计算他们的「损失」。客气点说这就是夸大了专有软件的价值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>法律
软件所有者经常引用当今的法律和苛刻的刑罚来威胁我们。这暗示现今的法律反映了一个不容置疑的道德观念，同时怂恿我们视这些刑罚为正常及不能推卸。
这些说词面对严谨的思维是站不住脚的，这做法只是打算利用了人的惯性思维。
显然法律是不能决定错对的。美国人都应该知道，五十年代的黑人在许多州份坐在巴士前座是违法的；但只有种族主义者才会说他们是错误的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自然权利
软件作者常常声称与自己编写的程序有一种特殊联系，因此他们宣称对这个程序的渴望和兴趣是高于世上任何人。（通常是公司持有软件版权，而不是作者，但是我们预期忽略这个差异。)
对那些打算把「作者高于一切」推崇为一种道德的人，本人作为一个著名的软件开发者，只能说这是废话。
但一般人有两个原因对自然权利的说法产生共鸣。
第一个原因是将软件与现实事物过分地类比。当我做意大利面时，如果其他人也要吃，我一定会反感，因为那样的话，我就吃不上了。他的行为对我造成的损失，正如他得到的利益一样。我们中仅有一人可以吃意大利面，问题是谁来吃？我们两者之间最小的分歧也足以打破道德上的平衡。
问题是︰你会否因为运行或修改一个我写的程序而直接影响到你，而对我只会产生一点间接影响？你是否复制我的软件给你的朋友，而对你们的影响远比对我的还要大？我不应有这样的权利去叫你不要这么做。任何人都不该有。
这第二个原因就是，人们被告知作者的自然权利是社会约定俗成的准则。
历史证明，相反的一方才是正确的。当年起草美国宪法时坚决驳回了关于作者自然权利的提议。这就是为什么宪法只是允许版权体系，而并不强制要求；所以说版权体制一定是临时的。宪法也说明版权体制的目的是促进发展，而不是奖励作者。版权确实给作者和出版社带来了更多收益，但这本来只是一种激励他们的手段而已。
事实是我们的社会建立了削弱公众自然权利的版权制度。然而版权只有用于公益事业才是正当的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>经济
软件应该有主人的最终辩解理由是，这会提高软件产量。
这个论据至少比以上的更切合主题。它立足于一个合理目标——满足软件用户的需求。以经验看来，人们因为满意的回报而生产更多，是很容易理解的。
但是这个关于经济的论据有瑕疵：它基于这样一个假设，区别仅仅是我们要付多少钱的问题。它假设无论软件是否有其所有者，「软件产品」都是我们想要的。
由于这个假设合乎我们处理真实物件的经验，所以人们很乐意接受。假设你付费与否都能得到一份一样的三明治，这样你付的费用就是唯一的分别。不管你是否购买，三明治有相同的味道和相同的营养，但你只能吃一次。不管你是否从所有者手中得到三明治，它都不能直接影响到你的金钱以外的任何事情。
对任何真实物件，这都是正确的︰不管它是否有主人都不会直接影响它的本质和用途。
如果程序有了主人，这将大大影响它的本质，和你对它的用途。不同之处不仅仅是钱的问题。软件该有主人的体制鼓励软件主人生产，但不一定是社会真正需要的。它导致的道德低落影响我们所有人。
社会需要什么？社会需要对公民真实可用的信息──例如，人们可以解读、修补、使用和改进的程序，而不只是操作。但是软件主人往往会给我们一个不能研究和修改的黑盒子。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>社会也需要自由。当程序有了主人，用户就失去了控制他们部分生活的自由。&lt;/p>
&lt;p>总之社会需要鼓励公民们自主合作的精神。当软件主人告诉我们用这种自然的方式帮助旁人是剽窃行为时，那他们就是玷污我们的人格。&lt;/p>
&lt;p>这正是我们提倡自由软件 事关自由，而并非价格的原因。&lt;/p>
&lt;p>支持所有者的经济论据是错误的，但是经济问题确实存在。一些人出于荣誉、认同和博爱，而编写了有用的软件，但是如果我们希望有更多的软件，就需要筹集资金。&lt;/p>
&lt;p>自由软件开发者自从八十年代尝试过许多寻求财源的方法，稍有小成。我们不需要让任何人致富，典型的收入，足以吸引人做很多比编程少满足感的工作。&lt;/p>
&lt;p>多年以来，我一直靠改进自己编写的自由软件为生，直到获得研究经费。每次改进我都会添加到标準发佈版本，使得大众受益。客户为我付费，这样我就会优先完成他们需求，自己的变成次要。&lt;/p>
&lt;p>一些自由软件开发者通过支援服务赚钱。1994年，Cygnus 有近50个员工，估计有大约百分之十五的员工从事自由软件开发︰对一间软件公司而言，这是个了不起的比例。&lt;/p>
&lt;p>九十年代，Intel、Motorola、Texas Instruments 和 Analog Devices 等公司联合赞助持续发展的GNU C语言编译器。现在大部份开发GCC的人工作还是受薪的开发者完成的。GNU的Ada语言编译器受美国空军赞助，之后成立专属公司延续过个项目。&lt;/p></description></item><item><title>Ubuntu引导修复</title><link>https://talengu.github.io/post/c5-linux/linux/boot-recovery/</link><pubDate>Wed, 14 Jun 2017 16:00:04 +0000</pubDate><guid>https://talengu.github.io/post/c5-linux/linux/boot-recovery/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>本文记录修复ubuntu引导，并修改ubuntu盘的大小过程。
参考：&lt;a href="http://www.cnblogs.com/jloveu/p/Ubuntu-partition-expansion-record.html">http://www.cnblogs.com/jloveu/p/Ubuntu-partition-expansion-record.html&lt;/a>
工具：Ubuntu 的live U盘，带有gparted分区工具，和grub修复工具&lt;/p>
&lt;!-- more -->
&lt;h2 id="修复启动">修复启动&lt;/h2>
&lt;p>对于使用gpt的格式的硬盘，ubuntu不要用uefi来安装。gpt还要生成一个bootgios的分区，很重要。&lt;/p>
&lt;p>执行以下命令（以root身份）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>mkdir /tmp/mydir
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount /dev/sda8 /tmp/mydir &lt;span style="color:#f92672">(&lt;/span>注：其中的&lt;span style="color:#e6db74">`&lt;/span>/dev/sda8&lt;span style="color:#e6db74">`&lt;/span>为我的&lt;span style="color:#e6db74">`&lt;/span>/&lt;span style="color:#e6db74">`&lt;/span>分区标识，根据自己情况修改为自己的&lt;span style="color:#e6db74">`&lt;/span>/&lt;span style="color:#e6db74">`&lt;/span>分区标识&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount /dev/sda11 /tmp/mydir/boot &lt;span style="color:#f92672">(&lt;/span>注：同上，&lt;span style="color:#e6db74">`&lt;/span>/dev/sda11&lt;span style="color:#e6db74">`&lt;/span>为&lt;span style="color:#e6db74">`&lt;/span>/boot&lt;span style="color:#e6db74">`&lt;/span>分区标识&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount --bind /dev /tmp/mydir/dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount --bind /proc /tmp/mydir/proc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mount --bind /sys /tmp/mydir/sys
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>chroot /tmp/mydir &lt;span style="color:#f92672">(&lt;/span>此步可能输出一些信息，可以无视&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grub-install /dev/sda &lt;span style="color:#f92672">(&lt;/span>注：其中的&lt;span style="color:#e6db74">`&lt;/span>/dev/sda&lt;span style="color:#e6db74">`&lt;/span>为&lt;span style="color:#e6db74">`&lt;/span>/&lt;span style="color:#e6db74">`&lt;/span>分区所在硬盘的标识&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>exit
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="修改ubuntu多系统的默认启动顺序">修改Ubuntu多系统的默认启动顺序&lt;/h2>
&lt;p>&lt;a href="http://jingyan.baidu.com/article/f71d60379e16021ab641d1ab.html">link&lt;/a>
打开该配置文件&amp;quot;/etc/default/grub&amp;quot;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo vim /etc/default/grub
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo update-grub
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中的“GRUB_DEFAULT=0”为设置默认启动项。系统启动菜单Windows10的启动项在第5项，修改为4（GRUB启动项是从0开始的）。&lt;br>





 


&lt;div style="text-align: center;">
&lt;img src="boot_file.png" 
 alt="GRUB修改" 
 
 style="width:80%;" 
/>
&lt;/div>&lt;/p>
&lt;h2 id="去除多余grub启动项直接">去除多余GRUB启动项（直接）&lt;/h2>
&lt;p>&lt;a href="https://zhidao.baidu.com/question/472571337.html">link&lt;/a>&lt;br>
注释掉“/boot/grub/grub.cfg”中对应&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo gedit /boot/grub/grub.cfg
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="ubuntu下如何修复grub引导">Ubuntu下如何修复Grub引导&lt;/h2>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/NDZPPA-0FhqSzRndQOhNEw">link&lt;/a>&lt;/p>
&lt;p>本文以 Ubuntu Live CD 修复 Grub 引导为例，已在 /dev/sda3 安装 Fedora。&lt;/p>
&lt;p>首先制作 Ubuntu 启动 USB&lt;/p></description></item><item><title>Ubuntu的优化与设置</title><link>https://talengu.github.io/post/c5-linux/linux/ubuntu-init/</link><pubDate>Mon, 22 May 2017 18:00:04 +0000</pubDate><guid>https://talengu.github.io/post/c5-linux/linux/ubuntu-init/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;ul>
&lt;li>
&lt;h2 id="窗口颜色设置浅绿色">窗口颜色设置浅绿色&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cd /usr/share/themes/Ambiance/gtk-3.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo gedit gtk-main.css
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="2--常用环境">2 常用环境&lt;/h2>
&lt;ul>
&lt;li>
&lt;h2 id="安装jdk">安装jdk&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># add java path&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export JAVA_HOME&lt;span style="color:#f92672">=&lt;/span>/usr/local/java/jdk1.7
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export JRE_HOME&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>JAVA_HOME&lt;span style="color:#e6db74">}&lt;/span>/jre
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export CLASSPATH&lt;span style="color:#f92672">=&lt;/span>.:&lt;span style="color:#e6db74">${&lt;/span>JAVA_HOME&lt;span style="color:#e6db74">}&lt;/span>/lib:&lt;span style="color:#e6db74">${&lt;/span>JRE_HOME&lt;span style="color:#e6db74">}&lt;/span>/lib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>JAVA_HOME&lt;span style="color:#e6db74">}&lt;/span>/bin:$PATH
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="3-安装软件">3 安装软件&lt;/h2>
&lt;ul>
&lt;li>
&lt;h2 id="在线软件安装">在线软件安装&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 备份源列表地址&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 修改&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo vim /etc/apt/sources.list
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 更新源&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get install xxx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 包search&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-cache search xxx
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="deb本地软件安装">deb本地软件安装&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 安装deb包命令&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dpkg -i *.deb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 如果缺少依赖执行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get -f install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="4-常用软件">4 常用软件&lt;/h2>
&lt;ul>
&lt;li>mpv播放器&lt;/li>
&lt;li>有道字典&lt;/li>
&lt;li>
&lt;h2 id="atom">atom&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">atom-pane&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">font-size&lt;/span>: &lt;span style="color:#ae81ff">16&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#a6e22e">command-palette&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">font-size&lt;/span>: &lt;span style="color:#ae81ff">16&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;h2 id="图标设置">图标设置&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cd /usr/share/applications
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>vim eclipse.desktop
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#!/usr/bin/env xdg-open
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>Desktop Entry&lt;span style="color:#f92672">]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Version&lt;span style="color:#f92672">=&lt;/span>22.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Name&lt;span style="color:#f92672">=&lt;/span>eclipse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Exec&lt;span style="color:#f92672">=&lt;/span>/home/gtc/Android/adt-bundle-linux/eclipse/eclipse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Terminal&lt;span style="color:#f92672">=&lt;/span>false
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Icon&lt;span style="color:#f92672">=&lt;/span>/home/gtc/Android/adt-bundle-linux/eclipse/icon.xpm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Type&lt;span style="color:#f92672">=&lt;/span>Application
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Categories&lt;span style="color:#f92672">=&lt;/span>Development
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="设备使用率指示">设备使用率指示&lt;/h3>
&lt;p>&lt;a href="https://github.com/fossfreedom/indicator-sysmonitor">https://github.com/fossfreedom/indicator-sysmonitor&lt;/a>&lt;/p></description></item></channel></rss>