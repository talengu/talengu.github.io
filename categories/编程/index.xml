<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程 on 一塘</title><link>https://example.com/categories/%E7%BC%96%E7%A8%8B/</link><description>Recent content in 编程 on 一塘</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sun, 27 Apr 2025 12:00:00 +0000</lastBuildDate><atom:link href="https://example.com/categories/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>「转」本科生反驳 40 年前的猜想，发明新型哈希表</title><link>https://example.com/post/c8-programming/hash_tables_news/</link><pubDate>Sun, 27 Apr 2025 12:00:00 +0000</pubDate><guid>https://example.com/post/c8-programming/hash_tables_news/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;blockquote>
&lt;p>本文原文发表于《广达杂志》（Quanta Magazine）。&lt;/p>&lt;/blockquote>
&lt;p>&lt;a href="https://www.quantamagazine.org/undergraduate-upends-a-40-year-old-data-science-conjecture-20250210/">&lt;em>本文&lt;/em>&lt;/a>原文_发表于 &lt;a href="https://www.quantamagazine.org/">《广达杂志》（Quanta Magazine&lt;/a>）。_&lt;/p>
&lt;p>2021 年秋天的某个时候，罗格斯大学 （Rutgers University） 的本科生安德鲁·克拉皮文 （Andrew Krapivin） 遇到了一篇改变他生活的论文。当时，克拉皮文并没有多想。但两年后，当他终于抽出时间阅读这篇论文时（用他的话说，“只是为了好玩”），他的努力将导致对计算机科学中广泛使用的工具的重新思考。&lt;/p>
 &lt;!-- more -->
&lt;p>该论文的标题“&lt;a href="https://arxiv.org/abs/2111.12800">Tiny Pointers&lt;/a>”指的是箭头状实体，可以将您引导至计算机内存中的一条信息或元素。Krapivin 很快就想出了一种潜在的方法来进一步缩小指针，从而减少它们消耗的内存。但是，为了实现这一点，他需要一种更好的方法来组织指针将指向的数据。&lt;/p>
&lt;p>他转向了一种称为哈希表的常用数据存储方法。但在修补过程中，Krapivin 意识到他发明了一种新型的哈希表，这种表的运行速度比预期的要快 — 查找特定元素所需的时间和步骤更少。&lt;/p>
&lt;p>“Tiny Pointers”论文的合著者、Krapivin 在罗格斯大学的前教授 &lt;a href="https://engineering.nyu.edu/faculty/martin-farach-colton">Martín Farach-Colton&lt;/a> 最初对 Krapivin 的新设计持怀疑态度。哈希表是所有计算机科学中研究最深入的数据结构之一;这个预告听起来好得令人难以置信。但为了保险起见，他请了一位经常合作的人（也是《Tiny Pointers》的合著者），卡内基梅隆大学的&lt;a href="https://csd.cmu.edu/people/faculty/william-kuszmaul">威廉·库斯莫尔（William Kuszmaul&lt;/a>）来看看他学生的发明。库斯莫尔有不同的反应。“你不只是想出了一个很酷的哈希表，”他记得对 Krapivin 说。“你居然彻底抹杀了一个 40 年前的猜想！”&lt;/p>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="4540c60338f01ec8cccbe2f8baa9f536_MD5.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;p>Andrew Krapivin 没有打算这样做，它颠覆了围绕哈希表的常见思维，哈希表是计算机科学中研究得最多的工具之一。&lt;/p>
&lt;p>照片：Phillip Ammon for Quanta Magazine&lt;/p>
&lt;p>Krapivin（现在是剑桥大学的研究生）、Farach-Colton（现在在纽约大学）和 Kuszmaul 在 &lt;a href="https://arxiv.org/abs/2501.02305">2025 年 1 月&lt;/a>的一篇论文中一起证明，这种新的哈希表确实可以比人们认为的更快地找到元素。他们这样做，就反驳了一个长期以来被认为是正确的猜想。&lt;/p>
&lt;p>“这是一篇重要的论文，”纽约市康奈尔理工学院的&lt;a href="https://ajhconway.com/">亚历克斯·康威（Alex Conway&lt;/a>）说。“哈希表是我们拥有的最古老的数据结构之一。而且它们仍然是最有效的数据存储方式之一。然而，他说，关于它们如何运作仍然存在悬而未决的问题。“这篇论文以令人惊讶的方式回答了其中的几个问题。”&lt;/p>
&lt;p>哈希表在计算中无处不在，部分原因是它们的简单性和易用性。它们旨在允许用户执行三项作：“查询”（搜索）元素、删除元素或将元素插入空槽。第一个哈希表可以追溯到 1950 年代初，从那时起，计算机科学家一直在研究和使用它们。除其他外，研究人员希望弄清楚其中一些作的速度限制。例如，新的搜索或插入可能有多快？&lt;/p>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="94be07a640f87d1921f3057b2e88b1c4_MD5.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;p>Martín Farach-Colton 帮助 Krapivin 证明他的新哈希表与一个长期存在的猜想相矛盾。&lt;/p>
&lt;p>摄影：Andrew Farach-Colton&lt;/p>
&lt;p>答案通常取决于在哈希表中查找空位所需的时间。反过来，这通常取决于哈希表的填充程度。充实度可以用总体百分比来描述——这个表格是 50%，那个表格是 90%——但研究人员经常处理更完整的表格。因此，他们可能会使用一个由 &lt;em>x&lt;/em> 表示的整数来指定哈希表接近 100% 满的程度。如果 &lt;em>x&lt;/em> 为 100，则表已满 99%。如果 &lt;em>x&lt;/em> 为 1,000，则表已满 99.9%。这种填充度度量提供了一种便捷的方法来评估执行查询或插入等作需要多长时间。&lt;/p></description></item><item><title>c结构体对齐</title><link>https://example.com/post/c8-programming/c_struct/</link><pubDate>Thu, 15 Dec 2022 12:00:00 +0000</pubDate><guid>https://example.com/post/c8-programming/c_struct/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>c语言的字节对齐，机器的大小段模式的理解。&lt;/p>
&lt;p>计算机存储的基础知识。&lt;/p>
&lt;!-- more -->
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> tm{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}TM;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> hp{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">char&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	TM &lt;span style="color:#f92672">*&lt;/span>t;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">short&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> d;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}HP;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>argv[])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	HP hp&lt;span style="color:#f92672">=&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		.a&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0xa1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		.b&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0xb1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		.c&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0xc1c2&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		.d&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0x1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>p&lt;span style="color:#f92672">=&amp;amp;&lt;/span>hp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;sizeof(HP) = %lu&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,&lt;span style="color:#66d9ef">sizeof&lt;/span>(HP) );	
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(HP); &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%02x &amp;#34;&lt;/span>,p[i] );	
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">if&lt;/span>((i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">%&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> d&lt;span style="color:#f92672">=&lt;/span>hp.d;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,d);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>//OUT
|| sizeof(HP) = 32
|| a1 b1 00 00 00 00 00 00 
|| 00 00 00 00 00 00 00 00 
|| c2 c1 00 00 00 00 00 00 
|| 01 00 00 00 00 00 00 00 
|| 1
&lt;/code>&lt;/pre>&lt;h2 id="存储方式">存储方式&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>	HP hp&lt;span style="color:#f92672">=&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		.a&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0xa1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		.b&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0xb1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		.c&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0xc1c2&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		.d&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0xd1d2d3d4&lt;/span>,&lt;span style="color:#75715e">//&amp;lt;-0x1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>//OUT
|| sizeof(HP) = 32
|| a1 b1 00 00 00 00 00 00 
|| 00 00 00 00 00 00 00 00 
|| c2 c1 00 00 00 00 00 00 
|| d4 d3 d2 d1 00 00 00 00 
|| 3520254932
&lt;/code>&lt;/pre>&lt;h2 id="字节对齐">字节对齐&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//将 d 改为 d:1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> hp{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">char&lt;/span> a;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	TM &lt;span style="color:#f92672">*&lt;/span>t;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">short&lt;/span> c;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> d:&lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">//&amp;lt;--- unsigned long d;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}HP;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>//OUT
|| 1 warning generated.
|| sizeof(HP) = 24
|| a1 b1 00 00 00 00 00 00 
|| 00 00 00 00 00 00 00 00 
|| c2 c1 01 00 00 00 00 00 
|| 1
&lt;/code>&lt;/pre>&lt;p>少占用了一个8字节。&lt;/p></description></item><item><title>「转」window软件运行时间</title><link>https://example.com/post/c8-programming/soft_run_time/</link><pubDate>Fri, 15 Apr 2022 12:39:04 +0000</pubDate><guid>https://example.com/post/c8-programming/soft_run_time/</guid><description>&lt;h2 id="背景">背景&lt;/h2>
&lt;p>对关注性能的程序开发人员而言，一个好的计时部件既是益友，也是良师。计时器既可以作为程序组件帮助程序员精确的控制程序进程，又是一件有力的调试武器，在有经验的程序员手里可以尽快的确定程序的性能瓶颈，或者对不同的算法作出有说服力的性能比较。&lt;/p>
&lt;!-- more -->
&lt;p>在Windows平台下，常用的计时器有两种，一种是&lt;code>timeGetTime&lt;/code>多媒体计时器，它可以提供毫秒级的计时。但这个精度对很多应用场合而言还是太粗糙了。另一种是&lt;code>QueryPerformanceCount&lt;/code>计数器，随系统的不同可以提供微秒级的计数。对于实时图形处理、多媒体数据流处理、或者实时系统构造的程序员，善用&lt;code>QueryPerformanceCount/QueryPerformanceFrequency&lt;/code>是一项基本功。&lt;/p>
&lt;p>本文要介绍的，是另一种直接利用&lt;code>Pentium CPU&lt;/code>内部时间戳进行计时的高精度计时手段。以下讨论主要得益于&lt;code>《Windows图形编程》&lt;/code>一书，第15页－17页，有兴趣的读者可以直接参考该书。关于RDTSC指令的详细讨论，可以参考Intel产品手册。本文仅仅作抛砖之用。&lt;/p>
&lt;p>在 &lt;code>Intel Pentium&lt;/code>以上级别的CPU中，有一个称为“时间戳（Time Stamp）”的部件，它以64位无符号整型数的格式，记录了自CPU上电以来所经过的时钟周期数。由于目前的CPU主频都非常高，因此这个部件可以达到纳秒级的计时精度。这个精确性是上述两种方法所无法比拟的。&lt;/p>
&lt;p>在Pentium以上的CPU中，提供了一条机器指令RDTSC（Read Time Stamp Counter）来读取这个时间戳的数字，并将其保存在EDX:EAX寄存器对中。由于&lt;code>EDX:EAX&lt;/code>寄存器对恰好是Win32平台下C++语言保存函数返回值的寄存器，所以我们可以把这条指令看成是一个普通的函数调用。像这样：&lt;/p>
&lt;pre tabindex="0">&lt;code> inline unsigned __int64 GetCycleCount() 
 { 
 __asm RDTSC 
 } 
&lt;/code>&lt;/pre>&lt;p>但是不行，因为RDTSC不被C++的内嵌汇编器直接支持，所以我们要用_emit伪指令直接嵌入该指令的机器码形式&lt;code>0X0F&lt;/code>、&lt;code>0X31&lt;/code>，如下：&lt;/p>
&lt;pre tabindex="0">&lt;code> inline unsigned __int64 GetCycleCount() 
 { 
 __asm _emit 0x0F 
 __asm _emit 0x31 
 } 
&lt;/code>&lt;/pre>&lt;p>以后在需要计数器的场合，可以像使用普通的Win32 API一样，调用两次GetCycleCount函数，比较两个返回值的差，像这样：&lt;/p>
&lt;pre tabindex="0">&lt;code> unsigned long t; 
 t = (unsigned long)GetCycleCount(); 
 //Do Something time-intensive ... 
 t -= (unsigned long)GetCycleCount(); 
&lt;/code>&lt;/pre>&lt;p>&lt;code>《Windows图形编程》&lt;/code>第15页编写了一个类，把这个计数器封装起来。有兴趣的读者可以去参考那个类的代码。作者为了更精确的定时，做了一点小小的改进，把执行&lt;code>RDTSC&lt;/code>指令的时间，通过连续两次调用&lt;code>GetCycleCount&lt;/code>函数计算出来并保存了起来，以后每次计时结束后，都从实际得到的计数中减掉这一小段时间，以得到更准确的计时数字。但我个人觉得这一点点改进意义不大。在我的机器上实测，这条指令大概花掉了几十到100多个周期，在&lt;code>Celeron 800MHz&lt;/code>的机器上，这不过是十分之一微秒的时间。对大多数应用来说，这点时间完全可以忽略不计；而对那些确实要精确到纳秒数量级的应用来说，这个补偿也过于粗糙了。&lt;/p>
&lt;p>这个方法的优点是：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>高精度。可以直接达到纳秒级的计时精度（在1GHz的CPU上每个时钟周期就是一纳秒），这是其他计时方法所难以企及的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>成本低。&lt;code>timeGetTime&lt;/code>函数需要链接多媒体库 &lt;code>winmm.lib&lt;/code>，&lt;code>QueryPerformance*&lt;/code>函数根据MSDN的说明，需要硬件的支持（虽然我还没有见过不支持的机器）和KERNEL库的支持，所以二者都只能在Windows平台下使用（关于DOS平台下的高精度计时问题，可以参考&lt;code>《图形程序开发人员指南》&lt;/code>，里面有关于控制定时器8253的详细说明）。但&lt;code>RDTSC&lt;/code>指令是一条CPU指令，凡是i386平台下Pentium以上的机器均支持，甚至没有平台的限制（我相信i386版本UNIX和Linux下这个方法同样适用，但没有条件试验），而且函数调用的开销是最小的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>具有和CPU主频直接对应的速率关系。一个计数相当于1/(CPU主频Hz数)秒，这样只要知道了CPU的主频，可以直接计算出时间。这和 &lt;code>QueryPerformanceCount&lt;/code>不同，后者需要通过&lt;code>QueryPerformanceFrequency&lt;/code>获取当前计数器每秒的计数次数才能换算成时间。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这个方法的缺点是：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>现有的C/C++编译器多数不直接支持使用RDTSC指令，需要用直接嵌入机器码的方式编程，比较麻烦。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>数据抖动比较厉害。其实对任何计量手段而言，精度和稳定性永远是一对矛盾。如果用低精度的&lt;code>timeGetTime&lt;/code>来计时，基本上每次计时的结果都是相同的；而&lt;code>RDTSC&lt;/code>指令每次结果都不一样，经常有几百甚至上千的差距。这是这种方法高精度本身固有的矛盾。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>关于这个方法计时的最大长度，我们可以简单的用下列公式计算：&lt;/p>
&lt;pre tabindex="0">&lt;code>自CPU上电以来的秒数 = RDTSC读出的周期数 / CPU主频速率（Hz） 
&lt;/code>&lt;/pre>&lt;p>64位无符号整数所能表达的最大数字是&lt;code>1.8×10^19&lt;/code>，在我的&lt;code>Celeron 800&lt;/code>上可以计时大约700年（书中说可以在200MHz的Pentium上计时117年，这个数字不知道是怎么得出来的，与我的计算有出入）。无论如何，我们大可不必关心溢出的问题。&lt;/p></description></item><item><title>「转」在 C/C++ 程序中打印当前函数调用栈</title><link>https://example.com/post/c8-programming/c_debug/</link><pubDate>Wed, 25 Aug 2021 23:18:52 +0000</pubDate><guid>https://example.com/post/c8-programming/c_debug/</guid><description>&lt;h2 id="背景">背景&lt;/h2>
&lt;p>2011 年 6 月 11 日 &lt;a href="http://www.wuzesheng.com/?author=2">小武哥&lt;/a>&lt;/p>
&lt;p>前几天帮同事跟踪的一个程序莫名退出，没有 core dump(当然 ulimit 是打开的) 的问题。我们知道，正常情况下，如果程序因为某种异常条件退出的话，应该会产生 core dump，而如果程序正常退出的话，应该是直接或者间接的调用了 exit() 相关的函数。基于这个事实，我想到了这样一个办法，在程序开始时，通过系统提供的 atexit()，向系统注册一个回调函数，在程序调用 exit() 退出的时候，这个回调函数就会被调用，然后我们在回调函数中打印出当前的函数调用栈，由此便可以知道 exit() 是在哪里调用，从而上述问题便迎刃而解了。上述方法用来解决类似问题是非常行之有效的。在上面，我提到了在 “回调函数中打印出当前的函数调用栈”，相信细心的朋友应该注意到这个了，本文的主要内容就是详细介绍，如何在程序中打印中当前的函数调用栈。&lt;/p>
&lt;!-- more -->
&lt;p>我之前写过一篇题目为《&lt;a href="http://www.wuzesheng.com/?p=1123">介绍几个关于 C/C++ 程序调试的函数&lt;/a>》的文章，看到这里，请读者朋友先看一下前面这篇，因为本文是以前面这篇文章为基础的。我正是用了 backtrace() 和 backtrace_symbols() 这两个函数实现的，下面是一个简单的例子，通过这个例子我们来介绍具体的方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;execinfo .h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio .h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdlib .h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">fun1&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">fun2&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">fun3&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">print_stacktrace&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fun3&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">fun1&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;stackstrace begin:&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">print_stacktrace&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">fun2&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fun1&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">fun3&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fun2&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">print_stacktrace&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">16&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span> array[&lt;span style="color:#ae81ff">16&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> stack_num &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">backtrace&lt;/span>(array, size);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">**&lt;/span> stacktrace &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">backtrace_symbols&lt;/span>(array, stack_num);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> stack_num; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%s&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, stacktrace[i]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">free&lt;/span>(stacktrace);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>（说明：下面的介绍采用的环境是 ubuntu 11.04, x86_64, gcc-4.5.2）&lt;/p></description></item><item><title>地表最强大的还有这 14 位程序员</title><link>https://example.com/post/c8-programming/cs_fonters/</link><pubDate>Thu, 09 Apr 2020 12:39:04 +0000</pubDate><guid>https://example.com/post/c8-programming/cs_fonters/</guid><description>&lt;p>原标题：除了 Linus，地表最强大的还有这 14 位程序员，速来膜拜！&lt;/p>
&lt;p>导语：IT world 曾经做过一次调查，这个世界上最强大的 15 位程序员，到底是？&lt;/p>
&lt;blockquote>
&lt;p>文 / IT world&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>译 / 优达菌&lt;/p>
&lt;p>转自 / 优达学城 2018&lt;/p>
&lt;p>原文地址 &lt;a href="https://www.sohu.com/a/223302790_700886">https://www.sohu.com/a/223302790_700886&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>当和技术基友谈论起 “谁是世界上最顶级的程序员” 的话题时，总是分分钟能引发骂战，优秀的程序员太多了，要评出最优秀的，貌似真的不容易。&lt;/p>
&lt;p>IT world 曾经就做过一次调查，当说到谁是世界上健在且最顶级的程序员时，这 15 个人的名字总是能浮现出来，是公认的还是有争议的，是真 · 大神还是伪 · 大神？一起来看看吧~&lt;/p>
&lt;img src="cs_fonters/3e28c4606b644378b652dc9c3716da02.jpeg" style="zoom:33%;" />
&lt;!-- more -->
&lt;h2 id="margaret-hamilton">Margaret Hamilton&lt;/h2>
&lt;img src="cs_fonters/264f0ac3e2254ea8b1f91eac42632e1c.jpeg" style="zoom:33%;" />
&lt;p>作为 15 位上榜者中唯一女性，玛格丽特被誉为是 “&lt;strong>阿波罗飞行控制软件背后的大脑&lt;/strong>”。&lt;/p>
&lt;p>作为查尔斯 · 斯塔克 · 德雷珀实验室（Charles Stark Draper Laboratory）软件工程部的老大，她组建了一个团队，负责设计和制造阿波罗舰载飞行控制器软件和空间实验室。&lt;/p>
&lt;p>基于这段经历，她开发了通用系统语言（Universal Systems Language）和开发先于事实（ Development Before the Fact）的范例，首先提出异步软件、优先调度和高可信度的软件设计理念。“软件工程（ software engineering）” 这个名字，公认是由她首先发明的。&lt;/p>
&lt;p>1986 年，玛格丽特获得了奥古斯塔 · 埃达 · 洛夫莱斯奖，2003 年获得 NASA 卓越太空行动奖。&lt;/p></description></item></channel></rss>