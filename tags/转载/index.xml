<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>转载 on 一塘</title><link>https://example.com/tags/%E8%BD%AC%E8%BD%BD/</link><description>Recent content in 转载 on 一塘</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Tue, 23 Jan 2024 12:00:00 +0000</lastBuildDate><atom:link href="https://example.com/tags/%E8%BD%AC%E8%BD%BD/index.xml" rel="self" type="application/rss+xml"/><item><title>「转」裁员增笑</title><link>https://example.com/post/c0-life/readings/caiyuanzengxiao/</link><pubDate>Tue, 23 Jan 2024 12:00:00 +0000</pubDate><guid>https://example.com/post/c0-life/readings/caiyuanzengxiao/</guid><description>&lt;p>我被公司裁了。
我一手搭建起核心项目的底层框架，总算熬出头时，公司把我裁了。
CEO 当着全公司的面落井下石，羞辱我是滥竽充数。
他不知道，核心代码的故障只有我能修。
公司求我的日子比想象中来得更快。&lt;/p>
&lt;!-- more -->
&lt;p>1&lt;/p>
&lt;p>「很遗憾地通知您，公司有人员调整，将结束与您的聘用关系。」
「您的门禁卡已经失效，请您立刻搬走全部个人物品。」
我一头雾水。
本以为被人事叫走只是开个小会，没想到是裁员通知。
三年前，公司只是不足20人的小企业。
我抓住虚拟交互的风口，一手搭建起核心项目的底层框架。
我无数个夜晚加班加点，做出第一款产品一Ribo，以眼镜或车窗为载体，实现所有外界环境与人的虚拟交互。
再也不用佩戴笨重的VR 设备，用户仿佛生活在科幻大片中。
Ribo 一经上市，就引爆市场。
无数代理商和开发商找我们合作。
Ribo 生态仿佛摩天大楼一般建设起来。
我们公司的规模也迅速从 20人扩张到5000人。
Ribo 如火如荼地发展，我们也抓紧更新迭代。我流连在技术网站中，把Ribo的系统升级成最前沿的高可用架构。
这个架构搭建时非常困难，因为掌握核心技术的人不多。
我全身心投入到工作中，无暇处理其他事。
陈炳就是那个时期被招进来的。
最开始他跟着我做些琐事。他这个人很圆滑，最擅长向上社交。
他的朋友圈都是跟大老板打高尔夫、跟产品经理喝下午茶。
Ribo 新产品要开发布会，通知我准备稿子。
我嫌麻烦。陈炳自告奋勇，主动写好稿子上直播。
他的口才好，又积极，让我专心处理技术，以后的发布会都让他去。
我乐得清静。我一心只想让Ribo 更好。
他宣称自己是 Ribo 的总工程师。久而久之，外界也默认了。
他靠着人脉一路高升，做到首席 CEO.
与此同时，我完成了Ribo的升级，工作总算轻松了一点。&lt;/p>
&lt;p>2&lt;/p>
&lt;p>有人问过我，陈炳的技术怎么样?
我说:「一般，他更擅长社交。」
这话传到了陈炳耳朵里。
说者无意，听者有心。
陈炳在发布会上以「总工程师」自居，不能容忍有人拆他的老底。
经济下行时期，很多科技公司都受到波及。
Ribo 的股票也有下降，公司传出裁员风波。
我做梦也想不到，第一个被裁掉的竟然是我。
我回到工位收拾东西，内心一片茫然。
门口传来「陈总好!」的声音，我抬头看，陈炳大腹便便地走过来。
可能是应酬太多，这三年，他迅速发福，成了一个油腻的中年胖子。
他笑眯眯地打招呼:「早，各位早啊!」
他晃到我面前，满脸惊讶:「咦，黎工怎么在收拾东西?」
有几人向我看过来。
陈炳仿佛突然想到什么，大声说:「黎工不会是被裁了吧!」
他一咋呼，整个办公室的同事都停下工作来看我。
我回答他:「对。我还得收拾东西，先失陪了。」
陈炳的话根本就不是对我说的。
他转过身，痛心疾首一般围着我转:
「可惜啊，黎工也是公司的老员工了!」
「公司有人员调整，竟然把黎工给裁了。我就不明白，这么多技术人员不裁，怎么偏偏要裁你呢?」
「难道公司考察了所有人的KPI吗?」
我不喜欢搞形式主义，平时的汇报总结能省则省，专心干活。
陈炳说的 KPI 就是那些形式主义的报告之一。
「我也算是跟黎工共事过，实在痛心。」
「但是公司不养闲人!」
「要是黎工走了，公司业务照常运转，大家就能发现是谁只拿工资不干活了!」
他越说声音越大，幸灾乐祸地斜眼瞟我。&lt;/p></description></item><item><title>「转」九张图一览 Linux 性能工具 全景图</title><link>https://example.com/post/c5-linux/linux/linux_tools/</link><pubDate>Sun, 11 Dec 2022 12:00:00 +0000</pubDate><guid>https://example.com/post/c5-linux/linux/linux_tools/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>当今时代，绝大多数企业的应用都是运行在 Linux 操作系统上，所以对应用进行性能诊断和性能优化时，离不开 Linux 的各种性能观测工具和性能优化工具。&lt;/p>
&lt;p>笔者使用过的常见的 Linux 性能观测和性能优化工具有：&lt;/p>
&lt;ul>
&lt;li>top/uptime&lt;/li>
&lt;li>ps/pstree&lt;/li>
&lt;li>df/du/free/lsblk&lt;/li>
&lt;li>ip/ifconfig/ping/telnet&lt;/li>
&lt;li>route/dig/nslookup&lt;/li>
&lt;li>lsof/netstat/ss&lt;/li>
&lt;li>tcpdump/tshark/wireshark&lt;/li>
&lt;li>netstat/vmstat/iostat/pidstat/dstat/mpstat&lt;/li>
&lt;li>sar/sysctl/ethtool&lt;/li>
&lt;/ul>
&lt;p>最近在拜读国际著名的 LINUX 性能专家 Brendan Gregg 的个人博客和技术书籍，摘抄了如下九张图，一览 Linux 性能工具全景图，大家共勉！&lt;/p>
&lt;!-- more -->
&lt;h2 id="2-linux-性能工具全景图">&lt;strong>2. Linux 性能工具全景图&lt;/strong>&lt;/h2>
&lt;ul>
&lt;li>linux performance observability tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-2eadd97c53a3f20f255394c3d90ea914_r.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>linux static performance tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-20032bac53c856c5733259eece5c2f76_r.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>linux performance benchmark tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-de23423f2eb9deb5410b7128c933f9a9_r.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>linux performance tuning tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-cdf37de145763b762ba5af1a620f9686_r.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>linux performance observability: sar&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-eee71a6bf3865367741137da03031411_r.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>linux performance observability: perf-tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-1c0134fefbb04597db98ae455a40fad5_r.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.zhihu.com/search?q=linux%20bcc&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2795830055%7D">linux bcc&lt;/a>/BPF Tracing tools&lt;/li>
&lt;/ul>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="v2-ffe70303f4d64828ca931d987b12a6d8_r.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p></description></item><item><title>「转」tcpdump是在哪儿抓到的包？</title><link>https://example.com/post/c5-linux/linux/how-tcpdump/</link><pubDate>Fri, 01 Jul 2022 16:00:04 +0000</pubDate><guid>https://example.com/post/c5-linux/linux/how-tcpdump/</guid><description>&lt;blockquote>
&lt;p>原文地址 &lt;a href="https://cloud.tencent.com/developer/article/1879646">cloud.tencent.com&lt;/a>&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对&amp;hellip;&lt;/p>&lt;/blockquote>
&lt;p>最近使用 tcpdump 的时候突然想到这个问题。因为我之前只存在一些一知半解的认识：比如直接镜像了网卡的包、在数据包进入内核前就获取了。但这些认识真的正确么？针对这个问题，我进行了一番学习探究。&lt;/p>
&lt;p>先说结论：通过 PF_PACKET 这个特殊的套接字协议，直接接收来自链路层的帧。数据包&lt;strong>并非没有&lt;/strong>进入内核，而是在进入内核后直接跳过了内核中三层 / 四层的协议栈，直达套接字接口，被应用层的 tcpdump 所使用。实际上，在网卡驱动程序通知内核接受到数据帧的时候，数据包就已经进入了内核处理流程。具体的区别，可以见下图。&lt;/p>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="1620.png" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;p>内核网络协议栈示意图&lt;/p>
&lt;!-- more -->
&lt;p>先来看看，普通的套接字的收包路径在内核中是怎么样。&lt;/p>
&lt;p>以最常见的以太网网卡，当网卡接口接收到了一个帧，那么接受者知道它一定包含了一个 Ethernet 报头。封包在协议栈向上传递过程中，一定会在报头中包含一个字段，指出下一阶段的处理应该使用哪一个协议。 以太网卡拥有特定的 MAC 地址，在监听数据帧的时候，当看到帧的目的 MAC 地址与自己的地址或者链路层广播地址（FF:FF:FF:FF:FF:FF）相匹配，就会通过 DMA 把该帧读取到内存中的 ring buffer。&lt;/p>
&lt;p>当一个数据帧被写入到内存后，将产生一个硬件中断请求，以通知 CPU 收到了数据包。操作系统为了减少硬中断产生的次数，会采用一个软中断 (softirq) 唤醒 NAPI 子系统。这样会产生一个单独的线程，调用网卡驱动注册的 poll 方法收包，同时禁止网卡产生新的硬中断，这样的效果便是一次中断可以接收多个包。一旦软终端代码判断有 softirq 处于 pending 状态，便会调用软终端处理函数 net_rx_action。&lt;/p>
&lt;p>中断处理函数会在处理循环中调用 NAPI poll 来接收数据包。poll 方法会分配一个 sk_buff 数据结构（include/linux/skbuff.h），表示该数据包的内核视图。然后将数据从缓冲区提取到新建的 sk_buff 中，并对其中的 protocol 字段做初始化，该字段用以识别特定的协议。之后这个字段会被 netif_receive_skb 内核函数查询，用来确定该执行哪个函数来处理三层的封包。字段涉及协议的值都列在了 include/uapi/linux/if_ether.h 中，名字形如 ETH_P_XXX，比如 ip 协议为 ETH_P_IP。而有一种特殊情况，单一封包可以传递给多个处理函数，这就是 tcpdump 等网络嗅探应用会用到的 ETH_P_ALL。&lt;/p></description></item><item><title>「转」GRE隧道测试</title><link>https://example.com/post/c6-network/gre-test/</link><pubDate>Thu, 05 May 2022 22:52:28 +0000</pubDate><guid>https://example.com/post/c6-network/gre-test/</guid><description>&lt;blockquote>
&lt;p>本文由 &lt;a href="http://ksria.com/simpread/">简悦 SimpRead&lt;/a> 转码， 原文地址 &lt;a href="https://juejin.cn/post/6988645230987706398">juejin.cn&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="e31bac5bcb1347a59142486adaf94e30.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;h2 id="0-前言">0. 前言&lt;/h2>
&lt;p>在学习 ipsec 过程中，一般都会涉及到 ipsec 的局限性：ipsec 协议是一种点对点协议，不支持组播，也不能保护组播、广播报文。因此 ipsec 协议无法用于音视频会议等场合，此时通常的解决办法是采用 &lt;strong>GRE Over IPSec&lt;/strong> .&lt;/p>
&lt;p>给出的解释是：GRE 协议可以封装组播、广播报文，但是无法对业务内容进行加密；而 ipsec 可以对报文进行加密，但是无法封装组播和广播报文。因此将两种协议结合，因而 GRE over IPSec 协议应运而生。 但是我找了很多资料 (其实没有多少)，都没有找到为什么 GRE 协议支持封装组播和广播报文，而 ipsec 不行；他们作为点对点协议，为什么 GRE 可以而 IPsec 不行呢？因为没有找到答案，所以不能证实自己的想法正确与否，于是通过搭建 GRE 隧道环境，学习 Linux 内核中 GRE 隧道的操作配置原则，希望能从中得到些许启发。&lt;/p>
&lt;p>搭建 GRE 隧道环境实际上是很简单的，因为 Linux 内核已经支持了 GRE 隧道，因此直接在虚拟机 (ubuntu 和 CentOS) 里进行简单的配置即可完成操作。&lt;/p>
&lt;!-- more -->
&lt;p>




 


&lt;div style="text-align: center;">
&lt;img src="db260d2dc98445f9988f1c768ca3e744.jpg" 
 alt="" 
 
/>
&lt;/div>&lt;/p>
&lt;h2 id="1-linux-内核支持的隧道类型">1. Linux 内核支持的隧道类型&lt;/h2>
&lt;p>目前 Linux 内核已经支持多种隧道类型，包括：IPIP 隧道，GRE 隧道，&amp;hellip; 。其余这几个我也没见过。当然除了这几种，还有 ipsec 协议，l2tp 协议，可以的是我目前都还没有用过，实在是暴殄天物，罪过罪过&lt;/p></description></item><item><title>「转」Ubuntu完全教程</title><link>https://example.com/post/c5-linux/linux/ubuntu-tour/</link><pubDate>Fri, 01 Apr 2022 18:00:04 +0000</pubDate><guid>https://example.com/post/c5-linux/linux/ubuntu-tour/</guid><description>&lt;blockquote>
&lt;p>ref:&lt;a href="http://www.cnblogs.com/dutlei/archive/2012/11/20/2778327.html">Ubuntu完全教程，让你成为Ubuntu高手！&lt;/a>
todo整理&lt;/p>&lt;/blockquote>
&lt;h2 id="ubuntu的发音">Ubuntu的发音&lt;/h2>
&lt;p>Ubuntu，源于非洲祖鲁人和科萨人的语言，发作 oo-boon-too 的音。了解发音是有意义的，您不是第一个为此困惑的人，当然，也不会是最后一个：）&lt;/p>
&lt;p>大多数的美国人读 ubuntu 时，将 u 作为元音发音，类似单词 who 或者 boo ，重音在第二个音节即 u&amp;rsquo;buntu ，oo-boon-too 。&lt;/p>
&lt;p>如果您喜欢撒哈拉，喜欢它令人窒息的温柔、梦幻般的寂寥还有张扬恣肆的旷远，您大可在第一个 u，后面带些嗡嗡声： oom-boon-too。&lt;/p>
&lt;p>Ubuntu的中文发音大约为： 乌班图&lt;/p>
&lt;h3 id="ubuntu的涵义">Ubuntu的涵义&lt;/h3>
&lt;p>Ubuntu这个单词源自非洲，意谓“班图精神”────谁都不是一座孤岛，自成一体。每个人都包孕于人类，因他人存在而存在，因他人幸福而幸福。&lt;/p>
&lt;h3 id="ubuntu当前版本">Ubuntu当前版本&lt;/h3>
&lt;p>Ubuntu Linux v6.06 LTS (Dapper Drake)&lt;/p>
&lt;p>LTS：Long Term Support&lt;/p>
&lt;p>Dapper Drake：当前版本的开发代号&lt;/p>
&lt;h3 id="ubuntu的特点">Ubuntu的特点&lt;/h3>
&lt;p>Ubuntu 完全基于 Linux 操作系统， 可以免费得到社区及专业机构的支持。庞大的社区是它成长的沃土，请向这片动人的热忱敞开心扉。&lt;/p>
&lt;p>Ubuntu 社区恪守 Ubuntu 理念：自由！软件应是自由的，应尊重人类的自由意志，它与人类之间不应有任何隔膜。本地语种，功能限制，自主改进的权利……都不应成为使用的障碍或负担。&lt;/p>
&lt;p>自由，让 Ubuntu 与传统的私有软件从根本上不同: 免费不能用来遮羞，您有权修正它，直到满意为止。&lt;/p>
&lt;p>Ubuntu 适合桌面和服务器。当前 Ubuntu 发布版支持 PC (Intel x86), 64-bit PC (AMD64) 和 PowerPC (Apple iBook 和 Powerbook, G4 和 G5) 架构。&lt;/p></description></item><item><title>「转」一文看懂Linux内核！Linux内核架构和工作原理详解</title><link>https://example.com/post/c5-linux/linux/linux-in-one/</link><pubDate>Thu, 23 Dec 2021 22:45:31 +0000</pubDate><guid>https://example.com/post/c5-linux/linux/linux-in-one/</guid><description>&lt;p>全文导读&lt;/p>
&lt;ul>
&lt;li>&lt;a href="">Linux 内核预备工作&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Linux 内核体系结构简析&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Linux 体系结构和内核结构区别&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Linux 驱动的 platform 机制&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Linux 内核体系结构&lt;/a>&lt;/li>
&lt;li>&lt;a href="">内核模块&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Linux 内核学习经验总结&lt;/a>&lt;/li>
&lt;li>&lt;a href="">结尾&lt;/a>&lt;/li>
&lt;/ul>
&lt;!-- more -->
&lt;h2 id="linux-内核预备工作">Linux 内核预备工作&lt;/h2>
&lt;p>理解 Linux 内核最好预备的知识点：&lt;/p>
&lt;p>懂 C 语言&lt;br>
懂一点操作系统的知识&lt;br>
熟悉少量相关算法&lt;br>
懂计算机体系结构&lt;/p>
&lt;p>Linux 内核的特点：&lt;/p>
&lt;p>结合了 unix 操作系统的一些基础概念&lt;/p>
&lt;img src="linux_in_one/174749211_2_20191103041018392.jpeg" alt="174749211_2_20191103041018392" style="zoom:50%;" />
&lt;img src="linux_in_one/174749211_3_20191103041018455.jpeg" alt="174749211_3_20191103041018455" style="zoom:60%;" />
&lt;p>Linux 内核的任务：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>从技术层面讲，内核是硬件与软件之间的一个中间层。作用是将应用层序的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>从应用程序的层面讲，应用程序与硬件没有联系，只与内核有联系，内核是应用程序知道的层次中的最底层。在实际工作中内核抽象了相关细节。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内核是一个资源管理程序。负责将可用的共享资源 (CPU 时间、磁盘空间、网络连接等) 分配得到各个系统进程。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内核就像一个库，提供了一组面向系统的命令。系统调用对于应用程序来说，就像调用普通函数一样。&lt;br>
内核实现策略：&lt;/p>
&lt;/li>
&lt;li>
&lt;p>微内核。最基本的功能由中央内核（微内核）实现。所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>宏内核。内核的所有代码，包括子系统（如内存管理、文件管理、设备驱动程序）都打包到一个文件中。内核中的每一个函数都可以访问到内核中所有其他部分。目前支持模块的动态装卸 (裁剪)。Linux 内核就是基于这个策略实现的。&lt;br>
哪些地方用到了内核机制？&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进程（在 cpu 的虚拟内存中分配地址空间，各个进程的地址空间完全独立; 同时执行的进程数最多不超过 cpu 数目）之间进行通   信，需要使用特定的内核机制。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进程间切换 (同时执行的进程数最多不超过 cpu 数目)，也需要用到内核机制。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>进程切换也需要像 FreeRTOS 任务切换一样保存状态，并将进程置于闲置状态 / 恢复状态。&lt;/p>
&lt;ol start="3">
&lt;li>
&lt;p>进程的调度。确认哪个进程运行多长的时间。&lt;br>
Linux 进程&lt;/p></description></item></channel></rss>